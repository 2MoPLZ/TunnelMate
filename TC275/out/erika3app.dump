
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x0000eb88 memsz 0x0000eb88 flags r-x
    LOAD off    0x00014000 vaddr 0x70000000 paddr 0x8000eba8 align 2**14
         filesz 0x00000988 memsz 0x00000988 flags rw-
    LOAD off    0x00016600 vaddr 0x5001a600 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x5001b700 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00016600 vaddr 0x6001a600 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x6001b700 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00014988 vaddr 0x70000988 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x000005d0 flags rw-
    LOAD off    0x00018600 vaddr 0x70018600 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00015700 vaddr 0x70019700 paddr 0x8000f530 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00017c00 vaddr 0x5001bc00 paddr 0x8000f540 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00017c00 vaddr 0x6001bc00 paddr 0x8000f540 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00015c00 vaddr 0x70019c00 paddr 0x8000f540 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00004020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00001278  80000028  80000028  00004028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .bss          000005d0  70000988  8000f530  00014988  2**3
                  ALLOC
  3 .data         00000988  70000000  8000eba8  00014000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .traptab      00000100  80001300  80001300  00005300  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ctors        00000008  80001400  80001400  00005400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .dtors        00000008  80001408  80001408  00005408  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .inttab_cpu0  00002000  80002000  80002000  00006000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text         0000aba8  80004000  80004000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .CPU2.ustack  00001000  5001a600  8000f530  00016600  2**3
                  ALLOC, CPU2
 10 .CPU2.istack  00000400  5001b700  8000f530  00017700  2**3
                  ALLOC, CPU2
 11 .CPU2.csa     00002000  5001bc00  8000f540  00017c00  2**6
                  ALLOC, CPU2
 12 .CPU1.ustack  00001000  6001a600  8000f530  00016600  2**3
                  ALLOC, CPU1
 13 .CPU1.istack  00000400  6001b700  8000f530  00017700  2**3
                  ALLOC, CPU1
 14 .CPU1.csa     00002000  6001bc00  8000f540  00017c00  2**6
                  ALLOC, CPU1
 15 .CPU0.ustack  00001000  70018600  8000f530  00018600  2**3
                  ALLOC, CPU0
 16 .CPU0.istack  00000400  70019700  8000f530  00015700  2**3
                  ALLOC, CPU0
 17 .CPU0.csa     00002000  70019c00  8000f540  00015c00  2**6
                  ALLOC, CPU0
 18 .comment      00000053  00000000  00000000  00014988  2**0
                  CONTENTS, READONLY
 19 .debug_aranges 00000d48  00000000  00000000  000149e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_info   000cc287  00000000  00000000  00015728  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_abbrev 0000c5a1  00000000  00000000  000e19af  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   0000d22a  00000000  00000000  000edf50  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  000023c0  00000000  00000000  000fb17c  2**2
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_str    00002215  00000000  00000000  000fd53c  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_loc    00014380  00000000  00000000  000ff751  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_ranges 00001370  00000000  00000000  00113ad1  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .version_info 0004ad67  00000000  00000000  00114e41  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
70000988 l    d  .bss	00000000 .bss
70000000 l    d  .data	00000000 .data
80001300 l    d  .traptab	00000000 .traptab
80001400 l    d  .ctors	00000000 .ctors
80001408 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 Button_Driver.c
00000000 l    df *ABS*	00000000 asw.c
70000000 l     O .data	00000004 c.16173
00000000 l    df *ABS*	00000000 bsw.c
00000000 l    df *ABS*	00000000 ee_applcfg.c
800000c0 l     O .rodata	00000020 osEE_tdb_ptr_array
800000b4 l     O .rodata	00000004 osEE_res_db_ptr_array
800000e0 l     O .rodata	00000100 osEE_tdb_array
70000030 l     O .data	00000038 osEE_sn_array
800000b8 l     O .rodata	00000008 osEE_res_db_array
70000c44 l     O .bss	0000000c osEE_res_cb_array
800001e0 l     O .rodata	00000008 osEE_sdb_array
70000c50 l     O .bss	00000004 osEE_scb_array
70000068 l     O .data	000000a0 osEE_tcb_array
00000000 l    df *ABS*	00000000 IfxVadc.c
800001e8 l     O .rodata	00000006 CSWTCH.25
00000000 l    df *ABS*	00000000 IfxVadc_cfg.c
00000000 l    df *ABS*	00000000 IfxAsclin_PinMap.c
00000000 l    df *ABS*	00000000 IfxAsclin_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
70000108 l     O .data	00000004 IfxScuCcu_xtalFrequency
800060c0 l     F .text	00000034 IfxScuCcu_wait
80000abc l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 IfxScu_PinMap.c
00000000 l    df *ABS*	00000000 IfxVadc_Adc.c
80000d58 l     O .rodata	00000040 IfxVadc_Adc_masterIndex
00000000 l    df *ABS*	00000000 infotainment_System.c
70000110 l     O .data	0000001c infotainmentArr
70000c58 l     O .bss	00000020 buf
70000c78 l     O .bss	00000004 infoState
80000e38 l     O .rodata	0000001c stateMaxArr
00000000 l    df *ABS*	00000000 uart_Driver.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 impure.c
7000055c l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 vfprintf.c
80000ff0 l     O .rodata	00000010 blanks.4035
80000fe0 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000cdc0 l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 locale.c
8000101c l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80001054 l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 ultrasonic_Driver.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70000980 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
80009c76 l     F .text	0000000e osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 Lcd_Driver.c
80004080 l     F .text	00000060 lcd_write4bits
800040e0 l     F .text	00000020 lcd_command
00000000 l    df *ABS*	00000000 IfxAsclin.c
00000000 l    df *ABS*	00000000 IfxAsclin_Asc.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuEru.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 Ifx_CircularBuffer.c
00000000 l    df *ABS*	00000000 Ifx_Fifo.c
00000000 l    df *ABS*	00000000 photoresistor_Driver.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
800097a6 l     F .text	00000054 osEE_tc_stm_us_ticks
70000f08 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
80009c84 l     F .text	0000001e osEE_shutdown_os
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
8000a548 l     F .text	00000022 osEE_release_all_m
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
8000aa3e l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
8000abca l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 Bsp.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 IfxCpu.c
00000000 l    df *ABS*	00000000 IfxCpu_Irq.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc.c
00000000 l    df *ABS*	00000000 IfxStdIf_DPipe.c
00000000 l    df *ABS*	00000000 IfxStm.c
00000000 l    df *ABS*	00000000 IfxStm_cfg.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc_cfg.c
800003f0 g     O .rodata	00000010 IfxAsclin1_TX_P33_12_OUT
800089ee g     F .text	0000001c printStateBlue
800031c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_142
80002d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_105
70000010 g     O .data	00000020 osEE_ccb_var
70000f58 g     O .text	00000001 __HEAP
80003980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_204
800058b4 g     F .text	00000062 IfxAsclin_Asc_write
8000922e g     F .text	000000ce measureEchoTick
80005152 g     F .text	0000000a IfxAsclin_Asc_getWriteEvent
800071dc g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
80002c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_100
80008894 g     F .text	0000007a setActuatorPacket
800021c0 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_14
80007410 g     F .text	00000036 IfxScuWdt_setCpuEndinit
80001060 g     O .rodata	00000028 __mprec_tinytens
80000b00 g     O .rodata	00000010 IfxScu_WDT1LCK_P20_7_OUT
8000b13c g     F .text	0000001a .hidden __ashldi3
80007172 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
800021e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_15
80009ff4 g     F .text	0000005a TerminateTask
800051ce g     F .text	00000006 IfxAsclin_Asc_resetSendCount
800001f0 g     O .rodata	000000a0 IfxVadc_cfg_srcAddresses
70000c40 g     O .bss	00000004 osEE_kcb_var
800003a0 g     O .rodata	00000010 IfxAsclin2_TX_P14_2_OUT
80002f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_123
800081ba g     F .text	00000020 Ifx_CircularBuffer_addDataIncr
80004c7e g     F .text	00000014 IfxVadc_setScan
8000e7e0 g     F .text	00000040 .hidden __eqdf2
800057e4 g     F .text	00000088 IfxAsclin_Asc_initModuleConfig
80007106 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
800048f0 g     F .text	00000010 IfxVadc_getQueueStatus
00000000 g       *ABS*	00000000 __HEAP_SIZE
80008470 g     F .text	00000176 Ifx_Fifo_read
80004cd8 g     F .text	0000001c IfxAsclin_disableModule
80000740 g     O .rodata	00000010 IfxAsclin3_RXC_P20_3_IN
8000a61e g     F .text	00000022 osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80008d64 g     F .text	0000006e myprintfSerial
80003e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_242
80002300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_24
80003580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_172
8000933a g     F .text	0000046c osEE_tc_core0_start
800024c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_38
80008336 g     F .text	00000004 Ifx_Fifo_destroy
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
8000764a g     F .text	00000108 IfxVadc_Adc_getChannelConfig
800048a0 g     F .text	00000018 IfxVadc_getAdcAnalogFrequency
70000000 g       *ABS*	00000000 __DSPR0_START
80002be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_95
80002740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_58
8000aa9e g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80002c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_97
8000697c g     F .text	00000012 IfxScuCcu_initErayPllConfig
8000a966 g     F .text	00000028 osEE_change_context_from_running
80005144 g     F .text	0000000e IfxAsclin_Asc_getWriteCount
80000760 g     O .rodata	00000010 IfxAsclin3_RXA_P15_7_IN
800020c0 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_6
8000709c g     F .text	00000032 IfxScuEru_setInterruptGatingPattern
80005290 g     F .text	00000014 IfxAsclin_Asc_clearTx
80005932 g     F .text	000000c6 IfxAsclin_Asc_stdIfDPipeInit
80002560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_43
80002040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_2
8000b920 g     F .text	00000002 __malloc_unlock
8000512e g     F .text	0000000a IfxAsclin_Asc_getReadEvent
800042d8 g     F .text	0000003e TimerISR
8000861c g     F .text	000000f0 Ifx_Fifo_canWriteCount
80007f82 g     F .text	000000e8 IfxVadc_Adc_initModule
800032e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_151
70000c89 g     O .bss	0000000b g_RecievedActuatorPacket
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_118
80002c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_99
800047ba g     F .text	0000003c IfxVadc_disablePostCalibration
80002680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_52
8000499e g     F .text	00000028 IfxVadc_getSrcAddress
800049ea g     F .text	00000024 IfxVadc_initialiseAdcConverterClock
80004e02 g     F .text	00000024 IfxAsclin_getOvsFrequency
8000a40e g     F .text	00000096 SetEvent
80007752 g     F .text	00000038 IfxVadc_Adc_getChannelConversionTime
80003e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_244
80002380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_28
8000705e g     F .text	00000012 IfxScuEru_setEventFlag
80003920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_201
8000a56a g     F .text	0000000a osEE_scheduler_task_wrapper_restore
80000d08 g     O .rodata	00000010 IfxScu_EVRWUPA_P14_1_IN
80000510 g     O .rodata	00000010 IfxAsclin3_SLSO_P12_1_OUT
70019600 g     O .CPU0.ustack	00000000 __USTACK0
80003720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_185
8000e328 g     F .text	00000050 memmove
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
8000dbee g     F .text	00000056 _Balloc
80000ce8 g     O .rodata	00000010 IfxScu_EXTCLK0_P23_1_OUT
80003b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_216
80000800 g     O .rodata	00000010 IfxAsclin1_RXE_P11_10_IN
800005e0 g     O .rodata	00000010 IfxAsclin3_SCLK_P15_8_OUT
80006296 g     F .text	0000004a IfxScuCcu_getModuleFrequency
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_213
800028e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_71
80006408 g     F .text	000003be IfxScuCcu_init
8000e860 g     F .text	00000040 .hidden __gtdf2
8000e7c4  w    F .text	0000000a __errno
800037e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_191
80003380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_156
80009cd4 g     F .text	00000042 SuspendAllInterrupts
80002140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_10
800051d4 g     F .text	00000008 IfxAsclin_Asc_canReadCount
80003180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_140
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_103
00001000 g       *ABS*	00000000 __USTACK0_SIZE
800007e0 g     O .rodata	00000010 IfxAsclin1_RXG_P02_3_IN
8000ab0c g     F .text	00000066 osEE_hal_terminate_ctx
80000290 g     O .rodata	00000010 IfxAsclin3_TX_P32_3_OUT
8000a6b0 g     F .text	00000048 osEE_sn_priority_insert
80003480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_164
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_215
8000a31c g     F .text	00000078 GetTaskState
80008178 g     F .text	00000020 Ifx_CircularBuffer_get32
8000a762 g     F .text	00000022 osEE_task_event_set_mask
80000320 g     O .rodata	00000010 IfxAsclin3_TX_P11_1_OUT
80000750 g     O .rodata	00000010 IfxAsclin3_RXB_P11_0_IN
80007446 g     F .text	0000009e IfxScuWdt_initCpuWatchdog
80005b98 g     F .text	00000092 IfxPort_setGroupModeOutput
80002080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_4
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80005fe6 g     F .text	00000072 IfxScuCcu_getPllFrequency
80002a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_82
70000f48 g     O .bss	00000004 errno
8000b0e2 g     F .text	0000001e .hidden __make_dp
80002e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_114
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
800022a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_21
80001360 g       .traptab	00000000 osEE_tc_trap_context
800075c8 g     F .text	00000040 IfxScuWdt_enableWatchdogWithDebugger
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_117
800006f0 g     O .rodata	00000010 IfxAsclin3_RXG_P21_3_IN
80000890 g     O .rodata	00000010 IfxAsclin2_RTS_P33_4_OUT
80000550 g     O .rodata	00000010 IfxAsclin2_SLSO_P02_3_OUT
800027e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_63
8000b1d0 g     F .text	00000016 .hidden __make_fp
80003560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_171
80004522 g     F .text	0000007e initVADCChannels
800023c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_30
800002c0 g     O .rodata	00000010 IfxAsclin3_TX_P22_0_OUT
80003780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_188
80000be8 g     O .rodata	00000014 IfxScu_REQ15_P14_1_IN
80000c60 g     O .rodata	00000014 IfxScu_REQ0_P15_4_IN
800070ce g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
8000a4d6 g     F .text	00000058 ClearEvent
8000635a g     F .text	00000042 IfxScuCcu_getCpuFrequency
80003d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_232
800028a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_69
8000a574 g     F .text	000000aa osEE_scheduler_task_wrapper_run
80003f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_251
800035c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_174
80000630 g     O .rodata	00000010 IfxAsclin3_SCLK_P00_0_OUT
80003700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_184
80000960 g     O .rodata	00000080 IfxPort_cfg_indexMap
80005436 g     F .text	000003ae IfxAsclin_Asc_initModule
8000a902 g     F .text	00000026 osEE_scheduler_task_preemption_point
8000dbd2 g     F .text	0000001c memcpy
8000bc1c g     F .text	000011a4 _svfprintf_r
8000b09a g     F .text	00000048 .hidden __floatsidf
8000778a g     F .text	0000023e IfxVadc_Adc_getGroupConfig
80006f30 g     F .text	00000026 IfxScuEru_enablePatternDetectionTrigger
8000a6f8 g     F .text	0000000e osEE_scheduler_rq_insert
80002940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_74
8000e8e0 g     F .text	00000040 .hidden __ltdf2
80004994 g     F .text	0000000a IfxVadc_getScanStatus
80001410 g       .dtors	00000000 __DTOR_END__
8000698e g     F .text	00000076 IfxScuCcu_setCpuFrequency
80007070 g     F .text	0000002c IfxScuEru_setFlagPatternDetection
8000a9ae g     F .text	00000026 osEE_idle_task_terminate
80000c4c g     O .rodata	00000014 IfxScu_REQ10_P14_3_IN
80003c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_228
80000880 g     O .rodata	00000010 IfxAsclin3_RTS_P00_9_OUT
800006b0 g     O .rodata	00000010 IfxAsclin1_SCLK_P20_10_OUT
8000e194 g     F .text	00000042 __fpclassifyd
800023a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_29
8000713e g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
80003a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_211
80002340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_26
800072d8 g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
80002540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_42
8000a83c g     F .text	0000003c osEE_scheduler_task_unblocked
80002960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_75
80003820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_193
800033c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_158
8000b46a g     F .text	0000000c malloc
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_102
80006da0 g     F .text	00000028 IfxScuEru_clearInputChannelConfiguration
00000000 g       *ABS*	00000000 NULL
80000710 g     O .rodata	00000010 IfxAsclin3_RXF_P21_6_IN
80009b84 g     F .text	0000001e osEE_tc_stm_set_sr0_next_match
80001340 g       .traptab	00000000 osEE_tc_trap_instruction
800010b0 g     O .rodata	000000c8 __mprec_tens
70000008 g     O .data	00000004 g_vadcChannelIDs
80005278 g     F .text	00000008 IfxAsclin_Asc_canWriteCount
800042aa g     F .text	0000002e ButtonISR
80002260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_19
8000a0c2 g     F .text	000000b2 GetResource
800003b0 g     O .rodata	00000010 IfxAsclin2_TX_P10_5_OUT
800004a0 g     O .rodata	00000010 IfxAsclin0_TX_P15_2_OUT
8000b99e g     F .text	00000016 vsnprintf
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_214
800029a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_77
800008e0 g     O .rodata	00000010 IfxAsclin3_CTSA_P00_12_IN
800038a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_197
70000f40 g     O .bss	00000004 __malloc_top_pad
800045c2 g     F .text	00000026 readADCValue
8000897e g     F .text	0000001c printStateOn
80006a04 g     F .text	0000008e IfxScuCcu_setGtmFrequency
80005d24 g     F .text	00000064 IfxPort_setPinModeLvdsHigh
8000aac2 g     F .text	0000002c osEE_hal_ready2stacked
80002660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_51
80000bc0 g     O .rodata	00000014 IfxScu_REQ1_P15_8_IN
800082e6 g     F .text	00000050 Ifx_CircularBuffer_write32
8000dbb0 g     F .text	0000000a _localeconv_r
80003460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_163
80004dc8 g     F .text	00000022 IfxAsclin_getIndex
8000dd80 g     F .text	00000010 __i2b
8000a04e g     F .text	00000074 Schedule
80004e26 g     F .text	00000016 IfxAsclin_getShiftFrequency
800079c8 g     F .text	000001ec IfxVadc_Adc_initChannel
80003f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_250
800002b0 g     O .rodata	00000010 IfxAsclin3_TX_P22_1_OUT
80006c66 g     F .text	00000112 IfxScuCcu_switchToBackupClock
80003100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_136
800006d0 g     O .rodata	00000010 IfxAsclin0_SCLK_P15_2_OUT
80007334 g     F .text	00000072 IfxScuWdt_enableSafetyWatchdog
80002060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_3
80003e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_240
8000b922 g     F .text	0000001e _sbrk_r
80000460 g     O .rodata	00000010 IfxAsclin1_TX_P11_12_OUT
80000c80 g     O .rodata	0000000c IfxScu_HWCFG5_P10_6_IN
80000470 g     O .rodata	00000010 IfxAsclin1_TX_P02_2_OUT
80003040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_130
800089d2 g     F .text	0000001c printStateGreen
80002b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_89
70000988 g     O .bss	00000001 g_buttonState
800025c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_46
700009b0 g     O .bss	0000000c g_vadcGroup
80006ee4 g     F .text	00000026 IfxScuEru_enableAutoClear
800006c0 g     O .rodata	00000010 IfxAsclin1_SCLK_P15_0_OUT
80009098 g     F .text	0000001a serialize_sensor_packet
800027a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_61
80002800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_64
8000b2f8 g     F .text	000000ac .hidden __unpack_d
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
80005dca g     F .text	0000003c IfxPort_setPinPadDriver
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_246
80002480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_36
80000420 g     O .rodata	00000010 IfxAsclin1_TX_P15_4_OUT
70000f3c g     O .bss	00000004 __malloc_max_sbrked_mem
80002a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_81
800013a0 g       .traptab	00000000 osEE_tc_trap_assertion
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_93
80008000 g       *ABS*	00000000 __A1_MEM
8000ab98 g     F .text	00000032 .hidden __extendsfdf2
80002700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_56
80008ef4 g     F .text	00000112 readActuatorPacket
80004d3e g     F .text	00000016 IfxAsclin_getAddress
8000ad66 g     F .text	00000038 .hidden __adddf3
800041da g     F .text	0000000e lcd_goto
80009e80 g     F .text	0000001a GetActiveApplicationMode
800062e0 g     F .text	0000007a IfxScuCcu_getSriFrequency
800091c8 g     F .text	00000066 sendTrigger
800030c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_134
80009d16 g     F .text	00000026 ResumeAllInterrupts
800036c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_182
800038e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_199
80006be6 g     F .text	00000080 IfxScuCcu_setSriFrequency
8000ea40 g     F .text	00000026 .hidden __umoddi3
80003740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_186
70019c00 g     O .CPU0.csa	00000000 __CSA0
80003840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_194
800033e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_159
80003280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_148
80002180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_12
800008b0 g     O .rodata	00000010 IfxAsclin1_RTS_P23_1_OUT
80000fa4 g     O .rodata	00000004 _global_impure_ptr
80006df0 g     F .text	00000036 IfxScuEru_connectTrigger
70000990 g     O .bss	00000020 g_vadcChannel
8000639c g     F .text	00000036 IfxScuCcu_getFsi2Frequency
8000e388 g     F .text	000003f0 _realloc_r
80000690 g     O .rodata	00000010 IfxAsclin1_SCLK_P33_12_OUT
80004e78 g     F .text	00000012 IfxAsclin_read16
8000890e g     F .text	0000001c printStateLv1
80005acc g     F .text	0000003c IfxPort_enableEmergencyStop
800002e0 g     O .rodata	00000010 IfxAsclin3_TX_P20_3_OUT
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_254
8000e9a0 g     F .text	000000a0 .hidden __udivdi3
80000860 g     O .rodata	00000010 IfxAsclin0_RXB_P15_3_IN
800002f0 g     O .rodata	00000010 IfxAsclin3_TX_P20_0_OUT
70008000 g       *ABS*	00000000 __A0_MEM
8000a640 g     F .text	00000070 osEE_scheduler_core_rq_preempt_stk
800004b0 g     O .rodata	00000010 IfxAsclin0_TX_P14_1_OUT
80004100 g     F .text	0000000a lcd_clear
80001088 g     O .rodata	00000028 __mprec_bigtens
8000e7ce g     F .text	00000012 abort
8000e96e g     F .text	00000032 .hidden __floatunsidf
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_85
8000dfe0 g     F .text	00000042 __mcmp
800038c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_198
800052a4 g     F .text	0000001c IfxAsclin_Asc_read
80009e9a g     F .text	00000084 ActivateTask
80000bfc g     O .rodata	00000014 IfxScu_REQ14_P02_1_IN
80003300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_152
80006e4c g     F .text	00000026 IfxScuEru_disableFallingEdgeDetection
80002de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_111
8000833a g     F .text	0000003a Ifx_Fifo_init
800089b6 g     F .text	0000001c printStateRed
80002420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_33
70000f50  w    O .bss	00000004 _my_errno
800004f0 g     O .rodata	00000010 IfxAsclin3_SLSO_P21_2_OUT
800059f8 g     F .text	00000030 IfxPort_getAddress
80003760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_187
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
80000910 g     O .rodata	00000010 IfxAsclin1_CTSB_P32_4_IN
8000a2c4 g     F .text	00000058 GetTaskID
800067da g     F .text	000001a2 IfxScuCcu_initErayPll
80000390 g     O .rodata	00000010 IfxAsclin2_TX_P14_3_OUT
80002220 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_17
80003de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_239
80000330 g     O .rodata	00000010 IfxAsclin3_TX_P11_0_OUT
80000a68 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
80006fa2 g     F .text	0000000e IfxScuEru_getAllEventFlagsStatus
80000ca4 g     O .rodata	0000000c IfxScu_HWCFG2EVR13_P14_2_IN
80009d3c g     F .text	0000005c SuspendOSInterrupts
80003a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_210
8000720e g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
80009006 g     F .text	00000028 asclin0RxISR
8000b156 g     F .text	0000007a .hidden __unpack_f
80009acc g     F .text	00000034 osEE_tc_stm_set_clockpersec
80003a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_208
800045a0 g     F .text	00000022 initADC
800031e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_143
80002d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_106
8000a928 g     F .text	0000003e osEE_scheduler_task_set_running
b0008000 g     O *ABS*	00000000 _SMALL_DATA4_
80009ba2 g     F .text	0000008e osEE_tc_stm_set_sr1
80000730 g     O .rodata	00000010 IfxAsclin3_RXD_P32_2_IN
80008dd2 g     F .text	0000000c asclin0TxISR
80000610 g     O .rodata	00000010 IfxAsclin3_SCLK_P11_1_OUT
80007268 g     F .text	00000070 IfxScuWdt_disableSafetyWatchdog
80002c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_96
800075c4 g     F .text	00000004 IfxScuWdt_serviceSafetyWatchdog
80000790 g     O .rodata	00000010 IfxAsclin2_RXE_P33_8_IN
80000640 g     O .rodata	00000010 IfxAsclin2_SCLK_P33_9_OUT
8000dcd8 g     F .text	00000042 __hi0bits
80002760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_59
80000830 g     O .rodata	00000010 IfxAsclin1_RXB_P15_5_IN
80002e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_115
80000400 g     O .rodata	00000010 IfxAsclin1_TX_P20_10_OUT
80000410 g     O .rodata	00000010 IfxAsclin1_TX_P15_5_OUT
8000e920 g     F .text	0000004e .hidden __fixdfsi
80003160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_139
8000a7a6 g     F .text	00000068 osEE_scheduler_task_activated
800060f4 g     F .text	00000078 IfxScuCcu_getBbbFrequency
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
80000340 g     O .rodata	00000010 IfxAsclin3_TX_P00_1_OUT
800004c0 g     O .rodata	00000010 IfxAsclin0_TX_P14_0_OUT
80002f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_121
8000468a g     F .text	0000000c asclin3TxISR
800063d2 g     F .text	00000036 IfxScuCcu_getFsiFrequency
80000b10 g     O .rodata	00000010 IfxScu_WDT0LCK_P20_8_OUT
80002100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_8
80002580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_44
80003d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_234
800032a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_149
800071a6 g     F .text	00000036 IfxScuWdt_clearCpuEndinit
800092fc g     F .text	00000028 getUltrasonic
80002e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_113
80003320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_153
800025e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_47
800022e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_23
80000660 g     O .rodata	00000010 IfxAsclin2_SCLK_P14_2_OUT
80004f6e g     F .text	00000182 IfxAsclin_setBitTiming
80000cc8 g     O .rodata	00000010 IfxScu_EXTCLK1_P32_4_OUT
800004d0 g     O .rodata	00000010 IfxAsclin3_SLSO_P33_1_OUT
80000300 g     O .rodata	00000010 IfxAsclin3_TX_P15_7_OUT
8000892a g     F .text	0000001c printStateLv2
80000810 g     O .rodata	00000010 IfxAsclin1_RXD_P14_8_IN
80000c8c g     O .rodata	0000000c IfxScu_HWCFG4_P10_5_IN
800090b2 g     F .text	000000b8 sendSensorPacket
80007608 g     F .text	00000026 IfxVadc_Adc_deInitGroup
8000ab72 g     F .text	00000026 .hidden __lshrdi3
80000720 g     O .rodata	00000010 IfxAsclin3_RXE_P00_1_IN
80008b6a g     F .text	00000008 initInfotainment
800039a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_205
80000850 g     O .rodata	00000010 IfxAsclin0_RXD_P34_2_IN
800005b0 g     O .rodata	00000010 IfxAsclin3_SCLK_P21_7_OUT
80007bca g     F .text	0000038a IfxVadc_Adc_initGroup
8000deaa g     F .text	0000007c __pow5mult
700009c0 g     O .bss	0000000c g_ERUconfig
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_255
80002860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_67
80002e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_112
80006e98 g     F .text	00000026 IfxScuEru_disableRisingEdgeDetection
80000570 g     O .rodata	00000010 IfxAsclin1_SLSO_P20_8_OUT
8000a878 g     F .text	0000008a osEE_scheduler_task_terminated
80000350 g     O .rodata	00000010 IfxAsclin3_TX_P00_0_OUT
80004282 g     F .text	00000028 FuncDashboardButtonTask
80002460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_35
800036a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_181
8000b3a4 g     F .text	000000c6 .hidden __pack_f
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_245
800081da g     F .text	0000005e Ifx_CircularBuffer_read8
800008a0 g     O .rodata	00000010 IfxAsclin2_RTS_P10_8_OUT
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
80003b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_219
80002360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_27
800037a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_189
800073f6 g     F .text	0000001a IfxScuWdt_initConfig
80001400 g       .ctors	00000000 __CTOR_LIST__
80009a28 g     F .text	000000a4 osEE_tc_get_fsource
80004e8a g     F .text	00000012 IfxAsclin_read32
80000c24 g     O .rodata	00000014 IfxScu_REQ12_P11_10_IN
800074e4 g     F .text	00000004 IfxScuWdt_serviceCpuWatchdog
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_247
800008d0 g     O .rodata	00000010 IfxAsclin0_RTS_P14_7_OUT
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_86
800007a0 g     O .rodata	00000010 IfxAsclin2_RXD_P10_6_IN
80009b00 g     F .text	00000084 osEE_tc_stm_set_sr0
80000b20 g     O .rodata	00000014 IfxScu_REQ9_P20_0_IN
80000670 g     O .rodata	00000010 IfxAsclin2_SCLK_P10_6_OUT
80002e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_116
8000aaee g     F .text	0000001e osEE_tc_change_context_from_isr2_end
80002a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_83
8000dbba g     F .text	00000018 memchr
80003400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_160
8000ba6e g     F .text	000001ac _free_r
8000586c g     F .text	00000048 IfxAsclin_Asc_initiateTransmission
800023e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_31
8000a52e g     F .text	00000018 GetISRID
80008946 g     F .text	0000001c printStateLv3
8000aa60 g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
800020a0 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_5
80001380 g       .traptab	00000000 osEE_tc_trap_bus
80005e08 g     F .text	000000f8 IfxScuCcu_calculateSysPllDividers
80008cdc g     F .text	00000006 getPhotoresiter
800008f0 g     O .rodata	00000010 IfxAsclin2_CTSB_P33_5_IN
70000148 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80003520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_169
80008374 g     F .text	00000022 Ifx_Fifo_create
80003f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_249
800073c6 g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800013e0 g       .traptab	00000000 osEE_tc_trap_nmi
8000df26 g     F .text	000000ba __lshift
80003600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_176
80000650 g     O .rodata	00000010 IfxAsclin2_SCLK_P33_7_OUT
8000762e g     F .text	0000001c IfxVadc_Adc_disableModule
8000902e g     F .text	0000006a readSensorPacket
00002000 g       *ABS*	00000000 __CSA_SIZE
8000e1d6 g     F .text	000000f0 __ssprint_r
800048b8 g     F .text	0000001a IfxVadc_getAdcDigitalFrequency
5001bc00 g       .CPU2.csa	00000000 __CSA2
800034a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_165
80003c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_227
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
8000473c g     F .text	00000038 IfxVadc_enableAccess
800027c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_62
8000dd90 g     F .text	0000011a __multiply
00000001 g       *ABS*	00000000 _.
70000c80 g     O .bss	00000009 g_RecievedSensorPacket
80006fb0 g     F .text	00000012 IfxScuEru_getEventFlagStatus
800041e8 g     F .text	00000036 lcd_print
80000530 g     O .rodata	00000010 IfxAsclin2_SLSO_P33_6_OUT
80000380 g     O .rodata	00000010 IfxAsclin2_TX_P32_5_OUT
80004c04 g     F .text	00000024 IfxVadc_selectPowerSupplyVoltage
80006e72 g     F .text	00000026 IfxScuEru_disablePatternDetectionTrigger
70000f10 g     O .bss	00000028 __malloc_current_mallinfo
8000e0ec g     F .text	000000a8 __d2b
80003c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_226
800037c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_190
80003360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_155
800026c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_54
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_125
8000899a g     F .text	0000001c printStateOff
80002b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_91
80000b5c g     O .rodata	00000014 IfxScu_REQ6_P02_0_IN
80008198 g     F .text	00000022 Ifx_CircularBuffer_get16
80000450 g     O .rodata	00000010 IfxAsclin1_TX_P14_10_OUT
80003680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_180
80005fa2 g     F .text	00000044 IfxScuCcu_getPllErayVcoFrequency
80001400 g       .ctors	00000000 __EH_FRAME_END__
80006e26 g     F .text	00000026 IfxScuEru_disableAutoClear
80006a92 g     F .text	00000050 IfxScuCcu_setPll2ErayFrequency
6001bb00 g       .CPU1.istack	00000000 __ISTACK1
80003800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_192
800033a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_157
800061fc g     F .text	00000022 IfxScuCcu_getBaud2Frequency
80003240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_146
80002da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_109
800005f0 g     O .rodata	00000010 IfxAsclin3_SCLK_P15_6_OUT
8000ea66 g     F .text	000000a6 .hidden __fpcmp_parts_d
80004d22 g     F .text	0000001c IfxAsclin_enableModule
800021a0 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_13
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
8000a706 g     F .text	00000026 osEE_scheduler_core_pop_running
80003f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_252
8000a9d4 g     F .text	0000006a osEE_cpu_startos
80003b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_218
80006f56 g     F .text	00000026 IfxScuEru_enableRisingEdgeDetection
800007d0 g     O .rodata	00000010 IfxAsclin2_RXA_P14_3_IN
80003e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_241
800029c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_78
80005a28 g     F .text	00000022 IfxPort_getIndex
800030a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_133
8000a4a4 g     F .text	00000032 GetEvent
8000541a g     F .text	0000001c IfxAsclin_Asc_disableModule
6001b600 g       .CPU1.ustack	00000000 __USTACK1
80004e9c g     F .text	00000012 IfxAsclin_read8
8000a80e g     F .text	0000002e osEE_scheduler_task_insert
80003be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_223
80002620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_49
8000af82 g     F .text	00000118 .hidden __divdf3
80000d28 g     O .rodata	00000010 IfxScu_EMGSTOPA_P33_8_IN
80000cd8 g     O .rodata	00000010 IfxScu_EXTCLK1_P11_12_OUT
80005916 g     F .text	0000001c IfxAsclin_Asc_blockingWrite
8000806a g     F .text	0000003a IfxVadc_Adc_initModuleConfig
70000150 g     O .data	00000408 __malloc_av_
80002f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_120
8000a260 g     F .text	00000064 ShutdownOS
80003060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_131
8000b954 g     F .text	0000004a _vsnprintf_r
800035e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_175
70018600 g     O .CPU0.ustack	00000000 __USTACK0_END
80003900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_200
80002120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_9
8000adde g     F .text	000001a4 .hidden __muldf3
80002500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_40
800006e0 g     O .rodata	00000010 IfxAsclin0_SCLK_P14_0_OUT
80002520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_41
80004380 g     F .text	0000006e delay_us
80000d18 g     O .rodata	00000010 IfxScu_EMGSTOPB_P21_2_IN
8000b91e g     F .text	00000002 __malloc_lock
8000e788 g     F .text	0000003c sbrk
80005f00 g     F .text	0000000e IfxScuCcu_getOsc0Frequency
80004704 g     F .text	00000038 IfxVadc_disableAccess
80008ce2 g     F .text	00000082 initUartDriver
80000000 g       .startup	00000000 BootModeHeader0
800013c0 g       .traptab	00000000 osEE_tc_trap_system
80000c98 g     O .rodata	0000000c IfxScu_HWCFG3_BMI_P14_3_IN
80004e64 g     F .text	00000014 IfxAsclin_getSrcPointerTx
80004900 g     F .text	00000094 IfxVadc_getResultBasedOnRequestSource
8000e2c6 g     F .text	00000062 _calloc_r
00002000 g       *ABS*	00000000 __CSA0_SIZE
8000621e g     F .text	00000078 IfxScuCcu_getSpbFrequency
80002820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_65
800007c0 g     O .rodata	00000010 IfxAsclin2_RXB_P02_1_IN
800047f6 g     F .text	000000aa IfxVadc_enableGroupSync
8000700a g     F .text	00000012 IfxScuEru_getPatternDetectionResult
800024a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_37
800052c0 g     F .text	0000009e IfxAsclin_Asc_isrTransmit
80000370 g     O .rodata	00000010 IfxAsclin2_TX_P33_8_OUT
80003d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_233
80003960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_203
8000e378 g     F .text	00000010 memset
800034e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_167
80002640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_50
8000410a g     F .text	000000d0 lcd_init
80004696 g     F .text	0000006c main
800073a6 g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
80004316 g     F .text	0000006a delay_ms
80006f7c g     F .text	00000026 IfxScuEru_enableTriggerPulse
80002200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_16
70000f38 g     O .bss	00000004 __malloc_max_total_mem
80003540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_170
8000421e g     F .text	00000064 FuncSensorTask
80004cf4 g     F .text	0000002e IfxAsclin_enableAscErrorFlags
8000eb0c g     F .text	0000009c .hidden __udiv6432
80008e0c g     F .text	000000de sendActuatorPacket
00000400 g       *ABS*	00000000 __ISTACK_SIZE
800061dc g     F .text	00000020 IfxScuCcu_getBaud1Frequency
800025a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_45
800080e6 g     F .text	00000092 IfxVadc_Adc_initExternalMultiplexerMode
80000bd4 g     O .rodata	00000014 IfxScu_REQ16_P15_1_IN
700009cc g     O .bss	00000274 g_AsclinAsc
80002b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_88
80000c74 g     O .rodata	0000000c IfxScu_HWCFG6_P14_4_IN
8000a72c g     F .text	00000018 osEE_task_activated
5001bb00 g       .CPU2.istack	00000000 __ISTACK2
80000098 g     O .rodata	00000014 osEE_kdb_var
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
800073e2 g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
8000b100 g     F .text	0000003c .hidden __truncdfsf2
80003b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_220
80003020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_129
8000cedc g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000b484 g     F .text	0000049a _malloc_r
800004e0 g     O .rodata	00000010 IfxAsclin3_SLSO_P21_6_OUT
80005d88 g     F .text	00000042 IfxPort_setPinModeLvdsMedium
800007b0 g     O .rodata	00000010 IfxAsclin2_RXC_P02_10_IN
800039e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_207
800053f4 g     F .text	00000026 IfxAsclin_Asc_blockingRead
80003d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_235
800024e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_39
80002020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_1
800005a0 g     O .rodata	00000010 IfxAsclin3_SCLK_P32_3_OUT
80005128 g     F .text	00000006 IfxAsclin_Asc_getReadCount
80002a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_80
80008000 g       *ABS*	00000000 __A8_MEM
80000590 g     O .rodata	00000010 IfxAsclin3_SCLK_P33_2_OUT
b0008000 g       *ABS*	00000000 __A9_MEM
80005104 g     F .text	00000012 IfxAsclin_write32
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_231
80003340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_154
70000130 g     O .data	0000000a g_FrontUltrasonic
80002c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_98
80004460 g     F .text	00000072 printfSerial
80000f90 g     O .rodata	00000014 .hidden __thenan_df
8000b9b4 g     F .text	000000ba _malloc_trim_r
80001408 g       .ctors	00000000 __CTOR_END__
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
800003c0 g     O .rodata	00000010 IfxAsclin2_TX_P02_9_OUT
80004b08 g     F .text	000000aa IfxVadc_getChannelConversionTime
50000000 g       *ABS*	00000000 __DSPR2_START
800028c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_70
80004774 g     F .text	00000046 IfxVadc_configExternalMultiplexerMode
8000a174 g     F .text	000000ec ReleaseResource
800080a4 g     F .text	00000042 IfxVadc_Adc_initExternalMultiplexerModeConfig
80004dea g     F .text	00000018 IfxAsclin_getPdFrequency
800048d6 g     F .text	0000001a IfxVadc_getBackgroundScanStatus
80003da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_237
80001408 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
80003c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_224
800026a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_53
00001000 g       *ABS*	00000000 __USTACK1_SIZE
80002b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_90
80004bb2 g     F .text	00000052 IfxVadc_resetKernel
800008c0 g     O .rodata	00000010 IfxAsclin1_RTS_P20_6_OUT
80008eea g     F .text	0000000a deserialize_actuator_packet
80000cbc g     O .rodata	0000000c IfxScu_HWCFG0DCLDO_P14_6_IN
8000e820 g     F .text	00000040 .hidden __nedf2
80004f1c g     F .text	00000052 IfxAsclin_setBaudrateBitFields
80003a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_209
80003880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_196
80006058 g     F .text	00000044 IfxScuCcu_getPllVcoFrequency
80006b32 g     F .text	000000b4 IfxScuCcu_setSpbFrequency
80003220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_145
80002d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_108
80006fe6 g     F .text	00000024 IfxScuEru_getOutputChannelConfiguration
80000af0 g     O .rodata	00000010 IfxScu_WDT2LCK_P20_6_OUT
800009e0 g     O .rodata	00000080 IfxPort_cfg_esrMasks
80002a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_84
80000700 g     O .rodata	00000010 IfxAsclin3_RXG_P21_2_IN
80003500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_168
80005280 g     F .text	00000010 IfxAsclin_Asc_clearRx
80000930 g     O .rodata	00000010 IfxAsclin0_CTSA_P14_9_IN
80002400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_32
80003000 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_128
80000d48 g     O .rodata	00000010 IfxScu_DCDCSYNC_P32_2_OUT
80005aa2 g     F .text	0000002a IfxPort_setESR
80000500 g     O .rodata	00000010 IfxAsclin3_SLSO_P14_3_OUT
80003620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_177
80000440 g     O .rodata	00000010 IfxAsclin1_TX_P15_0_OUT
80003120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_137
80002900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_72
80008df2 g     F .text	0000001a serialize_actuator_packet
80000920 g     O .rodata	00000010 IfxAsclin1_CTSA_P20_7_IN
80002600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_48
80000b98 g     O .rodata	00000014 IfxScu_REQ3_P10_3_IN
80000430 g     O .rodata	00000010 IfxAsclin1_TX_P15_1_OUT
70000558 g     O .data	00000004 _impure_ptr
80003660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_179
80005a4a g     F .text	00000028 IfxPort_resetESR
8000515c g     F .text	00000072 IfxAsclin_Asc_isrError
800049c6 g     F .text	00000024 IfxVadc_initialiseAdcArbiterClock
80008dde g     F .text	00000014 calculate_checksum
80004e50 g     F .text	00000014 IfxAsclin_getSrcPointerRx
800036e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_183
80000490 g     O .rodata	00000010 IfxAsclin0_TX_P15_3_OUT
80009174 g     F .text	00000054 initUltrasonic
70000c94 g     O .bss	00000274 g_AsclinStm
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_230
80004e3c g     F .text	00000014 IfxAsclin_getSrcPointerEr
00002000 g       *ABS*	00000000 __CSA1_SIZE
800022c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_22
800003e0 g     O .rodata	00000010 IfxAsclin1_TX_P33_13_OUT
80000820 g     O .rodata	00000010 IfxAsclin1_RXC_P20_9_IN
80009ca2 g     F .text	00000016 DisableAllInterrupts
80008288 g     F .text	0000005e Ifx_CircularBuffer_write8
8000535e g     F .text	00000096 IfxAsclin_Asc_isrReceive
80005b08 g     F .text	00000090 IfxPort_setGroupModeInput
80008396 g     F .text	000000da Ifx_Fifo_canReadCount
00001000 g       *ABS*	00000000 __USTACK_SIZE
80009f1e g     F .text	000000d6 ChainTask
8000702a g     F .text	00000034 IfxScuEru_selectExternalInput
80006f0a g     F .text	00000026 IfxScuEru_enableFallingEdgeDetection
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_101
80000900 g     O .rodata	00000010 IfxAsclin2_CTSA_P10_7_IN
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
80000780 g     O .rodata	00000010 IfxAsclin2_RXF_P32_6_IN
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_126
80000600 g     O .rodata	00000010 IfxAsclin3_SCLK_P11_4_OUT
800067c6 g     F .text	00000014 IfxScuCcu_initConfig
80003b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_217
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_221
800002d0 g     O .rodata	00000010 IfxAsclin3_TX_P21_7_OUT
80004a38 g     F .text	00000066 IfxVadc_initializeFAdcI
80000540 g     O .rodata	00000010 IfxAsclin2_SLSO_P10_5_OUT
80000b34 g     O .rodata	00000014 IfxScu_REQ8_P33_7_IN
800002a0 g     O .rodata	00000010 IfxAsclin3_TX_P32_2_OUT
80001300 g       .traptab	00000000 osEE_tc_trap_mmu
80008238 g     F .text	00000050 Ifx_CircularBuffer_read32
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_87
800051dc g     F .text	0000009c IfxAsclin_Asc_flushTx
80009c4e g     F .text	00000028 osEE_tc_delay
80000620 g     O .rodata	00000010 IfxAsclin3_SCLK_P00_2_OUT
80001178 g     O .rodata	00000000 __clear_table
80005f3e g     F .text	00000064 IfxScuCcu_getPllErayFrequency
800007f0 g     O .rodata	00000010 IfxAsclin1_RXF_P33_13_IN
8000a744 g     F .text	0000001e osEE_task_end
800005d0 g     O .rodata	00000010 IfxAsclin3_SCLK_P20_0_OUT
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_110
80002f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_124
80008b72 g     F .text	000000c6 updateStateByPacket
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_222
80002240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_18
80002440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_34
80000840 g     O .rodata	00000010 IfxAsclin1_RXA_P15_1_IN
80001400 g       .ctors	00000000 __EH_FRAME_BEGIN__
80000520 g     O .rodata	00000010 IfxAsclin3_SLSO_P00_3_OUT
80002840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_66
80003140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_138
80003e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_243
8000609c g     F .text	00000024 IfxScuCcu_getSourceFrequency
80000480 g     O .rodata	00000010 IfxAsclin0_TX_P34_1_OUT
80000d38 g     O .rodata	00000010 IfxScu_DCDCSYNC_P33_13_OUT
80000c10 g     O .rodata	00000014 IfxScu_REQ13_P15_5_IN
8000a98e g     F .text	00000020 osEE_change_context_from_task_end
8000a394 g     F .text	0000007a WaitEvent
80008c38 g     F .text	000000a4 updateStateByButton
80005a72 g     F .text	00000030 IfxPort_disableEmergencyStop
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_253
80003c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_225
80009324 g     F .text	00000016 calculateDistanceCm
80000310 g     O .rodata	00000010 IfxAsclin3_TX_P15_6_OUT
80002880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_68
80007f54 g     F .text	0000002e IfxVadc_Adc_initGroupConfig
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
80002980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_76
5001b600 g       .CPU2.ustack	00000000 __USTACK2
80003940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_202
80009c30 g     F .text	0000001e osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80003260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_147
80000020 g       .startup	00000000 BootModeIndex
800032c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_150
80003d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_236
7000014c g     O .data	00000004 __malloc_trim_threshold
800031a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_141
80002d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_104
800048d2 g     F .text	00000004 IfxVadc_getAdcModuleFrequency
8000870c g     F .text	00000186 Ifx_Fifo_write
8000e022 g     F .text	000000ca __mdiff
800020e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_7
80002920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_73
8000a784 g     F .text	00000022 osEE_activate_isr2
80007bb4 g     F .text	00000016 IfxVadc_Adc_initChannelConfig
80004d54 g     F .text	00000074 IfxAsclin_getFaFrequency
80006ae2 g     F .text	00000050 IfxScuCcu_setPll2Frequency
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_238
80020000 g       .startup	00000000 BootModeHeader1
800097fa g     F .text	0000022e osEE_tc_set_pll_fsource
80004a0e g     F .text	0000002a IfxVadc_initializeFAdcD
800043ee g     F .text	00000072 UART_init
80005c2a g     F .text	000000a4 IfxPort_setGroupPadDriver
800026e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_55
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_127
80002b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_92
80000cf8 g     O .rodata	00000010 IfxScu_EVRWUPB_P15_1_IN
80000870 g     O .rodata	00000010 IfxAsclin0_RXA_P14_1_IN
80008962 g     F .text	0000001c printStateLv4
80005116 g     F .text	00000012 IfxAsclin_write8
8000701c g     F .text	0000000e IfxScuEru_getWholePatternDetectionResult
80002320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_25
800039c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_206
800029e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_79
800011e0 g     O .rodata	00000000 __copy_table
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
800050f0 g     F .text	00000014 IfxAsclin_write16
800085e6 g     F .text	00000036 Ifx_Fifo_clear
80000bac g     O .rodata	00000014 IfxScu_REQ2_P10_2_IN
7000013a g     O .data	0000000a g_UpperUltrasonic
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_119
8000e778 g     F .text	00000010 _exit
80002280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_20
80001320 g       .traptab	00000000 osEE_tc_trap_protection
80001300 g     F .traptab	00000000 __TRAPTAB
80000c38 g     O .rodata	00000014 IfxScu_REQ11_P20_9_IN
00002000 g       *ABS*	00000000 __CSA2_SIZE
80006dc8 g     F .text	00000028 IfxScuEru_clearOutputChannelConfiguration
800035a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_173
80006ebe g     F .text	00000026 IfxScuEru_disableTriggerPulse
8000751a g     F .text	000000aa IfxScuWdt_initSafetyWatchdog
80005138 g     F .text	00000006 IfxAsclin_Asc_getSendCount
8000b940 g     F .text	00000014 strlen
80003860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_195
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
80004efa g     F .text	00000022 IfxAsclin_setClockSource
8000e8a0 g     F .text	00000040 .hidden __gedf2
80000a60 g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
800045e8 g     F .text	000000a2 initPeripheralsAndERU
80000770 g     O .rodata	00000010 IfxAsclin2_RXG_P02_0_IN
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_94
80002720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_57
80003420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_161
800003d0 g     O .rodata	00000010 IfxAsclin2_TX_P02_0_OUT
80002f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_122
80000b70 g     O .rodata	00000014 IfxScu_REQ5_P10_8_IN
80004c28 g     F .text	00000056 IfxVadc_setArbiterPriority
70000f58 g     O .text	00000001 __HEAP_END
80000560 g     O .rodata	00000010 IfxAsclin1_SLSO_P33_10_OUT
6001bc00 g       .CPU1.csa	00000000 __CSA1
8000616c g     F .text	00000070 IfxScuCcu_getMaxFrequency
80009cb8 g     F .text	0000001c EnableAllInterrupts
80000580 g     O .rodata	00000010 IfxAsclin1_SLSO_P14_3_OUT
80004c92 g     F .text	00000044 IfxVadc_startupCalibration
700009bc g     O .bss	00000004 g_vadc
80005cce g     F .text	00000056 IfxPort_setPinMode
80003640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_178
80002780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_60
80000b48 g     O .rodata	00000014 IfxScu_REQ7_P00_4_IN
8000aa84 g     F .text	0000001a osEE_hal_restore_ctx
800044f0 g     F .text	00000032 initVADCGroup
800005c0 g     O .rodata	00000010 IfxAsclin3_SCLK_P21_5_OUT
8000ad9e g     F .text	00000040 .hidden __subdf3
70008000 g     O *ABS*	00000000 _SMALL_DATA_
8000513e g     F .text	00000006 IfxAsclin_Asc_getTxTimeStamp
80004a9e g     F .text	0000006a IfxVadc_isPostCalibration
800044d2 g     F .text	0000001e initVADCModule
80003f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_248
80006d8a g     F .text	00000016 IfxScuEru_clearEventFlag
800074e8 g     F .text	00000032 IfxScuWdt_setSafetyEndinit
8000dd1a g     F .text	00000066 __lo0bits
800034c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_166
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
80000360 g     O .rodata	00000010 IfxAsclin2_TX_P33_9_OUT
80003080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_132
80005f0e g     F .text	00000030 IfxScuCcu_getOscFrequency
80009d98 g     F .text	0000003c ResumeOSInterrupts
80004000 g     F .text	00000080 readLcdButtons
800030e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_135
80004eae g     F .text	0000004c IfxAsclin_resetModule
8000916a g     F .text	0000000a deserialize_sensor_packet
80006fc2 g     F .text	00000024 IfxScuEru_getInputChannelConfiguration
80000680 g     O .rodata	00000010 IfxAsclin2_SCLK_P02_4_OUT
80006d78 g     F .text	00000012 IfxScuEru_clearAllEventFlags
80003200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_144
80002d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_107
80002160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_11
800000ac g     O .rodata	00000008 osEE_cdb_var
8000b1e6 g     F .text	00000112 .hidden __pack_d
80000940 g     O .rodata	00000020 IfxAsclin_cfg_indexMap
80009dd4 g     F .text	000000ac StartOS
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_229
80000cb0 g     O .rodata	0000000c IfxScu_HWCFG1EVR33_P14_5_IN
80000b84 g     O .rodata	00000014 IfxScu_REQ4_P10_7_IN
80003440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_162
8000b476 g     F .text	0000000e free
80000ae0 g     O .rodata	00000010 IfxScu_WDTSLCK_P20_9_OUT
8000dc56 g     F .text	00000082 __multadd
8000dc44 g     F .text	00000012 _Bfree
800006a0 g     O .rodata	00000010 IfxAsclin1_SCLK_P33_11_OUT
80008000 g     O *ABS*	00000000 _SMALL_DATA3_
80008a0a g     F .text	00000160 printInfoDisplay
80003a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_212



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 9d 49 	ja 8000933a <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80001300 <__TRAPTAB>:
80001300:	00 a0       	debug 
80001302:	1d ff ff ff 	j 80001300 <__TRAPTAB>
	...

80001320 <osEE_tc_trap_protection>:
80001320:	00 a0       	debug 
80001322:	1d ff ff ff 	j 80001320 <osEE_tc_trap_protection>
	...

80001340 <osEE_tc_trap_instruction>:
80001340:	00 a0       	debug 
80001342:	1d ff ff ff 	j 80001340 <osEE_tc_trap_instruction>
	...

80001360 <osEE_tc_trap_context>:
80001360:	00 a0       	debug 
80001362:	1d ff ff ff 	j 80001360 <osEE_tc_trap_context>
	...

80001380 <osEE_tc_trap_bus>:
80001380:	00 a0       	debug 
80001382:	1d ff ff ff 	j 80001380 <osEE_tc_trap_bus>
	...

800013a0 <osEE_tc_trap_assertion>:
800013a0:	00 a0       	debug 
800013a2:	1d ff ff ff 	j 800013a0 <osEE_tc_trap_assertion>
	...

800013c0 <osEE_tc_trap_system>:
800013c0:	00 a0       	debug 
800013c2:	1d ff ff ff 	j 800013c0 <osEE_tc_trap_system>
	...

800013e0 <osEE_tc_trap_nmi>:
800013e0:	00 a0       	debug 
800013e2:	1d ff ff ff 	j 800013e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001400 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001408 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_isr_dummy_entry_1>:
80002020:	3c 00       	j 80002020 <osEE_tc_isr_dummy_entry_1>
	...

80002040 <osEE_tc_isr_dummy_entry_2>:
80002040:	3c 00       	j 80002040 <osEE_tc_isr_dummy_entry_2>
	...

80002060 <osEE_tc_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_isr_dummy_entry_3>
	...

80002080 <osEE_tc_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_isr2_entry_5>:
800020a0:	0d 00 00 02 	svlcx 
800020a4:	82 34       	mov %d4,3
800020a6:	1d 00 e8 3d 	j 80009c76 <osEE_tc_isr2_wrapper>
	...

800020c0 <osEE_tc_isr2_entry_6>:
800020c0:	0d 00 00 02 	svlcx 
800020c4:	82 44       	mov %d4,4
800020c6:	1d 00 d8 3d 	j 80009c76 <osEE_tc_isr2_wrapper>
	...

800020e0 <osEE_tc_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_isr_dummy_entry_7>
	...

80002100 <osEE_tc_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_isr_dummy_entry_8>
	...

80002120 <osEE_tc_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_isr_dummy_entry_9>
	...

80002140 <osEE_tc_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_isr_dummy_entry_10>
	...

80002160 <osEE_tc_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_isr_dummy_entry_11>
	...

80002180 <osEE_tc_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_isr2_entry_13>:
800021a0:	0d 00 00 02 	svlcx 
800021a4:	82 14       	mov %d4,1
800021a6:	1d 00 68 3d 	j 80009c76 <osEE_tc_isr2_wrapper>
	...

800021c0 <osEE_tc_isr2_entry_14>:
800021c0:	0d 00 00 02 	svlcx 
800021c4:	82 24       	mov %d4,2
800021c6:	1d 00 58 3d 	j 80009c76 <osEE_tc_isr2_wrapper>
	...

800021e0 <osEE_tc_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_isr_dummy_entry_15>
	...

80002200 <osEE_tc_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_isr_dummy_entry_16>
	...

80002220 <osEE_tc_isr2_entry_17>:
80002220:	0d 00 00 02 	svlcx 
80002224:	82 04       	mov %d4,0
80002226:	1d 00 28 3d 	j 80009c76 <osEE_tc_isr2_wrapper>
	...

80002240 <osEE_tc_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_isr_dummy_entry_18>
	...

80002260 <osEE_tc_isr_dummy_entry_19>:
80002260:	3c 00       	j 80002260 <osEE_tc_isr_dummy_entry_19>
	...

80002280 <osEE_tc_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_isr_dummy_entry_23>
	...

80002300 <osEE_tc_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_isr_dummy_entry_24>
	...

80002320 <osEE_tc_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_isr_dummy_entry_25>
	...

80002340 <osEE_tc_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_isr_dummy_entry_26>
	...

80002360 <osEE_tc_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_isr_dummy_entry_27>
	...

80002380 <osEE_tc_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_isr_dummy_entry_31>
	...

80002400 <osEE_tc_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_isr_dummy_entry_32>
	...

80002420 <osEE_tc_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_isr_dummy_entry_33>
	...

80002440 <osEE_tc_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_isr_dummy_entry_34>
	...

80002460 <osEE_tc_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_isr_dummy_entry_35>
	...

80002480 <osEE_tc_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_isr_dummy_entry_39>
	...

80002500 <osEE_tc_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_isr_dummy_entry_40>
	...

80002520 <osEE_tc_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_isr_dummy_entry_41>
	...

80002540 <osEE_tc_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_isr_dummy_entry_42>
	...

80002560 <osEE_tc_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_isr_dummy_entry_43>
	...

80002580 <osEE_tc_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_isr_dummy_entry_47>
	...

80002600 <osEE_tc_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_isr_dummy_entry_48>
	...

80002620 <osEE_tc_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_isr_dummy_entry_49>
	...

80002640 <osEE_tc_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_isr_dummy_entry_50>
	...

80002660 <osEE_tc_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_isr_dummy_entry_51>
	...

80002680 <osEE_tc_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_isr_dummy_entry_55>
	...

80002700 <osEE_tc_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_isr_dummy_entry_56>
	...

80002720 <osEE_tc_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_isr_dummy_entry_57>
	...

80002740 <osEE_tc_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_isr_dummy_entry_58>
	...

80002760 <osEE_tc_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_isr_dummy_entry_59>
	...

80002780 <osEE_tc_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_isr_dummy_entry_63>
	...

80002800 <osEE_tc_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_isr_dummy_entry_64>
	...

80002820 <osEE_tc_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_isr_dummy_entry_65>
	...

80002840 <osEE_tc_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_isr_dummy_entry_66>
	...

80002860 <osEE_tc_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_isr_dummy_entry_67>
	...

80002880 <osEE_tc_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_isr_dummy_entry_71>
	...

80002900 <osEE_tc_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_isr_dummy_entry_72>
	...

80002920 <osEE_tc_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_isr_dummy_entry_73>
	...

80002940 <osEE_tc_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_isr_dummy_entry_74>
	...

80002960 <osEE_tc_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_isr_dummy_entry_75>
	...

80002980 <osEE_tc_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_isr_dummy_entry_127>
	...

80003000 <osEE_tc_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_isr_dummy_entry_128>
	...

80003020 <osEE_tc_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_isr_dummy_entry_129>
	...

80003040 <osEE_tc_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_isr_dummy_entry_130>
	...

80003060 <osEE_tc_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_isr_dummy_entry_131>
	...

80003080 <osEE_tc_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_isr_dummy_entry_135>
	...

80003100 <osEE_tc_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_isr_dummy_entry_136>
	...

80003120 <osEE_tc_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_isr_dummy_entry_137>
	...

80003140 <osEE_tc_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_isr_dummy_entry_138>
	...

80003160 <osEE_tc_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_isr_dummy_entry_139>
	...

80003180 <osEE_tc_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_isr_dummy_entry_143>
	...

80003200 <osEE_tc_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_isr_dummy_entry_144>
	...

80003220 <osEE_tc_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_isr_dummy_entry_145>
	...

80003240 <osEE_tc_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_isr_dummy_entry_146>
	...

80003260 <osEE_tc_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_isr_dummy_entry_147>
	...

80003280 <osEE_tc_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_isr_dummy_entry_151>
	...

80003300 <osEE_tc_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_isr_dummy_entry_152>
	...

80003320 <osEE_tc_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_isr_dummy_entry_153>
	...

80003340 <osEE_tc_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_isr_dummy_entry_154>
	...

80003360 <osEE_tc_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_isr_dummy_entry_155>
	...

80003380 <osEE_tc_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_isr_dummy_entry_159>
	...

80003400 <osEE_tc_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_isr_dummy_entry_160>
	...

80003420 <osEE_tc_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_isr_dummy_entry_161>
	...

80003440 <osEE_tc_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_isr_dummy_entry_162>
	...

80003460 <osEE_tc_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_isr_dummy_entry_163>
	...

80003480 <osEE_tc_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_isr_dummy_entry_167>
	...

80003500 <osEE_tc_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_isr_dummy_entry_168>
	...

80003520 <osEE_tc_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_isr_dummy_entry_169>
	...

80003540 <osEE_tc_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_isr_dummy_entry_170>
	...

80003560 <osEE_tc_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_isr_dummy_entry_171>
	...

80003580 <osEE_tc_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_isr_dummy_entry_175>
	...

80003600 <osEE_tc_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_isr_dummy_entry_176>
	...

80003620 <osEE_tc_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_isr_dummy_entry_177>
	...

80003640 <osEE_tc_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_isr_dummy_entry_178>
	...

80003660 <osEE_tc_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_isr_dummy_entry_179>
	...

80003680 <osEE_tc_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_isr_dummy_entry_183>
	...

80003700 <osEE_tc_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_isr_dummy_entry_184>
	...

80003720 <osEE_tc_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_isr_dummy_entry_185>
	...

80003740 <osEE_tc_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_isr_dummy_entry_186>
	...

80003760 <osEE_tc_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_isr_dummy_entry_187>
	...

80003780 <osEE_tc_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_isr_dummy_entry_191>
	...

80003800 <osEE_tc_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_isr_dummy_entry_192>
	...

80003820 <osEE_tc_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_isr_dummy_entry_193>
	...

80003840 <osEE_tc_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_isr_dummy_entry_194>
	...

80003860 <osEE_tc_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_isr_dummy_entry_195>
	...

80003880 <osEE_tc_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_isr_dummy_entry_199>
	...

80003900 <osEE_tc_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_isr_dummy_entry_200>
	...

80003920 <osEE_tc_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_isr_dummy_entry_201>
	...

80003940 <osEE_tc_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_isr_dummy_entry_202>
	...

80003960 <osEE_tc_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_isr_dummy_entry_203>
	...

80003980 <osEE_tc_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <readLcdButtons>:

int readLcdButtons(void)
{
    unsigned adc_key_in=0;
    int button_state=0;
    adc_key_in = readADCValue(BUTTON_CH);
80004000:	82 34       	mov %d4,3
80004002:	6d 00 e0 02 	call 800045c2 <readADCValue>
80004006:	02 2f       	mov %d15,%d2
    // printfSerial("ADC(%d)",adc_key_in);
    if (adc_key_in < 100) {
80004008:	8b 42 a6 22 	ge.u %d2,%d2,100
8000400c:	f6 29       	jnz %d2,8000401e <readLcdButtons+0x1e>
        button_state = btnUP;
        printfSerial("[U]");
8000400e:	91 00 00 48 	movh.a %a4,32768
80004012:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <_start+0x8>>
80004016:	6d 00 25 02 	call 80004460 <printfSerial>
    unsigned adc_key_in=0;
    int button_state=0;
    adc_key_in = readADCValue(BUTTON_CH);
    // printfSerial("ADC(%d)",adc_key_in);
    if (adc_key_in < 100) {
        button_state = btnUP;
8000401a:	82 02       	mov %d2,0
8000401c:	00 90       	ret 
        printfSerial("[U]");
    } 
    else if (adc_key_in < 1000){
8000401e:	3b 80 3e 20 	mov %d2,1000
80004022:	7f 2f 0a 80 	jge.u %d15,%d2,80004036 <readLcdButtons+0x36>
        button_state = btnRIGHT; 
        printfSerial("[R]");
80004026:	91 00 00 48 	movh.a %a4,32768
8000402a:	d9 44 2c 00 	lea %a4,[%a4]44 <8000002c <_start+0xc>>
8000402e:	6d 00 19 02 	call 80004460 <printfSerial>
    if (adc_key_in < 100) {
        button_state = btnUP;
        printfSerial("[U]");
    } 
    else if (adc_key_in < 1000){
        button_state = btnRIGHT; 
80004032:	82 32       	mov %d2,3
80004034:	00 90       	ret 
        printfSerial("[R]");
    }     
    else if (adc_key_in < 2500){ 
80004036:	3b 40 9c 20 	mov %d2,2500
8000403a:	7f 2f 0a 80 	jge.u %d15,%d2,8000404e <readLcdButtons+0x4e>
        button_state = btnLEFT; 
        printfSerial("[L]");
8000403e:	91 00 00 48 	movh.a %a4,32768
80004042:	d9 44 30 00 	lea %a4,[%a4]48 <80000030 <_start+0x10>>
80004046:	6d 00 0d 02 	call 80004460 <printfSerial>
    else if (adc_key_in < 1000){
        button_state = btnRIGHT; 
        printfSerial("[R]");
    }     
    else if (adc_key_in < 2500){ 
        button_state = btnLEFT; 
8000404a:	82 22       	mov %d2,2
8000404c:	00 90       	ret 
        printfSerial("[L]");
    } 
    else if (adc_key_in < 3500){ 
8000404e:	3b c0 da 20 	mov %d2,3500
80004052:	7f 2f 0a 80 	jge.u %d15,%d2,80004066 <readLcdButtons+0x66>
        button_state = btnDOWN; 
        printfSerial("[D]");
80004056:	91 00 00 48 	movh.a %a4,32768
8000405a:	d9 44 34 00 	lea %a4,[%a4]52 <80000034 <_start+0x14>>
8000405e:	6d 00 01 02 	call 80004460 <printfSerial>
    else if (adc_key_in < 2500){ 
        button_state = btnLEFT; 
        printfSerial("[L]");
    } 
    else if (adc_key_in < 3500){ 
        button_state = btnDOWN; 
80004062:	82 12       	mov %d2,1
80004064:	00 90       	ret 
        printfSerial("[D]");
    }  
    else if (adc_key_in >= 4000){ 
80004066:	3b 00 fa 30 	mov %d3,4000


int readLcdButtons(void)
{
    unsigned adc_key_in=0;
    int button_state=0;
8000406a:	82 02       	mov %d2,0
    } 
    else if (adc_key_in < 3500){ 
        button_state = btnDOWN; 
        printfSerial("[D]");
    }  
    else if (adc_key_in >= 4000){ 
8000406c:	3f 3f 09 80 	jlt.u %d15,%d3,8000407e <readLcdButtons+0x7e>
        button_state = btnNONE;  
        printfSerial("[?]");
80004070:	91 00 00 48 	movh.a %a4,32768
80004074:	d9 44 38 00 	lea %a4,[%a4]56 <80000038 <_start+0x18>>
80004078:	6d 00 f4 01 	call 80004460 <printfSerial>
    else if (adc_key_in < 3500){ 
        button_state = btnDOWN; 
        printfSerial("[D]");
    }  
    else if (adc_key_in >= 4000){ 
        button_state = btnNONE;  
8000407c:	82 42       	mov %d2,4
        printfSerial("[?]");
    }
    return button_state;
8000407e:	00 90       	ret 

80004080 <lcd_write4bits>:
    delay_ms(2);       
}

static void lcd_write4bits(uint8 data)
{
    IfxPort_setPinState(LCD_D4, (data & 0x01) ? IfxPort_State_high : IfxPort_State_low);
80004080:	8f 14 00 21 	and %d2,%d4,1
80004084:	7b 10 00 f0 	movh %d15,1
80004088:	ab 1f a0 f2 	seln %d15,%d2,%d15,1
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000408c:	91 40 00 ff 	movh.a %a15,61444
80004090:	06 4f       	sh %d15,4
80004092:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80004096:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D5, (data & 0x02) ? IfxPort_State_high : IfxPort_State_low);
80004098:	8f 24 00 21 	and %d2,%d4,2
8000409c:	7b 80 00 f0 	movh %d15,8
800040a0:	91 40 00 ff 	movh.a %a15,61444
800040a4:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040a8:	ab 8f a0 f2 	seln %d15,%d2,%d15,8
800040ac:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D6, (data & 0x04) ? IfxPort_State_high : IfxPort_State_low);
800040ae:	8f 44 00 21 	and %d2,%d4,4
800040b2:	7b 00 01 f0 	movh %d15,16
800040b6:	ab 0f a1 f2 	seln %d15,%d2,%d15,16
800040ba:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D7, (data & 0x08) ? IfxPort_State_high : IfxPort_State_low);
800040bc:	8f 84 00 41 	and %d4,%d4,8
800040c0:	7b 00 02 f0 	movh %d15,32
800040c4:	ab 0f a2 44 	seln %d4,%d4,%d15,32
800040c8:	68 14       	st.w [%a15]4,%d4
800040ca:	da 80       	mov %d15,128
800040cc:	68 1f       	st.w [%a15]4,%d15
#include "bsw.h"

static void lcd_pulse_enable(void)
{
    IfxPort_setPinHigh(LCD_E);
    delay_ms(2);       
800040ce:	82 24       	mov %d4,2
800040d0:	6d 00 23 01 	call 80004316 <delay_ms>
800040d4:	7b 00 08 f0 	movh %d15,128
800040d8:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinLow(LCD_E);
    delay_ms(2);       
800040da:	82 24       	mov %d4,2
800040dc:	1d 00 1d 01 	j 80004316 <delay_ms>

800040e0 <lcd_command>:
800040e0:	91 40 00 ff 	movh.a %a15,61444
800040e4:	7b 00 04 20 	movh %d2,64
800040e8:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
    lcd_pulse_enable();
}


static void lcd_command(uint8 cmd)
{
800040ec:	02 4f       	mov %d15,%d4
800040ee:	68 12       	st.w [%a15]4,%d2
    IfxPort_setPinLow(LCD_RS);
    lcd_write4bits(cmd >> 4);
800040f0:	06 c4       	sh %d4,-4
800040f2:	5c c7       	call 80004080 <lcd_write4bits>
    lcd_write4bits(cmd & 0x0F);
800040f4:	8f ff 00 41 	and %d4,%d15,15
800040f8:	5c c4       	call 80004080 <lcd_write4bits>
    delay_ms(5);       
800040fa:	82 54       	mov %d4,5
800040fc:	1d 00 0d 01 	j 80004316 <delay_ms>

80004100 <lcd_clear>:
}


void lcd_clear(void)
{
    lcd_command(0x01);
80004100:	82 14       	mov %d4,1
80004102:	5c ef       	call 800040e0 <lcd_command>
    delay_ms(5);       
80004104:	82 54       	mov %d4,5
80004106:	1d 00 08 01 	j 80004316 <delay_ms>

8000410a <lcd_init>:
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000410a:	91 40 00 4f 	movh.a %a4,61444
8000410e:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004112:	82 64       	mov %d4,6
80004114:	3b 00 08 50 	mov %d5,128
80004118:	6d 00 db 0d 	call 80005cce <IfxPort_setPinMode>
8000411c:	91 40 00 4f 	movh.a %a4,61444
80004120:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004124:	82 74       	mov %d4,7
80004126:	3b 00 08 50 	mov %d5,128
8000412a:	6d 00 d2 0d 	call 80005cce <IfxPort_setPinMode>
8000412e:	91 40 00 4f 	movh.a %a4,61444
80004132:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80004136:	82 44       	mov %d4,4
80004138:	3b 00 08 50 	mov %d5,128
8000413c:	6d 00 c9 0d 	call 80005cce <IfxPort_setPinMode>
80004140:	91 40 00 4f 	movh.a %a4,61444
80004144:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004148:	82 34       	mov %d4,3
8000414a:	3b 00 08 50 	mov %d5,128
8000414e:	6d 00 c0 0d 	call 80005cce <IfxPort_setPinMode>
80004152:	91 40 00 4f 	movh.a %a4,61444
80004156:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000415a:	82 44       	mov %d4,4
8000415c:	3b 00 08 50 	mov %d5,128
80004160:	6d 00 b7 0d 	call 80005cce <IfxPort_setPinMode>
80004164:	91 40 00 4f 	movh.a %a4,61444
80004168:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000416c:	3b 00 08 50 	mov %d5,128
80004170:	82 54       	mov %d4,5
80004172:	6d 00 ae 0d 	call 80005cce <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(LCD_D4, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D5, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D6, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D7, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    delay_ms(100);  
80004176:	3b 40 06 40 	mov %d4,100
8000417a:	6d 00 ce 00 	call 80004316 <delay_ms>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000417e:	91 40 00 ff 	movh.a %a15,61444
80004182:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004186:	7b 00 04 f0 	movh %d15,64
8000418a:	68 1f       	st.w [%a15]4,%d15
8000418c:	7b 00 08 f0 	movh %d15,128
80004190:	68 1f       	st.w [%a15]4,%d15

    IfxPort_setPinLow(LCD_RS);
    IfxPort_setPinLow(LCD_E);

    lcd_write4bits(0x03); delay_ms(10);  
80004192:	82 34       	mov %d4,3
80004194:	6d ff 76 ff 	call 80004080 <lcd_write4bits>
80004198:	3b a0 00 40 	mov %d4,10
8000419c:	6d 00 bd 00 	call 80004316 <delay_ms>
    lcd_write4bits(0x03); delay_ms(10);  
800041a0:	82 34       	mov %d4,3
800041a2:	6d ff 6f ff 	call 80004080 <lcd_write4bits>
800041a6:	3b a0 00 40 	mov %d4,10
800041aa:	6d 00 b6 00 	call 80004316 <delay_ms>
    lcd_write4bits(0x03); delay_ms(5);   
800041ae:	82 34       	mov %d4,3
800041b0:	6d ff 68 ff 	call 80004080 <lcd_write4bits>
800041b4:	82 54       	mov %d4,5
800041b6:	6d 00 b0 00 	call 80004316 <delay_ms>
    lcd_write4bits(0x02); delay_ms(5);   
800041ba:	82 24       	mov %d4,2
800041bc:	6d ff 62 ff 	call 80004080 <lcd_write4bits>
800041c0:	82 54       	mov %d4,5
800041c2:	6d 00 aa 00 	call 80004316 <delay_ms>

    lcd_command(0x28);
800041c6:	3b 80 02 40 	mov %d4,40
800041ca:	5c 8b       	call 800040e0 <lcd_command>
    lcd_command(0x0C);
800041cc:	3b c0 00 40 	mov %d4,12
800041d0:	5c 88       	call 800040e0 <lcd_command>
    lcd_command(0x06);
800041d2:	82 64       	mov %d4,6
800041d4:	5c 86       	call 800040e0 <lcd_command>
    lcd_clear();
800041d6:	1d ff 95 ff 	j 80004100 <lcd_clear>

800041da <lcd_goto>:
}


void lcd_goto(uint8 row, uint8 col)
{
    uint8 address = (row == 0) ? 0x00 : 0x40;
800041da:	ab 04 a4 44 	seln %d4,%d4,%d4,64
    address += col;
800041de:	42 54       	add %d4,%d5
    lcd_command(0x80 | address);
800041e0:	b7 14 99 43 	insert %d4,%d4,1,7,25
800041e4:	1d ff 7e ff 	j 800040e0 <lcd_command>

800041e8 <lcd_print>:
800041e8:	91 40 00 cf 	movh.a %a12,61444
}


void lcd_print(const char *str)
{
800041ec:	40 4f       	mov.aa %a15,%a4
800041ee:	d9 cc 00 8a 	lea %a12,[%a12]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800041f2:	3b 00 04 80 	mov %d8,64
    while (*str)
800041f6:	79 ff 00 00 	ld.b %d15,[%a15]0
800041fa:	6e 11       	jz %d15,8000421c <lcd_print+0x34>
        lcd_data(*str++);
800041fc:	16 ff       	and %d15,255


static void lcd_data(uint8 data)
{
    IfxPort_setPinHigh(LCD_RS);
    lcd_write4bits(data >> 4);
800041fe:	8f cf 1f 40 	sh %d4,%d15,-4
80004202:	59 c8 04 00 	st.w [%a12]4 <f0040004 <_SMALL_DATA4_+0x40038004>>,%d8
80004206:	6d ff 3d ff 	call 80004080 <lcd_write4bits>
    lcd_write4bits(data & 0x0F);
8000420a:	8f ff 00 41 	and %d4,%d15,15
8000420e:	6d ff 39 ff 	call 80004080 <lcd_write4bits>
    delay_ms(5);       
80004212:	82 54       	mov %d4,5


void lcd_print(const char *str)
{
    while (*str)
        lcd_data(*str++);
80004214:	b0 1f       	add.a %a15,1
static void lcd_data(uint8 data)
{
    IfxPort_setPinHigh(LCD_RS);
    lcd_write4bits(data >> 4);
    lcd_write4bits(data & 0x0F);
    delay_ms(5);       
80004216:	6d 00 80 00 	call 80004316 <delay_ms>
8000421a:	3c ee       	j 800041f6 <lcd_print+0xe>

void lcd_print(const char *str)
{
    while (*str)
        lcd_data(*str++);
}
8000421c:	00 90       	ret 

8000421e <FuncSensorTask>:

volatile uint8 g_buttonState;

TASK(SensorTask)
{
    int upperUltrasonicValue = getUltrasonic(&g_UpperUltrasonic);
8000421e:	91 00 00 47 	movh.a %a4,28672
#include "ultrasonic_Driver.h"

volatile uint8 g_buttonState;

TASK(SensorTask)
{
80004222:	20 10       	sub.a %sp,16
    int upperUltrasonicValue = getUltrasonic(&g_UpperUltrasonic);
80004224:	d9 44 3a 40 	lea %a4,[%a4]314
80004228:	6d 00 6a 28 	call 800092fc <getUltrasonic>
    int frontUltrasonicValue = getUltrasonic(&g_FrontUltrasonic);
8000422c:	91 00 00 47 	movh.a %a4,28672
80004230:	d9 44 30 40 	lea %a4,[%a4]304 <70000130 <g_FrontUltrasonic>>

volatile uint8 g_buttonState;

TASK(SensorTask)
{
    int upperUltrasonicValue = getUltrasonic(&g_UpperUltrasonic);
80004234:	02 29       	mov %d9,%d2
    int frontUltrasonicValue = getUltrasonic(&g_FrontUltrasonic);
80004236:	6d 00 63 28 	call 800092fc <getUltrasonic>
8000423a:	02 28       	mov %d8,%d2
    int photoValue = getPhotoresiter();
8000423c:	6d 00 50 25 	call 80008cdc <getPhotoresiter>

    struct SensorPacket packet = {
80004240:	d9 a4 07 00 	lea %a4,[%sp]7
80004244:	40 42       	mov.aa %a2,%a4
80004246:	82 0f       	mov %d15,0
80004248:	a0 8f       	mov.a %a15,8
8000424a:	24 2f       	st.b [%a2+],%d15
8000424c:	fc ff       	loop %a15,8000424a <FuncSensorTask+0x2c>
8000424e:	37 02 70 20 	extr.u %d2,%d2,0,16
80004252:	3b a0 fa ff 	mov %d15,-86
80004256:	2c a7       	st.b [%sp]7,%d15
80004258:	82 2f       	mov %d15,2
8000425a:	2c a8       	st.b [%sp]8,%d15
8000425c:	8f 82 1f f0 	sh %d15,%d2,-8
80004260:	e9 a2 09 00 	st.b [%sp]9,%d2
80004264:	2c aa       	st.b [%sp]10,%d15
80004266:	37 08 70 20 	extr.u %d2,%d8,0,16
8000426a:	37 09 70 f0 	extr.u %d15,%d9,0,16
8000426e:	e9 a2 0d 00 	st.b [%sp]13,%d2
80004272:	2c ab       	st.b [%sp]11,%d15
80004274:	06 82       	sh %d2,-8
80004276:	06 8f       	sh %d15,-8
80004278:	2c ac       	st.b [%sp]12,%d15
8000427a:	e9 a2 0e 00 	st.b [%sp]14,%d2
        .packet_id      = 0x02,
        .photo          = photoValue,
        .ultra_sonic1   = upperUltrasonicValue,
        .ultra_sonic2   = frontUltrasonicValue
    };
    sendSensorPacket(&packet);
8000427e:	1d 00 1a 27 	j 800090b2 <sendSensorPacket>

80004282 <FuncDashboardButtonTask>:
    // setActuatorPacket(&acc);
    // sendActuatorPacket(&acc);
}

TASK(DashboardButtonTask){
    updateStateByButton(g_buttonState);
80004282:	91 00 00 f7 	movh.a %a15,28672
    // struct ActuatorPacket acc={};
    // setActuatorPacket(&acc);
    // sendActuatorPacket(&acc);
}

TASK(DashboardButtonTask){
80004286:	20 10       	sub.a %sp,16
    updateStateByButton(g_buttonState);
80004288:	39 f4 88 60 	ld.bu %d4,[%a15]2440
8000428c:	6d 00 d6 24 	call 80008c38 <updateStateByButton>
    // struct ActuatorPacket acc={};
    // setActuatorPacket(&acc);
    // sendActuatorPacket(&acc);
    struct ActuatorPacket packet={};
80004290:	d9 af 05 00 	lea %a15,[%sp]5
80004294:	40 f2       	mov.aa %a2,%a15
    setActuatorPacket(&packet);
80004296:	40 f4       	mov.aa %a4,%a15
TASK(DashboardButtonTask){
    updateStateByButton(g_buttonState);
    // struct ActuatorPacket acc={};
    // setActuatorPacket(&acc);
    // sendActuatorPacket(&acc);
    struct ActuatorPacket packet={};
80004298:	82 0f       	mov %d15,0
8000429a:	a0 a3       	mov.a %a3,10
8000429c:	24 2f       	st.b [%a2+],%d15
8000429e:	fc 3f       	loop %a3,8000429c <FuncDashboardButtonTask+0x1a>
    setActuatorPacket(&packet);
800042a0:	6d 00 fa 22 	call 80008894 <setActuatorPacket>
    sendActuatorPacket(&packet);
800042a4:	40 f4       	mov.aa %a4,%a15
800042a6:	1d 00 b3 25 	j 80008e0c <sendActuatorPacket>

800042aa <ButtonISR>:
}

ISR2(ButtonISR)
{
    DisableAllInterrupts();
800042aa:	6d 00 fc 2c 	call 80009ca2 <DisableAllInterrupts>
    osEE_tc_delay(5000);// delay_us(25);
800042ae:	3b 80 38 41 	mov %d4,5000
800042b2:	6d 00 ce 2c 	call 80009c4e <osEE_tc_delay>
    g_buttonState = readLcdButtons();
800042b6:	6d ff a5 fe 	call 80004000 <readLcdButtons>
800042ba:	91 00 00 f7 	movh.a %a15,28672
800042be:	8f f2 0f 21 	and %d2,%d2,255
    ActivateTask(DashboardButtonTask);
800042c2:	82 64       	mov %d4,6

ISR2(ButtonISR)
{
    DisableAllInterrupts();
    osEE_tc_delay(5000);// delay_us(25);
    g_buttonState = readLcdButtons();
800042c4:	e9 f2 88 60 	st.b [%a15]2440 <70000988 <g_buttonState>>,%d2
    ActivateTask(DashboardButtonTask);
800042c8:	6d 00 e9 2d 	call 80009e9a <ActivateTask>
    osEE_tc_delay(3000);// delay_us(10);
800042cc:	3b 80 bb 40 	mov %d4,3000
800042d0:	6d 00 bf 2c 	call 80009c4e <osEE_tc_delay>
    EnableAllInterrupts();
800042d4:	1d 00 f2 2c 	j 80009cb8 <EnableAllInterrupts>

800042d8 <TimerISR>:
}

ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U); //1
800042d8:	7b f0 00 40 	movh %d4,15
    osEE_tc_delay(3000);// delay_us(10);
    EnableAllInterrupts();
}

ISR2(TimerISR)
{
800042dc:	20 08       	sub.a %sp,8
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U); //1
800042de:	1b 04 24 44 	addi %d4,%d4,16960

    /************** basic-TASK (every 1s) ********************/
    
    // ActivateTask(SendSensorPacket_TEST);
    // ActivateTask(SendAcutatorPacket_TEST);
    if(c==0){
800042e2:	91 00 00 f7 	movh.a %a15,28672
}

ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U); //1
800042e6:	6d 00 4f 2c 	call 80009b84 <osEE_tc_stm_set_sr0_next_match>

    /************** basic-TASK (every 1s) ********************/
    
    // ActivateTask(SendSensorPacket_TEST);
    // ActivateTask(SendAcutatorPacket_TEST);
    if(c==0){
800042ea:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
800042ee:	ee 05       	jnz %d15,800042f8 <TimerISR+0x20>
        lcd_clear();
800042f0:	6d ff 08 ff 	call 80004100 <lcd_clear>
        printInfoDisplay();
800042f4:	6d 00 8b 23 	call 80008a0a <printInfoDisplay>
    }
    ActivateTask(SensorTask);// 
800042f8:	82 54       	mov %d4,5
800042fa:	6d 00 d0 2d 	call 80009e9a <ActivateTask>
    

    /************** basic-TASK for debugging ********************/
    
    printfSerial("\n%4ld: ", c++);
800042fe:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004302:	91 00 00 48 	movh.a %a4,32768
80004306:	78 00       	st.w [%sp]0,%d15
80004308:	d9 44 3c 00 	lea %a4,[%a4]60 <8000003c <_start+0x1c>>
8000430c:	c2 1f       	add %d15,1
8000430e:	59 ff 00 00 	st.w [%a15]0 <70000000 <__DSPR0_START>>,%d15
80004312:	1d 00 a7 00 	j 80004460 <printfSerial>

80004316 <delay_ms>:
                                        IfxVadc_ChannelId_6,  /* AN38: channel 6 of group 4                         */
                                        IfxVadc_ChannelId_7}; /* AN39: channel 7 of group 4                         */


void delay_ms(unsigned long delay)
{
80004316:	02 4a       	mov %d10,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80004318:	6d 00 c2 0e 	call 8000609c <IfxScuCcu_getSourceFrequency>
8000431c:	91 30 00 ff 	movh.a %a15,61443
80004320:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80004324:	48 04       	ld.w %d4,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004326:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000432a:	37 04 64 44 	extr.u %d4,%d4,8,4
8000432e:	53 1f 40 00 	mul.u %e0,%d15,1
80004332:	4b 04 41 41 	itof %d4,%d4
    result |= ((uint64)stm->CAP.U) << 32;
80004336:	8f 0f 40 61 	or %d6,%d15,0
8000433a:	4b 42 51 20 	div.f %d2,%d2,%d4
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
    uint64 ticks_per_ms = freq / 1000;
8000433e:	3b 80 3e 40 	mov %d4,1000
                                        IfxVadc_ChannelId_7}; /* AN39: channel 7 of group 4                         */


void delay_ms(unsigned long delay)
{
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
80004342:	4b 02 71 21 	ftouz %d2,%d2
    uint64 ticks_per_ms = freq / 1000;
80004346:	4b 42 11 22 	div.u %e2,%d2,%d4
8000434a:	85 f3 2c 00 	ld.w %d3,f000002c <_SMALL_DATA4_+0x3fff802c>
    uint64 start = IfxStm_get(&MODULE_STM0);
    uint64 wait_ticks = delay * ticks_per_ms;
8000434e:	73 a2 68 40 	mul.u %e4,%d2,%d10
80004352:	0f 13 a0 70 	or %d7,%d3,%d1

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004356:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000435a:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
8000435e:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80004362:	8f 0f 40 81 	or %d8,%d15,0
80004366:	0f 32 a0 90 	or %d9,%d2,%d3

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
8000436a:	0b 68 c0 20 	subx %d2,%d8,%d6
8000436e:	0b 79 d0 30 	subc %d3,%d9,%d7
80004372:	3a 53       	eq %d15,%d3,%d5
80004374:	0b 42 30 f2 	and.lt.u %d15,%d2,%d4
80004378:	0b 53 a0 f2 	or.lt.u %d15,%d3,%d5
8000437c:	ee ed       	jnz %d15,80004356 <delay_ms+0x40>
}
8000437e:	00 90       	ret 

80004380 <delay_us>:

void delay_us(unsigned long delay)
{
80004380:	02 4a       	mov %d10,%d4
80004382:	6d 00 8d 0e 	call 8000609c <IfxScuCcu_getSourceFrequency>
80004386:	91 30 00 ff 	movh.a %a15,61443
8000438a:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000438e:	48 04       	ld.w %d4,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004390:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80004394:	37 04 64 44 	extr.u %d4,%d4,8,4
80004398:	53 1f 40 00 	mul.u %e0,%d15,1
8000439c:	4b 04 41 41 	itof %d4,%d4
    result |= ((uint64)stm->CAP.U) << 32;
800043a0:	8f 0f 40 61 	or %d6,%d15,0
800043a4:	4b 42 51 20 	div.f %d2,%d2,%d4
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
    uint64 ticks_per_us = freq / 1000000;
800043a8:	7b f0 00 40 	movh %d4,15
800043ac:	1b 04 24 44 	addi %d4,%d4,16960
    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
}

void delay_us(unsigned long delay)
{
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
800043b0:	4b 02 71 21 	ftouz %d2,%d2
    uint64 ticks_per_us = freq / 1000000;
800043b4:	4b 42 11 22 	div.u %e2,%d2,%d4
800043b8:	85 f3 2c 00 	ld.w %d3,f000002c <_SMALL_DATA4_+0x3fff802c>
    uint64 start = IfxStm_get(&MODULE_STM0);
    uint64 wait_ticks = delay * ticks_per_us;
800043bc:	73 a2 68 40 	mul.u %e4,%d2,%d10
800043c0:	0f 13 a0 70 	or %d7,%d3,%d1

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800043c4:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
800043c8:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
800043cc:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
800043d0:	8f 0f 40 81 	or %d8,%d15,0
800043d4:	0f 32 a0 90 	or %d9,%d2,%d3

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
800043d8:	0b 68 c0 20 	subx %d2,%d8,%d6
800043dc:	0b 79 d0 30 	subc %d3,%d9,%d7
800043e0:	3a 53       	eq %d15,%d3,%d5
800043e2:	0b 42 30 f2 	and.lt.u %d15,%d2,%d4
800043e6:	0b 53 a0 f2 	or.lt.u %d15,%d3,%d5
800043ea:	ee ed       	jnz %d15,800043c4 <delay_us+0x44>
}
800043ec:	00 90       	ret 

800043ee <UART_init>:

void UART_init(void)
{
800043ee:	20 60       	sub.a %sp,96

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
800043f0:	d9 a4 24 00 	lea %a4,[%sp]36
800043f4:	c5 f5 80 40 	lea %a5,f0000900 <_SMALL_DATA4_+0x3fff8900>
    ascConfig.baudrate.prescaler    = 1;
800043f8:	82 1f       	mov %d15,1

void UART_init(void)
{

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
800043fa:	6d 00 f5 09 	call 800057e4 <IfxAsclin_Asc_initModuleConfig>
    ascConfig.baudrate.prescaler    = 1;
800043fe:	f9 af 2c 00 	st.h [%sp]44,%d15
    ascConfig.baudrate.baudrate     = 115200;
80004402:	7b 10 7e f4 	movh %d15,18401
80004406:	78 0a       	st.w [%sp]40,%d15
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
80004408:	82 3f       	mov %d15,3
8000440a:	e9 af 2e 00 	st.b [%sp]46,%d15

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;
8000440e:	da 11       	mov %d15,17
80004410:	f9 af 00 10 	st.h [%sp]64,%d15


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80004414:	4d c0 e1 ff 	mfcr %d15,$core_id
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
80004418:	7b 00 00 28 	movh %d2,32768
8000441c:	60 23       	mov.a %a3,%d2
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000441e:	37 0f 63 f0 	extr.u %d15,%d15,0,3
80004422:	d9 af 04 00 	lea %a15,[%sp]4
80004426:	40 f4       	mov.aa %a4,%a15
80004428:	d9 32 04 10 	lea %a2,[%a3]68
    ascConfig.baudrate.baudrate     = 115200;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
8000442c:	e9 af 06 10 	st.b [%sp]70,%d15
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
80004430:	a0 33       	mov.a %a3,3
80004432:	09 22 48 01 	ld.d %e2,[%a2+]8
80004436:	89 42 48 01 	st.d [%a4+]8,%e2
8000443a:	fc 3c       	loop %a3,80004432 <UART_init+0x44>

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
8000443c:	7b 00 00 f7 	movh %d15,28672
80004440:	1b cf 9c f0 	addi %d15,%d15,2508
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
80004444:	91 00 00 47 	movh.a %a4,28672

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
80004448:	78 14       	st.w [%sp]80,%d15
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
8000444a:	d9 44 e0 00 	lea %a4,[%a4]3104 <70000c20 <g_AsclinAsc+0x254>>
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
8000444e:	3b 20 10 f0 	mov %d15,258
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
80004452:	d9 a5 24 00 	lea %a5,[%sp]36
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80004456:	f9 af 0e 10 	st.h [%sp]78,%d15
        &IfxAsclin3_RXD_P32_2_IN, IfxPort_InputMode_pullUp,        /* Rx pin */
        NULL_PTR,                     IfxPort_OutputMode_pushPull,     /* RTS pin not used */
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
8000445a:	f8 12       	st.a [%sp]72,%a15
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
8000445c:	1d 00 ed 07 	j 80005436 <IfxAsclin_Asc_initModule>

80004460 <printfSerial>:
    //printf("Asclin Asc is initialised\n");
}


void printfSerial(const char *fmt,...)
{
80004460:	20 e8       	sub.a %sp,232
80004462:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
80004464:	6d 00 2a 2c 	call 80009cb8 <EnableAllInterrupts>
    char buf[LEN_BUF];
    va_list args;
    va_start (args, fmt );
    vsnprintf(buf, LEN_BUF, fmt, args);
80004468:	40 f5       	mov.aa %a5,%a15
8000446a:	d9 a4 28 10 	lea %a4,[%sp]104
8000446e:	3b 00 08 40 	mov %d4,128
80004472:	d9 a6 28 30 	lea %a6,[%sp]232
80004476:	6d 00 94 3a 	call 8000b99e <vsnprintf>
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
8000447a:	d9 a4 28 10 	lea %a4,[%sp]104
8000447e:	6d 00 61 3a 	call 8000b940 <strlen>
80004482:	91 00 00 f7 	movh.a %a15,28672
80004486:	d9 ff 8c 70 	lea %a15,[%a15]2508 <700009cc <g_AsclinAsc>>
8000448a:	f9 f2 30 90 	st.h [%a15]624 <70000270 <__malloc_av_+0x120>>,%d2
    unsigned int i =0;
8000448e:	82 0f       	mov %d15,0
    for(; i<strlen(buf);i++) {
80004490:	d9 a4 28 10 	lea %a4,[%sp]104
80004494:	6d 00 56 3a 	call 8000b940 <strlen>
80004498:	7f 2f 0c 80 	jge.u %d15,%d2,800044b0 <printfSerial+0x50>
        txData[i] = buf[i];
8000449c:	d9 a3 04 00 	lea %a3,[%sp]4
800044a0:	10 32       	addsc.a %a2,%a3,%d15,0
800044a2:	d9 a3 28 10 	lea %a3,[%sp]104
800044a6:	10 3f       	addsc.a %a15,%a3,%d15,0
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
    unsigned int i =0;
    for(; i<strlen(buf);i++) {
800044a8:	c2 1f       	add %d15,1
        txData[i] = buf[i];
800044aa:	08 02       	ld.bu %d2,[%a15]0
800044ac:	34 22       	st.b [%a2],%d2
800044ae:	3c f1       	j 80004490 <printfSerial+0x30>
    }
    /* Transmit data */
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
800044b0:	82 f4       	mov %d4,-1
800044b2:	91 00 00 47 	movh.a %a4,28672
800044b6:	91 00 00 67 	movh.a %a6,28672
800044ba:	d9 44 e0 00 	lea %a4,[%a4]3104 <70000c20 <g_AsclinAsc+0x254>>
800044be:	d9 a5 04 00 	lea %a5,[%sp]4 <70000c20 <g_AsclinAsc+0x254>>
800044c2:	d9 66 fc 00 	lea %a6,[%a6]3132 <70000c3c <g_AsclinAsc+0x270>>
800044c6:	9b 04 00 58 	addih %d5,%d4,32768
800044ca:	6d 00 f5 09 	call 800058b4 <IfxAsclin_Asc_write>
    DisableAllInterrupts();
800044ce:	1d 00 ea 2b 	j 80009ca2 <DisableAllInterrupts>

800044d2 <initVADCModule>:
    IfxVadc_Adc_startBackgroundScan(&g_vadc);
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
800044d2:	20 28       	sub.a %sp,40
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
800044d4:	d9 a4 04 00 	lea %a4,[%sp]4
800044d8:	91 20 00 5f 	movh.a %a5,61442
800044dc:	6d 00 c7 1d 	call 8000806a <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the configuration                  */
800044e0:	91 00 00 47 	movh.a %a4,28672
800044e4:	d9 44 bc 60 	lea %a4,[%a4]2492 <700009bc <g_vadc>>
800044e8:	d9 a5 04 00 	lea %a5,[%sp]4 <700009bc <g_vadc>>
800044ec:	1d 00 4b 1d 	j 80007f82 <IfxVadc_Adc_initModule>

800044f0 <initVADCGroup>:
}

/* Function to initialize the VADC group */
void initVADCGroup(void)
{
800044f0:	20 38       	sub.a %sp,56
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */
800044f2:	91 00 00 57 	movh.a %a5,28672
800044f6:	40 a4       	mov.aa %a4,%sp
800044f8:	d9 55 bc 60 	lea %a5,[%a5]2492 <700009bc <g_vadc>>
800044fc:	6d 00 2c 1d 	call 80007f54 <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
80004500:	82 4f       	mov %d15,4
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004502:	91 00 00 47 	movh.a %a4,28672
void initVADCGroup(void)
{
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
80004506:	2c a4       	st.b [%sp]4,%d15
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */
80004508:	2c a5       	st.b [%sp]5,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
8000450a:	d9 44 b0 60 	lea %a4,[%a4]2480 <700009b0 <g_vadcGroup>>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
8000450e:	82 1f       	mov %d15,1
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004510:	40 a5       	mov.aa %a5,%sp

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
80004512:	e9 af 35 00 	st.b [%sp]53,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;
80004516:	e9 af 28 00 	st.b [%sp]40,%d15

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
8000451a:	e9 af 2c 00 	st.b [%sp]44,%d15

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
8000451e:	1d 00 56 1b 	j 80007bca <IfxVadc_Adc_initGroup>

80004522 <initVADCChannels>:
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004522:	91 00 00 e7 	movh.a %a14,28672

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004526:	7b 00 00 b7 	movh %d11,28672
8000452a:	7b 00 00 a7 	movh %d10,28672
}


IFX_INLINE void IfxVadc_Adc_setBackgroundScan(IfxVadc_Adc *vadc, IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setBackgroundScan(vadc->vadc, group->groupId, channels, mask);
8000452e:	91 00 00 d7 	movh.a %a13,28672
    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
}

/* Function to initialize the VADC used channels */
void initVADCChannels(void)
{
80004532:	20 60       	sub.a %sp,96
80004534:	82 0f       	mov %d15,0
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004536:	d9 ee b0 60 	lea %a14,[%a14]2480 <700009b0 <g_vadcGroup>>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
8000453a:	1b 8b 00 b0 	addi %d11,%d11,8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
8000453e:	82 19       	mov %d9,1
80004540:	1b 0a 99 a0 	addi %d10,%d10,2448
80004544:	d9 dd bc 60 	lea %a13,[%a13]2492
80004548:	53 8f 21 80 	mul %d8,%d15,24
8000454c:	40 ac       	mov.aa %a12,%sp
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
8000454e:	40 e5       	mov.aa %a5,%a14
80004550:	60 82       	mov.a %a2,%d8

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004552:	d9 af 20 10 	lea %a15,[%sp]96
80004556:	30 2c       	add.a %a12,%a2
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004558:	40 c4       	mov.aa %a4,%a12
8000455a:	6d 00 2d 1b 	call 80007bb4 <IfxVadc_Adc_initChannelConfig>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
8000455e:	60 83       	mov.a %a3,%d8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004560:	40 c5       	mov.aa %a5,%a12
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004562:	30 3f       	add.a %a15,%a3
80004564:	60 b3       	mov.a %a3,%d11
80004566:	10 32       	addsc.a %a2,%a3,%d15,0
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
80004568:	e9 ff ef ef 	st.b [%a15]-81,%d15
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
8000456c:	14 22       	ld.bu %d2,[%a2]
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
8000456e:	60 a2       	mov.a %a2,%d10
80004570:	d0 24       	addsc.a %a4,%a2,%d15,3
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004572:	e9 f2 ec ef 	st.b [%a15]-84,%d2
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
80004576:	e9 f9 e2 ef 	st.b [%a15]-94,%d9


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
8000457a:	6d 00 27 1a 	call 800079c8 <IfxVadc_Adc_initChannel>
8000457e:	d4 d2       	ld.a %a2,[%a13]
80004580:	39 e2 08 00 	ld.bu %d2,[%a14]8 <70000008 <g_vadcChannelIDs>>
80004584:	c2 1f       	add %d15,1
80004586:	01 22 02 26 	addsc.a %a2,%a2,%d2,2

        /* Add the channel to background scan */
        unsigned chnEnableBit = (1 << adcChannelConf[chn].channelId);   /* Set the the corresponding input channel  */
8000458a:	79 f2 ec ef 	ld.b %d2,[%a15]-84
}


IFX_INLINE void IfxVadc_setBackgroundScan(Ifx_VADC *vadc, IfxVadc_GroupId groupId, uint32 channels, uint32 mask)
{
    channels                = (vadc->BRSSEL[groupId].U & ~mask) | channels;
8000458e:	19 23 00 60 	ld.w %d3,[%a2]384
80004592:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
    vadc->BRSSEL[groupId].U = channels;
80004596:	59 22 00 60 	st.w [%a2]384,%d2
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
8000459a:	df 4f d7 ff 	jne %d15,4,80004548 <initVADCChannels+0x26>
        unsigned mask = chnEnableBit;                                   /* of the respective group to be added in   */
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup, chnEnableBit, mask); /* the background scan sequence.  */

    }

}
8000459e:	00 90       	ret 

800045a0 <initADC>:
}


IFX_INLINE void IfxVadc_Adc_startBackgroundScan(IfxVadc_Adc *vadc)
{
    IfxVadc_startBackgroundScan(vadc->vadc);
800045a0:	91 00 00 f7 	movh.a %a15,28672
}

/* Function to initialize the VADC module */
void initADC(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
800045a4:	6d ff 97 ff 	call 800044d2 <initVADCModule>
    initVADCGroup();                                                    /* Initialize the VADC group                */
800045a8:	6d ff a4 ff 	call 800044f0 <initVADCGroup>
    initVADCChannels();                                                 /* Initialize the used channels             */
800045ac:	6d ff bb ff 	call 80004522 <initVADCChannels>
800045b0:	99 ff bc 60 	ld.a %a15,[%a15]2492 <700009bc <g_vadc>>
}


IFX_INLINE void IfxVadc_startBackgroundScan(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.LDEV = 1;     /* execute Load event to start the conversion */
800045b4:	19 ff 04 80 	ld.w %d15,[%a15]516 <700009bc <g_vadc>>
800045b8:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
800045bc:	59 ff 04 80 	st.w [%a15]516,%d15
800045c0:	00 90       	ret 

800045c2 <readADCValue>:
}


IFX_INLINE Ifx_VADC_RES IfxVadc_Adc_getResult(IfxVadc_Adc_Channel *channel)
{
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
800045c2:	91 00 00 f7 	movh.a %a15,28672
800045c6:	d9 ff 90 60 	lea %a15,[%a15]2448 <70000990 <g_vadcChannel>>
800045ca:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
800045ce:	c8 12       	ld.a %a2,[%a15]4
800045d0:	0c f1       	ld.bu %d15,[%a15]1
800045d2:	99 22 04 00 	ld.a %a2,[%a2]4

IFX_INLINE Ifx_VADC_RES IfxVadc_getResult(Ifx_VADC_G *group, uint32 resultIdx)
{
    Ifx_VADC_RES tmpResult;

    tmpResult.U = group->RES[resultIdx].U;
800045d6:	1b 0f 0a f0 	addi %d15,%d15,160
800045da:	90 2f       	addsc.a %a15,%a2,%d15,2
800045dc:	4c f0       	ld.w %d15,[%a15]0
800045de:	37 0f 70 20 	extr.u %d2,%d15,0,16
{
    Ifx_VADC_RES conversionResult;
    do
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    } while(!conversionResult.B.VF);
800045e2:	ff 0f fd 7f 	jge %d15,0,800045dc <readADCValue+0x1a>

    return conversionResult.B.RESULT;
}
800045e6:	00 90       	ret 

800045e8 <initPeripheralsAndERU>:

void initPeripheralsAndERU(void)
{
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */
800045e8:	91 40 00 4f 	movh.a %a4,61444
800045ec:	d9 44 00 0e 	lea %a4,[%a4]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
800045f0:	82 74       	mov %d4,7
800045f2:	3b 00 01 50 	mov %d5,16
800045f6:	6d 00 6c 0b 	call 80005cce <IfxPort_setPinMode>


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
800045fa:	91 00 00 f8 	movh.a %a15,32768
800045fe:	d9 ff 9c d0 	lea %a15,[%a15]2908 <80000b5c <IfxScu_REQ6_P02_0_IN>>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80004602:	c8 24       	ld.a %a4,[%a15]8
80004604:	91 00 00 d7 	movh.a %a13,28672
80004608:	08 c4       	ld.bu %d4,[%a15]12
8000460a:	3b 80 00 50 	mov %d5,8
8000460e:	b5 df 80 70 	st.a [%a13]2496 <700009c0 <g_ERUconfig>>,%a15
80004612:	6d 00 5e 0b 	call 80005cce <IfxPort_setPinMode>
/******************************************************************************/

IFX_INLINE void IfxScuEru_initReqPin(IfxScu_Req_In *req, IfxPort_InputMode inputMode)
{
    IfxPort_setPinModeInput(req->pin.port, req->pin.pinIndex, inputMode);
    IfxScuEru_selectExternalInput((IfxScuEru_InputChannel)req->channelId, (IfxScuEru_ExternalInputSelection)req->select);
80004616:	39 f5 10 00 	ld.bu %d5,[%a15]16 <80000010 <BootModeHeader0+0x10>>
8000461a:	08 44       	ld.bu %d4,[%a15]4
8000461c:	6d 00 07 15 	call 8000702a <IfxScuEru_selectExternalInput>
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
80004620:	99 df 80 70 	ld.a %a15,[%a13]2496 <700009c0 <g_ERUconfig>>
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
80004624:	d9 dc 80 70 	lea %a12,[%a13]2496 <700009c0 <g_ERUconfig>>
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
80004628:	82 0f       	mov %d15,0
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
8000462a:	08 44       	ld.bu %d4,[%a15]4
8000462c:	e9 c4 04 00 	st.b [%a12]4 <70000004 <__DSPR0_START+0x4>>,%d4

    /* Input channel configuration */
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */
80004630:	6d 00 6d 14 	call 80006f0a <IfxScuEru_enableFallingEdgeDetection>
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
80004634:	39 c4 04 00 	ld.bu %d4,[%a12]4
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
80004638:	2c c6       	st.b [%a12]6,%d15
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;
8000463a:	2c c5       	st.b [%a12]5,%d15

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
8000463c:	6d 00 a0 14 	call 80006f7c <IfxScuEru_enableTriggerPulse>
    /* Determination of output channel for trigger event (Register INPx) */
    IfxScuEru_connectTrigger(g_ERUconfig.inputChannel, g_ERUconfig.triggerSelect);
80004640:	39 c4 04 00 	ld.bu %d4,[%a12]4
80004644:	39 c5 05 00 	ld.bu %d5,[%a12]5
80004648:	6d 00 d4 13 	call 80006df0 <IfxScuEru_connectTrigger>

    /* Configure Output channels, OutputGating Unit OGU (Register IGPy) */
    IfxScuEru_setInterruptGatingPattern(g_ERUconfig.outputChannel, IfxScuEru_InterruptGatingPattern_alwaysActive);
8000464c:	39 c4 06 00 	ld.bu %d4,[%a12]6
80004650:	82 15       	mov %d5,1
80004652:	6d 00 25 15 	call 8000709c <IfxScuEru_setInterruptGatingPattern>

    /* Service request configuration */
    /* Get source pointer depending on outputChannel (SRC_SCUERU0 for outputChannel0) */
    g_ERUconfig.src = &MODULE_SRC.SCU.SCU.ERU[(int) g_ERUconfig.outputChannel % 4];
80004656:	0c c6       	ld.bu %d15,[%a12]6
80004658:	16 03       	and %d15,3
8000465a:	06 2f       	sh %d15,2
8000465c:	60 f2       	mov.a %a2,%d15
8000465e:	d9 2f d4 38 	lea %a15,[%a2]-29484
80004662:	11 4f 00 ff 	addih.a %a15,%a15,61444
80004666:	ec c2       	st.a [%a12]8,%a15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80004668:	4c f0       	ld.w %d15,[%a15]0
8000466a:	b7 af 08 f0 	insert %d15,%d15,10,0,8
8000466e:	68 0f       	st.w [%a15]0,%d15
    src->B.TOS  = typOfService;
80004670:	4c f0       	ld.w %d15,[%a15]0
80004672:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
80004676:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80004678:	4c f0       	ld.w %d15,[%a15]0
8000467a:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
8000467e:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80004680:	4c f0       	ld.w %d15,[%a15]0
80004682:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80004686:	68 0f       	st.w [%a15]0,%d15
80004688:	00 90       	ret 

8000468a <asclin3TxISR>:
    IfxSrc_enable(g_ERUconfig.src);
}

ISR(asclin3TxISR)
{
    IfxAsclin_Asc_isrTransmit(&g_AsclinAsc.drivers.asc);
8000468a:	91 00 00 47 	movh.a %a4,28672
8000468e:	d9 44 e0 00 	lea %a4,[%a4]3104 <70000c20 <g_AsclinAsc+0x254>>
80004692:	1d 00 17 06 	j 800052c0 <IfxAsclin_Asc_isrTransmit>

80004696 <main>:
}

int main(void)
{
    osEE_tc_stm_set_clockpersec();
80004696:	6d 00 1b 2a 	call 80009acc <osEE_tc_stm_set_clockpersec>
    osEE_tc_stm_set_sr0(1000000U, 1U);
8000469a:	7b f0 00 40 	movh %d4,15
8000469e:	82 15       	mov %d5,1
800046a0:	1b 04 24 44 	addi %d4,%d4,16960
800046a4:	6d 00 2e 2a 	call 80009b00 <osEE_tc_stm_set_sr0>

    UART_init();
800046a8:	6d ff a3 fe 	call 800043ee <UART_init>
    initADC();
800046ac:	6d ff 7a ff 	call 800045a0 <initADC>
    initPeripheralsAndERU();
800046b0:	6d ff 9c ff 	call 800045e8 <initPeripheralsAndERU>
    
    /* custom driver init() added start*/
    lcd_init();
800046b4:	6d ff 2b fd 	call 8000410a <lcd_init>
    initUltrasonic(&g_UpperUltrasonic);
800046b8:	91 00 00 47 	movh.a %a4,28672
800046bc:	d9 44 3a 40 	lea %a4,[%a4]314 <7000013a <g_UpperUltrasonic>>
800046c0:	6d 00 5a 25 	call 80009174 <initUltrasonic>
    initUltrasonic(&g_FrontUltrasonic);
800046c4:	91 00 00 47 	movh.a %a4,28672
800046c8:	d9 44 30 40 	lea %a4,[%a4]304 <70000130 <g_FrontUltrasonic>>
800046cc:	6d 00 54 25 	call 80009174 <initUltrasonic>
    initUartDriver();
800046d0:	6d 00 09 23 	call 80008ce2 <initUartDriver>
    /* custom driver added end*/

    printfSerial("\n...............\n");
800046d4:	91 00 00 48 	movh.a %a4,32768
800046d8:	d9 44 24 10 	lea %a4,[%a4]100 <80000064 <_start+0x44>>
800046dc:	6d ff c2 fe 	call 80004460 <printfSerial>
    printfSerial("...OS Starts...\n");
800046e0:	91 00 00 48 	movh.a %a4,32768
800046e4:	d9 44 36 10 	lea %a4,[%a4]118 <80000076 <_start+0x56>>
800046e8:	6d ff bc fe 	call 80004460 <printfSerial>
    printfSerial("...............\n");
800046ec:	91 00 00 48 	movh.a %a4,32768
800046f0:	d9 44 07 20 	lea %a4,[%a4]135 <80000087 <_start+0x67>>
800046f4:	6d ff b6 fe 	call 80004460 <printfSerial>

    StartOS(OSDEFAULTAPPMODE);
800046f8:	82 04       	mov %d4,0
800046fa:	6d 00 6d 2b 	call 80009dd4 <StartOS>
    return 0;
}
800046fe:	82 02       	mov %d2,0
80004700:	00 90       	ret 
	...

80004704 <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80004704:	02 4f       	mov %d15,%d4
80004706:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004708:	6d 00 6d 16 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
8000470c:	02 24       	mov %d4,%d2
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
8000470e:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80004710:	6d 00 66 15 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80004714:	8b 0f a2 22 	ge.u %d2,%d15,32
80004718:	f6 28       	jnz %d2,80004728 <IfxVadc_disableAccess+0x24>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
8000471a:	19 f2 08 20 	ld.w %d2,[%a15]136
8000471e:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
80004722:	59 ff 08 20 	st.w [%a15]136,%d15
80004726:	3c 08       	j 80004736 <IfxVadc_disableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
80004728:	19 f2 0c 20 	ld.w %d2,[%a15]140
8000472c:	16 1f       	and %d15,31
8000472e:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
80004732:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80004736:	02 84       	mov %d4,%d8
80004738:	1d 00 d8 16 	j 800074e8 <IfxScuWdt_setSafetyEndinit>

8000473c <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
8000473c:	02 4f       	mov %d15,%d4
8000473e:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004740:	6d 00 51 16 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
80004744:	02 24       	mov %d4,%d2
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004746:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80004748:	6d 00 4a 15 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
8000474c:	8b 0f a2 22 	ge.u %d2,%d15,32
80004750:	f6 28       	jnz %d2,80004760 <IfxVadc_enableAccess+0x24>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
80004752:	19 f2 08 20 	ld.w %d2,[%a15]136
80004756:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
8000475a:	59 ff 08 20 	st.w [%a15]136,%d15
8000475e:	3c 08       	j 8000476e <IfxVadc_enableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
80004760:	19 f2 0c 20 	ld.w %d2,[%a15]140
80004764:	16 1f       	and %d15,31
80004766:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
8000476a:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
8000476e:	02 84       	mov %d4,%d8
80004770:	1d 00 bc 16 	j 800074e8 <IfxScuWdt_setSafetyEndinit>

80004774 <IfxVadc_configExternalMultiplexerMode>:

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
80004774:	82 0f       	mov %d15,0
80004776:	b7 1f 81 ff 	insert %d15,%d15,1,31,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
8000477a:	39 a3 04 00 	ld.bu %d3,[%sp]4
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
8000477e:	37 4f 02 fd 	insert %d15,%d15,%d4,26,2
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004782:	14 a2       	ld.bu %d2,[%sp]
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
80004784:	67 3f 1e f0 	ins.t %d15,%d15,30,%d3,0
    emuxctr.B.EMUXCH   = channels;
80004788:	37 5f 0a f8 	insert %d15,%d15,%d5,16,10
    emuxctr.B.EMUXSET  = startChannel;
8000478c:	37 6f 03 f0 	insert %d15,%d15,%d6,0,3
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
80004790:	3b f0 00 40 	mov %d4,15
    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
80004794:	67 7f 1c f0 	ins.t %d15,%d15,28,%d7,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004798:	40 5f       	mov.aa %a15,%a5
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
8000479a:	67 2f 1d f0 	ins.t %d15,%d15,29,%d2,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
8000479e:	40 4c       	mov.aa %a12,%a4
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800047a0:	6d ff ce ff 	call 8000473c <IfxVadc_enableAccess>
    vadcG->EMUXCTR.U   = emuxctr.U;
800047a4:	59 ff 30 50 	st.w [%a15]368,%d15
    emuxctr.B.EMXWC    = 0;
800047a8:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
    vadcG->EMUXCTR.U   = emuxctr.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800047ac:	40 c4       	mov.aa %a4,%a12
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
    vadcG->EMUXCTR.U   = emuxctr.U;
    emuxctr.B.EMXWC    = 0;
    vadcG->EMUXCTR.U   = emuxctr.U;
800047ae:	59 ff 30 50 	st.w [%a15]368,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800047b2:	3b f0 00 40 	mov %d4,15
800047b6:	1d ff a7 ff 	j 80004704 <IfxVadc_disableAccess>

800047ba <IfxVadc_disablePostCalibration>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_disablePostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group, boolean disable)
{
800047ba:	40 4f       	mov.aa %a15,%a4
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
800047bc:	ff 84 1c 80 	jge.u %d4,8,800047f4 <IfxVadc_disablePostCalibration+0x3a>
800047c0:	02 4f       	mov %d15,%d4
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800047c2:	3b f0 01 40 	mov %d4,31
800047c6:	02 58       	mov %d8,%d5
800047c8:	6d ff ba ff 	call 8000473c <IfxVadc_enableAccess>

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800047cc:	1b 0f 01 40 	addi %d4,%d15,16

        if (disable == TRUE)
        {
            vadc->GLOBCFG.U |= mask;
800047d0:	19 f2 00 20 	ld.w %d2,[%a15]128
{
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800047d4:	82 1f       	mov %d15,1
800047d6:	0f 4f 00 f0 	sh %d15,%d15,%d4

        if (disable == TRUE)
800047da:	df 18 04 80 	jne %d8,1,800047e2 <IfxVadc_disablePostCalibration+0x28>
        {
            vadc->GLOBCFG.U |= mask;
800047de:	a6 2f       	or %d15,%d2
800047e0:	3c 03       	j 800047e6 <IfxVadc_disablePostCalibration+0x2c>
        }
        else
        {
            vadc->GLOBCFG.U &= ~mask;
800047e2:	0f f2 e0 f0 	andn %d15,%d2,%d15
800047e6:	59 ff 00 20 	st.w [%a15]128,%d15
        }

        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047ea:	40 f4       	mov.aa %a4,%a15
800047ec:	3b f0 01 40 	mov %d4,31
800047f0:	1d ff 8a ff 	j 80004704 <IfxVadc_disableAccess>
800047f4:	00 90       	ret 

800047f6 <IfxVadc_enableGroupSync>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
800047f6:	40 4f       	mov.aa %a15,%a4
800047f8:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800047fa:	6d 00 d6 15 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
800047fe:	02 24       	mov %d4,%d2
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004800:	02 29       	mov %d9,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004802:	6d 00 d2 14 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004806:	40 f4       	mov.aa %a4,%a15
80004808:	3b f0 01 40 	mov %d4,31
    IfxScuWdt_clearCpuEndinit(passwd);

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
8000480c:	19 ff 00 20 	ld.w %d15,[%a15]128
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004810:	6d ff 96 ff 	call 8000473c <IfxVadc_enableAccess>

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
80004814:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
        vadcGlobCfg.B.DCMSB = 1;
80004818:	b7 1f 81 f3 	insert %d15,%d15,1,7,1

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000481c:	40 f4       	mov.aa %a4,%a15
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
8000481e:	59 ff 00 20 	st.w [%a15]128,%d15
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004822:	3b f0 01 40 	mov %d4,31
80004826:	6d ff 6f ff 	call 80004704 <IfxVadc_disableAccess>
    }

    if (ccu6Num == 0)
8000482a:	df 08 1a 80 	jne %d8,0,8000485e <IfxVadc_enableGroupSync+0x68>
    {
        // CCU60 Config
        CCU60_CLC.U = 0;
8000482e:	a5 f8 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d8

        if (CCU60_CLC.U)
80004832:	85 ff 80 82 	ld.w %d15,f0002a00 <_SMALL_DATA4_+0x3fffaa00>
        {}

        CCU60_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
80004836:	82 4f       	mov %d15,4
80004838:	a5 ff 94 92 	st.w f0002a54 <_SMALL_DATA4_+0x3fffaa54>,%d15
        CCU60_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
8000483c:	a5 ff 9c 92 	st.w f0002a5c <_SMALL_DATA4_+0x3fffaa5c>,%d15
        CCU60_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
80004840:	85 ff 80 a2 	ld.w %d15,f0002a80 <_SMALL_DATA4_+0x3fffaa80>
80004844:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
80004848:	a5 ff 80 a2 	st.w f0002a80 <_SMALL_DATA4_+0x3fffaa80>,%d15
        CCU60_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
8000484c:	3b 00 20 f4 	mov %d15,16896
80004850:	a5 ff b8 92 	st.w f0002a78 <_SMALL_DATA4_+0x3fffaa78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 0;                                                                  // CCU60_COUT63 routed to output signal CCU6061 TRIG1
80004854:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
80004858:	8f 8f c3 f1 	andn %d15,%d15,56
8000485c:	3c 1d       	j 80004896 <IfxVadc_enableGroupSync+0xa0>
    }
    else if (ccu6Num == 1)
8000485e:	df 18 1e 80 	jne %d8,1,8000489a <IfxVadc_enableGroupSync+0xa4>
    {
        // CCU60 + CCU61 Config
        CCU60_CLC.U = 0;
80004862:	82 0f       	mov %d15,0
80004864:	a5 ff 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d15
        CCU61_CLC.U = 0;
80004868:	a5 ff 80 c2 	st.w f0002b00 <_SMALL_DATA4_+0x3fffab00>,%d15

        if (CCU61_CLC.U)
8000486c:	85 ff 80 c2 	ld.w %d15,f0002b00 <_SMALL_DATA4_+0x3fffab00>
        {}

        CCU61_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
80004870:	82 4f       	mov %d15,4
80004872:	a5 ff 94 d2 	st.w f0002b54 <_SMALL_DATA4_+0x3fffab54>,%d15
        CCU61_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
80004876:	a5 ff 9c d2 	st.w f0002b5c <_SMALL_DATA4_+0x3fffab5c>,%d15
        CCU61_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
8000487a:	85 ff 80 e2 	ld.w %d15,f0002b80 <_SMALL_DATA4_+0x3fffab80>
8000487e:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
80004882:	a5 ff 80 e2 	st.w f0002b80 <_SMALL_DATA4_+0x3fffab80>,%d15
        CCU61_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
80004886:	3b 00 20 f4 	mov %d15,16896
8000488a:	a5 ff b8 d2 	st.w f0002b78 <_SMALL_DATA4_+0x3fffab78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 1;                                                                  // CCU61_COUT63 routed to output signal CCU6061 TRIG1
8000488e:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
80004892:	b7 1f 83 f1 	insert %d15,%d15,1,3,3
80004896:	a5 ff 8c 82 	st.w f0002a0c <_SMALL_DATA4_+0x3fffaa0c>,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
8000489a:	02 94       	mov %d4,%d9
8000489c:	1d 00 ba 15 	j 80007410 <IfxScuWdt_setCpuEndinit>

800048a0 <IfxVadc_getAdcAnalogFrequency>:
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
800048a0:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
800048a2:	6d 00 be 0c 	call 8000621e <IfxScuCcu_getSpbFrequency>
800048a6:	19 ff 00 20 	ld.w %d15,[%a15]128
800048aa:	16 1f       	and %d15,31
800048ac:	c2 1f       	add %d15,1
800048ae:	4b 0f 41 f1 	itof %d15,%d15
}
800048b2:	4b f2 51 20 	div.f %d2,%d2,%d15
800048b6:	00 90       	ret 

800048b8 <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
800048b8:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
800048ba:	6d 00 b2 0c 	call 8000621e <IfxScuCcu_getSpbFrequency>
800048be:	19 ff 00 20 	ld.w %d15,[%a15]128
800048c2:	37 0f 62 f4 	extr.u %d15,%d15,8,2
800048c6:	c2 1f       	add %d15,1
800048c8:	4b 0f 41 f1 	itof %d15,%d15
}
800048cc:	4b f2 51 20 	div.f %d2,%d2,%d15
800048d0:	00 90       	ret 

800048d2 <IfxVadc_getAdcModuleFrequency>:


float32 IfxVadc_getAdcModuleFrequency(void)
{
    return IfxScuCcu_getSpbFrequency();
800048d2:	1d 00 a6 0c 	j 8000621e <IfxScuCcu_getSpbFrequency>

800048d6 <IfxVadc_getBackgroundScanStatus>:
}


IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
800048d6:	82 0f       	mov %d15,0
800048d8:	a0 7f       	mov.a %a15,7
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
    {
        if (vadc->BRSPND[i].U)
800048da:	1b 0f 07 20 	addi %d2,%d15,112
800048de:	01 42 02 26 	addsc.a %a2,%a4,%d2,2
800048e2:	54 22       	ld.w %d2,[%a2]
800048e4:	f6 24       	jnz %d2,800048ec <IfxVadc_getBackgroundScanStatus+0x16>
800048e6:	c2 1f       	add %d15,1
IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
800048e8:	fc f9       	loop %a15,800048da <IfxVadc_getBackgroundScanStatus+0x4>
800048ea:	00 90       	ret 
    {
        if (vadc->BRSPND[i].U)
        {
            return IfxVadc_Status_channelsStillPending;
800048ec:	82 62       	mov %d2,6
            continue;
        }
    }

    return status;
}
800048ee:	00 90       	ret 

800048f0 <IfxVadc_getQueueStatus>:
IfxVadc_Status IfxVadc_getQueueStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    /* just fill level is checked */
    if (0x7 == group->QSR0.B.FILL)
800048f0:	19 42 08 20 	ld.w %d2,[%a4]136
800048f4:	8f f2 00 21 	and %d2,%d2,15
    {
        status = IfxVadc_Status_queueFull;
    }
    else
    {
        status = IfxVadc_Status_noError;
800048f8:	8b 72 00 22 	eq %d2,%d2,7
    }

    return status;
}
800048fc:	06 22       	sh %d2,2
800048fe:	00 90       	ret 

80004900 <IfxVadc_getResultBasedOnRequestSource>:
Ifx_VADC_RES IfxVadc_getResultBasedOnRequestSource(Ifx_VADC *vadc, Ifx_VADC_G *group, IfxVadc_ChannelId channel, IfxVadc_RequestSource sourceType)
{
    sint32       sourceResultRegister = -1;
    Ifx_VADC_RES tmpResult;

    switch (sourceType)
80004900:	df 15 09 00 	jeq %d5,1,80004912 <IfxVadc_getResultBasedOnRequestSource+0x12>
80004904:	76 54       	jz %d5,8000490c <IfxVadc_getResultBasedOnRequestSource+0xc>
80004906:	df 25 0b 00 	jeq %d5,2,8000491c <IfxVadc_getResultBasedOnRequestSource+0x1c>
8000490a:	3c 39       	j 8000497c <IfxVadc_getResultBasedOnRequestSource+0x7c>
    {
    case IfxVadc_RequestSource_queue:
        sourceResultRegister = group->QCTRL0.B.SRCRESREG;
8000490c:	19 5f 00 20 	ld.w %d15,[%a5]128
80004910:	3c 03       	j 80004916 <IfxVadc_getResultBasedOnRequestSource+0x16>
        break;

    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
80004912:	19 5f 20 20 	ld.w %d15,[%a5]160
80004916:	16 0f       	and %d15,15
    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
        break;
    }

    if (sourceResultRegister > 0)
80004918:	ee 39       	jnz %d15,8000498a <IfxVadc_getResultBasedOnRequestSource+0x8a>
8000491a:	3c 31       	j 8000497c <IfxVadc_getResultBasedOnRequestSource+0x7c>
    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
        break;

    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
8000491c:	19 4f 00 80 	ld.w %d15,[%a4]512
80004920:	16 0f       	and %d15,15
        break;
    }

    if (sourceResultRegister > 0)
80004922:	ee 34       	jnz %d15,8000498a <IfxVadc_getResultBasedOnRequestSource+0x8a>

        return tmpResult;
    }
    else
    {
        if ((sourceType == IfxVadc_RequestSource_background) && (group->CHCTR[channel].B.RESTBS == 1))
80004924:	1b 04 06 f0 	addi %d15,%d4,96
80004928:	90 5f       	addsc.a %a15,%a5,%d15,2
8000492a:	4c f0       	ld.w %d15,[%a15]0
8000492c:	ef 4f 28 00 	jz.t %d15,20,8000497c <IfxVadc_getResultBasedOnRequestSource+0x7c>
        {
            tmpResult.B.VF     = vadc->GLOBRES.B.VF;
80004930:	19 42 00 c0 	ld.w %d2,[%a4]768
80004934:	82 0f       	mov %d15,0
80004936:	67 2f 9f ff 	ins.t %d15,%d15,31,%d2,31
            tmpResult.B.FCR    = vadc->GLOBRES.B.FCR;
8000493a:	19 42 00 c0 	ld.w %d2,[%a4]768
8000493e:	67 2f 1e ff 	ins.t %d15,%d15,30,%d2,30
            tmpResult.B.CRS    = vadc->GLOBRES.B.CRS;
80004942:	19 42 00 c0 	ld.w %d2,[%a4]768
80004946:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000494a:	37 2f 02 fe 	insert %d15,%d15,%d2,28,2
            tmpResult.B.EMUX   = vadc->GLOBRES.B.EMUX;
8000494e:	19 42 00 c0 	ld.w %d2,[%a4]768
80004952:	37 02 e3 2c 	extr.u %d2,%d2,25,3
80004956:	37 2f 83 fc 	insert %d15,%d15,%d2,25,3
            tmpResult.B.CHNR   = vadc->GLOBRES.B.CHNR;
8000495a:	19 42 00 c0 	ld.w %d2,[%a4]768
8000495e:	37 02 65 2a 	extr.u %d2,%d2,20,5
80004962:	37 2f 05 fa 	insert %d15,%d15,%d2,20,5
            tmpResult.B.DRC    = vadc->GLOBRES.B.GNR; //The bitfields are the same but interpretation is different. TODO- define a generic result register type.
80004966:	19 42 00 c0 	ld.w %d2,[%a4]768
8000496a:	37 02 64 28 	extr.u %d2,%d2,16,4
8000496e:	37 2f 04 f8 	insert %d15,%d15,%d2,16,4
            tmpResult.B.RESULT = vadc->GLOBRES.B.RESULT;
80004972:	19 42 00 c0 	ld.w %d2,[%a4]768
80004976:	37 2f 10 20 	insert %d2,%d15,%d2,0,16

            return tmpResult;
8000497a:	00 90       	ret 
        }
        else
        {
            tmpResult.U = group->RES[group->CHCTR[channel].B.RESREG].U;
8000497c:	1b 04 06 40 	addi %d4,%d4,96
80004980:	01 54 02 f6 	addsc.a %a15,%a5,%d4,2
80004984:	4c f0       	ld.w %d15,[%a15]0
80004986:	37 0f 64 f8 	extr.u %d15,%d15,16,4
8000498a:	1b 0f 0a f0 	addi %d15,%d15,160
8000498e:	90 55       	addsc.a %a5,%a5,%d15,2
80004990:	54 52       	ld.w %d2,[%a5]

            return tmpResult;
80004992:	00 90       	ret 

80004994 <IfxVadc_getScanStatus>:

IfxVadc_Status IfxVadc_getScanStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    if (group->ASPND.U)
80004994:	19 42 2c 20 	ld.w %d2,[%a4]172
    }
    else
    {
        return status;
    }
}
80004998:	ab 62 a0 22 	seln %d2,%d2,%d2,6
8000499c:	00 90       	ret 

8000499e <IfxVadc_getSrcAddress>:

volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
8000499e:	bf 45 0a 80 	jlt.u %d5,4,800049b2 <IfxVadc_getSrcAddress+0x14>
    {
        index -= 4;
800049a2:	9a c5       	add %d15,%d5,-4
800049a4:	8f ff 0f 51 	and %d5,%d15,255

        if ((group & 0x1) != 0)
800049a8:	8f 14 00 41 	and %d4,%d4,1
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
800049ac:	da 08       	mov %d15,8
800049ae:	ab 9f a0 44 	seln %d4,%d4,%d15,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
800049b2:	13 44 20 45 	madd %d4,%d5,%d4,4
800049b6:	91 00 00 f8 	movh.a %a15,32768
800049ba:	d9 ff 30 70 	lea %a15,[%a15]496 <800001f0 <IfxVadc_cfg_srcAddresses>>
800049be:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2

    return &(base[0]);
}
800049c2:	c8 02       	ld.a %a2,[%a15]0
800049c4:	00 90       	ret 

800049c6 <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800049c6:	19 4f 00 20 	ld.w %d15,[%a4]128
    return &(base[0]);
}


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
800049ca:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
800049cc:	37 4f 02 f4 	insert %d15,%d15,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800049d0:	3b f0 01 40 	mov %d4,31
800049d4:	6d ff b4 fe 	call 8000473c <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
800049d8:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800049dc:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
800049de:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800049e2:	3b f0 01 40 	mov %d4,31
800049e6:	1d ff 8f fe 	j 80004704 <IfxVadc_disableAccess>

800049ea <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800049ea:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
}


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
800049ee:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
800049f0:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800049f4:	3b f0 01 40 	mov %d4,31
800049f8:	6d ff a2 fe 	call 8000473c <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
800049fc:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a00:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004a02:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a06:	3b f0 01 40 	mov %d4,31
80004a0a:	1d ff 7d fe 	j 80004704 <IfxVadc_disableAccess>

80004a0e <IfxVadc_initializeFAdcD>:
}


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
80004a0e:	02 4f       	mov %d15,%d4
80004a10:	40 4f       	mov.aa %a15,%a4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80004a12:	6d 00 06 0c 	call 8000621e <IfxScuCcu_getSpbFrequency>
80004a16:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
80004a1a:	4b f2 11 42 	div.u %e4,%d2,%d15
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004a1e:	82 3f       	mov %d15,3
80004a20:	c2 f4       	add %d4,-1
80004a22:	0b f4 90 41 	min.u %d4,%d4,%d15

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80004a26:	1b 14 00 80 	addi %d8,%d4,1
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80004a2a:	40 f4       	mov.aa %a4,%a15

    divD   = (fadc / fAdcD - 1);

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80004a2c:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80004a30:	6d ff cb ff 	call 800049c6 <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
80004a34:	02 82       	mov %d2,%d8
80004a36:	00 90       	ret 

80004a38 <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
80004a38:	02 4f       	mov %d15,%d4
80004a3a:	40 4f       	mov.aa %a15,%a4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80004a3c:	6d 00 f1 0b 	call 8000621e <IfxScuCcu_getSpbFrequency>
80004a40:	4b 02 71 21 	ftouz %d2,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
80004a44:	8f 22 00 40 	sh %d4,%d2,2
80004a48:	4b f4 11 42 	div.u %e4,%d4,%d15
80004a4c:	3b f0 01 50 	mov %d5,31

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
80004a50:	c2 24       	add %d4,2
80004a52:	06 e4       	sh %d4,-2
    divA   = __minu(divA - 1, 0x1Fu);
80004a54:	c2 f4       	add %d4,-1
80004a56:	0b 54 90 41 	min.u %d4,%d4,%d5
    result = fadc / (divA + 1);
80004a5a:	1b 14 00 30 	addi %d3,%d4,1
80004a5e:	4b 32 11 62 	div.u %e6,%d2,%d3
80004a62:	02 6f       	mov %d15,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
80004a64:	7b 10 13 60 	movh %d6,305
80004a68:	1b 16 d0 62 	addi %d6,%d6,11521
80004a6c:	3f 6f 08 80 	jlt.u %d15,%d6,80004a7c <IfxVadc_initializeFAdcI+0x44>
80004a70:	0b 53 90 41 	min.u %d4,%d3,%d5
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
80004a74:	9a 14       	add %d15,%d4,1
80004a76:	4b f2 11 22 	div.u %e2,%d2,%d15
80004a7a:	02 2f       	mov %d15,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80004a7c:	1b 0f ee 25 	addi %d2,%d15,24288
80004a80:	7b a0 12 30 	movh %d3,298
80004a84:	9b 82 ff 2f 	addih %d2,%d2,65528
80004a88:	1b 13 be 38 	addi %d3,%d3,-29727
80004a8c:	7f 32 06 80 	jge.u %d2,%d3,80004a98 <IfxVadc_initializeFAdcI+0x60>
    {
        result = 0;             /* Min / Max FAdcI frequency */
    }
    else
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
80004a90:	40 f4       	mov.aa %a4,%a15
80004a92:	6d ff ac ff 	call 800049ea <IfxVadc_initialiseAdcConverterClock>
80004a96:	3c 02       	j 80004a9a <IfxVadc_initializeFAdcI+0x62>
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
    {
        result = 0;             /* Min / Max FAdcI frequency */
80004a98:	82 0f       	mov %d15,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
80004a9a:	02 f2       	mov %d2,%d15
80004a9c:	00 90       	ret 

80004a9e <IfxVadc_isPostCalibration>:
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
        break;
    default: pcEnabled                = FALSE;
80004a9e:	82 02       	mov %d2,0

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
80004aa0:	ff 84 33 80 	jge.u %d4,8,80004b06 <IfxVadc_isPostCalibration+0x68>
80004aa4:	91 00 00 f8 	movh.a %a15,32768
80004aa8:	d9 ff b8 a4 	lea %a15,[%a15]19128 <80004ab8 <IfxVadc_isPostCalibration+0x1a>>
80004aac:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
        break;
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
80004ab0:	19 42 00 20 	ld.w %d2,[%a4]128

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
80004ab4:	dc 0f       	ji %a15
80004ab6:	00 00       	nop 
80004ab8:	1d 00 10 00 	j 80004ad8 <IfxVadc_isPostCalibration+0x3a>
80004abc:	1d 00 11 00 	j 80004ade <IfxVadc_isPostCalibration+0x40>
80004ac0:	1d 00 12 00 	j 80004ae4 <IfxVadc_isPostCalibration+0x46>
80004ac4:	1d 00 13 00 	j 80004aea <IfxVadc_isPostCalibration+0x4c>
80004ac8:	1d 00 14 00 	j 80004af0 <IfxVadc_isPostCalibration+0x52>
80004acc:	1d 00 15 00 	j 80004af6 <IfxVadc_isPostCalibration+0x58>
80004ad0:	1d 00 16 00 	j 80004afc <IfxVadc_isPostCalibration+0x5e>
80004ad4:	1d 00 17 00 	j 80004b02 <IfxVadc_isPostCalibration+0x64>
    {
    case IfxVadc_GroupId_0: pcEnabled = vadc->GLOBCFG.B.DPCAL0 == 0;
80004ad8:	07 22 10 28 	nand.t %d2,%d2,16,%d2,16
        break;
80004adc:	00 90       	ret 
    case IfxVadc_GroupId_1: pcEnabled = vadc->GLOBCFG.B.DPCAL1 == 0;
80004ade:	07 22 91 28 	nand.t %d2,%d2,17,%d2,17
        break;
80004ae2:	00 90       	ret 
    case IfxVadc_GroupId_2: pcEnabled = vadc->GLOBCFG.B.DPCAL2 == 0;
80004ae4:	07 22 12 29 	nand.t %d2,%d2,18,%d2,18
        break;
80004ae8:	00 90       	ret 
    case IfxVadc_GroupId_3: pcEnabled = vadc->GLOBCFG.B.DPCAL3 == 0;
80004aea:	07 22 93 29 	nand.t %d2,%d2,19,%d2,19
        break;
80004aee:	00 90       	ret 
    case IfxVadc_GroupId_4: pcEnabled = vadc->GLOBCFG.B.DPCAL4 == 0;
80004af0:	07 22 14 2a 	nand.t %d2,%d2,20,%d2,20
        break;
80004af4:	00 90       	ret 
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
80004af6:	07 22 95 2a 	nand.t %d2,%d2,21,%d2,21
        break;
80004afa:	00 90       	ret 
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
80004afc:	07 22 16 2b 	nand.t %d2,%d2,22,%d2,22
        break;
80004b00:	00 90       	ret 
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
80004b02:	07 22 97 2b 	nand.t %d2,%d2,23,%d2,23
    default: pcEnabled                = FALSE;
        break;
    }

    return pcEnabled;
}
80004b06:	00 90       	ret 

80004b08 <IfxVadc_getChannelConversionTime>:
    return status;
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
80004b08:	02 40       	mov %d0,%d4
80004b0a:	02 68       	mov %d8,%d6
80004b0c:	02 7a       	mov %d10,%d7
80004b0e:	14 a4       	ld.bu %d4,[%sp]
    IfxVadc_ChannelResolution resolution;
    uint32                    n;

    uint32                    inputClassNum;

    if (inputClass <= IfxVadc_InputClasses_group1)
80004b10:	ff 25 08 80 	jge.u %d5,2,80004b20 <IfxVadc_getChannelConversionTime+0x18>
    {
        inputClassNum = inputClass;
        stcs          = vadcG->ICLASS[inputClassNum].B.STCS;
80004b14:	8f 80 00 f0 	sh %d15,%d0,8
80004b18:	42 f5       	add %d5,%d15
80004b1a:	1b 85 12 50 	addi %d5,%d5,296
80004b1e:	3c 03       	j 80004b24 <IfxVadc_getChannelConversionTime+0x1c>
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004b20:	1b 65 02 50 	addi %d5,%d5,38
80004b24:	01 45 02 f6 	addsc.a %a15,%a4,%d5,2
80004b28:	4c f0       	ld.w %d15,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004b2a:	48 03       	ld.w %d3,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004b2c:	16 1f       	and %d15,31
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
    }

    if (stcs > 16)
80004b2e:	8b 1f 61 22 	lt.u %d2,%d15,17
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004b32:	37 03 63 34 	extr.u %d3,%d3,8,3
    }

    if (stcs > 16)
80004b36:	f6 24       	jnz %d2,80004b3e <IfxVadc_getChannelConversionTime+0x36>
    {
        stcs = (stcs - 15) * 16; // Reference for the logic: Table 28-4 of TC29xB User Manual v1.3
80004b38:	1b 1f ff ff 	addi %d15,%d15,-15
80004b3c:	06 4f       	sh %d15,4
80004b3e:	ff 63 35 80 	jge.u %d3,6,80004ba8 <IfxVadc_getChannelConversionTime+0xa0>
80004b42:	91 00 00 f8 	movh.a %a15,32768
80004b46:	d9 ff 28 70 	lea %a15,[%a15]488 <800001e8 <CSWTCH.25>>
80004b4a:	01 f3 00 f6 	addsc.a %a15,%a15,%d3,0
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004b4e:	82 02       	mov %d2,0
80004b50:	08 09       	ld.bu %d9,[%a15]0
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004b52:	df 04 2f 80 	jne %d4,0,80004bb0 <IfxVadc_getChannelConversionTime+0xa8>
    {
        if (resolution != IfxVadc_ChannelResolution_10bitFast)
80004b56:	df 53 0d 00 	jeq %d3,5,80004b70 <IfxVadc_getChannelConversionTime+0x68>
        {
            /* Standard conversion */
            uint32 pc = IfxVadc_isPostCalibration(vadc, group) ? 2 : 0;
80004b5a:	02 04       	mov %d4,%d0
80004b5c:	6d ff a1 ff 	call 80004a9e <IfxVadc_isPostCalibration>
80004b60:	92 24       	add %d4,%d15,2
80004b62:	ab 22 a0 22 	seln %d2,%d2,%d2,2
80004b66:	42 94       	add %d4,%d9
            conversionTime = (float32)(2 + stcs + n + pc) / analogFrequency + 2.0 / moduleFrequency;
80004b68:	42 24       	add %d4,%d2
80004b6a:	4b 04 41 41 	itof %d4,%d4
80004b6e:	3c 04       	j 80004b76 <IfxVadc_getChannelConversionTime+0x6e>
        }
        else
        {
            /* Fast compare mode */
            conversionTime = (float32)(2 + stcs + 2) / analogFrequency + 2.0 / moduleFrequency;
80004b70:	c2 4f       	add %d15,4
80004b72:	4b 0f 41 41 	itof %d4,%d15
80004b76:	4b 84 51 40 	div.f %d4,%d4,%d8
80004b7a:	6d 00 0f 30 	call 8000ab98 <__extendsfdf2>
80004b7e:	02 a4       	mov %d4,%d10
80004b80:	0b 23 10 88 	mov %e8,%d3,%d2
80004b84:	6d 00 0a 30 	call 8000ab98 <__extendsfdf2>
80004b88:	b7 00 21 4f 	imask %e4,0,30,1
80004b8c:	0b 23 10 68 	mov %e6,%d3,%d2
80004b90:	6d 00 f9 31 	call 8000af82 <__divdf3>
80004b94:	0b 89 10 48 	mov %e4,%d9,%d8
80004b98:	0b 23 10 68 	mov %e6,%d3,%d2
80004b9c:	6d 00 e5 30 	call 8000ad66 <__adddf3>
80004ba0:	0b 23 10 48 	mov %e4,%d3,%d2
80004ba4:	1d 00 ae 32 	j 8000b100 <__truncdfsf2>
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004ba8:	82 09       	mov %d9,0
80004baa:	df 04 d8 7f 	jeq %d4,0,80004b5a <IfxVadc_getChannelConversionTime+0x52>
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004bae:	82 02       	mov %d2,0
    {
        // do nothing
    }

    return conversionTime;
}
80004bb0:	00 90       	ret 

80004bb2 <IfxVadc_resetKernel>:
    return pcEnabled;
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
80004bb2:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004bb4:	6d 00 f9 13 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80004bb8:	02 24       	mov %d4,%d2
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004bba:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80004bbc:	6d 00 f5 12 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bc0:	3b f0 01 40 	mov %d4,31
80004bc4:	40 f4       	mov.aa %a4,%a15
80004bc6:	6d ff bb fd 	call 8000473c <IfxVadc_enableAccess>
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
80004bca:	48 c2       	ld.w %d2,[%a15]48
    vadc->KRST0.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004bcc:	02 f4       	mov %d4,%d15
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
80004bce:	8f 12 40 21 	or %d2,%d2,1
80004bd2:	68 c2       	st.w [%a15]48,%d2
    vadc->KRST0.B.RST = 1;
80004bd4:	48 d2       	ld.w %d2,[%a15]52
80004bd6:	8f 12 40 21 	or %d2,%d2,1
80004bda:	68 d2       	st.w [%a15]52,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004bdc:	6d 00 1a 14 	call 80007410 <IfxScuWdt_setCpuEndinit>

    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */
80004be0:	48 d2       	ld.w %d2,[%a15]52
80004be2:	6f 12 ff 7f 	jz.t %d2,1,80004be0 <IfxVadc_resetKernel+0x2e>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004be6:	02 f4       	mov %d4,%d15
80004be8:	6d 00 df 12 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
80004bec:	48 b2       	ld.w %d2,[%a15]44
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bee:	3b f0 01 40 	mov %d4,31
    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
80004bf2:	8f 12 40 21 	or %d2,%d2,1
80004bf6:	68 b2       	st.w [%a15]44,%d2
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bf8:	40 f4       	mov.aa %a4,%a15
80004bfa:	6d ff 85 fd 	call 80004704 <IfxVadc_disableAccess>
    IfxScuWdt_setCpuEndinit(passwd);
80004bfe:	02 f4       	mov %d4,%d15
80004c00:	1d 00 08 14 	j 80007410 <IfxScuWdt_setCpuEndinit>

80004c04 <IfxVadc_selectPowerSupplyVoltage>:


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80004c04:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
80004c08:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80004c0a:	67 4f 0e f0 	ins.t %d15,%d15,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c0e:	3b f0 01 40 	mov %d4,31
80004c12:	6d ff 95 fd 	call 8000473c <IfxVadc_enableAccess>
void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
80004c16:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c1a:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004c1c:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c20:	3b f0 01 40 	mov %d4,31
80004c24:	1d ff 70 fd 	j 80004704 <IfxVadc_disableAccess>

80004c28 <IfxVadc_setArbiterPriority>:
}


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80004c28:	1b 87 01 f0 	addi %d15,%d7,24
    if (slotEnable != FALSE)
80004c2c:	df 04 23 00 	jeq %d4,0,80004c72 <IfxVadc_setArbiterPriority+0x4a>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80004c30:	19 42 04 00 	ld.w %d2,[%a4]4
80004c34:	0f f4 00 40 	sh %d4,%d4,%d15
80004c38:	a6 24       	or %d4,%d2
80004c3a:	59 44 04 00 	st.w [%a4]4,%d4
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80004c3e:	19 42 04 00 	ld.w %d2,[%a4]4
80004c42:	06 27       	sh %d7,2
80004c44:	82 3f       	mov %d15,3
80004c46:	0f 7f 00 f0 	sh %d15,%d15,%d7
80004c4a:	0f f2 e0 f0 	andn %d15,%d2,%d15
80004c4e:	6c 41       	st.w [%a4]4,%d15
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80004c50:	4c 41       	ld.w %d15,[%a4]4
80004c52:	0f 75 00 50 	sh %d5,%d5,%d7
80004c56:	a6 f5       	or %d5,%d15
80004c58:	59 45 04 00 	st.w [%a4]4,%d5

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004c5c:	4c 41       	ld.w %d15,[%a4]4
80004c5e:	c2 37       	add %d7,3
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80004c60:	76 64       	jz %d6,80004c68 <IfxVadc_setArbiterPriority+0x40>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004c62:	d7 1f 01 77 	insert %d7,%d15,1,%d7,1
80004c66:	3c 03       	j 80004c6c <IfxVadc_setArbiterPriority+0x44>
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80004c68:	d7 0f 01 77 	insert %d7,%d15,0,%d7,1
80004c6c:	59 47 04 00 	st.w [%a4]4,%d7
80004c70:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80004c72:	19 44 04 00 	ld.w %d4,[%a4]4
80004c76:	d7 04 01 ff 	insert %d15,%d4,0,%d15,1
80004c7a:	6c 41       	st.w [%a4]4,%d15
80004c7c:	00 90       	ret 

80004c7e <IfxVadc_setScan>:

void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80004c7e:	19 4f 28 20 	ld.w %d15,[%a4]168
80004c82:	26 54       	and %d4,%d5
80004c84:	0f 5f e0 f0 	andn %d15,%d15,%d5
80004c88:	0f 4f a0 50 	or %d5,%d15,%d4
80004c8c:	59 45 28 20 	st.w [%a4]168,%d5
80004c90:	00 90       	ret 

80004c92 <IfxVadc_startupCalibration>:
{
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c92:	3b f0 01 40 	mov %d4,31
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004c96:	40 4f       	mov.aa %a15,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c98:	6d ff 52 fd 	call 8000473c <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80004c9c:	19 ff 00 20 	ld.w %d15,[%a15]128
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004ca0:	40 f4       	mov.aa %a4,%a15
80004ca2:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80004ca6:	3b f0 01 40 	mov %d4,31
80004caa:	59 ff 00 20 	st.w [%a15]128,%d15
80004cae:	6d ff 2b fd 	call 80004704 <IfxVadc_disableAccess>
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004cb2:	82 02       	mov %d2,0

    /* Wait for hardware self-test and calibration to complete */
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;
80004cb4:	82 0f       	mov %d15,0
80004cb6:	a0 72       	mov.a %a2,7


IFX_INLINE uint8 IfxVadc_getAdcCalibrationActiveState(Ifx_VADC *vadc, uint8 adcCalGroupNum)
{
    uint8 status;
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80004cb8:	8f a2 00 30 	sh %d3,%d2,10
80004cbc:	01 f3 00 36 	addsc.a %a3,%a15,%d3,0
80004cc0:	c2 12       	add %d2,1
80004cc2:	19 33 40 20 	ld.w %d3,[%a3]1152
80004cc6:	37 03 61 3e 	extr.u %d3,%d3,28,1

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
            {
                calibrationRunning = TRUE;
80004cca:	ab 1f a0 f3 	seln %d15,%d3,%d15,1
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80004cce:	fc 25       	loop %a2,80004cb8 <IfxVadc_startupCalibration+0x26>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80004cd0:	df 1f f1 7f 	jeq %d15,1,80004cb2 <IfxVadc_startupCalibration+0x20>
}
80004cd4:	00 90       	ret 
	...

80004cd8 <IfxAsclin_disableModule>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
80004cd8:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004cda:	6d 00 66 13 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004cde:	02 24       	mov %d4,%d2
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004ce0:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004ce2:	6d 00 62 12 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80004ce6:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclin); /* disables the module*/
    IfxScuWdt_setCpuEndinit(psw);              /* sets the endinit protection back on*/
80004ce8:	02 f4       	mov %d4,%d15
80004cea:	8f 12 40 21 	or %d2,%d2,1
80004cee:	68 02       	st.w [%a15]0,%d2
80004cf0:	1d 00 90 13 	j 80007410 <IfxScuWdt_setCpuEndinit>

80004cf4 <IfxAsclin_enableAscErrorFlags>:
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80004cf4:	7b 10 00 f0 	movh %d15,1
80004cf8:	ab 0f 80 44 	sel %d4,%d4,%d15,0
80004cfc:	19 4f 00 10 	ld.w %d15,[%a4]64
80004d00:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80004d04:	a6 f4       	or %d4,%d15
80004d06:	59 44 00 10 	st.w [%a4]64,%d4
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80004d0a:	7b 00 40 f0 	movh %d15,1024
80004d0e:	ab 0f 80 55 	sel %d5,%d5,%d15,0
80004d12:	19 4f 00 10 	ld.w %d15,[%a4]64
80004d16:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80004d1a:	a6 f5       	or %d5,%d15
80004d1c:	59 45 00 10 	st.w [%a4]64,%d5
80004d20:	00 90       	ret 

80004d22 <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
80004d22:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004d24:	6d 00 41 13 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004d28:	02 24       	mov %d4,%d2
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004d2a:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004d2c:	6d 00 3d 12 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
80004d30:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
80004d32:	02 f4       	mov %d4,%d15
80004d34:	8f 12 c0 21 	andn %d2,%d2,1
80004d38:	68 02       	st.w [%a15]0,%d2
80004d3a:	1d 00 6b 13 	j 80007410 <IfxScuWdt_setCpuEndinit>

80004d3e <IfxAsclin_getAddress>:
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
    }
    else
    {
        module = NULL_PTR;
80004d3e:	a0 02       	mov.a %a2,0

Ifx_ASCLIN *IfxAsclin_getAddress(IfxAsclin_Index asclin)
{
    Ifx_ASCLIN *module;

    if (asclin < IFXASCLIN_NUM_MODULES)
80004d40:	ff 44 09 00 	jge %d4,4,80004d52 <IfxAsclin_getAddress+0x14>
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
80004d44:	91 00 00 f8 	movh.a %a15,32768
80004d48:	d9 ff 80 50 	lea %a15,[%a15]2368 <80000940 <IfxAsclin_cfg_indexMap>>
80004d4c:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80004d50:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
80004d52:	00 90       	ret 

80004d54 <IfxAsclin_getFaFrequency>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004d54:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004d58:	16 1f       	and %d15,31
float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
80004d5a:	c2 ff       	add %d15,-1
80004d5c:	8b 0f a1 22 	ge.u %d2,%d15,16
80004d60:	df 02 32 80 	jne %d2,0,80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d64:	91 00 00 f8 	movh.a %a15,32768
80004d68:	d9 ff f0 54 	lea %a15,[%a15]19824 <80004d70 <IfxAsclin_getFaFrequency+0x1c>>
80004d6c:	90 ff       	addsc.a %a15,%a15,%d15,2
80004d6e:	dc 0f       	ji %a15
80004d70:	1d 00 20 00 	j 80004db0 <IfxAsclin_getFaFrequency+0x5c>
80004d74:	1d 00 20 00 	j 80004db4 <IfxAsclin_getFaFrequency+0x60>
80004d78:	1d 00 26 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d7c:	1d 00 1e 00 	j 80004db8 <IfxAsclin_getFaFrequency+0x64>
80004d80:	1d 00 22 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d84:	1d 00 20 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d88:	1d 00 1e 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d8c:	1d 00 18 00 	j 80004dbc <IfxAsclin_getFaFrequency+0x68>
80004d90:	1d 00 1a 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d94:	1d 00 18 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d98:	1d 00 16 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004d9c:	1d 00 14 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004da0:	1d 00 12 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004da4:	1d 00 10 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004da8:	1d 00 0e 00 	j 80004dc4 <IfxAsclin_getFaFrequency+0x70>
80004dac:	1d 00 0a 00 	j 80004dc0 <IfxAsclin_getFaFrequency+0x6c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80004db0:	1d 00 37 0a 	j 8000621e <IfxScuCcu_getSpbFrequency>
        break;
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
80004db4:	1d 00 a6 08 	j 80005f00 <IfxScuCcu_getOsc0Frequency>
        break;
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80004db8:	1d 00 c3 08 	j 80005f3e <IfxScuCcu_getPllErayFrequency>
        break;
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
80004dbc:	1d 00 20 0a 	j 800061fc <IfxScuCcu_getBaud2Frequency>
        break;
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80004dc0:	1d 00 0e 0a 	j 800061dc <IfxScuCcu_getBaud1Frequency>
        frequency = 0.0;
        break;
    }

    return frequency;
}
80004dc4:	82 02       	mov %d2,0
80004dc6:	00 90       	ret 

80004dc8 <IfxAsclin_getIndex>:

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004dc8:	91 00 00 38 	movh.a %a3,32768
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004dcc:	82 0f       	mov %d15,0
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004dce:	d9 33 80 50 	lea %a3,[%a3]2368 <80000940 <IfxAsclin_cfg_indexMap>>
80004dd2:	a0 3f       	mov.a %a15,3
80004dd4:	d0 32       	addsc.a %a2,%a3,%d15,3
80004dd6:	d4 25       	ld.a %a5,[%a2]
80004dd8:	7d 45 05 80 	jne.a %a5,%a4,80004de2 <IfxAsclin_getIndex+0x1a>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80004ddc:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80004de0:	00 90       	ret 
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004de2:	c2 1f       	add %d15,1
80004de4:	fc f8       	loop %a15,80004dd4 <IfxAsclin_getIndex+0xc>
IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;
80004de6:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80004de8:	00 90       	ret 

80004dea <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
80004dea:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
80004dec:	6d ff b4 ff 	call 80004d54 <IfxAsclin_getFaFrequency>
80004df0:	4c f5       	ld.w %d15,[%a15]20
80004df2:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004df6:	c2 1f       	add %d15,1
80004df8:	4b 0f 41 f1 	itof %d15,%d15
}
80004dfc:	4b f2 51 20 	div.f %d2,%d2,%d15
80004e00:	00 90       	ret 

80004e02 <IfxAsclin_getOvsFrequency>:
    return result;
}


float32 IfxAsclin_getOvsFrequency(Ifx_ASCLIN *asclin)
{
80004e02:	40 4f       	mov.aa %a15,%a4
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
80004e04:	6d ff f3 ff 	call 80004dea <IfxAsclin_getPdFrequency>
80004e08:	48 83       	ld.w %d3,[%a15]32
80004e0a:	4c f8       	ld.w %d15,[%a15]32
80004e0c:	37 03 6c 38 	extr.u %d3,%d3,16,12
80004e10:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004e14:	4b 03 41 31 	itof %d3,%d3
80004e18:	4b 0f 41 f1 	itof %d15,%d15
80004e1c:	4b 32 41 20 	mul.f %d2,%d2,%d3
}
80004e20:	4b f2 51 20 	div.f %d2,%d2,%d15
80004e24:	00 90       	ret 

80004e26 <IfxAsclin_getShiftFrequency>:
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
}


float32 IfxAsclin_getShiftFrequency(Ifx_ASCLIN *asclin)
{
80004e26:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getOvsFrequency(asclin) / asclin->BITCON.B.OVERSAMPLING;
80004e28:	6d ff ed ff 	call 80004e02 <IfxAsclin_getOvsFrequency>
80004e2c:	4c f5       	ld.w %d15,[%a15]20
80004e2e:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004e32:	4b 0f 41 f1 	itof %d15,%d15
}
80004e36:	4b f2 51 20 	div.f %d2,%d2,%d15
80004e3a:	00 90       	ret 

80004e3c <IfxAsclin_getSrcPointerEr>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
80004e3c:	6d ff c6 ff 	call 80004dc8 <IfxAsclin_getIndex>
80004e40:	53 c2 20 f0 	mul %d15,%d2,12
80004e44:	60 ff       	mov.a %a15,%d15
80004e46:	d9 f2 08 28 	lea %a2,[%a15]-32632
}
80004e4a:	11 42 00 2f 	addih.a %a2,%a2,61444
80004e4e:	00 90       	ret 

80004e50 <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
80004e50:	6d ff bc ff 	call 80004dc8 <IfxAsclin_getIndex>
80004e54:	53 c2 20 f0 	mul %d15,%d2,12
80004e58:	60 ff       	mov.a %a15,%d15
80004e5a:	d9 f2 04 28 	lea %a2,[%a15]-32636
}
80004e5e:	11 42 00 2f 	addih.a %a2,%a2,61444
80004e62:	00 90       	ret 

80004e64 <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
80004e64:	6d ff b2 ff 	call 80004dc8 <IfxAsclin_getIndex>
80004e68:	53 c2 20 f0 	mul %d15,%d2,12
80004e6c:	60 ff       	mov.a %a15,%d15
80004e6e:	d9 f2 00 28 	lea %a2,[%a15]-32640
}
80004e72:	11 42 00 2f 	addih.a %a2,%a2,61444
80004e76:	00 90       	ret 

80004e78 <IfxAsclin_read16>:


uint32 IfxAsclin_read16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004e78:	9f 04 04 80 	jned %d4,0,80004e80 <IfxAsclin_read16+0x8>
        *data++ = (uint16)rxData->U;
        count--;
    }

    return count;
}
80004e7c:	82 02       	mov %d2,0
80004e7e:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint16)rxData->U;
80004e80:	19 4f 08 10 	ld.w %d15,[%a4]72
80004e84:	ac 50       	st.h [%a5]0,%d15
80004e86:	b0 25       	add.a %a5,2
80004e88:	3c f8       	j 80004e78 <IfxAsclin_read16>

80004e8a <IfxAsclin_read32>:
    return count;
}


uint32 IfxAsclin_read32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004e8a:	9f 04 04 80 	jned %d4,0,80004e92 <IfxAsclin_read32+0x8>
        *data++ = rxData->U;
        count--;
    }

    return count;
}
80004e8e:	82 02       	mov %d2,0
80004e90:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = rxData->U;
80004e92:	19 4f 08 10 	ld.w %d15,[%a4]72
80004e96:	6c 50       	st.w [%a5]0,%d15
80004e98:	b0 45       	add.a %a5,4
80004e9a:	3c f8       	j 80004e8a <IfxAsclin_read32>

80004e9c <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004e9c:	9f 04 04 80 	jned %d4,0,80004ea4 <IfxAsclin_read8+0x8>
        *data++ = (uint8)rxData->U;
        count--;
    }

    return count;
}
80004ea0:	82 02       	mov %d2,0
80004ea2:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint8)rxData->U;
80004ea4:	19 4f 08 10 	ld.w %d15,[%a4]72
80004ea8:	2c 50       	st.b [%a5]0,%d15
80004eaa:	b0 15       	add.a %a5,1
80004eac:	3c f8       	j 80004e9c <IfxAsclin_read8>

80004eae <IfxAsclin_resetModule>:
    return count;
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
80004eae:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004eb0:	6d 00 7b 12 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004eb4:	02 24       	mov %d4,%d2
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004eb6:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004eb8:	6d 00 77 11 	call 800071a6 <IfxScuWdt_clearCpuEndinit>

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004ebc:	19 f2 34 30 	ld.w %d2,[%a15]244
    asclin->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004ec0:	02 f4       	mov %d4,%d15
void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004ec2:	8f 12 40 21 	or %d2,%d2,1
80004ec6:	59 f2 34 30 	st.w [%a15]244,%d2
    asclin->KRST1.B.RST = 1;
80004eca:	19 f2 30 30 	ld.w %d2,[%a15]240
80004ece:	8f 12 40 21 	or %d2,%d2,1
80004ed2:	59 f2 30 30 	st.w [%a15]240,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004ed6:	6d 00 9d 12 	call 80007410 <IfxScuWdt_setCpuEndinit>

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
80004eda:	19 f2 34 30 	ld.w %d2,[%a15]244
80004ede:	6f 12 fe 7f 	jz.t %d2,1,80004eda <IfxAsclin_resetModule+0x2c>
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004ee2:	02 f4       	mov %d4,%d15
80004ee4:	6d 00 61 11 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004ee8:	19 f2 2c 30 	ld.w %d2,[%a15]236

    IfxScuWdt_setCpuEndinit(passwd);
80004eec:	02 f4       	mov %d4,%d15

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004eee:	8f 12 40 21 	or %d2,%d2,1
80004ef2:	59 f2 2c 30 	st.w [%a15]236,%d2

    IfxScuWdt_setCpuEndinit(passwd);
80004ef6:	1d 00 8d 12 	j 80007410 <IfxScuWdt_setCpuEndinit>

80004efa <IfxAsclin_setClockSource>:
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004efa:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004efe:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
80004f02:	59 4f 0c 10 	st.w [%a4]76,%d15

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80004f06:	f6 46       	jnz %d4,80004f12 <IfxAsclin_setClockSource+0x18>
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004f08:	19 4f 0c 10 	ld.w %d15,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004f0c:	bf 0f fe 7f 	jlt %d15,0,80004f08 <IfxAsclin_setClockSource+0xe>
80004f10:	00 90       	ret 
80004f12:	19 4f 0c 10 	ld.w %d15,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80004f16:	ff 0f fe 7f 	jge %d15,0,80004f12 <IfxAsclin_setClockSource+0x18>
80004f1a:	00 90       	ret 

80004f1c <IfxAsclin_setBaudrateBitFields>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004f1c:	19 4f 0c 10 	ld.w %d15,[%a4]76
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004f20:	19 42 0c 10 	ld.w %d2,[%a4]76
80004f24:	16 1f       	and %d15,31
80004f26:	8f f2 c1 21 	andn %d2,%d2,31
80004f2a:	59 42 0c 10 	st.w [%a4]76,%d2
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004f2e:	19 42 0c 10 	ld.w %d2,[%a4]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004f32:	bf 02 fe 7f 	jlt %d2,0,80004f2e <IfxAsclin_setBaudrateBitFields+0x12>
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80004f36:	19 42 14 00 	ld.w %d2,[%a4]20
80004f3a:	c2 f4       	add %d4,-1
80004f3c:	37 42 0c 40 	insert %d4,%d2,%d4,0,12
80004f40:	59 44 14 00 	st.w [%a4]20,%d4
}


IFX_INLINE void IfxAsclin_setNumerator(Ifx_ASCLIN *asclin, uint16 numerator)
{
    asclin->BRG.B.NUMERATOR = numerator;
80004f44:	19 42 20 00 	ld.w %d2,[%a4]32
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);                             /* turns off the clock for settings */
    IfxAsclin_setPrescaler(asclin, prescaler);                                                   /* sets the prescaler*/
    IfxAsclin_setNumerator(asclin, numerator);                                                   /* sets the numerator*/
    IfxAsclin_setDenominator(asclin, denominator);                                               /* sets the denominator*/
    IfxAsclin_setOversampling(asclin, oversampling);                                             /* sets the oversampling*/
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
80004f48:	02 f4       	mov %d4,%d15
80004f4a:	37 52 0c 58 	insert %d5,%d2,%d5,16,12
80004f4e:	59 45 20 00 	st.w [%a4]32,%d5
}


IFX_INLINE void IfxAsclin_setDenominator(Ifx_ASCLIN *asclin, uint16 denominator)
{
    asclin->BRG.B.DENOMINATOR = denominator;
80004f52:	19 42 20 00 	ld.w %d2,[%a4]32
80004f56:	37 62 0c 60 	insert %d6,%d2,%d6,0,12
80004f5a:	59 46 20 00 	st.w [%a4]32,%d6
}


IFX_INLINE void IfxAsclin_setOversampling(Ifx_ASCLIN *asclin, IfxAsclin_OversamplingFactor ovsFactor)
{
    asclin->BITCON.B.OVERSAMPLING = ovsFactor;
80004f5e:	19 42 14 00 	ld.w %d2,[%a4]20
80004f62:	37 72 04 78 	insert %d7,%d2,%d7,16,4
80004f66:	59 47 14 00 	st.w [%a4]20,%d7
80004f6a:	1d ff c8 ff 	j 80004efa <IfxAsclin_setClockSource>

80004f6e <IfxAsclin_setBitTiming>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004f6e:	19 42 0c 10 	ld.w %d2,[%a4]76
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
80004f72:	20 08       	sub.a %sp,8
80004f74:	8f f2 01 21 	and %d2,%d2,31
80004f78:	02 5f       	mov %d15,%d5
80004f7a:	40 4f       	mov.aa %a15,%a4
80004f7c:	02 48       	mov %d8,%d4
80004f7e:	02 6a       	mov %d10,%d6
80004f80:	60 7d       	mov.a %a13,%d7
80004f82:	60 2c       	mov.a %a12,%d2
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004f84:	6d ff 33 ff 	call 80004dea <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004f88:	92 15       	add %d5,%d15,1
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004f8a:	02 29       	mov %d9,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004f8c:	82 4f       	mov %d15,4
80004f8e:	0b f5 b0 f1 	max.u %d15,%d5,%d15
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004f92:	8f ff 0f 21 	and %d2,%d15,255
80004f96:	59 a2 04 00 	st.w [%sp]4,%d2
80004f9a:	82 16       	mov %d6,1
80004f9c:	0b 6a b0 61 	max.u %d6,%d10,%d6
80004fa0:	16 ff       	and %d15,255
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
80004fa2:	4b 0f 41 31 	itof %d3,%d15
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004fa6:	8f f6 0f 61 	and %d6,%d6,255
    fOvs         = baudrate * oversampling;
80004faa:	4b 38 41 f0 	mul.f %d15,%d8,%d3
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004fae:	60 6e       	mov.a %a14,%d6
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004fb0:	02 f4       	mov %d4,%d15
80004fb2:	6d 00 f3 2d 	call 8000ab98 <__extendsfdf2>
80004fb6:	7b 00 f5 73 	movh %d7,16208
80004fba:	0b 23 10 48 	mov %e4,%d3,%d2
80004fbe:	7b 20 2f 6d 	movh %d6,54002
80004fc2:	1b d7 24 76 	addi %d7,%d7,25165
80004fc6:	1b c6 9f 6a 	addi %d6,%d6,-22020
80004fca:	6d 00 0a 2f 	call 8000adde <__muldf3>
80004fce:	0b 23 10 48 	mov %e4,%d3,%d2
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
    nBest          = n;
80004fd2:	82 1c       	mov %d12,1
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004fd4:	6d 00 96 30 	call 8000b100 <__truncdfsf2>

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004fd8:	4b f9 51 50 	div.f %d5,%d9,%d15
80004fdc:	91 00 00 20 	movh.a %a2,0

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);
80004fe0:	82 01       	mov %d1,0

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004fe2:	4b 05 71 51 	ftouz %d5,%d5
    }

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
80004fe6:	4b 05 61 31 	utof %d3,%d5
80004fea:	4b 39 51 30 	div.f %d3,%d9,%d3
    relError       = __absf(fOvs - f);
80004fee:	6b 03 31 3f 	sub.f %d3,%d15,%d3
80004ff2:	4b 13 01 00 	cmp.f %d0,%d3,%d1
80004ff6:	37 00 61 00 	extr.u %d0,%d0,0,1
80004ffa:	9b 03 00 48 	addih %d4,%d3,32768
80004ffe:	2b 34 40 30 	sel %d3,%d0,%d4,%d3
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80005002:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80005006:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
8000500a:	df 00 45 80 	jne %d0,0,80005094 <IfxAsclin_setBitTiming+0x126>
8000500e:	8f 15 00 60 	sh %d6,%d5,1
            /* Increase the value of the oversampling to generate the required baudrate */
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
80005012:	02 51       	mov %d1,%d5
    nBest          = n;
    adder_facL_min = 0;
80005014:	82 0e       	mov %d14,0
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80005016:	82 28       	mov %d8,2
80005018:	3b 00 00 71 	mov %d7,4096
8000501c:	7f 76 3b 80 	jge.u %d6,%d7,80005092 <IfxAsclin_setBitTiming+0x124>
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
80005020:	a0 13       	mov.a %a3,1

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
80005022:	82 1b       	mov %d11,1
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
80005024:	df 28 09 00 	jeq %d8,2,80005036 <IfxAsclin_setBitTiming+0xc8>
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80005028:	73 8e 0a a0 	mul %d10,%d14,%d8
8000502c:	4b ca 11 a2 	div.u %e10,%d10,%d12
            adder_facH = adder_facL + 1;
80005030:	60 a3       	mov.a %a3,%d10
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80005032:	02 ab       	mov %d11,%d10
            adder_facH = adder_facL + 1;
80005034:	b0 13       	add.a %a3,1
        }

        for (count = adder_facL; count <= adder_facH; count++)
80005036:	80 34       	mov.d %d4,%a3
80005038:	3f b4 25 80 	jlt.u %d4,%d11,80005082 <IfxAsclin_setBitTiming+0x114>
        {
            f           = (fpd * n) / (n * d + count);
8000503c:	4b 08 61 01 	utof %d0,%d8
80005040:	0b 6b 00 40 	add %d4,%d11,%d6
80005044:	4b 04 61 d1 	utof %d13,%d4
80005048:	4b 09 41 00 	mul.f %d0,%d9,%d0
            newRelError = __absf(fOvs - f);
8000504c:	80 2a       	mov.d %d10,%a2
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
        {
            f           = (fpd * n) / (n * d + count);
8000504e:	4b d0 51 00 	div.f %d0,%d0,%d13
            newRelError = __absf(fOvs - f);
80005052:	6b 00 31 0f 	sub.f %d0,%d15,%d0
80005056:	4b a0 01 d0 	cmp.f %d13,%d0,%d10
8000505a:	37 0d 61 d0 	extr.u %d13,%d13,0,1
8000505e:	9b 00 00 a8 	addih %d10,%d0,32768
80005062:	2b 0a 40 0d 	sel %d0,%d13,%d10,%d0

            if (relError > (newRelError))
80005066:	4b 03 01 d0 	cmp.f %d13,%d3,%d0
8000506a:	37 0d 61 d1 	extr.u %d13,%d13,2,1
8000506e:	2b be 50 ed 	seln %d14,%d13,%d14,%d11
80005072:	2b 03 50 3d 	seln %d3,%d13,%d3,%d0
80005076:	2b 8c 50 cd 	seln %d12,%d13,%d12,%d8
8000507a:	2b 41 50 1d 	seln %d1,%d13,%d1,%d4
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
8000507e:	c2 1b       	add %d11,1
80005080:	3c db       	j 80005036 <IfxAsclin_setBitTiming+0xc8>
                dBest          = (n * d + count);
                adder_facL_min = count;
            }
        }

        if (relError <= limit)
80005082:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80005086:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
8000508a:	f6 04       	jnz %d0,80005092 <IfxAsclin_setBitTiming+0x124>
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
8000508c:	c2 18       	add %d8,1
8000508e:	42 56       	add %d6,%d5
80005090:	3c c6       	j 8000501c <IfxAsclin_setBitTiming+0xae>
80005092:	02 15       	mov %d5,%d1
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80005094:	19 f3 0c 10 	ld.w %d3,[%a15]76
80005098:	8f f3 c1 31 	andn %d3,%d3,31
8000509c:	59 f3 0c 10 	st.w [%a15]76,%d3
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
800050a0:	19 ff 0c 10 	ld.w %d15,[%a15]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
800050a4:	bf 0f fe 7f 	jlt %d15,0,800050a0 <IfxAsclin_setBitTiming+0x132>
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
800050a8:	4c f8       	ld.w %d15,[%a15]32
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
800050aa:	19 a2 04 00 	ld.w %d2,[%sp]4
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
800050ae:	37 5f 0c 50 	insert %d5,%d15,%d5,0,12
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
800050b2:	c2 f2       	add %d2,-1
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
800050b4:	68 85       	st.w [%a15]32,%d5
    asclin->BRG.B.NUMERATOR   = nBest;
800050b6:	4c f8       	ld.w %d15,[%a15]32

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
800050b8:	80 ea       	mov.d %d10,%a14
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
800050ba:	37 cf 0c c8 	insert %d12,%d15,%d12,16,12
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
800050be:	80 c4       	mov.d %d4,%a12
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
800050c0:	68 8c       	st.w [%a15]32,%d12

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
800050c2:	4c f5       	ld.w %d15,[%a15]20
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
800050c4:	40 f4       	mov.aa %a4,%a15
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
800050c6:	37 2f 04 28 	insert %d2,%d15,%d2,16,4
800050ca:	68 52       	st.w [%a15]20,%d2

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
800050cc:	4c f5       	ld.w %d15,[%a15]20

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
800050ce:	80 d2       	mov.d %d2,%a13

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
800050d0:	37 af 04 6c 	insert %d6,%d15,%d10,24,4

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
800050d4:	7b 00 00 f8 	movh %d15,32768

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
800050d8:	68 56       	st.w [%a15]20,%d6

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
800050da:	ab 0f 80 72 	sel %d7,%d2,%d15,0
800050de:	4c f5       	ld.w %d15,[%a15]20
800050e0:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
800050e4:	a6 7f       	or %d15,%d7
800050e6:	68 5f       	st.w [%a15]20,%d15

    IfxAsclin_setClockSource(asclin, source);
800050e8:	6d ff 09 ff 	call 80004efa <IfxAsclin_setClockSource>

    return TRUE;
}
800050ec:	82 12       	mov %d2,1
800050ee:	00 90       	ret 

800050f0 <IfxAsclin_write16>:
    }
}


uint32 IfxAsclin_write16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
800050f0:	9f 04 04 80 	jned %d4,0,800050f8 <IfxAsclin_write16+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
800050f4:	82 02       	mov %d2,0
800050f6:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
800050f8:	b9 5f 00 00 	ld.hu %d15,[%a5]0
800050fc:	b0 25       	add.a %a5,2
800050fe:	59 4f 04 10 	st.w [%a4]68,%d15
80005102:	3c f7       	j 800050f0 <IfxAsclin_write16>

80005104 <IfxAsclin_write32>:
    return count;
}


uint32 IfxAsclin_write32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80005104:	9f 04 04 80 	jned %d4,0,8000510c <IfxAsclin_write32+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
80005108:	82 02       	mov %d2,0
8000510a:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
8000510c:	4c 50       	ld.w %d15,[%a5]0
8000510e:	b0 45       	add.a %a5,4
80005110:	59 4f 04 10 	st.w [%a4]68,%d15
80005114:	3c f8       	j 80005104 <IfxAsclin_write32>

80005116 <IfxAsclin_write8>:
    return count;
}

#include <stdio.h>
uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80005116:	9f 04 04 80 	jned %d4,0,8000511e <IfxAsclin_write8+0x8>
        count--;

    }

    return count;
}
8000511a:	82 02       	mov %d2,0
8000511c:	00 90       	ret 
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {

        txData->U = *data++;
8000511e:	0c 50       	ld.bu %d15,[%a5]0
80005120:	b0 15       	add.a %a5,1
80005122:	59 4f 04 10 	st.w [%a4]68,%d15
80005126:	3c f8       	j 80005116 <IfxAsclin_write8>

80005128 <IfxAsclin_Asc_getReadCount>:
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80005128:	cc 42       	ld.a %a15,[%a4]8


sint32 IfxAsclin_Asc_getReadCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_readCount(asclin->rx);
}
8000512a:	88 22       	ld.h %d2,[%a15]4
8000512c:	00 90       	ret 

8000512e <IfxAsclin_Asc_getReadEvent>:


IfxStdIf_DPipe_ReadEvent IfxAsclin_Asc_getReadEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->rx->eventWriter;
8000512e:	99 42 08 00 	ld.a %a2,[%a4]8
}
80005132:	d9 22 1d 00 	lea %a2,[%a2]29
80005136:	00 90       	ret 

80005138 <IfxAsclin_Asc_getSendCount>:


uint32 IfxAsclin_Asc_getSendCount(IfxAsclin_Asc *asclin)
{
    return asclin->sendCount;
80005138:	19 42 10 00 	ld.w %d2,[%a4]16
}
8000513c:	00 90       	ret 

8000513e <IfxAsclin_Asc_getTxTimeStamp>:


Ifx_TickTime IfxAsclin_Asc_getTxTimeStamp(IfxAsclin_Asc *asclin)
{
    return asclin->txTimestamp;
8000513e:	09 42 54 09 	ld.d %e2,[%a4]20
}
80005142:	00 90       	ret 

80005144 <IfxAsclin_Asc_getWriteCount>:


sint32 IfxAsclin_Asc_getWriteCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_writeCount(asclin->tx);
80005144:	cc 41       	ld.a %a15,[%a4]4
 *
 * \return Returns the free size in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_writeCount(Ifx_Fifo *fifo)
{
    return (Ifx_SizeT)(fifo->size - Ifx_Fifo_readCount(fifo));
80005146:	88 c2       	ld.h %d2,[%a15]24
80005148:	8c f2       	ld.h %d15,[%a15]4
8000514a:	a2 f2       	sub %d2,%d15
}
8000514c:	37 02 50 20 	extr %d2,%d2,0,16
80005150:	00 90       	ret 

80005152 <IfxAsclin_Asc_getWriteEvent>:


IfxStdIf_DPipe_WriteEvent IfxAsclin_Asc_getWriteEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->tx->eventWriter;
80005152:	99 42 04 00 	ld.a %a2,[%a4]4
}
80005156:	d9 22 1d 00 	lea %a2,[%a2]29
8000515a:	00 90       	ret 

8000515c <IfxAsclin_Asc_isrError>:
}


void IfxAsclin_Asc_isrError(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin; /* getting the pointer to ASCLIN registers from module handler*/
8000515c:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE boolean IfxAsclin_getParityErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.PE;
8000515e:	4c fd       	ld.w %d15,[%a15]52

    /* store all the flags in the variable */
    if (IfxAsclin_getParityErrorFlagStatus(asclinSFR))
80005160:	ef 0f 0a 00 	jz.t %d15,16,80005174 <IfxAsclin_Asc_isrError+0x18>
}


IFX_INLINE void IfxAsclin_clearParityErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.PEC = 1;
80005164:	4c ff       	ld.w %d15,[%a15]60
80005166:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
8000516a:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearParityErrorFlag(asclinSFR);
        asclin->errorFlags.flags.parityError = 1;
8000516c:	0c 4e       	ld.bu %d15,[%a4]14
8000516e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
80005172:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getFrameErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.FE;
80005174:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR))
80005176:	ef 2f 0a 00 	jz.t %d15,18,8000518a <IfxAsclin_Asc_isrError+0x2e>
}


IFX_INLINE void IfxAsclin_clearFrameErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.FEC = 1;
8000517a:	4c ff       	ld.w %d15,[%a15]60
8000517c:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80005180:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlags.flags.frameError = 1;
80005182:	0c 4e       	ld.bu %d15,[%a4]14
80005184:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
80005188:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFO;
8000518a:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR))
8000518c:	ef af 0a 00 	jz.t %d15,26,800051a0 <IfxAsclin_Asc_isrError+0x44>
}


IFX_INLINE void IfxAsclin_clearRxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFOC = 1;
80005190:	4c ff       	ld.w %d15,[%a15]60
80005192:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80005196:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoOverflow = 1;
80005198:	0c 4e       	ld.bu %d15,[%a4]14
8000519a:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
8000519e:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoUnderflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFU;
800051a0:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoUnderflowFlagStatus(asclinSFR))
800051a2:	ef bf 0a 00 	jz.t %d15,27,800051b6 <IfxAsclin_Asc_isrError+0x5a>
}


IFX_INLINE void IfxAsclin_clearRxFifoUnderflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFUC = 1;
800051a6:	4c ff       	ld.w %d15,[%a15]60
800051a8:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
800051ac:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoUnderflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoUnderflow = 1;
800051ae:	0c 4e       	ld.bu %d15,[%a4]14
800051b0:	b7 1f 81 f1 	insert %d15,%d15,1,3,1
800051b4:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getTxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.TFO;
800051b6:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR))
800051b8:	ef ef 0a 00 	jz.t %d15,30,800051cc <IfxAsclin_Asc_isrError+0x70>
}


IFX_INLINE void IfxAsclin_clearTxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.TFOC = 1;
800051bc:	4c ff       	ld.w %d15,[%a15]60
800051be:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800051c2:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.txFifoOverflow = 1;
800051c4:	0c 4e       	ld.bu %d15,[%a4]14
800051c6:	b7 1f 01 f2 	insert %d15,%d15,1,4,1
800051ca:	2c 4e       	st.b [%a4]14,%d15
800051cc:	00 90       	ret 

800051ce <IfxAsclin_Asc_resetSendCount>:
}


void IfxAsclin_Asc_resetSendCount(IfxAsclin_Asc *asclin)
{
    asclin->sendCount = 0;
800051ce:	82 0f       	mov %d15,0
800051d0:	6c 44       	st.w [%a4]16,%d15
800051d2:	00 90       	ret 

800051d4 <IfxAsclin_Asc_canReadCount>:
}


boolean IfxAsclin_Asc_canReadCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canReadCount(asclin->rx, count, timeout);
800051d4:	99 44 08 00 	ld.a %a4,[%a4]8
800051d8:	1d 00 df 18 	j 80008396 <Ifx_Fifo_canReadCount>

800051dc <IfxAsclin_Asc_flushTx>:

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800051dc:	82 f2       	mov %d2,-1
800051de:	06 f2       	sh %d2,-1
800051e0:	ba f4       	eq %d15,%d4,-1
800051e2:	0b 52 00 f2 	and.eq %d15,%d2,%d5
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
}


boolean IfxAsclin_Asc_flushTx(IfxAsclin_Asc *asclin, Ifx_TickTime timeout)
{
800051e6:	40 4f       	mov.aa %a15,%a4
800051e8:	02 46       	mov %d6,%d4
    {
        deadLine = TIME_INFINITE;
800051ea:	82 f9       	mov %d9,-1
800051ec:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800051ee:	ee 16       	jnz %d15,8000521a <IfxAsclin_Asc_flushTx+0x3e>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800051f0:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800051f4:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800051f8:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800051fc:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800051fe:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005202:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005206:	02 39       	mov %d9,%d3
80005208:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000520c:	76 23       	jz %d2,80005212 <IfxAsclin_Asc_flushTx+0x36>
    {
        __enable();
8000520e:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80005212:	0b 69 40 90 	addx %d9,%d9,%d6
80005216:	0b 58 50 80 	addc %d8,%d8,%d5
 *
 * \return TRUE if the buffer is emptied.
 */
IFX_INLINE boolean Ifx_Fifo_flush(Ifx_Fifo *fifo, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(fifo, fifo->size, timeout);
8000521a:	c8 14       	ld.a %a4,[%a15]4
8000521c:	02 57       	mov %d7,%d5
8000521e:	c9 44 18 00 	ld.h %d4,[%a4]24
80005222:	6d 00 fd 19 	call 8000861c <Ifx_Fifo_canWriteCount>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80005226:	82 f4       	mov %d4,-1
80005228:	06 f4       	sh %d4,-1
    boolean      result;

    /* Flush the software FIFO */
    result = Ifx_Fifo_flush(asclin->tx, timeout);

    if (result)
8000522a:	f6 23       	jnz %d2,80005230 <IfxAsclin_Asc_flushTx+0x54>
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
    {
        deadLine = TIME_INFINITE;
8000522c:	82 02       	mov %d2,0
8000522e:	00 90       	ret 
    {
        /* Flush the hardware FIFO (wait until all bytes have been transmitted) */
        do
        {
            result = IfxAsclin_getTxFifoFillLevel(asclin->asclin) == 0;
80005230:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
80005232:	4c 23       	ld.w %d15,[%a2]12
80005234:	37 0f 65 f8 	extr.u %d15,%d15,16,5
        } while (!result && !IfxStm_isDeadLine(deadline));
80005238:	6e 1e       	jz %d15,80005274 <IfxAsclin_Asc_flushTx+0x98>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000523a:	ba f9       	eq %d15,%d9,-1
8000523c:	0b 84 00 f2 	and.eq %d15,%d4,%d8
80005240:	ee f9       	jnz %d15,80005232 <IfxAsclin_Asc_flushTx+0x56>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005242:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80005246:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000524a:	0d 00 40 03 	disable 
8000524e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005250:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005254:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80005258:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000525c:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005260:	76 23       	jz %d2,80005266 <IfxAsclin_Asc_flushTx+0x8a>
    {
        __enable();
80005262:	0d 00 00 03 	enable 
80005266:	0b 8f 00 21 	eq %d2,%d15,%d8
8000526a:	0b 93 30 22 	and.lt.u %d2,%d3,%d9
8000526e:	0b 8f 90 22 	or.lt %d2,%d15,%d8
80005272:	3c dc       	j 8000522a <IfxAsclin_Asc_flushTx+0x4e>
80005274:	82 12       	mov %d2,1
    }

    return result;
}
80005276:	00 90       	ret 

80005278 <IfxAsclin_Asc_canWriteCount>:
}


boolean IfxAsclin_Asc_canWriteCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(asclin->tx, count, timeout);
80005278:	99 44 04 00 	ld.a %a4,[%a4]4
8000527c:	1d 00 d0 19 	j 8000861c <Ifx_Fifo_canWriteCount>

80005280 <IfxAsclin_Asc_clearRx>:
}


void IfxAsclin_Asc_clearRx(IfxAsclin_Asc *asclin)
{
    IfxAsclin_flushRxFifo(asclin->asclin);
80005280:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
80005282:	4c f4       	ld.w %d15,[%a15]16
80005284:	96 01       	or %d15,1
80005286:	68 4f       	st.w [%a15]16,%d15
    Ifx_Fifo_clear(asclin->rx);
80005288:	99 44 08 00 	ld.a %a4,[%a4]8
8000528c:	1d 00 ad 19 	j 800085e6 <Ifx_Fifo_clear>

80005290 <IfxAsclin_Asc_clearTx>:
}


void IfxAsclin_Asc_clearTx(IfxAsclin_Asc *asclin)
{
80005290:	40 4f       	mov.aa %a15,%a4
    Ifx_Fifo_clear(asclin->tx);
80005292:	99 44 04 00 	ld.a %a4,[%a4]4
80005296:	6d 00 a8 19 	call 800085e6 <Ifx_Fifo_clear>
    IfxAsclin_flushTxFifo(asclin->asclin);
8000529a:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
8000529c:	4c f3       	ld.w %d15,[%a15]12
8000529e:	96 01       	or %d15,1
800052a0:	68 3f       	st.w [%a15]12,%d15
800052a2:	00 90       	ret 

800052a4 <IfxAsclin_Asc_read>:
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800052a4:	99 44 08 00 	ld.a %a4,[%a4]8
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800052a8:	0b 45 10 68 	mov %e6,%d5,%d4
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800052ac:	94 64       	ld.h %d4,[%a6]
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800052ae:	40 6f       	mov.aa %a15,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800052b0:	6d 00 e0 18 	call 80008470 <Ifx_Fifo_read>

    *count -= left;
800052b4:	8c f0       	ld.h %d15,[%a15]0
800052b6:	a2 2f       	sub %d15,%d2
800052b8:	a8 0f       	st.h [%a15]0,%d15

    return left == 0;
}
800052ba:	8b 02 00 22 	eq %d2,%d2,0
800052be:	00 90       	ret 

800052c0 <IfxAsclin_Asc_isrTransmit>:
    }
}

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
800052c0:	20 18       	sub.a %sp,24
800052c2:	40 4f       	mov.aa %a15,%a4
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800052c4:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
800052c8:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800052cc:	0d 00 40 03 	disable 
800052d0:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800052d2:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800052d6:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800052da:	02 52       	mov %d2,%d5
800052dc:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800052e0:	76 43       	jz %d4,800052e6 <IfxAsclin_Asc_isrTransmit+0x26>
    {
        __enable();
800052e2:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
800052e6:	89 f2 54 09 	st.d [%a15]20,%e2
    asclin->sendCount++;

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800052ea:	c8 14       	ld.a %a4,[%a15]4

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
    asclin->txTimestamp = IfxStm_now();
    asclin->sendCount++;
800052ec:	4c f4       	ld.w %d15,[%a15]16
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
800052ee:	c9 44 04 00 	ld.h %d4,[%a4]4
800052f2:	c2 1f       	add %d15,1
800052f4:	68 4f       	st.w [%a15]16,%d15

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800052f6:	df 04 32 00 	jeq %d4,0,8000535a <IfxAsclin_Asc_isrTransmit+0x9a>
    {

        switch (asclin->dataBufferMode)
800052fa:	0c ff       	ld.bu %d15,[%a15]15
800052fc:	6e 03       	jz %d15,80005302 <IfxAsclin_Asc_isrTransmit+0x42>
800052fe:	9e 1d       	jeq %d15,1,80005338 <IfxAsclin_Asc_isrTransmit+0x78>
80005300:	00 90       	ret 
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
80005302:	c8 02       	ld.a %a2,[%a15]0
        case Ifx_DataBufferMode_normal:
        {

            uint8          ascData[16];
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;
80005304:	2c a7       	st.b [%sp]7,%d15

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
80005306:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
8000530a:	4c 23       	ld.w %d15,[%a2]12
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
8000530c:	d2 06       	mov %e6,0
8000530e:	37 0f 65 f8 	extr.u %d15,%d15,16,5
80005312:	d9 a5 08 00 	lea %a5,[%sp]8
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
80005316:	2c a7       	st.b [%sp]7,%d15

            i_count          = (16 - hw_tx_fill_level);
80005318:	0c a7       	ld.bu %d15,[%sp]7
8000531a:	8b 0f 01 f1 	rsub %d15,%d15,16
8000531e:	37 0f 70 f0 	extr.u %d15,%d15,0,16
80005322:	0b 4f 90 f1 	min.u %d15,%d15,%d4
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
80005326:	37 0f 50 40 	extr %d4,%d15,0,16
8000532a:	6d 00 a3 18 	call 80008470 <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
8000532e:	c8 04       	ld.a %a4,[%a15]0
80005330:	d9 a5 08 00 	lea %a5,[%sp]8
80005334:	02 f4       	mov %d4,%d15
80005336:	3c 10       	j 80005356 <IfxAsclin_Asc_isrTransmit+0x96>
        {

            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80005338:	d2 06       	mov %e6,0
8000533a:	d9 a5 08 00 	lea %a5,[%sp]8
8000533e:	3b c0 00 40 	mov %d4,12
80005342:	6d 00 97 18 	call 80008470 <Ifx_Fifo_read>

            ascData = packedData.data;
80005346:	39 af 10 00 	ld.bu %d15,[%sp]16
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
8000534a:	c8 04       	ld.a %a4,[%a15]0
            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);

            ascData = packedData.data;
8000534c:	d9 a5 18 00 	lea %a5,[%sp]24
80005350:	89 5f 2f f4 	st.b [+%a5]-17,%d15
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80005354:	82 14       	mov %d4,1
        }
        break;
80005356:	1d ff e0 fe 	j 80005116 <IfxAsclin_write8>
    }
    else
    {

        /* Transmit buffer is empty */
        asclin->txInProgress = FALSE;
8000535a:	28 c4       	st.b [%a15]12,%d4
8000535c:	00 90       	ret 

8000535e <IfxAsclin_Asc_isrReceive>:

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
8000535e:	0c 4f       	ld.bu %d15,[%a4]15
    }
}


void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
80005360:	20 20       	sub.a %sp,32
80005362:	40 4f       	mov.aa %a15,%a4
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005364:	6e 34       	jz %d15,800053cc <IfxAsclin_Asc_isrReceive+0x6e>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
80005366:	82 18       	mov %d8,1

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005368:	df 1f 45 80 	jne %d15,1,800053f2 <IfxAsclin_Asc_isrReceive+0x94>
    }
    case Ifx_DataBufferMode_timeStampSingle:
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
8000536c:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getRxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->RXFIFOCON.B.FILL;
8000536e:	4c 24       	ld.w %d15,[%a2]16
80005370:	37 0f 65 f8 	extr.u %d15,%d15,16,5
80005374:	6e 2b       	jz %d15,800053ca <IfxAsclin_Asc_isrReceive+0x6c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005376:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
8000537a:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000537e:	0d 00 40 03 	disable 
80005382:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005384:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005388:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000538c:	8f 02 40 21 	or %d2,%d2,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005390:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005394:	76 33       	jz %d3,8000539a <IfxAsclin_Asc_isrReceive+0x3c>
    {
        __enable();
80005396:	0d 00 00 03 	enable 
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
8000539a:	c8 04       	ld.a %a4,[%a15]0
8000539c:	d9 a5 10 00 	lea %a5,[%sp]16
800053a0:	82 14       	mov %d4,1
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
800053a2:	78 02       	st.w [%sp]8,%d15
800053a4:	59 a2 04 00 	st.w [%sp]4,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
800053a8:	6d ff 7a fd 	call 80004e9c <IfxAsclin_read8>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800053ac:	c8 24       	ld.a %a4,[%a15]8

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
800053ae:	39 af 10 00 	ld.bu %d15,[%sp]16

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800053b2:	d2 06       	mov %e6,0
800053b4:	d9 a5 04 00 	lea %a5,[%sp]4
800053b8:	3b c0 00 40 	mov %d4,12

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
800053bc:	2c ac       	st.b [%sp]12,%d15

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800053be:	6d 00 a7 19 	call 8000870c <Ifx_Fifo_write>
800053c2:	df 02 d5 7f 	jeq %d2,0,8000536c <IfxAsclin_Asc_isrReceive+0xe>
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
800053c6:	28 d8       	st.b [%a15]13,%d8
800053c8:	3c d2       	j 8000536c <IfxAsclin_Asc_isrReceive+0xe>
800053ca:	00 90       	ret 
    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
    {
        uint8 count;
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
800053cc:	d4 44       	ld.a %a4,[%a4]
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
800053ce:	d9 a5 10 00 	lea %a5,[%sp]16
800053d2:	4c 44       	ld.w %d15,[%a4]16
800053d4:	37 0f 65 f8 	extr.u %d15,%d15,16,5
800053d8:	02 f4       	mov %d4,%d15
800053da:	6d ff 61 fd 	call 80004e9c <IfxAsclin_read8>

        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
800053de:	c8 24       	ld.a %a4,[%a15]8
800053e0:	d2 06       	mov %e6,0
800053e2:	d9 a5 10 00 	lea %a5,[%sp]16
800053e6:	02 f4       	mov %d4,%d15
800053e8:	6d 00 92 19 	call 8000870c <Ifx_Fifo_write>
800053ec:	76 23       	jz %d2,800053f2 <IfxAsclin_Asc_isrReceive+0x94>
        {
            /* Receive buffer is full, data is discard */
            asclin->rxSwFifoOverflow = TRUE;
800053ee:	82 1f       	mov %d15,1
800053f0:	28 df       	st.b [%a15]13,%d15
800053f2:	00 90       	ret 

800053f4 <IfxAsclin_Asc_blockingRead>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
800053f4:	20 08       	sub.a %sp,8
    Ifx_SizeT count = 1;
800053f6:	82 1f       	mov %d15,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
800053f8:	40 4f       	mov.aa %a15,%a4
    Ifx_SizeT count = 1;
800053fa:	ac a3       	st.h [%sp]6,%d15
    uint8     data;

    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
800053fc:	82 f4       	mov %d4,-1
800053fe:	40 f4       	mov.aa %a4,%a15
80005400:	d9 a5 05 00 	lea %a5,[%sp]5
80005404:	d9 a6 06 00 	lea %a6,[%sp]6
80005408:	9b 04 00 58 	addih %d5,%d4,32768
8000540c:	6d ff 4c ff 	call 800052a4 <IfxAsclin_Asc_read>
80005410:	df 12 f6 ff 	jne %d2,1,800053fc <IfxAsclin_Asc_blockingRead+0x8>
    {}

    return data;
}
80005414:	39 a2 05 00 	ld.bu %d2,[%sp]5
80005418:	00 90       	ret 

8000541a <IfxAsclin_Asc_disableModule>:
}


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
8000541a:	cc 40       	ld.a %a15,[%a4]0
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
8000541c:	6d 00 c5 0f 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
80005420:	02 24       	mov %d4,%d2


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
80005422:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
80005424:	6d 00 c1 0e 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80005428:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclinSFR); /* disabling the module */
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
8000542a:	02 f4       	mov %d4,%d15
8000542c:	8f 12 40 21 	or %d2,%d2,1
80005430:	68 02       	st.w [%a15]0,%d2
80005432:	1d 00 ef 0f 	j 80007410 <IfxScuWdt_setCpuEndinit>

80005436 <IfxAsclin_Asc_initModule>:
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
80005436:	cc 50       	ld.a %a15,[%a5]0
    return &asclin->tx->eventWriter;
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
80005438:	40 4e       	mov.aa %a14,%a4
8000543a:	40 5c       	mov.aa %a12,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
    IfxAsclin_Status status    = IfxAsclin_Status_noError;

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
8000543c:	ec 40       	st.a [%a4]0,%a15

    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
8000543e:	40 f4       	mov.aa %a4,%a15
80005440:	6d ff 71 fc 	call 80004d22 <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
80005444:	40 f4       	mov.aa %a4,%a15
80005446:	82 04       	mov %d4,0
80005448:	6d ff 59 fd 	call 80004efa <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
8000544c:	4c f6       	ld.w %d15,[%a15]24
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
8000544e:	40 f4       	mov.aa %a4,%a15
80005450:	b7 0f 02 f8 	insert %d15,%d15,0,16,2
80005454:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80005456:	8c c4       	ld.h %d15,[%a12]8
80005458:	48 52       	ld.w %d2,[%a15]20
8000545a:	c2 ff       	add %d15,-1
8000545c:	37 f2 0c f0 	insert %d15,%d2,%d15,0,12
80005460:	68 5f       	st.w [%a15]20,%d15
80005462:	39 c4 28 00 	ld.bu %d4,[%a12]40
80005466:	6d ff 4a fd 	call 80004efa <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
8000546a:	40 f4       	mov.aa %a4,%a15
8000546c:	19 c4 04 00 	ld.w %d4,[%a12]4
80005470:	39 c5 0a 00 	ld.bu %d5,[%a12]10
80005474:	39 c6 0d 00 	ld.bu %d6,[%a12]13
80005478:	39 c7 0c 00 	ld.bu %d7,[%a12]12
8000547c:	6d ff 79 fd 	call 80004f6e <IfxAsclin_setBitTiming>
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80005480:	40 f4       	mov.aa %a4,%a15
80005482:	82 04       	mov %d4,0
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80005484:	02 29       	mov %d9,%d2
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80005486:	6d ff 3a fd 	call 80004efa <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_enableLoopBackMode(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.LB = enable ? 1 : 0;
8000548a:	39 c2 38 00 	ld.bu %d2,[%a12]56
8000548e:	7b 00 00 f1 	movh %d15,4096
80005492:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80005496:	4c f1       	ld.w %d15,[%a15]4
80005498:	b7 0f 01 fe 	insert %d15,%d15,0,28,1
8000549c:	a6 2f       	or %d15,%d2
8000549e:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxAsclin_enableParity(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
800054a0:	39 c2 14 00 	ld.bu %d2,[%a12]20
800054a4:	7b 00 00 f4 	movh %d15,16384
800054a8:	ab 0f 80 22 	sel %d2,%d2,%d15,0
800054ac:	4c f6       	ld.w %d15,[%a15]24
800054ae:	b7 0f 01 ff 	insert %d15,%d15,0,30,1
800054b2:	a6 2f       	or %d15,%d2
800054b4:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setParityType(Ifx_ASCLIN *asclin, IfxAsclin_ParityType type)
{
    asclin->FRAMECON.B.ODD = type;
800054b6:	48 62       	ld.w %d2,[%a15]24
800054b8:	39 cf 12 00 	ld.bu %d15,[%a12]18
800054bc:	37 f2 81 ff 	insert %d15,%d2,%d15,31,1
800054c0:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
800054c2:	48 62       	ld.w %d2,[%a15]24
800054c4:	0c cf       	ld.bu %d15,[%a12]15
800054c6:	37 f2 83 f4 	insert %d15,%d2,%d15,9,3
800054ca:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setShiftDirection(Ifx_ASCLIN *asclin, IfxAsclin_ShiftDirection dir)
{
    asclin->FRAMECON.B.MSB = dir;
800054cc:	48 62       	ld.w %d2,[%a15]24
800054ce:	39 cf 11 00 	ld.bu %d15,[%a12]17
800054d2:	67 f2 1c f0 	ins.t %d15,%d2,28,%d15,0
800054d6:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setDataLength(Ifx_ASCLIN *asclin, IfxAsclin_DataLength length)
{
    asclin->DATCON.B.DATLEN = length;
800054d8:	48 72       	ld.w %d2,[%a15]28
800054da:	39 cf 13 00 	ld.bu %d15,[%a12]19
800054de:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
800054e2:	68 7f       	st.w [%a15]28,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
800054e4:	48 32       	ld.w %d2,[%a15]12
800054e6:	39 cf 16 00 	ld.bu %d15,[%a12]22
800054ea:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
800054ee:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_setRxFifoOutletWidth(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoOutletWidth width)
{
    asclin->RXFIFOCON.B.OUTW = width;
800054f0:	48 42       	ld.w %d2,[%a15]16
800054f2:	39 cf 17 00 	ld.bu %d15,[%a12]23
800054f6:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
800054fa:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setIdleDelay(Ifx_ASCLIN *asclin, IfxAsclin_IdleDelay delay)
{
    asclin->FRAMECON.B.IDLE = delay;
800054fc:	48 62       	ld.w %d2,[%a15]24
800054fe:	0c ce       	ld.bu %d15,[%a12]14
80005500:	37 f2 03 f3 	insert %d15,%d2,%d15,6,3
80005504:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
80005506:	39 c2 18 00 	ld.bu %d2,[%a12]24
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000550a:	da 0f       	mov %d15,15
8000550c:	0b f2 90 21 	min.u %d2,%d2,%d15
80005510:	48 33       	ld.w %d3,[%a15]12
80005512:	37 23 04 24 	insert %d2,%d3,%d2,8,4
80005516:	68 32       	st.w [%a15]12,%d2
}


IFX_INLINE void IfxAsclin_setRxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoInterruptLevel level)
{
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
80005518:	39 c2 19 00 	ld.bu %d2,[%a12]25
8000551c:	0b f2 90 f1 	min.u %d15,%d2,%d15
80005520:	48 42       	ld.w %d2,[%a15]16
80005522:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
80005526:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005528:	39 cf 10 00 	ld.bu %d15,[%a12]16
8000552c:	48 62       	ld.w %d2,[%a15]24
8000552e:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
80005532:	68 6f       	st.w [%a15]24,%d15
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/

    /* Pin mapping */
    const IfxAsclin_Asc_Pins *pins = config->pins;
80005534:	99 cd 24 00 	ld.a %a13,[%a12]36

    if (pins != NULL_PTR)
80005538:	bd 0d 81 00 	jz.a %a13,8000563a <IfxAsclin_Asc_initModule+0x204>
    {
        IfxAsclin_Cts_In *cts = pins->cts;
8000553c:	4c d0       	ld.w %d15,[%a13]0

        if (cts != NULL_PTR)
8000553e:	6e 27       	jz %d15,8000558c <IfxAsclin_Asc_initModule+0x156>
}


IFX_INLINE void IfxAsclin_initCtsPin(const IfxAsclin_Cts_In *cts, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (cts->pin.port != NULL_PTR)
80005540:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
80005542:	79 d5 04 00 	ld.b %d5,[%a13]4
80005546:	99 24 04 00 	ld.a %a4,[%a2]4
8000554a:	39 d8 1d 00 	ld.bu %d8,[%a13]29
8000554e:	bd 04 1f 00 	jz.a %a4,8000558c <IfxAsclin_Asc_initModule+0x156>
80005552:	39 24 08 00 	ld.bu %d4,[%a2]8
80005556:	8f f5 0f 51 	and %d5,%d5,255
8000555a:	6d 00 ba 03 	call 80005cce <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
8000555e:	60 f3       	mov.a %a3,%d15
80005560:	02 85       	mov %d5,%d8
80005562:	99 34 04 00 	ld.a %a4,[%a3]4
80005566:	39 34 08 00 	ld.bu %d4,[%a3]8
8000556a:	6d 00 30 04 	call 80005dca <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
8000556e:	60 f3       	mov.a %a3,%d15
80005570:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_enableCts(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
80005572:	19 22 04 00 	ld.w %d2,[%a2]4
80005576:	b7 f2 81 2e 	insert %d2,%d2,15,29,1
8000557a:	59 22 04 00 	st.w [%a2]4,%d2
    if (cts->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
        IfxAsclin_enableCts(cts->module, TRUE);
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
8000557e:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setCtsInput(Ifx_ASCLIN *asclin, IfxAsclin_CtsInputSelect ctsi)
{
    asclin->IOCR.B.CTS = ctsi;
80005580:	0c 3c       	ld.bu %d15,[%a3]12
80005582:	19 22 04 00 	ld.w %d2,[%a2]4
80005586:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
8000558a:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rx_In *rx = pins->rx;
8000558c:	4c d2       	ld.w %d15,[%a13]8

        if (rx != NULL_PTR)
8000558e:	6e 20       	jz %d15,800055ce <IfxAsclin_Asc_initModule+0x198>
}


IFX_INLINE void IfxAsclin_initRxPin(const IfxAsclin_Rx_In *rx, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (rx->pin.port != NULL_PTR)
80005590:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
80005592:	79 d5 0c 00 	ld.b %d5,[%a13]12
80005596:	99 24 04 00 	ld.a %a4,[%a2]4
8000559a:	39 d8 1d 00 	ld.bu %d8,[%a13]29
8000559e:	bd 04 18 00 	jz.a %a4,800055ce <IfxAsclin_Asc_initModule+0x198>
800055a2:	39 24 08 00 	ld.bu %d4,[%a2]8
800055a6:	8f f5 0f 51 	and %d5,%d5,255
800055aa:	6d 00 92 03 	call 80005cce <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(rx->pin.port, rx->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
800055ae:	60 f3       	mov.a %a3,%d15
800055b0:	02 85       	mov %d5,%d8
800055b2:	99 34 04 00 	ld.a %a4,[%a3]4
800055b6:	39 34 08 00 	ld.bu %d4,[%a3]8
800055ba:	6d 00 08 04 	call 80005dca <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
800055be:	60 f3       	mov.a %a3,%d15
800055c0:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setRxInput(Ifx_ASCLIN *asclin, IfxAsclin_RxInputSelect alti)
{
    asclin->IOCR.B.ALTI = alti;
800055c2:	0c 3c       	ld.bu %d15,[%a3]12
800055c4:	19 22 04 00 	ld.w %d2,[%a2]4
800055c8:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3
800055cc:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rts_Out *rts = pins->rts;
800055ce:	4c d4       	ld.w %d15,[%a13]16

        if (rts != NULL_PTR)
800055d0:	6e 1a       	jz %d15,80005604 <IfxAsclin_Asc_initModule+0x1ce>
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800055d2:	60 f2       	mov.a %a2,%d15
800055d4:	39 d2 14 00 	ld.bu %d2,[%a13]20
800055d8:	39 23 0c 00 	ld.bu %d3,[%a2]12
800055dc:	99 24 04 00 	ld.a %a4,[%a2]4
800055e0:	0f 23 a0 50 	or %d5,%d3,%d2
800055e4:	39 24 08 00 	ld.bu %d4,[%a2]8
800055e8:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
800055ec:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800055f0:	6d 00 6f 03 	call 80005cce <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initRtsPin(const IfxAsclin_Rts_Out *rts, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
800055f4:	60 f3       	mov.a %a3,%d15
800055f6:	02 85       	mov %d5,%d8
800055f8:	99 34 04 00 	ld.a %a4,[%a3]4
800055fc:	39 34 08 00 	ld.bu %d4,[%a3]8
80005600:	6d 00 e5 03 	call 80005dca <IfxPort_setPinPadDriver>
        }

        IfxAsclin_Tx_Out *tx = pins->tx;
80005604:	4c d6       	ld.w %d15,[%a13]24

        if (tx != NULL_PTR)
80005606:	6e 1a       	jz %d15,8000563a <IfxAsclin_Asc_initModule+0x204>
80005608:	60 f2       	mov.a %a2,%d15
8000560a:	39 d2 1c 00 	ld.bu %d2,[%a13]28
8000560e:	39 23 0c 00 	ld.bu %d3,[%a2]12
80005612:	99 24 04 00 	ld.a %a4,[%a2]4
80005616:	0f 23 a0 50 	or %d5,%d3,%d2
8000561a:	39 24 08 00 	ld.bu %d4,[%a2]8
8000561e:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
80005622:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005626:	6d 00 54 03 	call 80005cce <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initTxPin(const IfxAsclin_Tx_Out *tx, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
8000562a:	60 f3       	mov.a %a3,%d15
8000562c:	02 85       	mov %d5,%d8
8000562e:	99 34 04 00 	ld.a %a4,[%a3]4
80005632:	39 34 08 00 	ld.bu %d4,[%a3]8
80005636:	6d 00 ca 03 	call 80005dca <IfxPort_setPinPadDriver>
        }
    }

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
8000563a:	40 f4       	mov.aa %a4,%a15
8000563c:	39 c4 28 00 	ld.bu %d4,[%a12]40
80005640:	6d ff 5d fc 	call 80004efa <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_disableAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSENABLE.U = 0x00000000;
80005644:	82 0f       	mov %d15,0
80005646:	59 ff 00 10 	st.w [%a15]64,%d15
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAsclin_clearAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
8000564a:	82 f2       	mov %d2,-1
8000564c:	68 f2       	st.w [%a15]60,%d2

    IfxAsclin_disableAllFlags(asclinSFR);                     /* disable all flags */
    IfxAsclin_clearAllFlags(asclinSFR);                       /* clear all flags */

    /* HW error flags */
    asclin->errorFlags.ALL = 0;
8000564e:	2c ee       	st.b [%a14]14,%d15

    if (config->errorFlags.flags.parityError)
80005650:	4c ca       	ld.w %d15,[%a12]40
80005652:	2e 87       	jz.t %d15,8,80005660 <IfxAsclin_Asc_initModule+0x22a>
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80005654:	19 ff 00 10 	ld.w %d15,[%a15]64
80005658:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
8000565c:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableParityErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.frameError)
80005660:	4c ca       	ld.w %d15,[%a12]40
80005662:	2e 97       	jz.t %d15,9,80005670 <IfxAsclin_Asc_initModule+0x23a>
}


IFX_INLINE void IfxAsclin_enableFrameErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
80005664:	19 ff 00 10 	ld.w %d15,[%a15]64
80005668:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
8000566c:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableFrameErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoOverflow)
80005670:	4c ca       	ld.w %d15,[%a12]40
80005672:	2e a7       	jz.t %d15,10,80005680 <IfxAsclin_Asc_initModule+0x24a>
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80005674:	19 ff 00 10 	ld.w %d15,[%a15]64
80005678:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
8000567c:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoOverflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoUnderflow)
80005680:	4c ca       	ld.w %d15,[%a12]40
80005682:	2e b7       	jz.t %d15,11,80005690 <IfxAsclin_Asc_initModule+0x25a>
}


IFX_INLINE void IfxAsclin_enableRxFifoUnderflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
80005684:	19 ff 00 10 	ld.w %d15,[%a15]64
80005688:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
8000568c:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoUnderflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.txFifoOverflow)
80005690:	4c ca       	ld.w %d15,[%a12]40
80005692:	2e c7       	jz.t %d15,12,800056a0 <IfxAsclin_Asc_initModule+0x26a>
}


IFX_INLINE void IfxAsclin_enableTxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
80005694:	19 ff 00 10 	ld.w %d15,[%a15]64
80005698:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000569c:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableTxFifoOverflowFlag(asclinSFR, TRUE);
    }

    /* transmission flags */
    asclin->rxSwFifoOverflow = FALSE;
800056a0:	82 0f       	mov %d15,0
800056a2:	2c ed       	st.b [%a14]13,%d15
    asclin->txInProgress     = FALSE;
800056a4:	2c ec       	st.b [%a14]12,%d15

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
800056a6:	d2 04       	mov %e4,0
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800056a8:	39 c3 39 00 	ld.bu %d3,[%a12]57
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;
800056ac:	82 0f       	mov %d15,0
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
800056ae:	89 e4 54 09 	st.d [%a14]20,%e4
    asclin->sendCount      = 0;
800056b2:	6c e4       	st.w [%a14]16,%d15
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800056b4:	e9 e3 0f 00 	st.b [%a14]15,%d3
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
        elementSize = 1;
800056b8:	82 1f       	mov %d15,1
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
800056ba:	76 34       	jz %d3,800056c2 <IfxAsclin_Asc_initModule+0x28c>
        break;
    case Ifx_DataBufferMode_timeStampSingle:
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
        break;
    default:
        elementSize = 0;
800056bc:	ba 13       	eq %d15,%d3,1
800056be:	ab cf a0 ff 	seln %d15,%d15,%d15,12
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
800056c2:	99 c4 2c 00 	ld.a %a4,[%a12]44
800056c6:	c9 c4 2a 00 	ld.h %d4,[%a12]42
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
800056ca:	02 f5       	mov %d5,%d15
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
800056cc:	bc 44       	jz.a %a4,800056d4 <IfxAsclin_Asc_initModule+0x29e>
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
800056ce:	6d 00 36 16 	call 8000833a <Ifx_Fifo_init>
800056d2:	3c 03       	j 800056d8 <IfxAsclin_Asc_initModule+0x2a2>
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800056d4:	6d 00 50 16 	call 80008374 <Ifx_Fifo_create>
    }

    if (config->rxBuffer != NULL_PTR)
800056d8:	99 c4 34 00 	ld.a %a4,[%a12]52
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800056dc:	b5 e2 04 00 	st.a [%a14]4,%a2
800056e0:	c9 c4 30 00 	ld.h %d4,[%a12]48
    }

    if (config->rxBuffer != NULL_PTR)
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
800056e4:	02 f5       	mov %d5,%d15
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
    }

    if (config->rxBuffer != NULL_PTR)
800056e6:	bc 44       	jz.a %a4,800056ee <IfxAsclin_Asc_initModule+0x2b8>
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
800056e8:	6d 00 29 16 	call 8000833a <Ifx_Fifo_init>
800056ec:	3c 03       	j 800056f2 <IfxAsclin_Asc_initModule+0x2bc>
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
800056ee:	6d 00 43 16 	call 80008374 <Ifx_Fifo_create>
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;
800056f2:	39 cf 22 00 	ld.bu %d15,[%a12]34

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
800056f6:	b9 c2 1e 00 	ld.hu %d2,[%a12]30
800056fa:	8b 3f 00 82 	eq %d8,%d15,3
800056fe:	02 83       	mov %d3,%d8
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80005700:	b5 e2 08 00 	st.a [%a14]8,%a2
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
80005704:	8b 02 00 35 	or.ne %d3,%d2,0
80005708:	df 03 1e 00 	jeq %d3,0,80005744 <IfxAsclin_Asc_initModule+0x30e>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
8000570c:	40 f4       	mov.aa %a4,%a15
8000570e:	6d ff a1 fb 	call 80004e50 <IfxAsclin_getSrcPointerRx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80005712:	54 22       	ld.w %d2,[%a2]
80005714:	39 c3 1e 00 	ld.bu %d3,[%a12]30
80005718:	8f f2 cf 21 	andn %d2,%d2,255
8000571c:	a6 32       	or %d2,%d3
8000571e:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80005720:	54 22       	ld.w %d2,[%a2]
80005722:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
80005726:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005728:	54 22       	ld.w %d2,[%a2]
8000572a:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
8000572e:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableRxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
80005730:	19 f2 00 10 	ld.w %d2,[%a15]64
80005734:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
80005738:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
8000573c:	54 22       	ld.w %d2,[%a2]
8000573e:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80005742:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.rxPriority);
        IfxAsclin_enableRxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
80005744:	b9 c2 1c 00 	ld.hu %d2,[%a12]28
80005748:	8b 02 00 85 	or.ne %d8,%d2,0
8000574c:	df 08 1e 00 	jeq %d8,0,80005788 <IfxAsclin_Asc_initModule+0x352>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
80005750:	40 f4       	mov.aa %a4,%a15
80005752:	6d ff 89 fb 	call 80004e64 <IfxAsclin_getSrcPointerTx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80005756:	54 22       	ld.w %d2,[%a2]
80005758:	39 c3 1c 00 	ld.bu %d3,[%a12]28
8000575c:	8f f2 cf 21 	andn %d2,%d2,255
80005760:	a6 32       	or %d2,%d3
80005762:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80005764:	54 22       	ld.w %d2,[%a2]
80005766:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
8000576a:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
8000576c:	54 22       	ld.w %d2,[%a2]
8000576e:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
80005772:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableTxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
80005774:	19 f2 00 10 	ld.w %d2,[%a15]64
80005778:	b7 f2 81 2f 	insert %d2,%d2,15,31,1
8000577c:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005780:	54 22       	ld.w %d2,[%a2]
80005782:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80005786:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.txPriority);
        IfxAsclin_enableTxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
80005788:	b9 c2 20 00 	ld.hu %d2,[%a12]32
8000578c:	df 02 1e 00 	jeq %d2,0,800057c8 <IfxAsclin_Asc_initModule+0x392>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
80005790:	40 f4       	mov.aa %a4,%a15
80005792:	6d ff 55 fb 	call 80004e3c <IfxAsclin_getSrcPointerEr>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80005796:	54 22       	ld.w %d2,[%a2]
80005798:	39 c3 20 00 	ld.bu %d3,[%a12]32
8000579c:	8f f2 cf 21 	andn %d2,%d2,255
800057a0:	a6 32       	or %d2,%d3
800057a2:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800057a4:	54 22       	ld.w %d2,[%a2]
800057a6:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
800057aa:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800057ac:	4c 20       	ld.w %d15,[%a2]0
800057ae:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
800057b2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
800057b4:	19 ff 00 10 	ld.w %d15,[%a15]64
800057b8:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800057bc:	59 ff 00 10 	st.w [%a15]64,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800057c0:	4c 20       	ld.w %d15,[%a2]0
800057c2:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800057c6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableRxFifoInlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
800057c8:	4c f4       	ld.w %d15,[%a15]16

    IfxAsclin_flushRxFifo(asclinSFR);              // flushing Rx FIFO
    IfxAsclin_flushTxFifo(asclinSFR);              // flushing Tx FIFO

    return status;
}
800057ca:	02 92       	mov %d2,%d9
800057cc:	96 02       	or %d15,2
800057ce:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_enableTxFifoOutlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
800057d0:	4c f3       	ld.w %d15,[%a15]12
800057d2:	96 02       	or %d15,2
800057d4:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
800057d6:	4c f4       	ld.w %d15,[%a15]16
800057d8:	96 01       	or %d15,1
800057da:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
800057dc:	4c f3       	ld.w %d15,[%a15]12
800057de:	96 01       	or %d15,1
800057e0:	68 3f       	st.w [%a15]12,%d15
800057e2:	00 90       	ret 

800057e4 <IfxAsclin_Asc_initModuleConfig>:

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
800057e4:	82 12       	mov %d2,1
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
800057e6:	7b 10 7e 34 	movh %d3,18401

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
800057ea:	e9 42 28 00 	st.b [%a4]40,%d2
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
800057ee:	82 12       	mov %d2,1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
800057f0:	82 0f       	mov %d15,0

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
800057f2:	f9 42 08 00 	st.h [%a4]8,%d2
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
800057f6:	59 43 04 00 	st.w [%a4]4,%d3
    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
800057fa:	e9 42 0f 00 	st.b [%a4]15,%d2

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
800057fe:	82 33       	mov %d3,3
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
80005800:	e9 42 10 00 	st.b [%a4]16,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
80005804:	e9 42 16 00 	st.b [%a4]22,%d2
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
80005808:	e9 42 17 00 	st.b [%a4]23,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
8000580c:	82 f2       	mov %d2,-1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
8000580e:	e9 4f 38 00 	st.b [%a4]56,%d15

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80005812:	e9 43 0a 00 	st.b [%a4]10,%d3

    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
80005816:	2c 4c       	st.b [%a4]12,%d15
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
80005818:	e9 43 0d 00 	st.b [%a4]13,%d3
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
8000581c:	2c 4e       	st.b [%a4]14,%d15
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
8000581e:	e9 4f 11 00 	st.b [%a4]17,%d15
    config->frame.parityBit               = FALSE;                             /* disable parity*/
80005822:	e9 4f 14 00 	st.b [%a4]20,%d15
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
80005826:	e9 4f 12 00 	st.b [%a4]18,%d15
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
8000582a:	82 73       	mov %d3,7

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
8000582c:	e9 4f 18 00 	st.b [%a4]24,%d15
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
80005830:	e9 4f 19 00 	st.b [%a4]25,%d15
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
80005834:	e9 4f 1a 00 	st.b [%a4]26,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
80005838:	e9 42 29 00 	st.b [%a4]41,%d2
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
8000583c:	82 0f       	mov %d15,0

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
8000583e:	82 02       	mov %d2,0
}


void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;
80005840:	f4 45       	st.a [%a4],%a5
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
80005842:	e9 43 13 00 	st.b [%a4]19,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
80005846:	ac 4f       	st.h [%a4]30,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
80005848:	ac 4e       	st.h [%a4]28,%d15
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
8000584a:	f9 4f 20 00 	st.h [%a4]32,%d15
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
8000584e:	e9 4f 22 00 	st.b [%a4]34,%d15

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
80005852:	59 42 24 00 	st.w [%a4]36,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
80005856:	59 42 34 00 	st.w [%a4]52,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
8000585a:	59 42 2c 00 	st.w [%a4]44,%d2

    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
8000585e:	f9 42 2a 00 	st.h [%a4]42,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
80005862:	f9 42 30 00 	st.h [%a4]48,%d2

    config->dataBufferMode = Ifx_DataBufferMode_normal;
80005866:	e9 4f 39 00 	st.b [%a4]57,%d15
8000586a:	00 90       	ret 

8000586c <IfxAsclin_Asc_initiateTransmission>:
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
8000586c:	0c 4c       	ld.bu %d15,[%a4]12
    config->dataBufferMode = Ifx_DataBufferMode_normal;
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
8000586e:	20 10       	sub.a %sp,16
80005870:	40 4f       	mov.aa %a15,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
80005872:	ee 20       	jnz %d15,800058b2 <IfxAsclin_Asc_initiateTransmission+0x46>
    {

        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
80005874:	99 44 04 00 	ld.a %a4,[%a4]4
80005878:	8c 42       	ld.h %d15,[%a4]4
8000587a:	6e 1c       	jz %d15,800058b2 <IfxAsclin_Asc_initiateTransmission+0x46>
        {
            uint8 data;

            asclin->txInProgress = TRUE;
8000587c:	82 1f       	mov %d15,1
8000587e:	28 cf       	st.b [%a15]12,%d15

            switch (asclin->dataBufferMode)
80005880:	0c ff       	ld.bu %d15,[%a15]15
80005882:	6e 0c       	jz %d15,8000589a <IfxAsclin_Asc_initiateTransmission+0x2e>
80005884:	de 11       	jne %d15,1,800058a6 <IfxAsclin_Asc_initiateTransmission+0x3a>
            break;
            case Ifx_DataBufferMode_timeStampSingle:
            {

                Ifx_DataBufferMode_TimeStampSingle packedData;
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80005886:	d2 06       	mov %e6,0
80005888:	d9 a5 04 00 	lea %a5,[%sp]4
8000588c:	3b c0 00 40 	mov %d4,12
80005890:	6d 00 f0 15 	call 80008470 <Ifx_Fifo_read>
                data = packedData.data;
80005894:	0c ac       	ld.bu %d15,[%sp]12
80005896:	2c a3       	st.b [%sp]3,%d15
80005898:	3c 07       	j 800058a6 <IfxAsclin_Asc_initiateTransmission+0x3a>
            switch (asclin->dataBufferMode)
            {
            case Ifx_DataBufferMode_normal: // here
            {

                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
8000589a:	d2 06       	mov %e6,0
8000589c:	d9 a5 03 00 	lea %a5,[%sp]3
800058a0:	82 14       	mov %d4,1
800058a2:	6d 00 e7 15 	call 80008470 <Ifx_Fifo_read>
                data = packedData.data;
            }
            break;
            }

            IfxAsclin_write8(asclin->asclin, &data, 1);
800058a6:	c8 04       	ld.a %a4,[%a15]0
800058a8:	d9 a5 03 00 	lea %a5,[%sp]3
800058ac:	82 14       	mov %d4,1
800058ae:	6d ff 34 fc 	call 80005116 <IfxAsclin_write8>
800058b2:	00 90       	ret 

800058b4 <IfxAsclin_Asc_write>:
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800058b4:	40 4f       	mov.aa %a15,%a4

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
800058b6:	0c 4c       	ld.bu %d15,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800058b8:	99 44 04 00 	ld.a %a4,[%a4]4

    if (*count != 0)
800058bc:	94 63       	ld.h %d3,[%a6]
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800058be:	0b 45 10 88 	mov %e8,%d5,%d4
800058c2:	40 5d       	mov.aa %a13,%a5

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800058c4:	c9 44 18 00 	ld.h %d4,[%a4]24
#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
800058c8:	82 12       	mov %d2,1
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;

    if (*count != 0)
800058ca:	df 03 25 00 	jeq %d3,0,80005914 <IfxAsclin_Asc_write+0x60>
800058ce:	40 6c       	mov.aa %a12,%a6
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
800058d0:	ee 13       	jnz %d15,800058f6 <IfxAsclin_Asc_write+0x42>
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800058d2:	37 04 70 f0 	extr.u %d15,%d4,0,16

    if (*count != 0)
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
800058d6:	7f 3f 10 00 	jge %d15,%d3,800058f6 <IfxAsclin_Asc_write+0x42>
        {


            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
800058da:	0b 89 10 68 	mov %e6,%d9,%d8
800058de:	6d 00 17 17 	call 8000870c <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
800058e2:	40 f4       	mov.aa %a4,%a15
800058e4:	6d ff c4 ff 	call 8000586c <IfxAsclin_Asc_initiateTransmission>

            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
800058e8:	94 c4       	ld.h %d4,[%a12]
800058ea:	c8 14       	ld.a %a4,[%a15]4
800058ec:	a2 f4       	sub %d4,%d15
800058ee:	10 d5       	addsc.a %a5,%a13,%d15,0
800058f0:	37 04 50 40 	extr %d4,%d4,0,16
800058f4:	3c 03       	j 800058fa <IfxAsclin_Asc_write+0x46>

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
800058f6:	40 d5       	mov.aa %a5,%a13
800058f8:	02 34       	mov %d4,%d3
800058fa:	0b 89 10 68 	mov %e6,%d9,%d8
800058fe:	6d 00 07 17 	call 8000870c <Ifx_Fifo_write>

            IfxAsclin_Asc_initiateTransmission(asclin);
80005902:	40 f4       	mov.aa %a4,%a15

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
80005904:	02 2f       	mov %d15,%d2

            IfxAsclin_Asc_initiateTransmission(asclin);
80005906:	6d ff b3 ff 	call 8000586c <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
8000590a:	94 c2       	ld.h %d2,[%a12]
8000590c:	a2 f2       	sub %d2,%d15
8000590e:	b4 c2       	st.h [%a12],%d2
        result  = left == 0;
80005910:	8b 0f 00 22 	eq %d2,%d15,0

    }

    return result;
}
80005914:	00 90       	ret 

80005916 <IfxAsclin_Asc_blockingWrite>:
    return data;
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
80005916:	20 10       	sub.a %sp,16
80005918:	e9 a4 07 00 	st.b [%sp]7,%d4
    Ifx_SizeT count = 1;

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
8000591c:	82 f4       	mov %d4,-1
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
8000591e:	82 1f       	mov %d15,1

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
80005920:	d9 a5 07 00 	lea %a5,[%sp]7
80005924:	d9 a6 0e 00 	lea %a6,[%sp]14
80005928:	9b 04 00 58 	addih %d5,%d4,32768
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
8000592c:	ac a7       	st.h [%sp]14,%d15

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
}
8000592e:	1d ff c3 ff 	j 800058b4 <IfxAsclin_Asc_write>

80005932 <IfxAsclin_Asc_stdIfDPipeInit>:


boolean IfxAsclin_Asc_stdIfDPipeInit(IfxStdIf_DPipe *stdif, IfxAsclin_Asc *asclin)
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));
80005932:	40 42       	mov.aa %a2,%a4
80005934:	82 0f       	mov %d15,0
80005936:	c5 0f 0b 10 	lea %a15,4b <_.+0x4a>
8000593a:	24 2f       	st.b [%a2+],%d15
8000593c:	fc ff       	loop %a15,8000593a <IfxAsclin_Asc_stdIfDPipeInit+0x8>

    /* Set the API link */
    stdif->driver         = asclin;
    stdif->write          = (IfxStdIf_DPipe_Write) & IfxAsclin_Asc_write;
8000593e:	7b 00 00 f8 	movh %d15,32768
80005942:	1b 4f 8b f5 	addi %d15,%d15,22708
80005946:	6c 42       	st.w [%a4]8,%d15
    stdif->read           = (IfxStdIf_DPipe_Read) & IfxAsclin_Asc_read;
80005948:	7b 00 00 f8 	movh %d15,32768
8000594c:	1b 4f 2a f5 	addi %d15,%d15,21156
80005950:	6c 43       	st.w [%a4]12,%d15
    stdif->getReadCount   = (IfxStdIf_DPipe_GetReadCount) & IfxAsclin_Asc_getReadCount;
80005952:	7b 00 00 f8 	movh %d15,32768
80005956:	1b 8f 12 f5 	addi %d15,%d15,20776
8000595a:	6c 44       	st.w [%a4]16,%d15
    stdif->getReadEvent   = (IfxStdIf_DPipe_GetReadEvent) & IfxAsclin_Asc_getReadEvent;
8000595c:	7b 00 00 f8 	movh %d15,32768
80005960:	1b ef 12 f5 	addi %d15,%d15,20782
80005964:	6c 45       	st.w [%a4]20,%d15
    stdif->getWriteCount  = (IfxStdIf_DPipe_GetWriteCount) & IfxAsclin_Asc_getWriteCount;
80005966:	7b 00 00 f8 	movh %d15,32768
8000596a:	1b 4f 14 f5 	addi %d15,%d15,20804
8000596e:	6c 46       	st.w [%a4]24,%d15
    stdif->getWriteEvent  = (IfxStdIf_DPipe_GetWriteEvent) & IfxAsclin_Asc_getWriteEvent;
80005970:	7b 00 00 f8 	movh %d15,32768
80005974:	1b 2f 15 f5 	addi %d15,%d15,20818
80005978:	6c 47       	st.w [%a4]28,%d15
    stdif->canReadCount   = (IfxStdIf_DPipe_CanReadCount) & IfxAsclin_Asc_canReadCount;
8000597a:	7b 00 00 f8 	movh %d15,32768
8000597e:	1b 4f 1d f5 	addi %d15,%d15,20948
80005982:	6c 48       	st.w [%a4]32,%d15
    stdif->canWriteCount  = (IfxStdIf_DPipe_CanWriteCount) & IfxAsclin_Asc_canWriteCount;
80005984:	7b 00 00 f8 	movh %d15,32768
80005988:	1b 8f 27 f5 	addi %d15,%d15,21112
8000598c:	6c 49       	st.w [%a4]36,%d15
    stdif->flushTx        = (IfxStdIf_DPipe_FlushTx) & IfxAsclin_Asc_flushTx;
8000598e:	7b 00 00 f8 	movh %d15,32768
80005992:	1b cf 1d f5 	addi %d15,%d15,20956
80005996:	6c 4a       	st.w [%a4]40,%d15
    stdif->clearTx        = (IfxStdIf_DPipe_ClearTx) & IfxAsclin_Asc_clearTx;
80005998:	7b 00 00 f8 	movh %d15,32768
8000599c:	1b 0f 29 f5 	addi %d15,%d15,21136
800059a0:	6c 4b       	st.w [%a4]44,%d15
    stdif->clearRx        = (IfxStdIf_DPipe_ClearRx) & IfxAsclin_Asc_clearRx;
800059a2:	7b 00 00 f8 	movh %d15,32768
800059a6:	1b 0f 28 f5 	addi %d15,%d15,21120
800059aa:	6c 4c       	st.w [%a4]48,%d15
    stdif->onReceive      = (IfxStdIf_DPipe_OnReceive) & IfxAsclin_Asc_isrReceive;
800059ac:	7b 00 00 f8 	movh %d15,32768
800059b0:	1b ef 35 f5 	addi %d15,%d15,21342
800059b4:	6c 4d       	st.w [%a4]52,%d15
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
800059b6:	7b 00 00 f8 	movh %d15,32768
800059ba:	1b 0f 2c f5 	addi %d15,%d15,21184
800059be:	6c 4e       	st.w [%a4]56,%d15
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
800059c0:	7b 00 00 f8 	movh %d15,32768
800059c4:	1b cf 15 f5 	addi %d15,%d15,20828
800059c8:	6c 4f       	st.w [%a4]60,%d15
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
800059ca:	7b 00 00 f8 	movh %d15,32768
800059ce:	1b 8f 13 f5 	addi %d15,%d15,20792
800059d2:	59 4f 00 10 	st.w [%a4]64,%d15
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
800059d6:	7b 00 00 f8 	movh %d15,32768
800059da:	1b ef 13 f5 	addi %d15,%d15,20798
800059de:	59 4f 04 10 	st.w [%a4]68,%d15
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
800059e2:	7b 00 00 f8 	movh %d15,32768
800059e6:	1b ef 1c f5 	addi %d15,%d15,20942
800059ea:	59 4f 08 10 	st.w [%a4]72,%d15
    stdif->txDisabled     = FALSE;
800059ee:	82 0f       	mov %d15,0
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));

    /* Set the API link */
    stdif->driver         = asclin;
800059f0:	f4 45       	st.a [%a4],%a5
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
    stdif->txDisabled     = FALSE;
800059f2:	2c 44       	st.b [%a4]4,%d15
    return TRUE;
}
800059f4:	82 12       	mov %d2,1
800059f6:	00 90       	ret 

800059f8 <IfxPort_getAddress>:
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
800059f8:	91 00 00 28 	movh.a %a2,32768
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
800059fc:	82 05       	mov %d5,0
}


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
800059fe:	82 02       	mov %d2,0
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005a00:	d9 22 a0 50 	lea %a2,[%a2]2400 <80000960 <IfxPort_cfg_indexMap>>
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80005a04:	8f f5 0f f1 	and %d15,%d5,255
80005a08:	8b 02 00 32 	eq %d3,%d2,0
80005a0c:	8b 0f 61 34 	and.lt.u %d3,%d15,16
80005a10:	76 3a       	jz %d3,80005a24 <IfxPort_getAddress+0x2c>
80005a12:	02 5f       	mov %d15,%d5
80005a14:	16 ff       	and %d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005a16:	d0 2f       	addsc.a %a15,%a2,%d15,3
80005a18:	82 02       	mov %d2,0
80005a1a:	4c f1       	ld.w %d15,[%a15]4
80005a1c:	7e 42       	jne %d15,%d4,80005a20 <IfxPort_getAddress+0x28>
        {
            module = IfxPort_cfg_indexMap[i].module;
80005a1e:	48 02       	ld.w %d2,[%a15]0
80005a20:	c2 15       	add %d5,1
80005a22:	3c f1       	j 80005a04 <IfxPort_getAddress+0xc>

        i++;
    }

    return module;
}
80005a24:	60 22       	mov.a %a2,%d2
80005a26:	00 90       	ret 

80005a28 <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80005a28:	91 00 00 38 	movh.a %a3,32768
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80005a2c:	82 0f       	mov %d15,0
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80005a2e:	d9 33 a0 50 	lea %a3,[%a3]2400 <80000960 <IfxPort_cfg_indexMap>>
80005a32:	a0 ff       	mov.a %a15,15
80005a34:	d0 32       	addsc.a %a2,%a3,%d15,3
80005a36:	d4 25       	ld.a %a5,[%a2]
80005a38:	7d 45 05 80 	jne.a %a5,%a4,80005a42 <IfxPort_getIndex+0x1a>
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
80005a3c:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80005a40:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80005a42:	c2 1f       	add %d15,1
80005a44:	fc f8       	loop %a15,80005a34 <IfxPort_getIndex+0xc>
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
80005a46:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80005a48:	00 90       	ret 

80005a4a <IfxPort_resetESR>:


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
80005a4a:	40 4f       	mov.aa %a15,%a4
80005a4c:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a4e:	6d 00 ac 0c 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005a52:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a54:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005a56:	6d 00 a8 0b 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
80005a5a:	82 12       	mov %d2,1
80005a5c:	d9 f4 10 10 	lea %a4,[%a15]80
80005a60:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005a64:	d2 06       	mov %e6,0
80005a66:	02 27       	mov %d7,%d2
80005a68:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005a6c:	02 f4       	mov %d4,%d15
80005a6e:	1d 00 d1 0c 	j 80007410 <IfxScuWdt_setCpuEndinit>

80005a72 <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a72:	91 00 00 38 	movh.a %a3,32768
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a76:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a78:	d9 33 a0 70 	lea %a3,[%a3]2528 <800009e0 <IfxPort_cfg_esrMasks>>
80005a7c:	a0 ff       	mov.a %a15,15
80005a7e:	d0 32       	addsc.a %a2,%a3,%d15,3
80005a80:	d4 25       	ld.a %a5,[%a2]
80005a82:	7d 54 0c 80 	jne.a %a4,%a5,80005a9a <IfxPort_disableEmergencyStop+0x28>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005a86:	b9 2f 04 00 	ld.hu %d15,[%a2]4
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
80005a8a:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005a8c:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
80005a90:	6e 08       	jz %d15,80005aa0 <IfxPort_disableEmergencyStop+0x2e>
            {
                IfxPort_resetESR(port, pinIndex);
80005a92:	6d ff dc ff 	call 80005a4a <IfxPort_resetESR>
                result = TRUE;
80005a96:	82 12       	mov %d2,1
80005a98:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a9a:	c2 1f       	add %d15,1
80005a9c:	fc f1       	loop %a15,80005a7e <IfxPort_disableEmergencyStop+0xc>
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
80005a9e:	82 02       	mov %d2,0
            break;
        }
    }

    return result;
}
80005aa0:	00 90       	ret 

80005aa2 <IfxPort_setESR>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
80005aa2:	40 4f       	mov.aa %a15,%a4
80005aa4:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005aa6:	6d 00 80 0c 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005aaa:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005aac:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005aae:	6d 00 7c 0b 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
80005ab2:	82 12       	mov %d2,1
80005ab4:	0f 82 00 20 	sh %d2,%d2,%d8
80005ab8:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005abc:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005ac0:	02 27       	mov %d7,%d2
80005ac2:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005ac6:	02 f4       	mov %d4,%d15
80005ac8:	1d 00 a4 0c 	j 80007410 <IfxScuWdt_setCpuEndinit>

80005acc <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80005acc:	82 19       	mov %d9,1
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005ace:	91 00 00 d8 	movh.a %a13,32768
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80005ad2:	40 4c       	mov.aa %a12,%a4
80005ad4:	02 48       	mov %d8,%d4
80005ad6:	0f 49 00 90 	sh %d9,%d9,%d4
    sint32  portIndex;
    boolean result = FALSE;
80005ada:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005adc:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005ade:	d9 dd a0 70 	lea %a13,[%a13]2528 <800009e0 <IfxPort_cfg_esrMasks>>
80005ae2:	d0 df       	addsc.a %a15,%a13,%d15,3
80005ae4:	c8 02       	ld.a %a2,[%a15]0
80005ae6:	7d 2c 0b 80 	jne.a %a12,%a2,80005afc <IfxPort_enableEmergencyStop+0x30>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005aea:	b9 f3 04 00 	ld.hu %d3,[%a15]4
80005aee:	26 93       	and %d3,%d9
80005af0:	76 36       	jz %d3,80005afc <IfxPort_enableEmergencyStop+0x30>
            {
                IfxPort_setESR(port, pinIndex);
80005af2:	40 c4       	mov.aa %a4,%a12
80005af4:	02 84       	mov %d4,%d8
80005af6:	6d ff d6 ff 	call 80005aa2 <IfxPort_setESR>
                result = TRUE;
80005afa:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005afc:	c2 1f       	add %d15,1
80005afe:	8b 0f 21 32 	ne %d3,%d15,16
80005b02:	df 03 f0 ff 	jne %d3,0,80005ae2 <IfxPort_enableEmergencyStop+0x16>
            }
        }
    }

    return result;
}
80005b06:	00 90       	ret 

80005b08 <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b08:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
80005b0a:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b0c:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005b0e:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b10:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80005b12:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b14:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005b16:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b18:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005b1a:	78 07       	st.w [%sp]28,%d15
80005b1c:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b20:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005b24:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b28:	3b 80 0f 70 	mov %d7,248
80005b2c:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b30:	9f 0f 07 80 	jned %d15,0,80005b3e <IfxPort_setGroupModeInput+0x36>
80005b34:	d9 44 10 00 	lea %a4,[%a4]16
80005b38:	82 0f       	mov %d15,0
80005b3a:	a0 3f       	mov.a %a15,3
80005b3c:	3c 1e       	j 80005b78 <IfxPort_setGroupModeInput+0x70>
    {
        if ((imask & (1U << i)) != 0)
80005b3e:	57 05 61 24 	extr.u %d2,%d5,%d4,1
80005b42:	df 02 19 00 	jeq %d2,0,80005b74 <IfxPort_setGroupModeInput+0x6c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b46:	8f 34 c0 31 	andn %d3,%d4,3
80005b4a:	60 32       	mov.a %a2,%d3
80005b4c:	d9 af 20 00 	lea %a15,[%sp]32
80005b50:	30 2f       	add.a %a15,%a2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80005b52:	8f 34 00 21 	and %d2,%d4,3
80005b56:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b58:	19 f0 f0 ff 	ld.w %d0,[%a15]-16
80005b5c:	0f 27 00 30 	sh %d3,%d7,%d2
80005b60:	a6 03       	or %d3,%d0
80005b62:	59 f3 f0 ff 	st.w [%a15]-16,%d3
            iocrVal[index]  |= (mode) << shift;
80005b66:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
80005b6a:	0f 26 00 20 	sh %d2,%d6,%d2
80005b6e:	a6 32       	or %d2,%d3
80005b70:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b74:	c2 14       	add %d4,1
80005b76:	3c dd       	j 80005b30 <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005b78:	d9 a3 20 00 	lea %a3,[%sp]32
80005b7c:	90 32       	addsc.a %a2,%a3,%d15,2
80005b7e:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005b82:	76 47       	jz %d4,80005b90 <IfxPort_setGroupModeInput+0x88>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005b84:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005b88:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005b8a:	02 43       	mov %d3,%d4
80005b8c:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005b90:	c2 1f       	add %d15,1
80005b92:	b0 44       	add.a %a4,4
80005b94:	fc f2       	loop %a15,80005b78 <IfxPort_setGroupModeInput+0x70>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005b96:	00 90       	ret 

80005b98 <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b98:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
80005b9a:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b9c:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005b9e:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ba0:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80005ba2:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ba4:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005ba6:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ba8:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005baa:	78 07       	st.w [%sp]28,%d15
80005bac:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005bb0:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005bb4:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005bb8:	3b 80 0f 00 	mov %d0,248
80005bbc:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005bc0:	9f 0f 07 80 	jned %d15,0,80005bce <IfxPort_setGroupModeOutput+0x36>
80005bc4:	d9 44 10 00 	lea %a4,[%a4]16
80005bc8:	82 0f       	mov %d15,0
80005bca:	a0 3f       	mov.a %a15,3
80005bcc:	3c 1f       	j 80005c0a <IfxPort_setGroupModeOutput+0x72>
    {
        if ((imask & (1U << i)) != 0)
80005bce:	57 05 61 24 	extr.u %d2,%d5,%d4,1
80005bd2:	df 02 1a 00 	jeq %d2,0,80005c06 <IfxPort_setGroupModeOutput+0x6e>
        {
            uint32 index = i / 4;
80005bd6:	8f e4 1f 30 	sh %d3,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005bda:	d9 a2 20 00 	lea %a2,[%sp]32
80005bde:	01 23 02 f6 	addsc.a %a15,%a2,%d3,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80005be2:	8f 34 00 21 	and %d2,%d4,3
80005be6:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
80005be8:	a6 63       	or %d3,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005bea:	0f 20 00 70 	sh %d7,%d0,%d2
80005bee:	19 f1 f0 ff 	ld.w %d1,[%a15]-16
            iocrVal[index]  |= (mode | index) << shift;
80005bf2:	0f 23 00 20 	sh %d2,%d3,%d2
80005bf6:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005bfa:	a6 17       	or %d7,%d1
            iocrVal[index]  |= (mode | index) << shift;
80005bfc:	a6 32       	or %d2,%d3
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005bfe:	59 f7 f0 ff 	st.w [%a15]-16,%d7
            iocrVal[index]  |= (mode | index) << shift;
80005c02:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005c06:	c2 14       	add %d4,1
80005c08:	3c dc       	j 80005bc0 <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005c0a:	d9 a3 20 00 	lea %a3,[%sp]32
80005c0e:	90 32       	addsc.a %a2,%a3,%d15,2
80005c10:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005c14:	76 47       	jz %d4,80005c22 <IfxPort_setGroupModeOutput+0x8a>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005c16:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005c1a:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005c1c:	02 43       	mov %d3,%d4
80005c1e:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode | index) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005c22:	c2 1f       	add %d15,1
80005c24:	b0 44       	add.a %a4,4
80005c26:	fc f2       	loop %a15,80005c0a <IfxPort_setGroupModeOutput+0x72>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005c28:	00 90       	ret 

80005c2a <IfxPort_setGroupPadDriver>:


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80005c2a:	20 10       	sub.a %sp,16
80005c2c:	02 4f       	mov %d15,%d4
80005c2e:	02 5a       	mov %d10,%d5
80005c30:	40 4c       	mov.aa %a12,%a4
80005c32:	02 69       	mov %d9,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c34:	6d 00 b9 0b 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005c38:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c3a:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005c3c:	6d 00 b5 0a 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005c40:	82 03       	mov %d3,0
80005c42:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80005c44:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005c48:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80005c4c:	59 a3 0c 00 	st.w [%sp]12,%d3
80005c50:	8b 1f a1 22 	ge.u %d2,%d15,17
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005c54:	8b 0f 01 31 	rsub %d3,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80005c58:	0f fa 00 50 	sh %d5,%d10,%d15
80005c5c:	ab 03 a0 32 	seln %d3,%d2,%d3,0

        for (i = pinIndex; i < 16; i++)
80005c60:	9f 03 03 80 	jned %d3,0,80005c66 <IfxPort_setGroupPadDriver+0x3c>
80005c64:	3c 1d       	j 80005c9e <IfxPort_setGroupPadDriver+0x74>
        {
            if ((imask & (1U << i)) != 0)
80005c66:	57 05 61 2f 	extr.u %d2,%d5,%d15,1
80005c6a:	df 02 18 00 	jeq %d2,0,80005c9a <IfxPort_setGroupPadDriver+0x70>
            {
                uint32 index = i / 8;
80005c6e:	8f df 1f 40 	sh %d4,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005c72:	d9 a2 10 00 	lea %a2,[%sp]16
80005c76:	01 24 02 f6 	addsc.a %a15,%a2,%d4,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005c7a:	8f 7f 00 21 	and %d2,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80005c7e:	19 f4 f8 ff 	ld.w %d4,[%a15]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005c82:	06 22       	sh %d2,2
                pdrMask[index] |= (0xFUL << shift);
80005c84:	d7 f4 04 42 	insert %d4,%d4,15,%d2,4
                pdrVal[index]  |= (padDriver << shift);
80005c88:	0f 29 00 20 	sh %d2,%d9,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005c8c:	59 f4 f8 ff 	st.w [%a15]-8,%d4
                pdrVal[index]  |= (padDriver << shift);
80005c90:	19 f4 f0 ff 	ld.w %d4,[%a15]-16
80005c94:	a6 42       	or %d2,%d4
80005c96:	59 f2 f0 ff 	st.w [%a15]-16,%d2
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80005c9a:	c2 1f       	add %d15,1
80005c9c:	3c e2       	j 80005c60 <IfxPort_setGroupPadDriver+0x36>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005c9e:	58 02       	ld.w %d15,[%sp]8
80005ca0:	6e 08       	jz %d15,80005cb0 <IfxPort_setGroupPadDriver+0x86>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005ca2:	d9 cf 00 10 	lea %a15,[%a12]64
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005ca6:	54 a6       	ld.w %d6,[%sp]
80005ca8:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005caa:	02 f7       	mov %d7,%d15
80005cac:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005cb0:	58 03       	ld.w %d15,[%sp]12
80005cb2:	6e 09       	jz %d15,80005cc4 <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005cb4:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005cb8:	19 a6 04 00 	ld.w %d6,[%sp]4
80005cbc:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005cbe:	02 f7       	mov %d7,%d15
80005cc0:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005cc4:	02 84       	mov %d4,%d8
}
80005cc6:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005cca:	1d 00 a3 0b 	j 80007410 <IfxScuWdt_setCpuEndinit>

80005cce <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80005cce:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005cd2:	8f 34 00 91 	and %d9,%d4,3

    if (port == &MODULE_P40)
80005cd6:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80005cda:	40 4f       	mov.aa %a15,%a4
80005cdc:	02 4f       	mov %d15,%d4
80005cde:	02 5a       	mov %d10,%d5
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80005ce0:	d9 4c 10 00 	lea %a12,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80005ce4:	8f e4 1f b0 	sh %d11,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005ce8:	06 39       	sh %d9,3

    if (port == &MODULE_P40)
80005cea:	7d 24 11 80 	jne.a %a4,%a2,80005d0c <IfxPort_setPinMode+0x3e>
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005cee:	6d 00 5c 0b 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80005cf2:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005cf4:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80005cf6:	6d 00 58 0a 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80005cfa:	19 f2 20 10 	ld.w %d2,[%a15]96
        IfxScuWdt_setCpuEndinit(passwd);
80005cfe:	02 84       	mov %d4,%d8

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80005d00:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80005d04:	59 ff 20 10 	st.w [%a15]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80005d08:	6d 00 84 0b 	call 80007410 <IfxScuWdt_setCpuEndinit>
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80005d0c:	da ff       	mov %d15,255
80005d0e:	01 cb 02 f6 	addsc.a %a15,%a12,%d11,2
80005d12:	0f 9f 00 f0 	sh %d15,%d15,%d9
80005d16:	0f 9a 00 20 	sh %d2,%d10,%d9
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005d1a:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005d1c:	02 f3       	mov %d3,%d15
80005d1e:	49 f2 40 08 	ldmst [%a15]0,%e2
80005d22:	00 90       	ret 

80005d24 <IfxPort_setPinModeLvdsHigh>:
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80005d24:	02 5a       	mov %d10,%d5
80005d26:	40 4f       	mov.aa %a15,%a4
80005d28:	02 49       	mov %d9,%d4
80005d2a:	02 6f       	mov %d15,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005d2c:	6d 00 3d 0b 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005d30:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005d32:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005d34:	6d 00 39 0a 	call 800071a6 <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80005d38:	37 0a 48 50 	extr %d5,%d10,0,8
80005d3c:	bf 05 11 00 	jlt %d5,0,80005d5e <IfxPort_setPinModeLvdsHigh+0x3a>
    {
        if (pinIndex < 2)
80005d40:	bf 29 21 80 	jlt.u %d9,2,80005d82 <IfxPort_setPinModeLvdsHigh+0x5e>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80005d44:	19 f2 24 20 	ld.w %d2,[%a15]164
80005d48:	37 f2 01 f0 	insert %d15,%d2,%d15,0,1
80005d4c:	59 ff 24 20 	st.w [%a15]164,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
80005d50:	19 ff 24 20 	ld.w %d15,[%a15]164
80005d54:	8f 2f c0 f1 	andn %d15,%d15,2
80005d58:	59 ff 24 20 	st.w [%a15]164,%d15
80005d5c:	3c 13       	j 80005d82 <IfxPort_setPinModeLvdsHigh+0x5e>
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80005d5e:	19 f2 28 20 	ld.w %d2,[%a15]168
80005d62:	67 f2 0c f0 	ins.t %d15,%d2,12,%d15,0
80005d66:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_DIS    = 0;
80005d6a:	19 ff 28 20 	ld.w %d15,[%a15]168
80005d6e:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80005d72:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_PD     = 0;
80005d76:	19 ff 28 20 	ld.w %d15,[%a15]168
80005d7a:	b7 0f 01 f7 	insert %d15,%d15,0,14,1
80005d7e:	59 ff 28 20 	st.w [%a15]168,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80005d82:	02 84       	mov %d4,%d8
80005d84:	1d 00 46 0b 	j 80007410 <IfxScuWdt_setCpuEndinit>

80005d88 <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005d88:	0b 65 10 a8 	mov %e10,%d5,%d6
80005d8c:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005d8e:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005d92:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005d94:	6d 00 09 0b 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005d98:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005d9a:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005d9c:	6d 00 05 0a 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80005da0:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80005da2:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005da6:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005daa:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80005dae:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005db2:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005db6:	0f 2b 00 50 	sh %d5,%d11,%d2
80005dba:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005dbc:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005dbe:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005dc0:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80005dc4:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005dc6:	1d 00 25 0b 	j 80007410 <IfxScuWdt_setCpuEndinit>

80005dca <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80005dca:	0b 45 10 88 	mov %e8,%d5,%d4
80005dce:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005dd0:	6d 00 eb 0a 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005dd4:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005dd6:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005dd8:	6d 00 e7 09 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80005ddc:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005de0:	06 22       	sh %d2,2
80005de2:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80005de4:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005de8:	3b f0 00 30 	mov %d3,15
80005dec:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80005df0:	0f 23 00 30 	sh %d3,%d3,%d2
80005df4:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005df8:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005dfa:	02 37       	mov %d7,%d3
80005dfc:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005e00:	02 f4       	mov %d4,%d15
80005e02:	1d 00 07 0b 	j 80007410 <IfxScuWdt_setCpuEndinit>
	...

80005e08 <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80005e08:	7b e0 e4 30 	movh %d3,3662
80005e0c:	1b 13 c0 31 	addi %d3,%d3,7169
80005e10:	0b 34 30 c1 	lt.u %d12,%d4,%d3
80005e14:	82 2f       	mov %d15,2
80005e16:	ab 1f 80 cc 	sel %d12,%d12,%d15,1
80005e1a:	8f 4c 00 80 	sh %d8,%d12,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005e1e:	7b c0 be 00 	movh %d0,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005e22:	91 40 0f 50 	movh.a %a5,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005e26:	7b 80 82 6e 	movh %d6,59432
80005e2a:	91 80 7d 61 	movh.a %a6,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
80005e2e:	19 4e 10 10 	ld.w %d14,[%a4]80
80005e32:	60 83       	mov.a %a3,%d8
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005e34:	1b 00 20 0c 	addi %d0,%d0,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80005e38:	d2 0a       	mov %e10,0
80005e3a:	82 09       	mov %d9,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005e3c:	3b 00 01 50 	mov %d5,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005e40:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005e44:	82 f7       	mov %d7,-1
80005e46:	1b 06 c0 67 	addi %d6,%d6,31744
80005e4a:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
80005e4e:	a0 ff       	mov.a %a15,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005e50:	4b 5e 11 22 	div.u %e2,%d14,%d5

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005e54:	7b 60 f8 1f 	movh %d1,65414
80005e58:	1b 01 e0 1e 	addi %d1,%d1,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005e5c:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005e5e:	0b 12 40 10 	addx %d1,%d2,%d1
80005e62:	8b f3 bf 20 	addc %d2,%d3,-1
80005e66:	80 53       	mov.d %d3,%a5
80005e68:	ba 02       	eq %d15,%d2,0
80005e6a:	0b 31 50 f2 	and.ge.u %d15,%d1,%d3
80005e6e:	8b 02 00 f5 	or.ne %d15,%d2,0
80005e72:	ee 24       	jnz %d15,80005eba <IfxScuCcu_calculateSysPllDividers+0xb2>
80005e74:	02 5d       	mov %d13,%d5
80005e76:	82 11       	mov %d1,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005e78:	03 41 68 26 	madd.u %e2,%e6,%d1,%d4
80005e7c:	80 68       	mov.d %d8,%a6
80005e7e:	ba 03       	eq %d15,%d3,0
80005e80:	0b 82 50 f2 	and.ge.u %d15,%d2,%d8
80005e84:	8b 03 00 f5 	or.ne %d15,%d3,0
80005e88:	ee 13       	jnz %d15,80005eae <IfxScuCcu_calculateSysPllDividers+0xa6>
80005e8a:	82 18       	mov %d8,1
80005e8c:	c5 02 3f 10 	lea %a2,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
80005e90:	4b d8 11 22 	div.u %e2,%d8,%d13
80005e94:	e2 e2       	mul %d2,%d14
80005e96:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
80005e98:	df 02 18 00 	jeq %d2,0,80005ec8 <IfxScuCcu_calculateSysPllDividers+0xc0>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
80005e9c:	82 1f       	mov %d15,1
80005e9e:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80005ea2:	6a 8b       	cmovn %d11,%d15,%d8
80005ea4:	6a 20       	cmovn %d0,%d15,%d2
80005ea6:	6a 5a       	cmovn %d10,%d15,%d5
80005ea8:	6a 19       	cmovn %d9,%d15,%d1
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
80005eaa:	c2 18       	add %d8,1
80005eac:	fc 22       	loop %a2,80005e90 <IfxScuCcu_calculateSysPllDividers+0x88>
80005eae:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80005eb0:	42 c1       	add %d1,%d12
80005eb2:	42 fd       	add %d13,%d15
80005eb4:	8b 11 68 f2 	lt.u %d15,%d1,129
80005eb8:	ee e0       	jnz %d15,80005e78 <IfxScuCcu_calculateSysPllDividers+0x70>
80005eba:	60 c2       	mov.a %a2,%d12
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005ebc:	c2 f5       	add %d5,-1
80005ebe:	01 23 20 30 	sub.a %a3,%a3,%a2
80005ec2:	fd f0 c7 7f 	loop %a15,80005e50 <IfxScuCcu_calculateSysPllDividers+0x48>
80005ec6:	3c 05       	j 80005ed0 <IfxScuCcu_calculateSysPllDividers+0xc8>

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
                                bestN          = n;
80005ec8:	0b 58 10 a8 	mov %e10,%d8,%d5
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
80005ecc:	02 19       	mov %d9,%d1
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
80005ece:	82 00       	mov %d0,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005ed0:	da 64       	mov %d15,100
80005ed2:	06 14       	sh %d4,1
80005ed4:	4b f4 11 42 	div.u %e4,%d4,%d15
80005ed8:	82 1f       	mov %d15,1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80005eda:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005edc:	0b 40 50 f2 	and.ge.u %d15,%d0,%d4
80005ee0:	ee 0f       	jnz %d15,80005efe <IfxScuCcu_calculateSysPllDividers+0xf6>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005ee2:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005ee4:	c2 fb       	add %d11,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005ee6:	c2 fa       	add %d10,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005ee8:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005eea:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005eee:	e9 4b 09 00 	st.b [%a4]9,%d11
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005ef2:	e9 4a 08 00 	st.b [%a4]8,%d10
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005ef6:	e9 49 0a 00 	st.b [%a4]10,%d9
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80005efa:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80005efc:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80005efe:	00 90       	ret 

80005f00 <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80005f00:	91 00 00 f7 	movh.a %a15,28672
80005f04:	19 f2 08 40 	ld.w %d2,[%a15]264 <70000108 <IfxScuCcu_xtalFrequency>>
}
80005f08:	4b 02 61 21 	utof %d2,%d2
80005f0c:	00 90       	ret 

80005f0e <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005f0e:	91 30 00 ff 	movh.a %a15,61443
80005f12:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005f16:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005f18:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005f1c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005f20:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005f24:	6e 0c       	jz %d15,80005f3c <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005f26:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
80005f28:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005f2a:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005f2e:	5e 17       	jne %d15,1,80005f3c <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80005f30:	91 00 00 f7 	movh.a %a15,28672
80005f34:	19 f2 08 40 	ld.w %d2,[%a15]264 <70000108 <IfxScuCcu_xtalFrequency>>
80005f38:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}
80005f3c:	00 90       	ret 

80005f3e <IfxScuCcu_getPllErayFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005f3e:	91 30 00 ff 	movh.a %a15,61443
80005f42:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005f46:	6d ff e4 ff 	call 80005f0e <IfxScuCcu_getOscFrequency>

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005f4a:	4c f9       	ld.w %d15,[%a15]36
80005f4c:	2e 05       	jz.t %d15,0,80005f56 <IfxScuCcu_getPllErayFrequency+0x18>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80005f4e:	4c fb       	ld.w %d15,[%a15]44
80005f50:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005f54:	3c 21       	j 80005f96 <IfxScuCcu_getPllErayFrequency+0x58>
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80005f56:	4c f9       	ld.w %d15,[%a15]36
80005f58:	6f 3f 15 00 	jz.t %d15,3,80005f82 <IfxScuCcu_getPllErayFrequency+0x44>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80005f5c:	48 b4       	ld.w %d4,[%a15]44
80005f5e:	8f f4 07 41 	and %d4,%d4,127
80005f62:	c2 14       	add %d4,1
80005f64:	6d 00 9b 28 	call 8000b09a <__floatsidf>
80005f68:	7b 80 19 54 	movh %d5,16792
80005f6c:	0b 23 10 68 	mov %e6,%d3,%d2
80005f70:	82 04       	mov %d4,0
80005f72:	1b 45 78 5d 	addi %d5,%d5,-10364
80005f76:	6d 00 06 28 	call 8000af82 <__divdf3>
80005f7a:	0b 23 10 48 	mov %e4,%d3,%d2
80005f7e:	1d 00 c1 28 	j 8000b100 <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80005f82:	48 a3       	ld.w %d3,[%a15]40
80005f84:	4c fb       	ld.w %d15,[%a15]44
80005f86:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005f8a:	16 7f       	and %d15,127
80005f8c:	c2 13       	add %d3,1
80005f8e:	4b 03 41 31 	itof %d3,%d3
80005f92:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005f96:	c2 1f       	add %d15,1
80005f98:	4b 0f 41 f1 	itof %d15,%d15
80005f9c:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005fa0:	00 90       	ret 

80005fa2 <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005fa2:	91 30 00 ff 	movh.a %a15,61443
80005fa6:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80005faa:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005fac:	7b f0 cb 24 	movh %d2,19647
80005fb0:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005fb4:	6f 3f 18 80 	jnz.t %d15,3,80005fe4 <IfxScuCcu_getPllErayVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80005fb8:	6d ff ab ff 	call 80005f0e <IfxScuCcu_getOscFrequency>
80005fbc:	91 30 00 ff 	movh.a %a15,61443
80005fc0:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80005fc4:	48 03       	ld.w %d3,[%a15]0
80005fc6:	4c f0       	ld.w %d15,[%a15]0
80005fc8:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005fcc:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005fd0:	c2 13       	add %d3,1
80005fd2:	4b 03 41 31 	itof %d3,%d3
80005fd6:	c2 1f       	add %d15,1
80005fd8:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005fdc:	4b 0f 41 f1 	itof %d15,%d15
80005fe0:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005fe4:	00 90       	ret 

80005fe6 <IfxScuCcu_getPllFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005fe6:	91 30 00 ff 	movh.a %a15,61443
80005fea:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005fee:	6d ff 90 ff 	call 80005f0e <IfxScuCcu_getOscFrequency>

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005ff2:	4c f5       	ld.w %d15,[%a15]20
80005ff4:	2e 06       	jz.t %d15,0,80006000 <IfxScuCcu_getPllFrequency+0x1a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80005ff6:	4c f7       	ld.w %d15,[%a15]28
80005ff8:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005ffc:	c2 1f       	add %d15,1
80005ffe:	3c 28       	j 8000604e <IfxScuCcu_getPllFrequency+0x68>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80006000:	4c f5       	ld.w %d15,[%a15]20
80006002:	6f 3f 15 00 	jz.t %d15,3,8000602c <IfxScuCcu_getPllFrequency+0x46>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80006006:	48 74       	ld.w %d4,[%a15]28
80006008:	8f f4 07 41 	and %d4,%d4,127
8000600c:	c2 14       	add %d4,1
8000600e:	6d 00 46 28 	call 8000b09a <__floatsidf>
80006012:	7b 80 19 54 	movh %d5,16792
80006016:	0b 23 10 68 	mov %e6,%d3,%d2
8000601a:	82 04       	mov %d4,0
8000601c:	1b 45 78 5d 	addi %d5,%d5,-10364
80006020:	6d 00 b1 27 	call 8000af82 <__divdf3>
80006024:	0b 23 10 48 	mov %e4,%d3,%d2
80006028:	1d 00 6c 28 	j 8000b100 <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000602c:	48 64       	ld.w %d4,[%a15]24
8000602e:	4c f7       	ld.w %d15,[%a15]28
80006030:	37 04 e7 44 	extr.u %d4,%d4,9,7
80006034:	8f ff 07 31 	and %d3,%d15,127
80006038:	4c f6       	ld.w %d15,[%a15]24
8000603a:	c2 14       	add %d4,1
8000603c:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80006040:	4b 04 41 41 	itof %d4,%d4
80006044:	c2 1f       	add %d15,1
80006046:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
8000604a:	4b 42 41 20 	mul.f %d2,%d2,%d4
8000604e:	4b 0f 41 f1 	itof %d15,%d15
80006052:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80006056:	00 90       	ret 

80006058 <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80006058:	91 30 00 ff 	movh.a %a15,61443
8000605c:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006060:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80006062:	7b f0 cb 24 	movh %d2,19647
80006066:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
8000606a:	6f 3f 18 80 	jnz.t %d15,3,8000609a <IfxScuCcu_getPllVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
8000606e:	6d ff 50 ff 	call 80005f0e <IfxScuCcu_getOscFrequency>
80006072:	91 30 00 ff 	movh.a %a15,61443
80006076:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000607a:	48 03       	ld.w %d3,[%a15]0
8000607c:	4c f0       	ld.w %d15,[%a15]0
8000607e:	37 03 e7 34 	extr.u %d3,%d3,9,7
80006082:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80006086:	c2 13       	add %d3,1
80006088:	4b 03 41 31 	itof %d3,%d3
8000608c:	c2 1f       	add %d15,1
8000608e:	4b 32 41 20 	mul.f %d2,%d2,%d3
80006092:	4b 0f 41 f1 	itof %d15,%d15
80006096:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
8000609a:	00 90       	ret 

8000609c <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000609c:	91 30 00 ff 	movh.a %a15,61443
800060a0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800060a4:	4c f0       	ld.w %d15,[%a15]0
800060a6:	37 0f 62 fe 	extr.u %d15,%d15,28,2
800060aa:	6e 06       	jz %d15,800060b6 <IfxScuCcu_getSourceFrequency+0x1a>
800060ac:	1e 13       	jeq %d15,1,800060b2 <IfxScuCcu_getSourceFrequency+0x16>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800060ae:	82 02       	mov %d2,0
800060b0:	00 90       	ret 
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
800060b2:	1d ff 9a ff 	j 80005fe6 <IfxScuCcu_getPllFrequency>
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800060b6:	7b f0 cb 24 	movh %d2,19647
800060ba:	1b 02 c2 2b 	addi %d2,%d2,-17376
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
800060be:	00 90       	ret 

800060c0 <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
800060c0:	02 4f       	mov %d15,%d4
800060c2:	6d ff ed ff 	call 8000609c <IfxScuCcu_getSourceFrequency>
800060c6:	91 30 00 ff 	movh.a %a15,61443
800060ca:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800060ce:	48 03       	ld.w %d3,[%a15]0
800060d0:	37 03 64 34 	extr.u %d3,%d3,8,4
800060d4:	4b 03 41 31 	itof %d3,%d3
800060d8:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
800060dc:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
800060e0:	4b f2 41 20 	mul.f %d2,%d2,%d15
800060e4:	4b 02 71 21 	ftouz %d2,%d2
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
800060e8:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
800060ec:	a2 3f       	sub %d15,%d3
800060ee:	3f 2f fd ff 	jlt.u %d15,%d2,800060e8 <IfxScuCcu_wait+0x28>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
800060f2:	00 90       	ret 

800060f4 <IfxScuCcu_getBbbFrequency>:
float32 IfxScuCcu_getBbbFrequency(void)
{
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800060f4:	6d ff d4 ff 	call 8000609c <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
800060f8:	91 30 00 ff 	movh.a %a15,61443
800060fc:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006100:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0;
80006102:	82 0f       	mov %d15,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006104:	37 03 64 36 	extr.u %d3,%d3,12,4
80006108:	ff 53 30 80 	jge.u %d3,5,80006168 <IfxScuCcu_getBbbFrequency+0x74>
8000610c:	91 00 00 f8 	movh.a %a15,32768
80006110:	d9 ff 1c 46 	lea %a15,[%a15]24860 <8000611c <IfxScuCcu_getBbbFrequency+0x28>>
80006114:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80006118:	dc 0f       	ji %a15
8000611a:	00 00       	nop 
8000611c:	1d 00 0a 00 	j 80006130 <IfxScuCcu_getBbbFrequency+0x3c>
80006120:	1d 00 17 00 	j 8000614e <IfxScuCcu_getBbbFrequency+0x5a>
80006124:	1d 00 18 00 	j 80006154 <IfxScuCcu_getBbbFrequency+0x60>
80006128:	1d 00 19 00 	j 8000615a <IfxScuCcu_getBbbFrequency+0x66>
8000612c:	1d 00 1a 00 	j 80006160 <IfxScuCcu_getBbbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80006130:	91 30 00 ff 	movh.a %a15,61443
80006134:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80006138:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0;
8000613a:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
8000613c:	8f f3 00 31 	and %d3,%d3,15
80006140:	df 03 14 00 	jeq %d3,0,80006168 <IfxScuCcu_getBbbFrequency+0x74>
        {
            bbbFrequency = 0.0;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
80006144:	4c f0       	ld.w %d15,[%a15]0
80006146:	16 0f       	and %d15,15
80006148:	4b 0f 41 f1 	itof %d15,%d15
8000614c:	3c 0c       	j 80006164 <IfxScuCcu_getBbbFrequency+0x70>
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
8000614e:	7b 00 1f f4 	movh %d15,16880
80006152:	3c 09       	j 80006164 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
80006154:	7b 00 27 f4 	movh %d15,17008
80006158:	3c 06       	j 80006164 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
8000615a:	7b 00 2f f4 	movh %d15,17136
8000615e:	3c 03       	j 80006164 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
80006160:	7b 00 37 f4 	movh %d15,17264
80006164:	4b f2 51 f0 	div.f %d15,%d2,%d15
        bbbFrequency = 0.0;
        break;
    }

    return bbbFrequency;
}
80006168:	02 f2       	mov %d2,%d15
8000616a:	00 90       	ret 

8000616c <IfxScuCcu_getMaxFrequency>:
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000616c:	91 30 00 ff 	movh.a %a15,61443
80006170:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>

float32 IfxScuCcu_getMaxFrequency(void)
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006174:	6d ff 94 ff 	call 8000609c <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80006178:	4c f0       	ld.w %d15,[%a15]0
8000617a:	37 0f 64 f6 	extr.u %d15,%d15,12,4
8000617e:	ff 5f 2d 80 	jge.u %d15,5,800061d8 <IfxScuCcu_getMaxFrequency+0x6c>
80006182:	91 00 00 f8 	movh.a %a15,32768
80006186:	d9 ff 10 66 	lea %a15,[%a15]24976 <80006190 <IfxScuCcu_getMaxFrequency+0x24>>
8000618a:	90 ff       	addsc.a %a15,%a15,%d15,2
8000618c:	dc 0f       	ji %a15
8000618e:	00 00       	nop 
80006190:	1d 00 0a 00 	j 800061a4 <IfxScuCcu_getMaxFrequency+0x38>
80006194:	1d 00 14 00 	j 800061bc <IfxScuCcu_getMaxFrequency+0x50>
80006198:	1d 00 15 00 	j 800061c2 <IfxScuCcu_getMaxFrequency+0x56>
8000619c:	1d 00 16 00 	j 800061c8 <IfxScuCcu_getMaxFrequency+0x5c>
800061a0:	1d 00 17 00 	j 800061ce <IfxScuCcu_getMaxFrequency+0x62>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
800061a4:	91 30 00 ff 	movh.a %a15,61443
800061a8:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
800061ac:	4c f0       	ld.w %d15,[%a15]0
800061ae:	16 0f       	and %d15,15
800061b0:	6e 15       	jz %d15,800061da <IfxScuCcu_getMaxFrequency+0x6e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
800061b2:	4c f0       	ld.w %d15,[%a15]0
800061b4:	16 0f       	and %d15,15
800061b6:	4b 0f 41 f1 	itof %d15,%d15
800061ba:	3c 0c       	j 800061d2 <IfxScuCcu_getMaxFrequency+0x66>
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
800061bc:	7b 00 17 f4 	movh %d15,16752
800061c0:	3c 09       	j 800061d2 <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
800061c2:	7b 00 1f f4 	movh %d15,16880
800061c6:	3c 06       	j 800061d2 <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
800061c8:	7b 00 27 f4 	movh %d15,17008
800061cc:	3c 03       	j 800061d2 <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
800061ce:	7b 00 2f f4 	movh %d15,17136
800061d2:	4b f2 51 20 	div.f %d2,%d2,%d15
        break;
800061d6:	00 90       	ret 
    default:
        maxFrequency = 0.0;
800061d8:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
800061da:	00 90       	ret 

800061dc <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061dc:	91 30 00 ff 	movh.a %a15,61443
800061e0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061e4:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
800061e6:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061e8:	8f ff 00 81 	and %d8,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
800061ec:	76 87       	jz %d8,800061fa <IfxScuCcu_getBaud1Frequency+0x1e>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
800061ee:	6d ff bf ff 	call 8000616c <IfxScuCcu_getMaxFrequency>
800061f2:	4b 08 41 f1 	itof %d15,%d8
800061f6:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
800061fa:	00 90       	ret 

800061fc <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061fc:	91 30 00 ff 	movh.a %a15,61443
80006200:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006204:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
80006206:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006208:	37 0f 64 82 	extr.u %d8,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
8000620c:	16 f0       	and %d15,240
8000620e:	6e 07       	jz %d15,8000621c <IfxScuCcu_getBaud2Frequency+0x20>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
80006210:	6d ff ae ff 	call 8000616c <IfxScuCcu_getMaxFrequency>
80006214:	4b 08 41 f1 	itof %d15,%d8
80006218:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
8000621c:	00 90       	ret 

8000621e <IfxScuCcu_getSpbFrequency>:
float32 IfxScuCcu_getSpbFrequency(void)
{
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
8000621e:	6d ff 3f ff 	call 8000609c <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80006222:	91 30 00 ff 	movh.a %a15,61443
80006226:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000622a:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0;
8000622c:	82 0f       	mov %d15,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000622e:	37 03 64 36 	extr.u %d3,%d3,12,4
80006232:	ff 53 30 80 	jge.u %d3,5,80006292 <IfxScuCcu_getSpbFrequency+0x74>
80006236:	91 00 00 f8 	movh.a %a15,32768
8000623a:	d9 ff 04 96 	lea %a15,[%a15]25156 <80006244 <IfxScuCcu_getSpbFrequency+0x26>>
8000623e:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80006242:	dc 0f       	ji %a15
80006244:	1d 00 0a 00 	j 80006258 <IfxScuCcu_getSpbFrequency+0x3a>
80006248:	1d 00 18 00 	j 80006278 <IfxScuCcu_getSpbFrequency+0x5a>
8000624c:	1d 00 19 00 	j 8000627e <IfxScuCcu_getSpbFrequency+0x60>
80006250:	1d 00 1a 00 	j 80006284 <IfxScuCcu_getSpbFrequency+0x66>
80006254:	1d 00 1b 00 	j 8000628a <IfxScuCcu_getSpbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80006258:	91 30 00 ff 	movh.a %a15,61443
8000625c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006260:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0;
80006262:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80006264:	37 03 64 38 	extr.u %d3,%d3,16,4
80006268:	df 03 15 00 	jeq %d3,0,80006292 <IfxScuCcu_getSpbFrequency+0x74>
        {
            spbFrequency = 0.0;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
8000626c:	4c f0       	ld.w %d15,[%a15]0
8000626e:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80006272:	4b 0f 41 f1 	itof %d15,%d15
80006276:	3c 0c       	j 8000628e <IfxScuCcu_getSpbFrequency+0x70>
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80006278:	7b 00 1f f4 	movh %d15,16880
8000627c:	3c 09       	j 8000628e <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
8000627e:	7b 00 27 f4 	movh %d15,17008
80006282:	3c 06       	j 8000628e <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
80006284:	7b 00 2f f4 	movh %d15,17136
80006288:	3c 03       	j 8000628e <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
8000628a:	7b 00 37 f4 	movh %d15,17264
8000628e:	4b f2 51 f0 	div.f %d15,%d2,%d15
        spbFrequency = 0.0;
        break;
    }

    return spbFrequency;
}
80006292:	02 f2       	mov %d2,%d15
80006294:	00 90       	ret 

80006296 <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
80006296:	91 30 00 ff 	movh.a %a15,61443
8000629a:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
8000629e:	48 09       	ld.w %d9,[%a15]0
    spbFreq = IfxScuCcu_getSpbFrequency();
800062a0:	6d ff bf ff 	call 8000621e <IfxScuCcu_getSpbFrequency>

    if (scuFdr.B.DM == 1)
800062a4:	bb 00 00 fc 	mov.u %d15,49152
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();
800062a8:	02 23       	mov %d3,%d2

    if (scuFdr.B.DM == 1)
800062aa:	26 9f       	and %d15,%d9
800062ac:	3b 00 00 24 	mov %d2,16384
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
800062b0:	b7 09 16 85 	insert %d8,%d9,0,10,22
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
800062b4:	7e 29       	jne %d15,%d2,800062c6 <IfxScuCcu_getModuleFrequency+0x30>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
800062b6:	3b 00 40 20 	mov %d2,1024
800062ba:	a2 82       	sub %d2,%d8
800062bc:	4b 02 41 21 	itof %d2,%d2
800062c0:	4b 23 51 20 	div.f %d2,%d3,%d2
800062c4:	00 90       	ret 
    }
    else if (scuFdr.B.DM == 2)
800062c6:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
800062ca:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
800062cc:	7e 49       	jne %d15,%d4,800062de <IfxScuCcu_getModuleFrequency+0x48>
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
800062ce:	4b 08 41 21 	itof %d2,%d8
800062d2:	7b 00 a8 f3 	movh %d15,14976
800062d6:	4b 23 41 20 	mul.f %d2,%d3,%d2
800062da:	4b f2 41 20 	mul.f %d2,%d2,%d15
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
800062de:	00 90       	ret 

800062e0 <IfxScuCcu_getSriFrequency>:
float32 IfxScuCcu_getSriFrequency(void)
{
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800062e0:	6d ff de fe 	call 8000609c <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
800062e4:	91 30 00 ff 	movh.a %a15,61443
800062e8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800062ec:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0;
800062ee:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800062f0:	37 03 64 36 	extr.u %d3,%d3,12,4
800062f4:	ff 53 31 80 	jge.u %d3,5,80006356 <IfxScuCcu_getSriFrequency+0x76>
800062f8:	91 00 00 f8 	movh.a %a15,32768
800062fc:	d9 ff 08 c6 	lea %a15,[%a15]25352 <80006308 <IfxScuCcu_getSriFrequency+0x28>>
80006300:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80006304:	dc 0f       	ji %a15
80006306:	00 00       	nop 
80006308:	1d 00 0a 00 	j 8000631c <IfxScuCcu_getSriFrequency+0x3c>
8000630c:	1d 00 18 00 	j 8000633c <IfxScuCcu_getSriFrequency+0x5c>
80006310:	1d 00 19 00 	j 80006342 <IfxScuCcu_getSriFrequency+0x62>
80006314:	1d 00 1a 00 	j 80006348 <IfxScuCcu_getSriFrequency+0x68>
80006318:	1d 00 1b 00 	j 8000634e <IfxScuCcu_getSriFrequency+0x6e>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
8000631c:	91 30 00 ff 	movh.a %a15,61443
80006320:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006324:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0;
80006326:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80006328:	37 03 64 34 	extr.u %d3,%d3,8,4
8000632c:	df 03 15 00 	jeq %d3,0,80006356 <IfxScuCcu_getSriFrequency+0x76>
        {
            sriFrequency = 0.0;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80006330:	4c f0       	ld.w %d15,[%a15]0
80006332:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80006336:	4b 0f 41 f1 	itof %d15,%d15
8000633a:	3c 0c       	j 80006352 <IfxScuCcu_getSriFrequency+0x72>
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
8000633c:	7b 00 1f f4 	movh %d15,16880
80006340:	3c 09       	j 80006352 <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
80006342:	7b 00 27 f4 	movh %d15,17008
80006346:	3c 06       	j 80006352 <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80006348:	7b 00 2f f4 	movh %d15,17136
8000634c:	3c 03       	j 80006352 <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
8000634e:	7b 00 37 f4 	movh %d15,17264
80006352:	4b f2 51 f0 	div.f %d15,%d2,%d15
        sriFrequency = 0.0;
        break;
    }

    return sriFrequency;
}
80006356:	02 f2       	mov %d2,%d15
80006358:	00 90       	ret 

8000635a <IfxScuCcu_getCpuFrequency>:
    return bbbFrequency;
}


float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
8000635a:	02 4f       	mov %d15,%d4
    float32 frequency = IfxScuCcu_getSriFrequency();
8000635c:	6d ff c2 ff 	call 800062e0 <IfxScuCcu_getSriFrequency>
    uint32  cpuDiv    = 0;

    switch (cpu)
80006360:	1e 1d       	jeq %d15,1,8000637a <IfxScuCcu_getCpuFrequency+0x20>
80006362:	6e 07       	jz %d15,80006370 <IfxScuCcu_getCpuFrequency+0x16>
80006364:	de 2a       	jne %d15,2,80006398 <IfxScuCcu_getCpuFrequency+0x3e>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
80006366:	91 30 00 ff 	movh.a %a15,61443
8000636a:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
8000636e:	3c 0a       	j 80006382 <IfxScuCcu_getCpuFrequency+0x28>
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
80006370:	91 30 00 ff 	movh.a %a15,61443
80006374:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006378:	3c 05       	j 80006382 <IfxScuCcu_getCpuFrequency+0x28>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
8000637a:	91 30 00 ff 	movh.a %a15,61443
8000637e:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
80006382:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0;
        break;
    }

    if (cpuDiv != 0)
80006384:	6e 0b       	jz %d15,8000639a <IfxScuCcu_getCpuFrequency+0x40>
    {
        frequency = frequency * (cpuDiv / 64.0f);
80006386:	4b 0f 61 f1 	utof %d15,%d15
8000638a:	7b 00 c8 33 	movh %d3,15488
8000638e:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80006392:	4b f2 41 20 	mul.f %d2,%d2,%d15
80006396:	00 90       	ret 
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0;
80006398:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
8000639a:	00 90       	ret 

8000639c <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000639c:	91 30 00 ff 	movh.a %a15,61443
800063a0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063a4:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
800063a6:	7b 00 03 30 	movh %d3,48
800063aa:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800063ac:	37 0f 62 8a 	extr.u %d8,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
800063b0:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
800063b2:	76 3f       	jz %d3,800063d0 <IfxScuCcu_getFsi2Frequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800063b4:	6d ff 96 ff 	call 800062e0 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800063b8:	3b 00 f0 30 	mov %d3,3840
800063bc:	26 3f       	and %d15,%d3
800063be:	1b 0f f0 ff 	addi %d15,%d15,-256
800063c2:	8f 0f d0 f1 	andn %d15,%d15,256
800063c6:	ee 05       	jnz %d15,800063d0 <IfxScuCcu_getFsi2Frequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
800063c8:	4b 08 41 f1 	itof %d15,%d8
800063cc:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
800063d0:	00 90       	ret 

800063d2 <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800063d2:	91 30 00 ff 	movh.a %a15,61443
800063d6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063da:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
800063dc:	7b 00 30 30 	movh %d3,768
800063e0:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800063e2:	37 0f 62 8c 	extr.u %d8,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
800063e6:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
800063e8:	76 3f       	jz %d3,80006406 <IfxScuCcu_getFsiFrequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800063ea:	6d ff 7b ff 	call 800062e0 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800063ee:	3b 00 f0 30 	mov %d3,3840
800063f2:	26 3f       	and %d15,%d3
800063f4:	1b 0f f0 ff 	addi %d15,%d15,-256
800063f8:	8f 0f d0 f1 	andn %d15,%d15,256
800063fc:	ee 05       	jnz %d15,80006406 <IfxScuCcu_getFsiFrequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
800063fe:	4b 08 41 f1 	itof %d15,%d8
80006402:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
80006406:	00 90       	ret 

80006408 <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80006408:	19 4f 10 10 	ld.w %d15,[%a4]80
8000640c:	91 00 00 c7 	movh.a %a12,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
80006410:	40 4f       	mov.aa %a15,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80006412:	59 cf 08 40 	st.w [%a12]264 <70000108 <IfxScuCcu_xtalFrequency>>,%d15

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
80006416:	6d 00 c8 07 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
8000641a:	02 29       	mov %d9,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
8000641c:	6d 00 e3 07 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006420:	02 94       	mov %d4,%d9
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80006422:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006424:	6d 00 c1 06 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006428:	91 30 00 2f 	movh.a %a2,61443
8000642c:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006430:	54 2c       	ld.w %d12,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;
80006432:	4c 20       	ld.w %d15,[%a2]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006434:	02 94       	mov %d4,%d9

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006436:	96 08       	or %d15,8
80006438:	6c 20       	st.w [%a2]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000643a:	6d 00 eb 07 	call 80007410 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000643e:	02 84       	mov %d4,%d8
80006440:	6d 00 ce 06 	call 800071dc <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006444:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
80006448:	91 30 00 3f 	movh.a %a3,61443
8000644c:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006450:	4c 30       	ld.w %d15,[%a3]0
80006452:	91 30 00 2f 	movh.a %a2,61443
80006456:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000645a:	bf 0f fb 7f 	jlt %d15,0,80006450 <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
8000645e:	4c 20       	ld.w %d15,[%a2]0
80006460:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006464:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006466:	4c 20       	ld.w %d15,[%a2]0
80006468:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000646c:	6c 20       	st.w [%a2]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
8000646e:	91 30 00 2f 	movh.a %a2,61443
80006472:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006476:	4c 20       	ld.w %d15,[%a2]0
80006478:	96 10       	or %d15,16
8000647a:	6c 20       	st.w [%a2]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON0.B.LCK != 0U)
8000647c:	91 30 00 2f 	movh.a %a2,61443
80006480:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006484:	4c 20       	ld.w %d15,[%a2]0
80006486:	bf 0f ff 7f 	jlt %d15,0,80006484 <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
8000648a:	91 30 00 2f 	movh.a %a2,61443
8000648e:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006492:	4c 20       	ld.w %d15,[%a2]0
80006494:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
80006498:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
8000649a:	4c 20       	ld.w %d15,[%a2]0
8000649c:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800064a0:	6c 20       	st.w [%a2]0,%d15
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800064a2:	6d 00 82 07 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800064a6:	91 30 00 2f 	movh.a %a2,61443
800064aa:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800064ae:	02 2f       	mov %d15,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800064b0:	54 22       	ld.w %d2,[%a2]

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800064b2:	40 23       	mov.aa %a3,%a2
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800064b4:	8f 02 c6 21 	andn %d2,%d2,96
800064b8:	74 22       	st.w [%a2],%d2

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
800064ba:	19 c6 08 40 	ld.w %d6,[%a12]264 <70000108 <IfxScuCcu_xtalFrequency>>
800064be:	7b 60 02 20 	movh %d2,38
800064c2:	1b 02 5a 22 	addi %d2,%d2,9632
800064c6:	4b 26 11 62 	div.u %e6,%d6,%d2
800064ca:	54 22       	ld.w %d2,[%a2]
800064cc:	c2 f6       	add %d6,-1
800064ce:	37 62 05 68 	insert %d6,%d2,%d6,16,5
800064d2:	74 26       	st.w [%a2],%d6

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
800064d4:	54 22       	ld.w %d2,[%a2]
800064d6:	8f 42 40 21 	or %d2,%d2,4
800064da:	74 22       	st.w [%a2],%d2

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800064dc:	c5 02 3f 90 	lea %a2,27f <_.+0x27e>
800064e0:	54 32       	ld.w %d2,[%a3]
800064e2:	6f 12 05 80 	jnz.t %d2,1,800064ec <IfxScuCcu_init+0xe4>
800064e6:	fc 2d       	loop %a2,800064e0 <IfxScuCcu_init+0xd8>
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
800064e8:	82 1b       	mov %d11,1
800064ea:	3c 05       	j 800064f4 <IfxScuCcu_init+0xec>

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800064ec:	54 32       	ld.w %d2,[%a3]
800064ee:	6f 82 fc 7f 	jz.t %d2,8,800064e6 <IfxScuCcu_init+0xde>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
800064f2:	82 0b       	mov %d11,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800064f4:	02 f4       	mov %d4,%d15
800064f6:	6d 00 58 06 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800064fa:	91 30 00 2f 	movh.a %a2,61443
800064fe:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
80006502:	54 22       	ld.w %d2,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
80006504:	02 f4       	mov %d4,%d15
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80006506:	8f 82 40 21 	or %d2,%d2,8
8000650a:	74 22       	st.w [%a2],%d2
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
8000650c:	91 30 00 2f 	movh.a %a2,61443
80006510:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006514:	54 22       	ld.w %d2,[%a2]
80006516:	8f 82 40 21 	or %d2,%d2,8
8000651a:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinitPw);
8000651c:	6d 00 7a 07 	call 80007410 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006520:	02 84       	mov %d4,%d8
80006522:	6d 00 e3 07 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
    }

    if (status == 0)
80006526:	df 0b 29 81 	jne %d11,0,80006778 <IfxScuCcu_init+0x370>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000652a:	02 84       	mov %d4,%d8
8000652c:	6d 00 58 06 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006530:	91 30 00 2f 	movh.a %a2,61443
80006534:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006538:	4c 20       	ld.w %d15,[%a2]0
8000653a:	6f 5f ff 7f 	jz.t %d15,5,80006538 <IfxScuCcu_init+0x130>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
8000653e:	91 30 00 2f 	movh.a %a2,61443
80006542:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80006546:	54 22       	ld.w %d2,[%a2]
80006548:	0c fa       	ld.bu %d15,[%a15]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000654a:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
8000654e:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006552:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80006556:	6c 20       	st.w [%a2]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80006558:	91 30 00 2f 	movh.a %a2,61443
8000655c:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006560:	54 22       	ld.w %d2,[%a2]
80006562:	0c f8       	ld.bu %d15,[%a15]8
80006564:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80006568:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
8000656a:	54 22       	ld.w %d2,[%a2]
8000656c:	0c f9       	ld.bu %d15,[%a15]9
8000656e:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
80006572:	6c 20       	st.w [%a2]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
80006574:	4c 20       	ld.w %d15,[%a2]0
80006576:	96 40       	or %d15,64
80006578:	6c 20       	st.w [%a2]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
8000657a:	4c 20       	ld.w %d15,[%a2]0
8000657c:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80006580:	6c 20       	st.w [%a2]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
80006582:	4c 20       	ld.w %d15,[%a2]0
80006584:	96 20       	or %d15,32
80006586:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
80006588:	4c 20       	ld.w %d15,[%a2]0
8000658a:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
8000658e:	6c 20       	st.w [%a2]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
80006590:	4c 20       	ld.w %d15,[%a2]0
80006592:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80006596:	6c 20       	st.w [%a2]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006598:	6d ff 94 fd 	call 800060c0 <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
8000659c:	91 30 00 2f 	movh.a %a2,61443
800065a0:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800065a4:	4c 20       	ld.w %d15,[%a2]0
800065a6:	6f 2f ff 7f 	jz.t %d15,2,800065a4 <IfxScuCcu_init+0x19c>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800065aa:	91 30 00 2f 	movh.a %a2,61443
800065ae:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800065b2:	4c 20       	ld.w %d15,[%a2]0

                    while (SCU_CCUCON0.B.LCK != 0U)
800065b4:	91 30 00 3f 	movh.a %a3,61443
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800065b8:	8f 1f c0 f1 	andn %d15,%d15,1
800065bc:	6c 20       	st.w [%a2]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
800065be:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800065c2:	4c 30       	ld.w %d15,[%a3]0
800065c4:	91 30 00 2f 	movh.a %a2,61443
800065c8:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800065cc:	bf 0f fb 7f 	jlt %d15,0,800065c2 <IfxScuCcu_init+0x1ba>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
800065d0:	4c 20       	ld.w %d15,[%a2]0
800065d2:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
800065d6:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
800065d8:	4c 20       	ld.w %d15,[%a2]0
800065da:	91 30 00 cf 	movh.a %a12,61443
800065de:	d9 cc 30 06 	lea %a12,[%a12]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800065e2:	bf 0f fb 7f 	jlt %d15,0,800065d8 <IfxScuCcu_init+0x1d0>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
800065e6:	48 34       	ld.w %d4,[%a15]12
800065e8:	6d ff 6c fd 	call 800060c0 <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800065ec:	4c f5       	ld.w %d15,[%a15]20
800065ee:	54 c3       	ld.w %d3,[%a12]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800065f0:	48 42       	ld.w %d2,[%a15]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800065f2:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800065f6:	26 f2       	and %d2,%d15
800065f8:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
800065fc:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
80006600:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
80006604:	91 30 00 3f 	movh.a %a3,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
80006608:	6c c0       	st.w [%a12]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
8000660a:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000660e:	4c 30       	ld.w %d15,[%a3]0
80006610:	91 30 00 2f 	movh.a %a2,61443
80006614:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006618:	bf 0f fb 7f 	jlt %d15,0,8000660e <IfxScuCcu_init+0x206>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
8000661c:	4c f7       	ld.w %d15,[%a15]28
8000661e:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80006620:	48 62       	ld.w %d2,[%a15]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80006622:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80006626:	26 f2       	and %d2,%d15
80006628:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon1.B.INSEL = 1;
8000662c:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
80006630:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80006634:	91 30 00 3f 	movh.a %a3,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
80006638:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
8000663a:	d9 33 00 16 	lea %a3,[%a3]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
8000663e:	4c 30       	ld.w %d15,[%a3]0
80006640:	91 30 00 2f 	movh.a %a2,61443
80006644:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80006648:	bf 0f fb 7f 	jlt %d15,0,8000663e <IfxScuCcu_init+0x236>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
8000664c:	4c f9       	ld.w %d15,[%a15]36
8000664e:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80006650:	48 82       	ld.w %d2,[%a15]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80006652:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80006656:	26 f2       	and %d2,%d15
80006658:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon2.B.UP = 1;
8000665c:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
80006660:	91 30 00 3f 	movh.a %a3,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
80006664:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
80006666:	d9 33 0c 16 	lea %a3,[%a3]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
8000666a:	4c 30       	ld.w %d15,[%a3]0
8000666c:	91 30 00 2f 	movh.a %a2,61443
80006670:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80006674:	bf 0f fb 7f 	jlt %d15,0,8000666a <IfxScuCcu_init+0x262>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80006678:	54 23       	ld.w %d3,[%a2]
8000667a:	4c fb       	ld.w %d15,[%a15]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000667c:	48 a2       	ld.w %d2,[%a15]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
8000667e:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80006682:	26 f2       	and %d2,%d15
80006684:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon5.B.UP = 1;
80006688:	b7 1f 01 ff 	insert %d15,%d15,1,30,1

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
8000668c:	48 c2       	ld.w %d2,[%a15]48
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
8000668e:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80006690:	91 30 00 2f 	movh.a %a2,61443
80006694:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006698:	54 23       	ld.w %d3,[%a2]
8000669a:	4c fd       	ld.w %d15,[%a15]52
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
                        SCU_CCUCON8 = ccucon8;
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000669c:	02 84       	mov %d4,%d8
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
8000669e:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
800066a2:	26 f2       	and %d2,%d15
800066a4:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON6 = ccucon6;
800066a8:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800066aa:	91 30 00 2f 	movh.a %a2,61443
800066ae:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
800066b2:	54 23       	ld.w %d3,[%a2]
800066b4:	4c ff       	ld.w %d15,[%a15]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800066b6:	48 e2       	ld.w %d2,[%a15]56
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800066b8:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800066bc:	26 f2       	and %d2,%d15
800066be:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON7 = ccucon7;
800066c2:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800066c4:	91 30 00 2f 	movh.a %a2,61443
800066c8:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800066cc:	54 23       	ld.w %d3,[%a2]
800066ce:	19 ff 04 10 	ld.w %d15,[%a15]68 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800066d2:	19 f2 00 10 	ld.w %d2,[%a15]64 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800066d6:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800066da:	26 f2       	and %d2,%d15
800066dc:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON8 = ccucon8;
800066e0:	6c 20       	st.w [%a2]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066e2:	6d 00 03 07 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
800066e6:	91 00 80 cf 	movh.a %a12,63488
800066ea:	d9 cc 14 02 	lea %a12,[%a12]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800066ee:	19 ff 0c 10 	ld.w %d15,[%a15]76 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800066f2:	54 c3       	ld.w %d3,[%a12]

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800066f4:	19 f2 08 10 	ld.w %d2,[%a15]72 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
800066f8:	0f f3 e0 30 	andn %d3,%d3,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800066fc:	26 f2       	and %d2,%d15
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800066fe:	02 94       	mov %d4,%d9
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006700:	0f 23 a0 f0 	or %d15,%d3,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80006704:	6d 00 51 05 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
80006708:	6c c0       	st.w [%a12]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
8000670a:	02 94       	mov %d4,%d9
8000670c:	6d 00 82 06 	call 80007410 <IfxScuWdt_setCpuEndinit>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006710:	91 30 00 df 	movh.a %a13,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006714:	91 30 00 cf 	movh.a %a12,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80006718:	82 0d       	mov %d13,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000671a:	d9 dd 14 06 	lea %a13,[%a13]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
8000671e:	d9 cc 1c 06 	lea %a12,[%a12]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80006722:	0c f0       	ld.bu %d15,[%a15]0
80006724:	8f fd 0f 21 	and %d2,%d13,255
80006728:	7f f2 28 80 	jge.u %d2,%d15,80006778 <IfxScuCcu_init+0x370>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000672c:	02 84       	mov %d4,%d8
8000672e:	6d 00 57 05 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006732:	4c d0       	ld.w %d15,[%a13]0
80006734:	6f 5f ff 7f 	jz.t %d15,5,80006732 <IfxScuCcu_init+0x32a>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006738:	02 df       	mov %d15,%d13
8000673a:	16 ff       	and %d15,255
8000673c:	53 cf 20 a0 	mul %d10,%d15,12
80006740:	c8 12       	ld.a %a2,[%a15]4
80006742:	4c c0       	ld.w %d15,[%a12]0
80006744:	60 a3       	mov.a %a3,%d10
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006746:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006748:	30 32       	add.a %a2,%a3
8000674a:	14 22       	ld.bu %d2,[%a2]
8000674c:	37 2f 07 20 	insert %d2,%d15,%d2,0,7
80006750:	74 c2       	st.w [%a12],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006752:	6d 00 cb 06 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
80006756:	c8 12       	ld.a %a2,[%a15]4
80006758:	60 a3       	mov.a %a3,%d10
8000675a:	30 32       	add.a %a2,%a3
8000675c:	99 22 08 00 	ld.a %a2,[%a2]8
80006760:	bc 23       	jz.a %a2,80006766 <IfxScuCcu_init+0x35e>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
80006762:	2d 02 00 00 	calli %a2
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
80006766:	c8 12       	ld.a %a2,[%a15]4
80006768:	60 a3       	mov.a %a3,%d10
8000676a:	c2 1d       	add %d13,1
8000676c:	30 32       	add.a %a2,%a3
8000676e:	19 24 04 00 	ld.w %d4,[%a2]4
80006772:	6d ff a7 fc 	call 800060c0 <IfxScuCcu_wait>
80006776:	3c d6       	j 80006722 <IfxScuCcu_init+0x31a>
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006778:	02 84       	mov %d4,%d8
8000677a:	6d 00 31 05 	call 800071dc <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000677e:	91 30 00 ff 	movh.a %a15,61443
80006782:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006786:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006788:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000678a:	8f 0f c4 f1 	andn %d15,%d15,64
8000678e:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006790:	6d 00 ac 06 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006794:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006798:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;
8000679a:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000679e:	6d 00 04 05 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
800067a2:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800067a4:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800067a6:	96 08       	or %d15,8
800067a8:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800067aa:	91 30 00 ff 	movh.a %a15,61443
800067ae:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800067b2:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800067b4:	02 94       	mov %d4,%d9
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800067b6:	8f 8f c0 f1 	andn %d15,%d15,8
800067ba:	a6 fc       	or %d12,%d15
800067bc:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
800067be:	6d 00 29 06 	call 80007410 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
800067c2:	02 b2       	mov %d2,%d11
800067c4:	00 90       	ret 

800067c6 <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
800067c6:	91 00 00 f8 	movh.a %a15,32768
800067ca:	d9 ff a8 90 	lea %a15,[%a15]2664 <80000a68 <IfxScuCcu_defaultClockConfig>>
800067ce:	c5 02 14 00 	lea %a2,14 <_.+0x13>
800067d2:	44 ff       	ld.w %d15,[%a15+]
800067d4:	64 4f       	st.w [%a4+],%d15
800067d6:	fc 2e       	loop %a2,800067d2 <IfxScuCcu_initConfig+0xc>
800067d8:	00 90       	ret 

800067da <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
800067da:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
800067dc:	6d 00 e5 05 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
800067e0:	02 2f       	mov %d15,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800067e2:	6d 00 00 06 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800067e6:	02 f4       	mov %d4,%d15
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800067e8:	02 28       	mov %d8,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800067ea:	6d 00 de 04 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800067ee:	91 30 00 ff 	movh.a %a15,61443
800067f2:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800067f6:	48 03       	ld.w %d3,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
800067f8:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800067fa:	02 f4       	mov %d4,%d15
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800067fc:	8f 82 40 21 	or %d2,%d2,8
80006800:	68 02       	st.w [%a15]0,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006802:	37 03 e1 a1 	extr.u %d10,%d3,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006806:	6d 00 05 06 	call 80007410 <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000680a:	02 84       	mov %d4,%d8
8000680c:	6d 00 e8 04 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
80006810:	91 30 00 ff 	movh.a %a15,61443
80006814:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006818:	48 02       	ld.w %d2,[%a15]0
8000681a:	ef 02 0c 00 	jz.t %d2,16,80006832 <IfxScuCcu_initErayPll+0x58>
8000681e:	48 02       	ld.w %d2,[%a15]0
80006820:	6f 12 09 80 	jnz.t %d2,1,80006832 <IfxScuCcu_initErayPll+0x58>
80006824:	91 30 00 ff 	movh.a %a15,61443
80006828:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000682c:	48 02       	ld.w %d2,[%a15]0
8000682e:	6f 12 19 00 	jz.t %d2,1,80006860 <IfxScuCcu_initErayPll+0x86>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
80006832:	91 30 00 ff 	movh.a %a15,61443
80006836:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000683a:	48 02       	ld.w %d2,[%a15]0
8000683c:	b7 f2 01 28 	insert %d2,%d2,15,16,1
80006840:	68 02       	st.w [%a15]0,%d2
        SCU_PLLERAYCON0.B.VCOPWD = 0;
80006842:	48 02       	ld.w %d2,[%a15]0
80006844:	8f 22 c0 21 	andn %d2,%d2,2
80006848:	68 02       	st.w [%a15]0,%d2

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
8000684a:	91 30 00 ff 	movh.a %a15,61443
8000684e:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006852:	48 02       	ld.w %d2,[%a15]0
80006854:	6f 12 ff ff 	jnz.t %d2,1,80006852 <IfxScuCcu_initErayPll+0x78>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
80006858:	19 c4 04 00 	ld.w %d4,[%a12]4
8000685c:	6d ff 32 fc 	call 800060c0 <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
80006860:	91 30 00 ff 	movh.a %a15,61443
80006864:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006868:	48 02       	ld.w %d2,[%a15]0
8000686a:	6f 02 15 80 	jnz.t %d2,0,80006894 <IfxScuCcu_initErayPll+0xba>
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
8000686e:	48 02       	ld.w %d2,[%a15]0
80006870:	6f 42 ff 7f 	jz.t %d2,4,8000686e <IfxScuCcu_initErayPll+0x94>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
80006874:	91 30 00 ff 	movh.a %a15,61443
80006878:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
8000687c:	48 02       	ld.w %d2,[%a15]0
8000687e:	b7 32 07 28 	insert %d2,%d2,3,16,7
80006882:	68 02       	st.w [%a15]0,%d2

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
80006884:	91 30 00 ff 	movh.a %a15,61443
80006888:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000688c:	48 02       	ld.w %d2,[%a15]0
8000688e:	8f 12 40 21 	or %d2,%d2,1
80006892:	68 02       	st.w [%a15]0,%d2
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
80006894:	91 30 00 ff 	movh.a %a15,61443
80006898:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000689c:	48 02       	ld.w %d2,[%a15]0
8000689e:	6f 52 ff 7f 	jz.t %d2,5,8000689c <IfxScuCcu_initErayPll+0xc2>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
800068a2:	91 30 00 ff 	movh.a %a15,61443
800068a6:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800068aa:	48 03       	ld.w %d3,[%a15]0
800068ac:	39 c2 02 00 	ld.bu %d2,[%a12]2 <f0030000 <_SMALL_DATA4_+0x40028000>>
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800068b0:	02 84       	mov %d4,%d8
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
800068b2:	37 23 07 20 	insert %d2,%d3,%d2,0,7
800068b6:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
800068b8:	91 30 00 ff 	movh.a %a15,61443
800068bc:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800068c0:	48 03       	ld.w %d3,[%a15]0
800068c2:	14 c2       	ld.bu %d2,[%a12]
800068c4:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800068c8:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
800068ca:	48 03       	ld.w %d3,[%a15]0
800068cc:	39 c2 01 00 	ld.bu %d2,[%a12]1
800068d0:	37 23 85 24 	insert %d2,%d3,%d2,9,5
800068d4:	68 02       	st.w [%a15]0,%d2
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
800068d6:	48 02       	ld.w %d2,[%a15]0
800068d8:	b7 f2 01 29 	insert %d2,%d2,15,18,1
800068dc:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
800068de:	48 02       	ld.w %d2,[%a15]0
800068e0:	8f 02 42 21 	or %d2,%d2,32
800068e4:	68 02       	st.w [%a15]0,%d2

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800068e6:	6d 00 01 06 	call 800074e8 <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
800068ea:	91 10 00 f0 	movh.a %a15,1
800068ee:	91 30 00 2f 	movh.a %a2,61443
800068f2:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800068f6:	d9 ff 0f dc 	lea %a15,[%a15]-15537 <c34f <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4f>>
800068fa:	fd f0 04 00 	loop %a15,80006902 <IfxScuCcu_initErayPll+0x128>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
800068fe:	82 19       	mov %d9,1
80006900:	3c 05       	j 8000690a <IfxScuCcu_initErayPll+0x130>
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
80006902:	54 22       	ld.w %d2,[%a2]
80006904:	6f 22 fb 7f 	jz.t %d2,2,800068fa <IfxScuCcu_initErayPll+0x120>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
80006908:	82 09       	mov %d9,0
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000690a:	02 84       	mov %d4,%d8
8000690c:	6d 00 68 04 	call 800071dc <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
80006910:	91 30 00 ff 	movh.a %a15,61443
80006914:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006918:	48 02       	ld.w %d2,[%a15]0
8000691a:	8f 12 c0 21 	andn %d2,%d2,1
8000691e:	68 02       	st.w [%a15]0,%d2

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
80006920:	91 30 00 ff 	movh.a %a15,61443
80006924:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006928:	48 02       	ld.w %d2,[%a15]0
8000692a:	6f 02 ff ff 	jnz.t %d2,0,80006928 <IfxScuCcu_initErayPll+0x14e>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
8000692e:	91 30 00 ff 	movh.a %a15,61443
80006932:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006936:	48 02       	ld.w %d2,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006938:	02 84       	mov %d4,%d8

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
8000693a:	37 02 61 21 	extr.u %d2,%d2,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000693e:	91 30 00 ff 	movh.a %a15,61443
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
80006942:	ab 19 80 92 	sel %d9,%d2,%d9,1
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006946:	6d 00 d1 05 	call 800074e8 <IfxScuWdt_setSafetyEndinit>

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000694a:	02 f4       	mov %d4,%d15
8000694c:	6d 00 2d 04 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006950:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
80006954:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006956:	8f 3a 00 30 	sh %d3,%d10,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000695a:	8f 82 40 21 	or %d2,%d2,8
8000695e:	68 02       	st.w [%a15]0,%d2
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006960:	91 30 00 ff 	movh.a %a15,61443
80006964:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006968:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000696a:	02 f4       	mov %d4,%d15
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000696c:	8f 82 c0 21 	andn %d2,%d2,8
80006970:	a6 32       	or %d2,%d3
80006972:	68 02       	st.w [%a15]0,%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006974:	6d 00 4e 05 	call 80007410 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80006978:	02 92       	mov %d2,%d9
8000697a:	00 90       	ret 

8000697c <IfxScuCcu_initErayPllConfig>:


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
8000697c:	91 00 00 f8 	movh.a %a15,32768
80006980:	d9 ff a0 90 	lea %a15,[%a15]2656 <80000a60 <IfxScuCcu_defaultErayPllConfig>>
80006984:	09 f2 40 09 	ld.d %e2,[%a15]
80006988:	89 42 40 09 	st.d [%a4],%e2
8000698c:	00 90       	ret 

8000698e <IfxScuCcu_setCpuFrequency>:
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
8000698e:	02 5a       	mov %d10,%d5
80006990:	02 49       	mov %d9,%d4
    uint16  endinitSfty_pw;
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();
80006992:	6d ff a7 fc 	call 800062e0 <IfxScuCcu_getSriFrequency>
80006996:	02 2f       	mov %d15,%d2

    if (cpuFreq >= sriFreq)
80006998:	4b 2a 01 20 	cmp.f %d2,%d10,%d2
8000699c:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
    {
        cpuDiv = 0;
800069a0:	82 08       	mov %d8,0
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
800069a2:	f6 29       	jnz %d2,800069b4 <IfxScuCcu_setCpuFrequency+0x26>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
800069a4:	7b 00 28 84 	movh %d8,17024
800069a8:	4b 8a 41 80 	mul.f %d8,%d10,%d8
800069ac:	4b f8 51 80 	div.f %d8,%d8,%d15
800069b0:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800069b4:	6d 00 17 05 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800069b8:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800069ba:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800069bc:	6d 00 10 04 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
800069c0:	df 19 0f 00 	jeq %d9,1,800069de <IfxScuCcu_setCpuFrequency+0x50>
800069c4:	76 98       	jz %d9,800069d4 <IfxScuCcu_setCpuFrequency+0x46>
800069c6:	df 29 11 80 	jne %d9,2,800069e8 <IfxScuCcu_setCpuFrequency+0x5a>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800069ca:	91 30 00 ff 	movh.a %a15,61443
800069ce:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800069d2:	3c 0a       	j 800069e6 <IfxScuCcu_setCpuFrequency+0x58>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
800069d4:	91 30 00 ff 	movh.a %a15,61443
800069d8:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800069dc:	3c 05       	j 800069e6 <IfxScuCcu_setCpuFrequency+0x58>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
800069de:	91 30 00 ff 	movh.a %a15,61443
800069e2:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800069e6:	68 08       	st.w [%a15]0,%d8

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800069e8:	02 a4       	mov %d4,%d10
800069ea:	6d 00 7f 05 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
800069ee:	76 89       	jz %d8,80006a00 <IfxScuCcu_setCpuFrequency+0x72>
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
800069f0:	4b 08 61 81 	utof %d8,%d8
800069f4:	7b 00 c8 23 	movh %d2,15488
800069f8:	4b 28 41 80 	mul.f %d8,%d8,%d2
800069fc:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
80006a00:	02 f2       	mov %d2,%d15
80006a02:	00 90       	ret 

80006a04 <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80006a04:	91 30 00 ff 	movh.a %a15,61443
80006a08:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
    return sriFreq;
}


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
80006a0c:	02 48       	mov %d8,%d4
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80006a0e:	4c f0       	ld.w %d15,[%a15]0

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006a10:	6d ff 46 fb 	call 8000609c <IfxScuCcu_getSourceFrequency>
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
80006a14:	4b 82 51 20 	div.f %d2,%d2,%d8
80006a18:	4b 02 31 31 	ftoiz %d3,%d2
80006a1c:	4b 03 41 41 	itof %d4,%d3
80006a20:	6b 04 31 22 	sub.f %d2,%d2,%d4
80006a24:	7b 00 f0 43 	movh %d4,16128
80006a28:	4b 42 01 20 	cmp.f %d2,%d2,%d4
80006a2c:	37 02 61 21 	extr.u %d2,%d2,2,1
80006a30:	42 32       	add %d2,%d3
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80006a32:	82 13       	mov %d3,1
80006a34:	0b 32 b0 21 	max.u %d2,%d2,%d3
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
80006a38:	8b e2 00 52 	eq %d5,%d2,14
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
80006a3c:	1b 92 ff 4f 	addi %d4,%d2,-7
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
    {
        gtmDiv = 12;
80006a40:	ab c2 a0 95 	seln %d9,%d5,%d2,12
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
80006a44:	8f 12 c0 31 	andn %d3,%d2,1
80006a48:	02 92       	mov %d2,%d9
80006a4a:	8b 74 a0 92 	ge.u %d9,%d4,7
80006a4e:	2b 32 40 99 	sel %d9,%d9,%d2,%d3
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006a52:	6d 00 c8 04 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006a56:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006a58:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006a5a:	6d 00 c1 03 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
80006a5e:	40 f2       	mov.aa %a2,%a15
80006a60:	54 22       	ld.w %d2,[%a2]
80006a62:	91 30 00 ff 	movh.a %a15,61443
80006a66:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006a6a:	bf 02 fb 7f 	jlt %d2,0,80006a60 <IfxScuCcu_setGtmFrequency+0x5c>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
80006a6e:	37 9f 04 f6 	insert %d15,%d15,%d9,12,4
    ccucon1.B.UP     = 1U;
80006a72:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a76:	02 84       	mov %d4,%d8
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
80006a78:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a7a:	6d 00 37 05 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
80006a7e:	6d ff 0f fb 	call 8000609c <IfxScuCcu_getSourceFrequency>
80006a82:	4c f0       	ld.w %d15,[%a15]0
80006a84:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80006a88:	4b 0f 41 f1 	itof %d15,%d15

    return IfxScuCcu_getGtmFrequency();
}
80006a8c:	4b f2 51 20 	div.f %d2,%d2,%d15
80006a90:	00 90       	ret 

80006a92 <IfxScuCcu_setPll2ErayFrequency>:


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
80006a92:	02 48       	mov %d8,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80006a94:	6d 00 a7 04 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
80006a98:	02 2f       	mov %d15,%d2
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006a9a:	6d ff 84 fa 	call 80005fa2 <IfxScuCcu_getPllErayVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(password);
80006a9e:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006aa0:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(password);
80006aa2:	6d 00 9d 03 	call 800071dc <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006aa6:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80006aaa:	91 30 00 ff 	movh.a %a15,61443
80006aae:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006ab2:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006ab4:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
80006ab8:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006aba:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006abe:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80006ac2:	37 82 04 84 	insert %d8,%d2,%d8,8,4
80006ac6:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(password);
80006ac8:	6d 00 10 05 	call 800074e8 <IfxScuWdt_setSafetyEndinit>

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
80006acc:	6d ff 6b fa 	call 80005fa2 <IfxScuCcu_getPllErayVcoFrequency>
80006ad0:	4c f0       	ld.w %d15,[%a15]0
80006ad2:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80006ad6:	c2 1f       	add %d15,1
80006ad8:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
80006adc:	4b f2 51 20 	div.f %d2,%d2,%d15
80006ae0:	00 90       	ret 

80006ae2 <IfxScuCcu_setPll2Frequency>:


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
80006ae2:	02 48       	mov %d8,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006ae4:	6d 00 7f 04 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
80006ae8:	02 2f       	mov %d15,%d2
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006aea:	6d ff b7 fa 	call 80006058 <IfxScuCcu_getPllVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006aee:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006af0:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006af2:	6d 00 75 03 	call 800071dc <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006af6:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006afa:	91 30 00 ff 	movh.a %a15,61443
80006afe:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80006b02:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006b04:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006b08:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006b0a:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006b0e:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006b12:	37 82 07 84 	insert %d8,%d2,%d8,8,7
80006b16:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006b18:	6d 00 e8 04 	call 800074e8 <IfxScuWdt_setSafetyEndinit>


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80006b1c:	6d ff 9e fa 	call 80006058 <IfxScuCcu_getPllVcoFrequency>
80006b20:	4c f0       	ld.w %d15,[%a15]0
80006b22:	37 0f 67 f4 	extr.u %d15,%d15,8,7
80006b26:	c2 1f       	add %d15,1
80006b28:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2Frequency();
}
80006b2c:	4b f2 51 20 	div.f %d2,%d2,%d15
80006b30:	00 90       	ret 

80006b32 <IfxScuCcu_setSpbFrequency>:


float32 IfxScuCcu_setSpbFrequency(float32 spbFreq)
{
80006b32:	02 4f       	mov %d15,%d4
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006b34:	6d ff b4 fa 	call 8000609c <IfxScuCcu_getSourceFrequency>
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80006b38:	4b f2 51 20 	div.f %d2,%d2,%d15
80006b3c:	82 24       	mov %d4,2
80006b3e:	4b 02 71 21 	ftouz %d2,%d2
80006b42:	0b 42 b0 41 	max.u %d4,%d2,%d4
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
80006b46:	8b e4 00 32 	eq %d3,%d4,14
    {
        spbDiv = 12;
80006b4a:	ab c4 a0 a3 	seln %d10,%d3,%d4,12
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
80006b4e:	1b 94 ff 2f 	addi %d2,%d4,-7
    {
        spbDiv = spbDiv - 1;
80006b52:	8f 14 c0 f1 	andn %d15,%d4,1
80006b56:	02 a4       	mov %d4,%d10
80006b58:	8b 72 a0 a2 	ge.u %d10,%d2,7
80006b5c:	2b f4 40 aa 	sel %d10,%d10,%d4,%d15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
80006b60:	6d 00 23 04 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
80006b64:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006b66:	6d 00 3e 04 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006b6a:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006b6c:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006b6e:	6d 00 1c 03 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006b72:	91 30 00 ff 	movh.a %a15,61443
80006b76:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006b7a:	48 02       	ld.w %d2,[%a15]0
80006b7c:	3b 00 3e f0 	mov %d15,992
80006b80:	a6 2f       	or %d15,%d2
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b82:	02 84       	mov %d4,%d8

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006b84:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b86:	6d 00 45 04 	call 80007410 <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006b8a:	02 94       	mov %d4,%d9
80006b8c:	6d 00 28 03 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006b90:	91 30 00 2f 	movh.a %a2,61443
80006b94:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b98:	4c 20       	ld.w %d15,[%a2]0
80006b9a:	91 30 00 ff 	movh.a %a15,61443
80006b9e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006ba2:	bf 0f fb 7f 	jlt %d15,0,80006b98 <IfxScuCcu_setSpbFrequency+0x66>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006ba6:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006ba8:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
80006baa:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
80006bae:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006bb2:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006bb4:	6d 00 9a 04 	call 800074e8 <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006bb8:	02 84       	mov %d4,%d8
80006bba:	6d 00 f6 02 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80006bbe:	91 30 00 ff 	movh.a %a15,61443
80006bc2:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006bc6:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006bc8:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80006bca:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
80006bce:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006bd0:	6d 00 20 04 	call 80007410 <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006bd4:	91 30 00 ff 	movh.a %a15,61443
80006bd8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006bdc:	4c f0       	ld.w %d15,[%a15]0
80006bde:	bf 0f ff 7f 	jlt %d15,0,80006bdc <IfxScuCcu_setSpbFrequency+0xaa>
    {}

    return IfxScuCcu_getSpbFrequency();
80006be2:	1d ff 1e fb 	j 8000621e <IfxScuCcu_getSpbFrequency>

80006be6 <IfxScuCcu_setSriFrequency>:
}


float32 IfxScuCcu_setSriFrequency(float32 sriFreq)
{
80006be6:	02 4f       	mov %d15,%d4
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
80006be8:	6d ff 5a fa 	call 8000609c <IfxScuCcu_getSourceFrequency>
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
80006bec:	4b f2 51 20 	div.f %d2,%d2,%d15
80006bf0:	4b 02 31 31 	ftoiz %d3,%d2
80006bf4:	4b 03 41 f1 	itof %d15,%d3
80006bf8:	6b 0f 31 22 	sub.f %d2,%d2,%d15
80006bfc:	7b 00 f0 f3 	movh %d15,16128
80006c00:	4b f2 01 f0 	cmp.f %d15,%d2,%d15
80006c04:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80006c08:	82 12       	mov %d2,1
80006c0a:	42 3f       	add %d15,%d3
80006c0c:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
80006c10:	8b ef 00 42 	eq %d4,%d15,14
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
80006c14:	92 93       	add %d3,%d15,-7
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
    {
        sriDiv = 12;
80006c16:	ab cf a0 94 	seln %d9,%d4,%d15,12
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
80006c1a:	8f 1f c0 21 	andn %d2,%d15,1
80006c1e:	02 9f       	mov %d15,%d9
80006c20:	8b 73 a0 92 	ge.u %d9,%d3,7
80006c24:	2b 2f 40 99 	sel %d9,%d9,%d15,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006c28:	6d 00 dd 03 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006c2c:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006c2e:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006c30:	6d 00 d6 02 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006c34:	91 30 00 2f 	movh.a %a2,61443
80006c38:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c3c:	4c 20       	ld.w %d15,[%a2]0
80006c3e:	91 30 00 ff 	movh.a %a15,61443
80006c42:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c46:	bf 0f fb 7f 	jlt %d15,0,80006c3c <IfxScuCcu_setSriFrequency+0x56>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006c4a:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006c4c:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
80006c4e:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
80006c52:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006c56:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006c58:	6d 00 48 04 	call 800074e8 <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006c5c:	4c f0       	ld.w %d15,[%a15]0
80006c5e:	bf 0f ff 7f 	jlt %d15,0,80006c5c <IfxScuCcu_setSriFrequency+0x76>
    {}

    freq = IfxScuCcu_getSriFrequency();
80006c62:	1d ff 3f fb 	j 800062e0 <IfxScuCcu_getSriFrequency>

80006c66 <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80006c66:	91 30 00 ff 	movh.a %a15,61443
80006c6a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c6e:	4c f0       	ld.w %d15,[%a15]0
80006c70:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80006c74:	df 0f 81 00 	jeq %d15,0,80006d76 <IfxScuCcu_switchToBackupClock+0x110>
80006c78:	40 4f       	mov.aa %a15,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006c7a:	6d 00 b4 03 	call 800073e2 <IfxScuWdt_getSafetyWatchdogPassword>
80006c7e:	02 29       	mov %d9,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006c80:	6d 00 93 03 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006c84:	0c f0       	ld.bu %d15,[%a15]0
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006c86:	02 28       	mov %d8,%d2
80006c88:	53 cf 20 20 	mul %d2,%d15,12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006c8c:	91 30 00 ef 	movh.a %a14,61443
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c90:	91 30 00 df 	movh.a %a13,61443
80006c94:	60 22       	mov.a %a2,%d2
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006c96:	d9 ee 14 06 	lea %a14,[%a14]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006c9a:	d9 2c f4 ff 	lea %a12,[%a2]-12 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c9e:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006ca2:	6e 1b       	jz %d15,80006cd8 <IfxScuCcu_switchToBackupClock+0x72>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006ca4:	02 94       	mov %d4,%d9
80006ca6:	6d 00 9b 02 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006caa:	54 e2       	ld.w %d2,[%a14]
80006cac:	6f 52 ff 7f 	jz.t %d2,5,80006caa <IfxScuCcu_switchToBackupClock+0x44>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006cb0:	c8 12       	ld.a %a2,[%a15]4
80006cb2:	54 d3       	ld.w %d3,[%a13]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006cb4:	02 94       	mov %d4,%d9
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006cb6:	30 c2       	add.a %a2,%a12
80006cb8:	14 22       	ld.bu %d2,[%a2]

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006cba:	c2 ff       	add %d15,-1
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006cbc:	37 23 07 20 	insert %d2,%d3,%d2,0,7
80006cc0:	74 d2       	st.w [%a13],%d2

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006cc2:	6d 00 13 04 	call 800074e8 <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80006cc6:	c8 12       	ld.a %a2,[%a15]4
80006cc8:	30 c2       	add.a %a2,%a12
80006cca:	19 24 04 00 	ld.w %d4,[%a2]4
80006cce:	6d ff f9 f9 	call 800060c0 <IfxScuCcu_wait>
80006cd2:	d9 cc f4 ff 	lea %a12,[%a12]-12
80006cd6:	3c e6       	j 80006ca2 <IfxScuCcu_switchToBackupClock+0x3c>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006cd8:	02 84       	mov %d4,%d8
80006cda:	6d 00 66 02 	call 800071a6 <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006cde:	91 30 00 ff 	movh.a %a15,61443
80006ce2:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006ce6:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006ce8:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006cea:	02 84       	mov %d4,%d8
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006cec:	96 08       	or %d15,8
80006cee:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006cf0:	37 02 e1 a1 	extr.u %d10,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006cf4:	6d 00 8e 03 	call 80007410 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006cf8:	02 94       	mov %d4,%d9
80006cfa:	6d 00 71 02 	call 800071dc <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
80006cfe:	91 30 00 2f 	movh.a %a2,61443
80006d02:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006d06:	4c 20       	ld.w %d15,[%a2]0
80006d08:	91 30 00 ff 	movh.a %a15,61443
80006d0c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006d10:	bf 0f fb 7f 	jlt %d15,0,80006d06 <IfxScuCcu_switchToBackupClock+0xa0>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80006d14:	4c f0       	ld.w %d15,[%a15]0
80006d16:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006d1a:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006d1c:	4c f0       	ld.w %d15,[%a15]0
80006d1e:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006d22:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
80006d24:	4c f0       	ld.w %d15,[%a15]0
80006d26:	bf 0f ff 7f 	jlt %d15,0,80006d24 <IfxScuCcu_switchToBackupClock+0xbe>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006d2a:	91 30 00 ff 	movh.a %a15,61443
80006d2e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006d32:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006d34:	02 94       	mov %d4,%d9
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006d36:	96 10       	or %d15,16
80006d38:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006d3a:	4c f0       	ld.w %d15,[%a15]0
80006d3c:	8f 0f c4 f1 	andn %d15,%d15,64
80006d40:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006d42:	6d 00 d3 03 	call 800074e8 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006d46:	91 30 00 ff 	movh.a %a15,61443
80006d4a:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006d4e:	02 84       	mov %d4,%d8
80006d50:	6d 00 2b 02 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006d54:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006d56:	8f 3a 00 20 	sh %d2,%d10,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006d5a:	96 08       	or %d15,8
80006d5c:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006d5e:	91 30 00 ff 	movh.a %a15,61443
80006d62:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006d66:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006d68:	02 84       	mov %d4,%d8
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006d6a:	8f 8f c0 f1 	andn %d15,%d15,8
80006d6e:	a6 2f       	or %d15,%d2
80006d70:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006d72:	1d 00 4f 03 	j 80007410 <IfxScuWdt_setCpuEndinit>
80006d76:	00 90       	ret 

80006d78 <IfxScuEru_clearAllEventFlags>:
/******************************************************************************/

void IfxScuEru_clearAllEventFlags(void)
{
    uint32 mask = (0xFF << 16);
    MODULE_SCU.FMR.U = mask;
80006d78:	91 30 00 ff 	movh.a %a15,61443
80006d7c:	7b f0 0f f0 	movh %d15,255
80006d80:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d84:	59 ff 24 80 	st.w [%a15]548 <f0030224 <_SMALL_DATA4_+0x40028224>>,%d15
80006d88:	00 90       	ret 

80006d8a <IfxScuEru_clearEventFlag>:
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006d8a:	1b 04 01 40 	addi %d4,%d4,16
80006d8e:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006d90:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006d94:	0f 4f 00 f0 	sh %d15,%d15,%d4
    SCU_FMR.U = mask;
80006d98:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006d9c:	68 0f       	st.w [%a15]0,%d15
80006d9e:	00 90       	ret 

80006da0 <IfxScuEru_clearInputChannelConfiguration>:


void IfxScuEru_clearInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006da0:	8f f4 1f f0 	sh %d15,%d4,-1
80006da4:	06 2f       	sh %d15,2
80006da6:	60 ff       	mov.a %a15,%d15
80006da8:	d9 ff 00 06 	lea %a15,[%a15]24576
80006dac:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006db0:	19 ff 10 80 	ld.w %d15,[%a15]528
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006db4:	6f 04 05 00 	jz.t %d4,0,80006dbe <IfxScuEru_clearInputChannelConfiguration+0x1e>
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006db8:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006dbc:	3c 03       	j 80006dc2 <IfxScuEru_clearInputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006dbe:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006dc2:	59 ff 10 80 	st.w [%a15]528,%d15
80006dc6:	00 90       	ret 

80006dc8 <IfxScuEru_clearOutputChannelConfiguration>:


void IfxScuEru_clearOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006dc8:	8f f4 1f f0 	sh %d15,%d4,-1
80006dcc:	06 2f       	sh %d15,2
80006dce:	60 ff       	mov.a %a15,%d15
80006dd0:	d9 ff 00 06 	lea %a15,[%a15]24576
80006dd4:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006dd8:	19 ff 2c 80 	ld.w %d15,[%a15]556
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006ddc:	6f 04 05 00 	jz.t %d4,0,80006de6 <IfxScuEru_clearOutputChannelConfiguration+0x1e>
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006de0:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006de4:	3c 03       	j 80006dea <IfxScuEru_clearOutputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006de6:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006dea:	59 ff 2c 80 	st.w [%a15]556,%d15
80006dee:	00 90       	ret 

80006df0 <IfxScuEru_connectTrigger>:


void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006df0:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006df4:	91 30 00 ff 	movh.a %a15,61443
80006df8:	1b 4f 08 f0 	addi %d15,%d15,132
80006dfc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e00:	8f 75 00 51 	and %d5,%d5,7
80006e04:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e06:	6f 04 08 00 	jz.t %d4,0,80006e16 <IfxScuEru_connectTrigger+0x26>
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006e0a:	4c f0       	ld.w %d15,[%a15]0
80006e0c:	8f c5 01 50 	sh %d5,%d5,28
80006e10:	b7 0f 03 fe 	insert %d15,%d15,0,28,3
80006e14:	3c 06       	j 80006e20 <IfxScuEru_connectTrigger+0x30>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.INP0 = triggerSelect;
80006e16:	4c f0       	ld.w %d15,[%a15]0
80006e18:	8f c5 00 50 	sh %d5,%d5,12
80006e1c:	b7 0f 03 f6 	insert %d15,%d15,0,12,3
80006e20:	a6 f5       	or %d5,%d15
80006e22:	68 05       	st.w [%a15]0,%d5
80006e24:	00 90       	ret 

80006e26 <IfxScuEru_disableAutoClear>:


void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e26:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006e2a:	91 30 00 ff 	movh.a %a15,61443
80006e2e:	1b 4f 08 f0 	addi %d15,%d15,132
80006e32:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e36:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e38:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e3a:	6f 04 05 00 	jz.t %d4,0,80006e44 <IfxScuEru_disableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006e3e:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80006e42:	3c 03       	j 80006e48 <IfxScuEru_disableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = FALSE;
80006e44:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80006e48:	68 0f       	st.w [%a15]0,%d15
80006e4a:	00 90       	ret 

80006e4c <IfxScuEru_disableFallingEdgeDetection>:


void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e4c:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006e50:	91 30 00 ff 	movh.a %a15,61443
80006e54:	1b 4f 08 f0 	addi %d15,%d15,132
80006e58:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e5c:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e5e:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e60:	6f 04 05 00 	jz.t %d4,0,80006e6a <IfxScuEru_disableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006e64:	b7 0f 01 fc 	insert %d15,%d15,0,24,1
80006e68:	3c 03       	j 80006e6e <IfxScuEru_disableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = FALSE;
80006e6a:	8f 0f d0 f1 	andn %d15,%d15,256
80006e6e:	68 0f       	st.w [%a15]0,%d15
80006e70:	00 90       	ret 

80006e72 <IfxScuEru_disablePatternDetectionTrigger>:


void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e72:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006e76:	91 30 00 ff 	movh.a %a15,61443
80006e7a:	1b bf 08 f0 	addi %d15,%d15,139
80006e7e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e82:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e84:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e86:	6f 04 05 00 	jz.t %d4,0,80006e90 <IfxScuEru_disablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006e8a:	b7 0f 81 fe 	insert %d15,%d15,0,29,1
80006e8e:	3c 03       	j 80006e94 <IfxScuEru_disablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = FALSE;
80006e90:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80006e94:	68 0f       	st.w [%a15]0,%d15
80006e96:	00 90       	ret 

80006e98 <IfxScuEru_disableRisingEdgeDetection>:


void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e98:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006e9c:	91 30 00 ff 	movh.a %a15,61443
80006ea0:	1b 4f 08 f0 	addi %d15,%d15,132
80006ea4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ea8:	90 ff       	addsc.a %a15,%a15,%d15,2
80006eaa:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006eac:	6f 04 05 00 	jz.t %d4,0,80006eb6 <IfxScuEru_disableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006eb0:	b7 0f 81 fc 	insert %d15,%d15,0,25,1
80006eb4:	3c 03       	j 80006eba <IfxScuEru_disableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = FALSE;
80006eb6:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80006eba:	68 0f       	st.w [%a15]0,%d15
80006ebc:	00 90       	ret 

80006ebe <IfxScuEru_disableTriggerPulse>:


void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ebe:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006ec2:	91 30 00 ff 	movh.a %a15,61443
80006ec6:	1b 4f 08 f0 	addi %d15,%d15,132
80006eca:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ece:	90 ff       	addsc.a %a15,%a15,%d15,2
80006ed0:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006ed2:	6f 04 05 00 	jz.t %d4,0,80006edc <IfxScuEru_disableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006ed6:	b7 0f 81 fd 	insert %d15,%d15,0,27,1
80006eda:	3c 03       	j 80006ee0 <IfxScuEru_disableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = FALSE;
80006edc:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80006ee0:	68 0f       	st.w [%a15]0,%d15
80006ee2:	00 90       	ret 

80006ee4 <IfxScuEru_enableAutoClear>:


void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ee4:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006ee8:	91 30 00 ff 	movh.a %a15,61443
80006eec:	1b 4f 08 f0 	addi %d15,%d15,132
80006ef0:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ef4:	90 ff       	addsc.a %a15,%a15,%d15,2
80006ef6:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006ef8:	6f 04 05 00 	jz.t %d4,0,80006f02 <IfxScuEru_enableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006efc:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80006f00:	3c 03       	j 80006f06 <IfxScuEru_enableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = TRUE;
80006f02:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80006f06:	68 0f       	st.w [%a15]0,%d15
80006f08:	00 90       	ret 

80006f0a <IfxScuEru_enableFallingEdgeDetection>:


void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f0a:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006f0e:	91 30 00 ff 	movh.a %a15,61443
80006f12:	1b 4f 08 f0 	addi %d15,%d15,132
80006f16:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f1a:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f1c:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006f1e:	6f 04 05 00 	jz.t %d4,0,80006f28 <IfxScuEru_enableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006f22:	b7 ff 01 fc 	insert %d15,%d15,15,24,1
80006f26:	3c 03       	j 80006f2c <IfxScuEru_enableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = TRUE;
80006f28:	8f 0f 50 f1 	or %d15,%d15,256
80006f2c:	68 0f       	st.w [%a15]0,%d15
80006f2e:	00 90       	ret 

80006f30 <IfxScuEru_enablePatternDetectionTrigger>:


void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f30:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006f34:	91 30 00 ff 	movh.a %a15,61443
80006f38:	1b bf 08 f0 	addi %d15,%d15,139
80006f3c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f40:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f42:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006f44:	6f 04 05 00 	jz.t %d4,0,80006f4e <IfxScuEru_enablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006f48:	b7 ff 81 fe 	insert %d15,%d15,15,29,1
80006f4c:	3c 03       	j 80006f52 <IfxScuEru_enablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = TRUE;
80006f4e:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80006f52:	68 0f       	st.w [%a15]0,%d15
80006f54:	00 90       	ret 

80006f56 <IfxScuEru_enableRisingEdgeDetection>:


void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f56:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006f5a:	91 30 00 ff 	movh.a %a15,61443
80006f5e:	1b 4f 08 f0 	addi %d15,%d15,132
80006f62:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f66:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f68:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006f6a:	6f 04 05 00 	jz.t %d4,0,80006f74 <IfxScuEru_enableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006f6e:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80006f72:	3c 03       	j 80006f78 <IfxScuEru_enableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = TRUE;
80006f74:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80006f78:	68 0f       	st.w [%a15]0,%d15
80006f7a:	00 90       	ret 

80006f7c <IfxScuEru_enableTriggerPulse>:


void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f7c:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006f80:	91 30 00 ff 	movh.a %a15,61443
80006f84:	1b 4f 08 f0 	addi %d15,%d15,132
80006f88:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f8c:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f8e:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006f90:	6f 04 05 00 	jz.t %d4,0,80006f9a <IfxScuEru_enableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006f94:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80006f98:	3c 03       	j 80006f9e <IfxScuEru_enableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = TRUE;
80006f9a:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80006f9e:	68 0f       	st.w [%a15]0,%d15
80006fa0:	00 90       	ret 

80006fa2 <IfxScuEru_getAllEventFlagsStatus>:
}


uint32 IfxScuEru_getAllEventFlagsStatus(void)
{
    return MODULE_SCU.EIFR.U;
80006fa2:	91 30 00 ff 	movh.a %a15,61443
80006fa6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006faa:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006fae:	00 90       	ret 

80006fb0 <IfxScuEru_getEventFlagStatus>:


boolean IfxScuEru_getEventFlagStatus(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = (1U << inputChannel);
    return (MODULE_SCU.EIFR.U & mask) ? TRUE : FALSE;
80006fb0:	91 30 00 ff 	movh.a %a15,61443
80006fb4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006fb8:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006fbc:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006fc0:	00 90       	ret 

80006fc2 <IfxScuEru_getInputChannelConfiguration>:


uint32 IfxScuEru_getInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006fc2:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006fc6:	91 30 00 ff 	movh.a %a15,61443
80006fca:	1b 4f 08 f0 	addi %d15,%d15,132
80006fce:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006fd2:	90 ff       	addsc.a %a15,%a15,%d15,2
80006fd4:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006fd6:	6f 04 05 00 	jz.t %d4,0,80006fe0 <IfxScuEru_getInputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006fda:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006fde:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.EICR[index].U & mask);
80006fe0:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006fe4:	00 90       	ret 

80006fe6 <IfxScuEru_getOutputChannelConfiguration>:


uint32 IfxScuEru_getOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006fe6:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006fea:	91 30 00 ff 	movh.a %a15,61443
80006fee:	1b bf 08 f0 	addi %d15,%d15,139
80006ff2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ff6:	90 ff       	addsc.a %a15,%a15,%d15,2
80006ff8:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006ffa:	6f 04 05 00 	jz.t %d4,0,80007004 <IfxScuEru_getOutputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006ffe:	b7 02 10 20 	insert %d2,%d2,0,0,16
80007002:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.IGCR[index].U & mask);
80007004:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80007008:	00 90       	ret 

8000700a <IfxScuEru_getPatternDetectionResult>:


boolean IfxScuEru_getPatternDetectionResult(IfxScuEru_OutputChannel outputChannel)
{
    uint32 mask = (1U << outputChannel);
    return (MODULE_SCU.PDRR.U & mask) ? TRUE : FALSE;
8000700a:	91 30 00 ff 	movh.a %a15,61443
8000700e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007012:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80007016:	57 02 61 24 	extr.u %d2,%d2,%d4,1
8000701a:	00 90       	ret 

8000701c <IfxScuEru_getWholePatternDetectionResult>:


uint32 IfxScuEru_getWholePatternDetectionResult(void)
{
    return MODULE_SCU.PDRR.U;
8000701c:	91 30 00 ff 	movh.a %a15,61443
80007020:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007024:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80007028:	00 90       	ret 

8000702a <IfxScuEru_selectExternalInput>:


void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
8000702a:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
8000702e:	91 30 00 ff 	movh.a %a15,61443
80007032:	1b 4f 08 f0 	addi %d15,%d15,132
80007036:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000703a:	8f 75 00 51 	and %d5,%d5,7
8000703e:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80007040:	6f 04 08 00 	jz.t %d4,0,80007050 <IfxScuEru_selectExternalInput+0x26>
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80007044:	4c f0       	ld.w %d15,[%a15]0
80007046:	8f 45 01 50 	sh %d5,%d5,20
8000704a:	b7 0f 03 fa 	insert %d15,%d15,0,20,3
8000704e:	3c 05       	j 80007058 <IfxScuEru_selectExternalInput+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EXIS0 = inputSignal;
80007050:	4c f0       	ld.w %d15,[%a15]0
80007052:	06 45       	sh %d5,4
80007054:	8f 0f c7 f1 	andn %d15,%d15,112
80007058:	a6 f5       	or %d5,%d15
8000705a:	68 05       	st.w [%a15]0,%d5
8000705c:	00 90       	ret 

8000705e <IfxScuEru_setEventFlag>:
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
8000705e:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80007060:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80007064:	0f 4f 00 40 	sh %d4,%d15,%d4
    SCU_FMR.U = mask;
80007068:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
8000706c:	68 04       	st.w [%a15]0,%d4
8000706e:	00 90       	ret 

80007070 <IfxScuEru_setFlagPatternDetection>:
}


void IfxScuEru_setFlagPatternDetection(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InputChannel inputChannel, boolean state)
{
80007070:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 shift, mask;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD) // for channels 1, 3 ,5 and 7
80007074:	6f 04 04 00 	jz.t %d4,0,8000707c <IfxScuEru_setFlagPatternDetection+0xc>
    {
        shift = (inputChannel + 16);                  // offset at location IPEN10
80007078:	1b 05 01 50 	addi %d5,%d5,16
8000707c:	06 2f       	sh %d15,2
8000707e:	60 f2       	mov.a %a2,%d15
80007080:	d9 2f 00 06 	lea %a15,[%a2]24576
80007084:	11 3f 00 ff 	addih.a %a15,%a15,61443
    {
        shift = inputChannel;
        mask  = (1 << shift);
        // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
        uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & ~mask) | ((uint32)state << shift);
80007088:	19 ff 2c 80 	ld.w %d15,[%a15]556
8000708c:	d7 0f 01 f5 	insert %d15,%d15,0,%d5,1
80007090:	0f 56 00 50 	sh %d5,%d6,%d5
80007094:	a6 f5       	or %d5,%d15
80007096:	59 f5 2c 80 	st.w [%a15]556,%d5
8000709a:	00 90       	ret 

8000709c <IfxScuEru_setInterruptGatingPattern>:


void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
8000709c:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
800070a0:	91 30 00 ff 	movh.a %a15,61443
800070a4:	1b bf 08 f0 	addi %d15,%d15,139
800070a8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800070ac:	8f 35 00 51 	and %d5,%d5,3
800070b0:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
800070b2:	6f 04 06 00 	jz.t %d4,0,800070be <IfxScuEru_setInterruptGatingPattern+0x22>
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
800070b6:	4c f0       	ld.w %d15,[%a15]0
800070b8:	37 5f 02 5f 	insert %d5,%d15,%d5,30,2
800070bc:	3c 07       	j 800070ca <IfxScuEru_setInterruptGatingPattern+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.IGP0 = gatingPattern;
800070be:	4c f0       	ld.w %d15,[%a15]0
800070c0:	8f e5 00 50 	sh %d5,%d5,14
800070c4:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
800070c8:	a6 f5       	or %d5,%d15
800070ca:	68 05       	st.w [%a15]0,%d5
800070cc:	00 90       	ret 

800070ce <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800070ce:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800070d2:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
800070d4:	53 cf 20 f0 	mul %d15,%d15,12
800070d8:	60 f2       	mov.a %a2,%d15
800070da:	d9 2f 00 46 	lea %a15,[%a2]24832
800070de:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
800070e2:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
800070e4:	2e 16       	jz.t %d15,1,800070f0 <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800070e6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
800070ea:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
800070ee:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
800070f0:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
800070f4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
800070f8:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
800070fc:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800070fe:	4c f0       	ld.w %d15,[%a15]0
80007100:	6f 0f ff 7f 	jz.t %d15,0,800070fe <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
80007104:	00 90       	ret 

80007106 <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007106:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000710a:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000710c:	53 cf 20 f0 	mul %d15,%d15,12
80007110:	60 f2       	mov.a %a2,%d15
80007112:	d9 2f 00 46 	lea %a15,[%a2]24832
80007116:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
8000711a:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000711c:	2e 16       	jz.t %d15,1,80007128 <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000711e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80007122:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80007126:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007128:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000712c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80007130:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80007134:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80007136:	4c f0       	ld.w %d15,[%a15]0
80007138:	6f 0f ff 7f 	jz.t %d15,0,80007136 <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
8000713c:	00 90       	ret 

8000713e <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
8000713e:	91 30 00 ff 	movh.a %a15,61443
80007142:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007146:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80007148:	2e 16       	jz.t %d15,1,80007154 <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000714a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000714e:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80007152:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007154:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80007158:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
8000715c:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80007160:	91 30 00 ff 	movh.a %a15,61443
80007164:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007168:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000716a:	4c f0       	ld.w %d15,[%a15]0
8000716c:	6f 0f ff 7f 	jz.t %d15,0,8000716a <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
80007170:	00 90       	ret 

80007172 <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
80007172:	91 30 00 ff 	movh.a %a15,61443
80007176:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000717a:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000717c:	2e 16       	jz.t %d15,1,80007188 <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000717e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80007182:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80007186:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007188:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000718c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80007190:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80007194:	91 30 00 ff 	movh.a %a15,61443
80007198:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000719c:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
8000719e:	4c f0       	ld.w %d15,[%a15]0
800071a0:	6f 0f ff 7f 	jz.t %d15,0,8000719e <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
800071a4:	00 90       	ret 

800071a6 <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800071a6:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800071aa:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800071ac:	53 cf 20 f0 	mul %d15,%d15,12
800071b0:	06 24       	sh %d4,2
800071b2:	60 f2       	mov.a %a2,%d15
800071b4:	d9 2f 00 46 	lea %a15,[%a2]24832
800071b8:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800071bc:	4c f0       	ld.w %d15,[%a15]0
800071be:	2e 16       	jz.t %d15,1,800071ca <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800071c0:	4c f0       	ld.w %d15,[%a15]0
800071c2:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071c6:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071c8:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800071ca:	4c f0       	ld.w %d15,[%a15]0
800071cc:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071d0:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071d2:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
800071d4:	4c f0       	ld.w %d15,[%a15]0
800071d6:	6f 0f ff ff 	jnz.t %d15,0,800071d4 <IfxScuWdt_clearCpuEndinit+0x2e>
}
800071da:	00 90       	ret 

800071dc <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800071dc:	91 30 00 ff 	movh.a %a15,61443
800071e0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071e4:	4c f0       	ld.w %d15,[%a15]0
800071e6:	06 24       	sh %d4,2
800071e8:	2e 16       	jz.t %d15,1,800071f4 <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800071ea:	4c f0       	ld.w %d15,[%a15]0
800071ec:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800071f0:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800071f2:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800071f4:	91 30 00 ff 	movh.a %a15,61443
800071f8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071fc:	4c f0       	ld.w %d15,[%a15]0
800071fe:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007202:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007204:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007206:	4c f0       	ld.w %d15,[%a15]0
80007208:	6f 0f ff ff 	jnz.t %d15,0,80007206 <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
8000720c:	00 90       	ret 

8000720e <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000720e:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007212:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80007214:	53 cf 20 f0 	mul %d15,%d15,12
80007218:	06 24       	sh %d4,2
8000721a:	60 f2       	mov.a %a2,%d15
8000721c:	d9 2f 00 46 	lea %a15,[%a2]24832
80007220:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007224:	4c f0       	ld.w %d15,[%a15]0
80007226:	2e 16       	jz.t %d15,1,80007232 <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007228:	4c f0       	ld.w %d15,[%a15]0
8000722a:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000722e:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007230:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007232:	4c f0       	ld.w %d15,[%a15]0
80007234:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007238:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000723a:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000723c:	4c f0       	ld.w %d15,[%a15]0
8000723e:	6f 0f ff ff 	jnz.t %d15,0,8000723c <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
80007242:	4c f1       	ld.w %d15,[%a15]4
80007244:	96 08       	or %d15,8
80007246:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007248:	4c f0       	ld.w %d15,[%a15]0
8000724a:	2e 16       	jz.t %d15,1,80007256 <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000724c:	4c f0       	ld.w %d15,[%a15]0
8000724e:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007252:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007254:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007256:	4c f0       	ld.w %d15,[%a15]0
80007258:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000725c:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000725e:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007260:	4c f0       	ld.w %d15,[%a15]0
80007262:	6f 0f ff 7f 	jz.t %d15,0,80007260 <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80007266:	00 90       	ret 

80007268 <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007268:	91 30 00 ff 	movh.a %a15,61443
8000726c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007270:	4c f0       	ld.w %d15,[%a15]0
80007272:	06 24       	sh %d4,2
80007274:	2e 16       	jz.t %d15,1,80007280 <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007276:	4c f0       	ld.w %d15,[%a15]0
80007278:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000727c:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000727e:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007280:	91 30 00 ff 	movh.a %a15,61443
80007284:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007288:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000728a:	40 f2       	mov.aa %a2,%a15
8000728c:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007290:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007292:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007294:	4c 20       	ld.w %d15,[%a2]0
80007296:	91 30 00 ff 	movh.a %a15,61443
8000729a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000729e:	6f 0f fb ff 	jnz.t %d15,0,80007294 <IfxScuWdt_disableSafetyWatchdog+0x2c>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
800072a2:	91 30 00 2f 	movh.a %a2,61443
800072a6:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
800072aa:	4c 20       	ld.w %d15,[%a2]0
800072ac:	96 08       	or %d15,8
800072ae:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800072b0:	4c f0       	ld.w %d15,[%a15]0
800072b2:	2e 16       	jz.t %d15,1,800072be <IfxScuWdt_disableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072b4:	4c f0       	ld.w %d15,[%a15]0
800072b6:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072ba:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072bc:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072be:	91 30 00 ff 	movh.a %a15,61443
800072c2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072c6:	4c f0       	ld.w %d15,[%a15]0
800072c8:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072cc:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072ce:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800072d0:	4c f0       	ld.w %d15,[%a15]0
800072d2:	6f 0f ff 7f 	jz.t %d15,0,800072d0 <IfxScuWdt_disableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800072d6:	00 90       	ret 

800072d8 <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800072d8:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800072dc:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800072de:	53 cf 20 f0 	mul %d15,%d15,12
800072e2:	06 24       	sh %d4,2
800072e4:	60 f2       	mov.a %a2,%d15
800072e6:	d9 2f 00 46 	lea %a15,[%a2]24832
800072ea:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800072ee:	4c f0       	ld.w %d15,[%a15]0
800072f0:	2e 16       	jz.t %d15,1,800072fc <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800072f2:	4c f0       	ld.w %d15,[%a15]0
800072f4:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800072f8:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800072fa:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800072fc:	4c f0       	ld.w %d15,[%a15]0
800072fe:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007302:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007304:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80007306:	4c f0       	ld.w %d15,[%a15]0
80007308:	6f 0f ff ff 	jnz.t %d15,0,80007306 <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
8000730c:	4c f1       	ld.w %d15,[%a15]4
8000730e:	8f 8f c0 f1 	andn %d15,%d15,8
80007312:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007314:	4c f0       	ld.w %d15,[%a15]0
80007316:	2e 16       	jz.t %d15,1,80007322 <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007318:	4c f0       	ld.w %d15,[%a15]0
8000731a:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000731e:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007320:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007322:	4c f0       	ld.w %d15,[%a15]0
80007324:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007328:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000732a:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000732c:	4c f0       	ld.w %d15,[%a15]0
8000732e:	6f 0f ff 7f 	jz.t %d15,0,8000732c <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80007332:	00 90       	ret 

80007334 <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007334:	91 30 00 ff 	movh.a %a15,61443
80007338:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000733c:	4c f0       	ld.w %d15,[%a15]0
8000733e:	06 24       	sh %d4,2
80007340:	2e 16       	jz.t %d15,1,8000734c <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007342:	4c f0       	ld.w %d15,[%a15]0
80007344:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007348:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000734a:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000734c:	91 30 00 ff 	movh.a %a15,61443
80007350:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007354:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007356:	40 f2       	mov.aa %a2,%a15
80007358:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000735c:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000735e:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007360:	4c 20       	ld.w %d15,[%a2]0
80007362:	91 30 00 ff 	movh.a %a15,61443
80007366:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000736a:	6f 0f fb ff 	jnz.t %d15,0,80007360 <IfxScuWdt_enableSafetyWatchdog+0x2c>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
8000736e:	91 30 00 2f 	movh.a %a2,61443
80007372:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
80007376:	4c 20       	ld.w %d15,[%a2]0
80007378:	8f 8f c0 f1 	andn %d15,%d15,8
8000737c:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000737e:	4c f0       	ld.w %d15,[%a15]0
80007380:	2e 16       	jz.t %d15,1,8000738c <IfxScuWdt_enableSafetyWatchdog+0x58>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007382:	4c f0       	ld.w %d15,[%a15]0
80007384:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007388:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000738a:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000738c:	91 30 00 ff 	movh.a %a15,61443
80007390:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007394:	4c f0       	ld.w %d15,[%a15]0
80007396:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000739a:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000739c:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000739e:	4c f0       	ld.w %d15,[%a15]0
800073a0:	6f 0f ff 7f 	jz.t %d15,0,8000739e <IfxScuWdt_enableSafetyWatchdog+0x6a>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800073a4:	00 90       	ret 

800073a6 <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800073a6:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800073aa:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800073ac:	53 cf 20 f0 	mul %d15,%d15,12
800073b0:	60 f2       	mov.a %a2,%d15
800073b2:	d9 2f 00 46 	lea %a15,[%a2]24832
800073b6:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800073ba:	48 02       	ld.w %d2,[%a15]0
800073bc:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
800073c0:	8f f2 83 21 	xor %d2,%d2,63
800073c4:	00 90       	ret 

800073c6 <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800073c6:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800073ca:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800073cc:	53 cf 20 f0 	mul %d15,%d15,12
800073d0:	60 f2       	mov.a %a2,%d15
800073d2:	d9 2f 00 46 	lea %a15,[%a2]24832
800073d6:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
800073da:	48 02       	ld.w %d2,[%a15]0
}
800073dc:	8f 12 00 21 	and %d2,%d2,1
800073e0:	00 90       	ret 

800073e2 <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800073e2:	91 30 00 ff 	movh.a %a15,61443
800073e6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800073ea:	48 02       	ld.w %d2,[%a15]0
800073ec:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
800073f0:	8f f2 83 21 	xor %d2,%d2,63
800073f4:	00 90       	ret 

800073f6 <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
800073f6:	da 3c       	mov %d15,60
800073f8:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
800073fa:	82 cf       	mov %d15,-4
800073fc:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
800073fe:	82 0f       	mov %d15,0
80007400:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
80007402:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
80007404:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
80007406:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
80007408:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
8000740a:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
8000740c:	2c 4a       	st.b [%a4]10,%d15
8000740e:	00 90       	ret 

80007410 <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007410:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007414:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80007416:	53 cf 20 f0 	mul %d15,%d15,12
8000741a:	06 24       	sh %d4,2
8000741c:	60 f2       	mov.a %a2,%d15
8000741e:	d9 2f 00 46 	lea %a15,[%a2]24832
80007422:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007426:	4c f0       	ld.w %d15,[%a15]0
80007428:	2e 16       	jz.t %d15,1,80007434 <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000742a:	4c f0       	ld.w %d15,[%a15]0
8000742c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007430:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007432:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007434:	4c f0       	ld.w %d15,[%a15]0
80007436:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000743a:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000743c:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000743e:	4c f0       	ld.w %d15,[%a15]0
80007440:	6f 0f ff 7f 	jz.t %d15,0,8000743e <IfxScuWdt_setCpuEndinit+0x2e>
}
80007444:	00 90       	ret 

80007446 <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
80007446:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
80007448:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000744a:	6f 12 0b 00 	jz.t %d2,1,80007460 <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000744e:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
80007452:	37 02 6e 31 	extr.u %d3,%d2,2,14
80007456:	8f f3 83 31 	xor %d3,%d3,63
8000745a:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000745e:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
80007460:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
80007462:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
80007466:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
8000746a:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
8000746e:	b9 53 02 00 	ld.hu %d3,[%a5]2
80007472:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
80007476:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007478:	54 42       	ld.w %d2,[%a4]
8000747a:	6f 02 ff ff 	jnz.t %d2,0,80007478 <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
8000747e:	39 52 04 00 	ld.bu %d2,[%a5]4
80007482:	df 12 0a 00 	jeq %d2,1,80007496 <IfxScuWdt_initCpuWatchdog+0x50>
80007486:	76 26       	jz %d2,80007492 <IfxScuWdt_initCpuWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
80007488:	8b 22 20 22 	ne %d2,%d2,2
8000748c:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
80007490:	3c 07       	j 8000749e <IfxScuWdt_initCpuWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
80007492:	82 0f       	mov %d15,0
        break;
80007494:	3c 05       	j 8000749e <IfxScuWdt_initCpuWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
80007496:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000749a:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
8000749e:	39 52 05 00 	ld.bu %d2,[%a5]5
800074a2:	8b 02 20 22 	ne %d2,%d2,0
800074a6:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
800074aa:	39 52 06 00 	ld.bu %d2,[%a5]6
800074ae:	8b 02 20 22 	ne %d2,%d2,0
800074b2:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
800074b6:	39 52 07 00 	ld.bu %d2,[%a5]7
800074ba:	8b 02 20 22 	ne %d2,%d2,0
800074be:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
800074c2:	39 52 08 00 	ld.bu %d2,[%a5]8
800074c6:	8b 02 20 22 	ne %d2,%d2,0
800074ca:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
800074ce:	39 52 09 00 	ld.bu %d2,[%a5]9
800074d2:	8b 02 20 22 	ne %d2,%d2,0
800074d6:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800074da:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
800074dc:	b9 54 00 00 	ld.hu %d4,[%a5]0
800074e0:	1d ff 98 ff 	j 80007410 <IfxScuWdt_setCpuEndinit>

800074e4 <IfxScuWdt_serviceCpuWatchdog>:
}


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
800074e4:	1d ff 96 ff 	j 80007410 <IfxScuWdt_setCpuEndinit>

800074e8 <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800074e8:	91 30 00 ff 	movh.a %a15,61443
800074ec:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800074f0:	4c f0       	ld.w %d15,[%a15]0
800074f2:	06 24       	sh %d4,2
800074f4:	2e 16       	jz.t %d15,1,80007500 <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800074f6:	4c f0       	ld.w %d15,[%a15]0
800074f8:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800074fc:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800074fe:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007500:	91 30 00 ff 	movh.a %a15,61443
80007504:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007508:	4c f0       	ld.w %d15,[%a15]0
8000750a:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000750e:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007510:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007512:	4c f0       	ld.w %d15,[%a15]0
80007514:	6f 0f ff 7f 	jz.t %d15,0,80007512 <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
80007518:	00 90       	ret 

8000751a <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
8000751a:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
8000751c:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000751e:	6f 12 0b 00 	jz.t %d2,1,80007534 <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80007522:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
80007526:	37 02 6e 31 	extr.u %d3,%d2,2,14
8000752a:	8f f3 83 31 	xor %d3,%d3,63
8000752e:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80007532:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
80007534:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
80007536:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
8000753a:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
8000753e:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
80007542:	b9 53 02 00 	ld.hu %d3,[%a5]2
80007546:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
8000754a:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
8000754c:	54 42       	ld.w %d2,[%a4]
8000754e:	6f 02 ff ff 	jnz.t %d2,0,8000754c <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
80007552:	39 52 04 00 	ld.bu %d2,[%a5]4
80007556:	df 12 0a 00 	jeq %d2,1,8000756a <IfxScuWdt_initSafetyWatchdog+0x50>
8000755a:	76 26       	jz %d2,80007566 <IfxScuWdt_initSafetyWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
8000755c:	8b 22 20 22 	ne %d2,%d2,2
80007560:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
80007564:	3c 07       	j 80007572 <IfxScuWdt_initSafetyWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
80007566:	82 0f       	mov %d15,0
        break;
80007568:	3c 05       	j 80007572 <IfxScuWdt_initSafetyWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000756a:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000756e:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
80007572:	39 52 05 00 	ld.bu %d2,[%a5]5
80007576:	8b 02 20 22 	ne %d2,%d2,0
8000757a:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
8000757e:	39 52 06 00 	ld.bu %d2,[%a5]6
80007582:	8b 02 20 22 	ne %d2,%d2,0
80007586:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
8000758a:	39 52 07 00 	ld.bu %d2,[%a5]7
8000758e:	8b 02 20 22 	ne %d2,%d2,0
80007592:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
80007596:	39 52 08 00 	ld.bu %d2,[%a5]8
8000759a:	8b 02 20 22 	ne %d2,%d2,0
8000759e:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
800075a2:	39 52 09 00 	ld.bu %d2,[%a5]9
800075a6:	8b 02 20 22 	ne %d2,%d2,0
800075aa:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 0 : 1;
800075ae:	39 52 0a 00 	ld.bu %d2,[%a5]10
800075b2:	8b 02 00 22 	eq %d2,%d2,0
800075b6:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800075ba:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
800075bc:	b9 54 00 00 	ld.hu %d4,[%a5]0
800075c0:	1d ff 94 ff 	j 800074e8 <IfxScuWdt_setSafetyEndinit>

800075c4 <IfxScuWdt_serviceSafetyWatchdog>:
}


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
800075c4:	1d ff 92 ff 	j 800074e8 <IfxScuWdt_setSafetyEndinit>

800075c8 <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
800075c8:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
800075cc:	2e 07       	jz.t %d15,0,800075da <IfxScuWdt_enableWatchdogWithDebugger+0x12>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
800075ce:	3b 00 00 f3 	mov %d15,12288
800075d2:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
800075d6:	82 0f       	mov %d15,0
800075d8:	3c 11       	j 800075fa <IfxScuWdt_enableWatchdogWithDebugger+0x32>

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
800075da:	3b 10 0a 20 	mov %d2,161
800075de:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
800075e2:	da 5e       	mov %d15,94
800075e4:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
800075e8:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
800075ec:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
800075f0:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
800075f4:	6f 0f ed ff 	jnz.t %d15,0,800075ce <IfxScuWdt_enableWatchdogWithDebugger+0x6>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
800075f8:	82 1f       	mov %d15,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
800075fa:	85 f2 40 20 	ld.w %d2,f0000480 <_SMALL_DATA4_+0x3fff8480>
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
800075fe:	37 02 e1 23 	extr.u %d2,%d2,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
80007602:	ab 1f 80 22 	sel %d2,%d2,%d15,1
80007606:	00 90       	ret 

80007608 <IfxVadc_Adc_deInitGroup>:
    Ifx_VADC_G     *vadcG      = IfxVadc_Adc_getGroupRegsFromGroup(group);
    /* Get group index */
    IfxVadc_GroupId groupIndex = group->groupId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007608:	0c 48       	ld.bu %d15,[%a4]8
8000760a:	d4 4c       	ld.a %a12,[%a4]
8000760c:	1b 0f 01 f0 	addi %d15,%d15,16
80007610:	16 ff       	and %d15,255
80007612:	99 4d 04 00 	ld.a %a13,[%a4]4
80007616:	02 f4       	mov %d4,%d15
80007618:	40 c4       	mov.aa %a4,%a12
8000761a:	6d ff 91 e8 	call 8000473c <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_resetGroup(Ifx_VADC_G *vadcG)
{
    vadcG->ARBCFG.B.ANONC = IfxVadc_AnalogConverterMode_off;   /* turn off group */
8000761e:	54 d2       	ld.w %d2,[%a13]
    IfxVadc_resetGroup(vadcG);
    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007620:	40 c4       	mov.aa %a4,%a12
80007622:	8f 32 c0 21 	andn %d2,%d2,3
80007626:	74 d2       	st.w [%a13],%d2
80007628:	02 f4       	mov %d4,%d15
8000762a:	1d ff 6d e8 	j 80004704 <IfxVadc_disableAccess>

8000762e <IfxVadc_Adc_disableModule>:
}


void IfxVadc_Adc_disableModule(Ifx_VADC *vadc)
{
8000762e:	40 4f       	mov.aa %a15,%a4
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007630:	6d ff bb fe 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80007634:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007636:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80007638:	6d ff b7 fd 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.B.DISR = 1;
8000763c:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setCpuEndinit(passwd);
8000763e:	02 f4       	mov %d4,%d15

IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->CLC.B.DISR = 1;
80007640:	8f 12 40 21 	or %d2,%d2,1
80007644:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007646:	1d ff e5 fe 	j 80007410 <IfxScuWdt_setCpuEndinit>

8000764a <IfxVadc_Adc_getChannelConfig>:
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
8000764a:	99 42 04 00 	ld.a %a2,[%a4]4
8000764e:	99 2d 04 00 	ld.a %a13,[%a2]4
    IfxVadc_ChannelId channelIndex = channel->channel;
80007652:	79 42 00 00 	ld.b %d2,[%a4]0

    config->channelId = channel->channel;
    config->group     = channel->group;
80007656:	b5 52 14 00 	st.a [%a5]20,%a2


IFX_INLINE Ifx_VADC_CHCTR IfxVadc_getChannelControlConfig(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U = vadcG->CHCTR[channelIndex].U;
8000765a:	1b 02 06 f0 	addi %d15,%d2,96
8000765e:	90 d2       	addsc.a %a2,%a13,%d15,2
void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
    IfxVadc_ChannelId channelIndex = channel->channel;

    config->channelId = channel->channel;
80007660:	e9 52 0c 00 	st.b [%a5]12,%d2
80007664:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
80007666:	40 4c       	mov.aa %a12,%a4

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
80007668:	37 0f 62 30 	extr.u %d3,%d15,0,2
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
8000766c:	40 5f       	mov.aa %a15,%a5

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
8000766e:	e9 53 0d 00 	st.b [%a5]13,%d3
    config->reference           = (IfxVadc_ChannelReference)tempChctr.B.REFSEL;
80007672:	37 0f e1 35 	extr.u %d3,%d15,11,1
80007676:	e9 53 0e 00 	st.b [%a5]14,%d3
    config->resultRegister      = (IfxVadc_ChannelResult)tempChctr.B.RESREG;
8000767a:	37 0f 64 38 	extr.u %d3,%d15,16,4
8000767e:	e9 53 0f 00 	st.b [%a5]15,%d3
    config->globalResultUsage   = tempChctr.B.RESTBS;
80007682:	37 0f 61 3a 	extr.u %d3,%d15,20,1
80007686:	34 53       	st.b [%a5],%d3
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
80007688:	37 0f 62 32 	extr.u %d3,%d15,4,2
8000768c:	e9 53 10 00 	st.b [%a5]16,%d3
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
80007690:	37 0f 62 33 	extr.u %d3,%d15,6,2
80007694:	e9 53 11 00 	st.b [%a5]17,%d3
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
80007698:	37 0f 64 36 	extr.u %d3,%d15,12,4
8000769c:	e9 53 12 00 	st.b [%a5]18,%d3
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
800076a0:	37 0f 62 34 	extr.u %d3,%d15,8,2
800076a4:	e9 53 13 00 	st.b [%a5]19,%d3
    config->synchonize          = tempChctr.B.SYNC;
800076a8:	37 0f 61 35 	extr.u %d3,%d15,10,1
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800076ac:	37 0f e1 fa 	extr.u %d15,%d15,21,1
    config->globalResultUsage   = tempChctr.B.RESTBS;
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
    config->synchonize          = tempChctr.B.SYNC;
800076b0:	e9 53 01 00 	st.b [%a5]1,%d3
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800076b4:	2c 53       	st.b [%a5]3,%d15


IFX_INLINE Ifx_VADC_G_CHASS IfxVadc_getAssignedChannels(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CHASS assignChannels;
    assignChannels.U = vadcG->CHASS.U;
800076b6:	4c d2       	ld.w %d15,[%a13]8

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
800076b8:	57 0f 61 22 	extr.u %d2,%d15,%d2,1
800076bc:	8f 12 80 21 	xor %d2,%d2,1
800076c0:	e9 52 02 00 	st.b [%a5]2,%d2
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
800076c4:	99 42 04 00 	ld.a %a2,[%a4]4
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
800076c8:	79 4f 00 00 	ld.b %d15,[%a4]0


IFX_INLINE Ifx_VADC_G_CEVNP0 IfxVadc_getChannelServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CEVNP0 serviceRequestNodePtr;
    serviceRequestNodePtr.U = vadcG->CEVNP0.U;
800076cc:	19 d2 20 40 	ld.w %d2,[%a13]288
800076d0:	06 2f       	sh %d15,2
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
800076d2:	57 02 64 ff 	extr.u %d15,%d2,%d15,4
    config->rightAlignedStorage = tempChctr.B.RESPOS;

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
800076d6:	39 28 08 00 	ld.bu %d8,[%a2]8
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
800076da:	0b 8f 10 48 	mov %e4,%d15,%d8
800076de:	6d ff 60 e9 	call 8000499e <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
800076e2:	54 22       	ld.w %d2,[%a2]
800076e4:	6f a2 0a 00 	jz.t %d2,10,800076f8 <IfxVadc_Adc_getChannelConfig+0xae>
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)channelServiceRequestNodePtr;
800076e8:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)src->B.SRPN;
800076ea:	4c 20       	ld.w %d15,[%a2]0
800076ec:	16 ff       	and %d15,255
800076ee:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)src->B.TOS;
800076f0:	4c 20       	ld.w %d15,[%a2]0
800076f2:	37 0f e2 f5 	extr.u %d15,%d15,11,2
800076f6:	3c 05       	j 80007700 <IfxVadc_Adc_getChannelConfig+0xb6>
    }
    else
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)0;
800076f8:	82 0f       	mov %d15,0
800076fa:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)0;
800076fc:	82 0f       	mov %d15,0
800076fe:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)0;
80007700:	28 9f       	st.b [%a15]9,%d15
    }

    uint32 resultServiceRequestNodePtr;

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80007702:	0c ff       	ld.bu %d15,[%a15]15
80007704:	79 c2 00 00 	ld.b %d2,[%a12]0
80007708:	ff 8f 08 80 	jge.u %d15,8,80007718 <IfxVadc_Adc_getChannelConfig+0xce>


IFX_INLINE Ifx_VADC_G_REVNP0 IfxVadc_getChannelResultServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP0 resultServiceRequestNodePtr0;
    resultServiceRequestNodePtr0.U = vadcG->REVNP0.U;
8000770c:	19 df 30 40 	ld.w %d15,[%a13]304
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
80007710:	06 22       	sh %d2,2
80007712:	57 0f 64 f2 	extr.u %d15,%d15,%d2,4
80007716:	3c 08       	j 80007726 <IfxVadc_Adc_getChannelConfig+0xdc>
    }
    else
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer1(vadcG)).U >> ((channel->channel - IfxVadc_ChannelResult_8) * 4)) & 0xF;
80007718:	9a 82       	add %d15,%d2,-8


IFX_INLINE Ifx_VADC_G_REVNP1 IfxVadc_getChannelResultServiceRequestNodePointer1(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP1 resultServiceRequestNodePtr1;
    resultServiceRequestNodePtr1.U = vadcG->REVNP1.U;
8000771a:	19 d3 34 40 	ld.w %d3,[%a13]308
8000771e:	8f 2f 00 20 	sh %d2,%d15,2
80007722:	57 03 64 f2 	extr.u %d15,%d3,%d2,4
    }

    src = IfxVadc_getSrcAddress(groupIndex, resultServiceRequestNodePtr);
80007726:	16 ff       	and %d15,255
80007728:	0b 8f 10 48 	mov %e4,%d15,%d8
8000772c:	6d ff 39 e9 	call 8000499e <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
80007730:	54 22       	ld.w %d2,[%a2]
80007732:	6f a2 0a 00 	jz.t %d2,10,80007746 <IfxVadc_Adc_getChannelConfig+0xfc>
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)resultServiceRequestNodePtr;
80007736:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)src->B.SRPN;
80007738:	4c 20       	ld.w %d15,[%a2]0
8000773a:	16 ff       	and %d15,255
8000773c:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)src->B.TOS;
8000773e:	4c 20       	ld.w %d15,[%a2]0
80007740:	37 0f e2 f5 	extr.u %d15,%d15,11,2
80007744:	3c 05       	j 8000774e <IfxVadc_Adc_getChannelConfig+0x104>
    }
    else
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)0;
80007746:	82 0f       	mov %d15,0
80007748:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)0;
8000774a:	82 0f       	mov %d15,0
8000774c:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)0;
8000774e:	28 8f       	st.b [%a15]8,%d15
80007750:	00 90       	ret 

80007752 <IfxVadc_Adc_getChannelConversionTime>:
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007752:	cc 41       	ld.a %a15,[%a4]4
80007754:	c8 12       	ld.a %a2,[%a15]4
}


IFX_INLINE IfxVadc_InputClasses IfxVadc_getChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    return (IfxVadc_InputClasses)vadcG->CHCTR[channelIndex].B.ICLSEL;
80007756:	79 4f 00 00 	ld.b %d15,[%a4]0
8000775a:	08 8a       	ld.bu %d10,[%a15]8
8000775c:	c8 0f       	ld.a %a15,[%a15]0
8000775e:	1b 0f 06 f0 	addi %d15,%d15,96
80007762:	90 22       	addsc.a %a2,%a2,%d15,2
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
80007764:	20 08       	sub.a %sp,8
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007766:	40 f4       	mov.aa %a4,%a15
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
80007768:	02 49       	mov %d9,%d4
8000776a:	54 28       	ld.w %d8,[%a2]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
8000776c:	6d ff 9a e8 	call 800048a0 <IfxVadc_getAdcAnalogFrequency>
80007770:	02 2f       	mov %d15,%d2
80007772:	6d ff b0 e8 	call 800048d2 <IfxVadc_getAdcModuleFrequency>
80007776:	8f 38 00 81 	and %d8,%d8,3
8000777a:	74 a9       	st.w [%sp],%d9
8000777c:	40 f4       	mov.aa %a4,%a15
8000777e:	0b a8 10 48 	mov %e4,%d8,%d10
80007782:	0b f2 10 68 	mov %e6,%d2,%d15
}
80007786:	1d ff c1 e9 	j 80004b08 <IfxVadc_getChannelConversionTime>

8000778a <IfxVadc_Adc_getGroupConfig>:

void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
8000778a:	d4 4d       	ld.a %a13,[%a4]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
8000778c:	40 4e       	mov.aa %a14,%a4
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
8000778e:	99 4c 04 00 	ld.a %a12,[%a4]4
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007792:	40 d4       	mov.aa %a4,%a13
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
80007794:	40 5f       	mov.aa %a15,%a5
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007796:	6d ff 85 e8 	call 800048a0 <IfxVadc_getAdcAnalogFrequency>

    config->groupId                    = group->groupId;
8000779a:	0c e8       	ld.bu %d15,[%a14]8
    config->module                     = &group->module;
8000779c:	e8 0e       	st.a [%a15]0,%a14
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);

    config->groupId                    = group->groupId;
8000779e:	28 4f       	st.b [%a15]4,%d15
}


IFX_INLINE IfxVadc_ArbitrationRounds IfxVadc_getArbiterRoundLength(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_ArbitrationRounds)vadcG->ARBCFG.B.ARBRND;
800077a0:	4c c0       	ld.w %d15,[%a12]0
800077a2:	37 0f 62 f2 	extr.u %d15,%d15,4,2
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);
800077a6:	e9 ff 32 00 	st.b [%a15]50,%d15
800077aa:	82 0f       	mov %d15,0
}


IFX_INLINE IfxVadc_ChannelResolution IfxVadc_getGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum)
{
    return (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
800077ac:	1b 8f 00 30 	addi %d3,%d15,8
800077b0:	01 c3 02 26 	addsc.a %a2,%a12,%d3,2

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
800077b4:	d0 f3       	addsc.a %a3,%a15,%d15,3
800077b6:	54 23       	ld.w %d3,[%a2]
800077b8:	37 03 63 34 	extr.u %d3,%d3,8,3
800077bc:	e9 33 0c 00 	st.b [%a3]12,%d3
}


IFX_INLINE float32 IfxVadc_getGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = vadcG->ICLASS[inputClassNum].B.STCS;
800077c0:	54 23       	ld.w %d3,[%a2]
800077c2:	8f f3 01 31 	and %d3,%d3,31

    if (sampleTime > 16)
800077c6:	8b 13 61 42 	lt.u %d4,%d3,17
800077ca:	f6 44       	jnz %d4,800077d2 <IfxVadc_Adc_getGroupConfig+0x48>
    {
        sampleTime = (sampleTime - 15) * 16;
800077cc:	1b 13 ff 3f 	addi %d3,%d3,-15
800077d0:	06 43       	sh %d3,4
    }

    return (float32)(IFXVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
800077d2:	c2 23       	add %d3,2
800077d4:	4b 03 41 31 	itof %d3,%d3
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
800077d8:	92 14       	add %d4,%d15,1
800077da:	4b 23 51 30 	div.f %d3,%d3,%d2
800077de:	01 f4 03 26 	addsc.a %a2,%a15,%d4,3
800077e2:	74 23       	st.w [%a2],%d3
    config->groupId                    = group->groupId;
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
800077e4:	1e 13       	jeq %d15,1,800077ea <IfxVadc_Adc_getGroupConfig+0x60>
800077e6:	82 1f       	mov %d15,1
800077e8:	3c e2       	j 800077ac <IfxVadc_Adc_getGroupConfig+0x22>
}


IFX_INLINE boolean IfxVadc_isRequestScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN1;
800077ea:	19 c2 04 00 	ld.w %d2,[%a12]4
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
    }

    if (IfxVadc_isRequestScanSlotEnabled(vadcG) == TRUE)
800077ee:	ef 92 33 00 	jz.t %d2,25,80007854 <IfxVadc_Adc_getGroupConfig+0xca>
    {
        config->arbiter.requestSlotScanEnabled          = TRUE;
800077f2:	e9 ff 34 00 	st.b [%a15]52,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO1;
800077f6:	19 c2 04 00 	ld.w %d2,[%a12]4
800077fa:	37 02 62 22 	extr.u %d2,%d2,4,2
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
800077fe:	e9 f2 1e 00 	st.b [%a15]30,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM1;
80007802:	19 c2 04 00 	ld.w %d2,[%a12]4
80007806:	37 02 e1 23 	extr.u %d2,%d2,7,1
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);
8000780a:	e9 f2 1f 00 	st.b [%a15]31,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getScanSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->ASCTRL.B.XTSEL;
8000780e:	19 c3 20 20 	ld.w %d3,[%a12]160
80007812:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
80007816:	e9 f3 1b 00 	st.b [%a15]27,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getScanSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->ASCTRL.B.XTMODE;
8000781a:	19 c2 20 20 	ld.w %d2,[%a12]160
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000781e:	8b f3 00 32 	eq %d3,%d3,15
80007822:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotScanEnabled          = TRUE;
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);
80007826:	e9 f2 1d 00 	st.b [%a15]29,%d2

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000782a:	f6 35       	jnz %d3,80007834 <IfxVadc_Adc_getGroupConfig+0xaa>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getScanSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->ASMR.B.ENGT;
8000782c:	19 cf 24 20 	ld.w %d15,[%a12]164
80007830:	16 03       	and %d15,3
80007832:	3c 02       	j 80007836 <IfxVadc_Adc_getGroupConfig+0xac>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_getScanSlotGatingMode(vadcG);
        }
        else if (config->scanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007834:	76 23       	jz %d2,8000783a <IfxVadc_Adc_getGroupConfig+0xb0>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80007836:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getScanSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->ASCTRL.B.GTSEL;
8000783a:	19 cf 20 20 	ld.w %d15,[%a12]160
8000783e:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->scanRequest.triggerConfig.gatingSource = IfxVadc_getScanSlotGatingSource(vadcG);
80007842:	e9 ff 1a 00 	st.b [%a15]26,%d15
}


IFX_INLINE boolean IfxVadc_isAutoScanEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ASMR.B.SCAN;
80007846:	19 cf 24 20 	ld.w %d15,[%a12]164
8000784a:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->scanRequest.autoscanEnabled            = IfxVadc_isAutoScanEnabled(vadcG);
8000784e:	e9 ff 18 00 	st.b [%a15]24,%d15
80007852:	3c 0c       	j 8000786a <IfxVadc_Adc_getGroupConfig+0xe0>
    }
    else
    {
        config->scanRequest.autoscanEnabled             = FALSE;
80007854:	82 0f       	mov %d15,0
80007856:	e9 ff 18 00 	st.b [%a15]24,%d15
        config->scanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
8000785a:	e9 ff 1c 00 	st.b [%a15]28,%d15
        config->scanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;    /* Use CCU6061 TRIG0 */
8000785e:	e9 ff 1a 00 	st.b [%a15]26,%d15
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
80007862:	e9 ff 1d 00 	st.b [%a15]29,%d15
        config->scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;   /* Trigger source taken from Gating Input */
80007866:	e9 ff 1b 00 	st.b [%a15]27,%d15
}


IFX_INLINE boolean IfxVadc_isRequestQueueSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN0;
8000786a:	4c c1       	ld.w %d15,[%a12]4
8000786c:	37 0f 61 fc 	extr.u %d15,%d15,24,1
    }

    if (IfxVadc_isRequestQueueSlotEnabled(vadcG) == TRUE)
80007870:	df 1f 30 80 	jne %d15,1,800078d0 <IfxVadc_Adc_getGroupConfig+0x146>
    {
        config->arbiter.requestSlotQueueEnabled          = TRUE;
80007874:	e9 ff 33 00 	st.b [%a15]51,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getQueueSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO0;
80007878:	19 c2 04 00 	ld.w %d2,[%a12]4
8000787c:	8f 32 00 21 	and %d2,%d2,3
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
80007880:	e9 f2 26 00 	st.b [%a15]38,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getQueueSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM0;
80007884:	19 c2 04 00 	ld.w %d2,[%a12]4
80007888:	37 02 e1 21 	extr.u %d2,%d2,3,1
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);
8000788c:	e9 f2 27 00 	st.b [%a15]39,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getQueueSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->QCTRL0.B.XTSEL;
80007890:	19 c3 00 20 	ld.w %d3,[%a12]128
80007894:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
80007898:	e9 f3 23 00 	st.b [%a15]35,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getQueueSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->QCTRL0.B.XTMODE;
8000789c:	19 c2 00 20 	ld.w %d2,[%a12]128
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800078a0:	8b f3 00 32 	eq %d3,%d3,15
800078a4:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotQueueEnabled          = TRUE;
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);
800078a8:	e9 f2 25 00 	st.b [%a15]37,%d2

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800078ac:	f6 35       	jnz %d3,800078b6 <IfxVadc_Adc_getGroupConfig+0x12c>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getQueueSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->QMR0.B.ENGT;
800078ae:	19 cf 04 20 	ld.w %d15,[%a12]132
800078b2:	16 03       	and %d15,3
800078b4:	3c 02       	j 800078b8 <IfxVadc_Adc_getGroupConfig+0x12e>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_getQueueSlotGatingMode(vadcG);
        }
        else if (config->queueRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800078b6:	76 23       	jz %d2,800078bc <IfxVadc_Adc_getGroupConfig+0x132>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800078b8:	e9 ff 24 00 	st.b [%a15]36,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getQueueSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->QCTRL0.B.GTSEL;
800078bc:	19 cf 00 20 	ld.w %d15,[%a12]128
800078c0:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->queueRequest.triggerConfig.gatingSource = IfxVadc_getQueueSlotGatingSource(vadcG);
800078c4:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.flushQueueAfterInit        = FALSE;
800078c8:	82 0f       	mov %d15,0
800078ca:	e9 ff 20 00 	st.b [%a15]32,%d15
800078ce:	3c 0c       	j 800078e6 <IfxVadc_Adc_getGroupConfig+0x15c>
    }
    else
    {
        config->queueRequest.flushQueueAfterInit         = FALSE;
800078d0:	82 0f       	mov %d15,0
800078d2:	e9 ff 20 00 	st.b [%a15]32,%d15
        config->queueRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
800078d6:	e9 ff 24 00 	st.b [%a15]36,%d15
        config->queueRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;        /* Use CCU6061 TRIG0 */
800078da:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800078de:	e9 ff 25 00 	st.b [%a15]37,%d15
        config->queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;       /* Trigger source taken from Gating Input */
800078e2:	e9 ff 23 00 	st.b [%a15]35,%d15
}


IFX_INLINE boolean IfxVadc_isRequestBackgroundScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN2;
800078e6:	4c c1       	ld.w %d15,[%a12]4
800078e8:	37 0f 61 fd 	extr.u %d15,%d15,26,1
    }

    if (IfxVadc_isRequestBackgroundScanSlotEnabled(vadcG) == TRUE)
800078ec:	df 1f 33 80 	jne %d15,1,80007952 <IfxVadc_Adc_getGroupConfig+0x1c8>
    {
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
800078f0:	e9 ff 35 00 	st.b [%a15]53,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getBackgroundScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO2;
800078f4:	19 c2 04 00 	ld.w %d2,[%a12]4
800078f8:	37 02 62 24 	extr.u %d2,%d2,8,2
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
800078fc:	e9 f2 2e 00 	st.b [%a15]46,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getBackgroundScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM2;
80007900:	19 c2 04 00 	ld.w %d2,[%a12]4
80007904:	37 02 e1 25 	extr.u %d2,%d2,11,1
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);
80007908:	e9 f2 2f 00 	st.b [%a15]47,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getBackgroundScanTriggerInput(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerSource)vadc->BRSCTRL.B.XTSEL;
8000790c:	19 d3 00 80 	ld.w %d3,[%a13]512
80007910:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
80007914:	e9 f3 2b 00 	st.b [%a15]43,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getBackgroundScanTriggerMode(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerMode)vadc->BRSCTRL.B.XTMODE;
80007918:	19 d2 00 80 	ld.w %d2,[%a13]512
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000791c:	8b f3 00 32 	eq %d3,%d3,15
80007920:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);
80007924:	e9 f2 2d 00 	st.b [%a15]45,%d2

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007928:	f6 35       	jnz %d3,80007932 <IfxVadc_Adc_getGroupConfig+0x1a8>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getBackgroundScanGatingMode(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingMode)vadc->BRSMR.B.ENGT;
8000792a:	19 df 04 80 	ld.w %d15,[%a13]516
8000792e:	16 03       	and %d15,3
80007930:	3c 02       	j 80007934 <IfxVadc_Adc_getGroupConfig+0x1aa>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_getBackgroundScanGatingMode(vadc);
        }
        else if (config->backgroundScanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007932:	76 23       	jz %d2,80007938 <IfxVadc_Adc_getGroupConfig+0x1ae>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80007934:	e9 ff 2c 00 	st.b [%a15]44,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getBackgroundScanGatingSource(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingSource)vadc->BRSCTRL.B.GTSEL;
80007938:	19 df 00 80 	ld.w %d15,[%a13]512
8000793c:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->backgroundScanRequest.triggerConfig.gatingSource = IfxVadc_getBackgroundScanGatingSource(vadc);
80007940:	e9 ff 2a 00 	st.b [%a15]42,%d15
}


IFX_INLINE boolean IfxVadc_isAutoBackgroundScanEnabled(Ifx_VADC *vadc)
{
    return (boolean)vadc->BRSMR.B.SCAN;
80007944:	19 df 04 80 	ld.w %d15,[%a13]516
80007948:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->backgroundScanRequest.autoBackgroundScanEnabled  = IfxVadc_isAutoBackgroundScanEnabled(vadc);
8000794c:	e9 ff 28 00 	st.b [%a15]40,%d15
80007950:	3c 0c       	j 80007968 <IfxVadc_Adc_getGroupConfig+0x1de>
    }
    else
    {
        config->backgroundScanRequest.autoBackgroundScanEnabled   = FALSE;
80007952:	82 0f       	mov %d15,0
80007954:	e9 ff 28 00 	st.b [%a15]40,%d15
        config->backgroundScanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
80007958:	e9 ff 2c 00 	st.b [%a15]44,%d15
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
8000795c:	e9 ff 2a 00 	st.b [%a15]42,%d15
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
80007960:	e9 ff 2d 00 	st.b [%a15]45,%d15
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
80007964:	e9 ff 2b 00 	st.b [%a15]43,%d15


IFX_INLINE uint8 IfxVadc_getMasterIndex(Ifx_VADC_G *vadcG)
{
    uint8 masterIndex = 0;
    masterIndex = vadcG->SYNCTR.B.STSEL;
80007968:	19 c3 00 10 	ld.w %d3,[%a12]64
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
8000796c:	39 e7 08 00 	ld.bu %d7,[%a14]8
80007970:	8f 33 00 31 	and %d3,%d3,3
80007974:	02 72       	mov %d2,%d7
IFX_INLINE IfxVadc_GroupId IfxVadc_Adc_getMasterId(IfxVadc_GroupId slave, IfxVadc_Adc_SYNCTR_STSEL masterIndex)
{
    uint8           i, idxOffset;
    IfxVadc_GroupId masterId = slave;

    if (masterIndex == 0)
80007976:	df 03 1f 00 	jeq %d3,0,800079b4 <IfxVadc_Adc_getGroupConfig+0x22a>
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
8000797a:	7b 00 00 58 	movh %d5,32768
8000797e:	1b 85 d5 50 	addi %d5,%d5,3416
80007982:	13 87 20 55 	madd %d5,%d5,%d7,8
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
80007986:	8b 47 60 42 	lt.u %d4,%d7,4
8000798a:	82 02       	mov %d2,0
8000798c:	ab 42 80 24 	sel %d2,%d4,%d2,4

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007990:	1a 25       	add %d15,%d5,%d2
80007992:	60 f4       	mov.a %a4,%d15
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
80007994:	82 04       	mov %d4,0

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007996:	a0 32       	mov.a %a2,3
80007998:	01 44 00 36 	addsc.a %a3,%a4,%d4,0
8000799c:	8f f4 0f 61 	and %d6,%d4,255
800079a0:	14 35       	ld.bu %d5,[%a3]
800079a2:	5f 35 06 80 	jne %d5,%d3,800079ae <IfxVadc_Adc_getGroupConfig+0x224>
            {
                return (IfxVadc_GroupId)(i + idxOffset);
800079a6:	42 62       	add %d2,%d6
800079a8:	8f f2 0f 21 	and %d2,%d2,255
800079ac:	3c 04       	j 800079b4 <IfxVadc_Adc_getGroupConfig+0x22a>
800079ae:	c2 14       	add %d4,1
800079b0:	fc 24       	loop %a2,80007998 <IfxVadc_Adc_getGroupConfig+0x20e>
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
800079b2:	02 72       	mov %d2,%d7
800079b4:	28 52       	st.b [%a15]5,%d2


IFX_INLINE Ifx_VADC_GLOBCFG IfxVadc_getGlobalConfigValue(Ifx_VADC *vadc)
{
    Ifx_VADC_GLOBCFG globCfg;
    globCfg.U = vadc->GLOBCFG.U;
800079b6:	19 d2 00 20 	ld.w %d2,[%a13]128

    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
800079ba:	1b 07 01 f0 	addi %d15,%d7,16
800079be:	57 02 61 ff 	extr.u %d15,%d2,%d15,1
800079c2:	e9 ff 30 00 	st.b [%a15]48,%d15
800079c6:	00 90       	ret 

800079c8 <IfxVadc_Adc_initChannel>:


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
800079c8:	99 52 14 00 	ld.a %a2,[%a5]20
800079cc:	d4 2e       	ld.a %a14,[%a2]
800079ce:	99 2c 04 00 	ld.a %a12,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
800079d2:	39 28 08 00 	ld.bu %d8,[%a2]8
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
800079d6:	b5 42 04 00 	st.a [%a4]4,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800079da:	02 84       	mov %d4,%d8
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
800079dc:	40 4d       	mov.aa %a13,%a4
    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800079de:	40 e4       	mov.aa %a4,%a14
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
800079e0:	40 5f       	mov.aa %a15,%a5
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;
800079e2:	79 59 0c 00 	ld.b %d9,[%a5]12

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800079e6:	6d ff ab e6 	call 8000473c <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
800079ea:	1b 09 06 20 	addi %d2,%d9,96
800079ee:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
800079f2:	0c fe       	ld.bu %d15,[%a15]14
800079f4:	54 22       	ld.w %d2,[%a2]
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800079f6:	40 e4       	mov.aa %a4,%a14
800079f8:	67 f2 0b f0 	ins.t %d15,%d2,11,%d15,0
800079fc:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
800079fe:	54 22       	ld.w %d2,[%a2]
80007a00:	0c ff       	ld.bu %d15,[%a15]15
80007a02:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
80007a06:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setLowerBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection lowerBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
80007a08:	54 22       	ld.w %d2,[%a2]
80007a0a:	39 ff 10 00 	ld.bu %d15,[%a15]16
80007a0e:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007a12:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setUpperBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection upperBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
80007a14:	54 22       	ld.w %d2,[%a2]
80007a16:	39 ff 11 00 	ld.bu %d15,[%a15]17
80007a1a:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80007a1e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setSyncRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean synchonize)
{
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
80007a20:	54 22       	ld.w %d2,[%a2]
80007a22:	0c f1       	ld.bu %d15,[%a15]1
80007a24:	67 f2 0a f0 	ins.t %d15,%d2,10,%d15,0
80007a28:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_InputClasses inputClass)
{
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
80007a2a:	54 22       	ld.w %d2,[%a2]
80007a2c:	0c fd       	ld.bu %d15,[%a15]13
80007a2e:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007a32:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelLimitCheckMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_LimitCheck limitCheck)
{
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
80007a34:	54 22       	ld.w %d2,[%a2]
80007a36:	39 ff 13 00 	ld.bu %d15,[%a15]19
80007a3a:	37 f2 02 f4 	insert %d15,%d2,%d15,8,2
80007a3e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setResultPosition(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean rightAlignedStorage)
{
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
80007a40:	54 22       	ld.w %d2,[%a2]
80007a42:	0c f3       	ld.bu %d15,[%a15]3
80007a44:	67 f2 15 f0 	ins.t %d15,%d2,21,%d15,0
80007a48:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBackgroundResultTarget(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean globalResultUsage)
{
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
80007a4a:	54 22       	ld.w %d2,[%a2]
80007a4c:	0c f0       	ld.bu %d15,[%a15]0
80007a4e:	67 f2 14 f0 	ins.t %d15,%d2,20,%d15,0
80007a52:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBoundaryMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundaryExtension boundaryMode)
{
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
80007a54:	54 22       	ld.w %d2,[%a2]
80007a56:	39 ff 12 00 	ld.bu %d15,[%a15]18
80007a5a:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
80007a5e:	6c 20       	st.w [%a2]0,%d15
80007a60:	1b 08 01 f0 	addi %d15,%d8,16
80007a64:	16 ff       	and %d15,255
80007a66:	02 f4       	mov %d4,%d15
80007a68:	6d ff 6a e6 	call 8000473c <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
80007a6c:	08 23       	ld.bu %d3,[%a15]2
80007a6e:	82 12       	mov %d2,1
80007a70:	0f 92 00 20 	sh %d2,%d2,%d9
80007a74:	f6 35       	jnz %d3,80007a7e <IfxVadc_Adc_initChannel+0xb6>
}


IFX_INLINE void IfxVadc_setGroupPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U |= (1 << channelIndex);
80007a76:	19 c3 08 00 	ld.w %d3,[%a12]8
80007a7a:	a6 32       	or %d2,%d3
80007a7c:	3c 05       	j 80007a86 <IfxVadc_Adc_initChannel+0xbe>
}


IFX_INLINE void IfxVadc_setBackgroundPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U &= ~(1 << channelIndex);
80007a7e:	19 c3 08 00 	ld.w %d3,[%a12]8
80007a82:	0f 23 e0 20 	andn %d2,%d3,%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007a86:	02 f4       	mov %d4,%d15
80007a88:	59 c2 08 00 	st.w [%a12]8,%d2
80007a8c:	40 e4       	mov.aa %a4,%a14
80007a8e:	6d ff 3b e6 	call 80004704 <IfxVadc_disableAccess>
}


IFX_INLINE void IfxVadc_setChannelEventNodePointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr channelSrcNr, IfxVadc_ChannelId channel)
{
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
80007a92:	79 d3 00 00 	ld.b %d3,[%a13]0
80007a96:	19 c5 20 40 	ld.w %d5,[%a12]288
80007a9a:	8f 23 00 f0 	sh %d15,%d3,2
80007a9e:	3b f0 00 20 	mov %d2,15
80007aa2:	0f f2 00 20 	sh %d2,%d2,%d15
80007aa6:	0f 25 e0 20 	andn %d2,%d5,%d2

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
80007aaa:	08 b4       	ld.bu %d4,[%a15]11
80007aac:	59 c2 20 40 	st.w [%a12]288,%d2
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
80007ab0:	19 c2 20 40 	ld.w %d2,[%a12]288
80007ab4:	0f f4 00 f0 	sh %d15,%d4,%d15
80007ab8:	a6 2f       	or %d15,%d2
80007aba:	59 cf 20 40 	st.w [%a12]288,%d15

    if (config->channelPriority > 0)
80007abe:	b9 ff 06 00 	ld.hu %d15,[%a15]6
80007ac2:	6e 1f       	jz %d15,80007b00 <IfxVadc_Adc_initChannel+0x138>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
80007ac4:	02 84       	mov %d4,%d8
80007ac6:	08 b5       	ld.bu %d5,[%a15]11
80007ac8:	6d ff 6b e7 	call 8000499e <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_clearChannelRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelId)
{
    vadcG->CEFCLR.U = 1 << channelId;
80007acc:	79 f2 0c 00 	ld.b %d2,[%a15]12
80007ad0:	82 1f       	mov %d15,1
80007ad2:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007ad6:	59 cf 10 40 	st.w [%a12]272,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007ada:	54 22       	ld.w %d2,[%a2]
80007adc:	08 63       	ld.bu %d3,[%a15]6
80007ade:	8f f2 cf 21 	andn %d2,%d2,255
80007ae2:	a6 32       	or %d2,%d3

        IfxVadc_clearChannelRequest(vadcG, config->channelId);
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
80007ae4:	0c f9       	ld.bu %d15,[%a15]9
80007ae6:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007ae8:	54 22       	ld.w %d2,[%a2]
80007aea:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007aee:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007af0:	4c 20       	ld.w %d15,[%a2]0
80007af2:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007af6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007af8:	4c 20       	ld.w %d15,[%a2]0
80007afa:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007afe:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80007b00:	0c ff       	ld.bu %d15,[%a15]15
80007b02:	08 a2       	ld.bu %d2,[%a15]10
80007b04:	ff 8f 15 80 	jge.u %d15,8,80007b2e <IfxVadc_Adc_initChannel+0x166>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80007b08:	19 c4 30 40 	ld.w %d4,[%a12]304
80007b0c:	06 2f       	sh %d15,2
80007b0e:	3b f0 00 30 	mov %d3,15
80007b12:	0f f3 00 30 	sh %d3,%d3,%d15
80007b16:	0f 34 e0 30 	andn %d3,%d4,%d3
80007b1a:	59 c3 30 40 	st.w [%a12]304,%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
80007b1e:	19 c3 30 40 	ld.w %d3,[%a12]304
80007b22:	0f f2 00 f0 	sh %d15,%d2,%d15
80007b26:	a6 3f       	or %d15,%d3
80007b28:	59 cf 30 40 	st.w [%a12]304,%d15
80007b2c:	3c 14       	j 80007b54 <IfxVadc_Adc_initChannel+0x18c>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer1(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007b2e:	c2 8f       	add %d15,-8
80007b30:	19 c4 34 40 	ld.w %d4,[%a12]308
80007b34:	06 2f       	sh %d15,2
80007b36:	3b f0 00 30 	mov %d3,15
80007b3a:	0f f3 00 30 	sh %d3,%d3,%d15
80007b3e:	0f 34 e0 30 	andn %d3,%d4,%d3
80007b42:	59 c3 34 40 	st.w [%a12]308,%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007b46:	19 c3 34 40 	ld.w %d3,[%a12]308
80007b4a:	0f f2 00 f0 	sh %d15,%d2,%d15
80007b4e:	a6 3f       	or %d15,%d3
80007b50:	59 cf 34 40 	st.w [%a12]308,%d15
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80007b54:	b9 ff 04 00 	ld.hu %d15,[%a15]4
80007b58:	6e 24       	jz %d15,80007ba0 <IfxVadc_Adc_initChannel+0x1d8>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
80007b5a:	02 84       	mov %d4,%d8
80007b5c:	08 a5       	ld.bu %d5,[%a15]10
80007b5e:	6d ff 20 e7 	call 8000499e <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_enableServiceRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelResult resultRegister)
{
    vadcG->RCR[resultRegister].B.SRGEN = 1;
80007b62:	0c ff       	ld.bu %d15,[%a15]15
80007b64:	1b 0f 08 f0 	addi %d15,%d15,128
80007b68:	90 c3       	addsc.a %a3,%a12,%d15,2
80007b6a:	4c 30       	ld.w %d15,[%a3]0
80007b6c:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80007b70:	6c 30       	st.w [%a3]0,%d15
}


IFX_INLINE void IfxVadc_clearAllResultRequests(Ifx_VADC_G *vadcG)
{
    vadcG->REFCLR.U = 0x0000FFFFu;
80007b72:	bb f0 ff ff 	mov.u %d15,65535
80007b76:	59 cf 14 40 	st.w [%a12]276,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007b7a:	54 22       	ld.w %d2,[%a2]
80007b7c:	08 43       	ld.bu %d3,[%a15]4
80007b7e:	8f f2 cf 21 	andn %d2,%d2,255
80007b82:	a6 32       	or %d2,%d3

        IfxVadc_enableServiceRequest(vadcG, config->resultRegister);
        IfxVadc_clearAllResultRequests(vadcG);
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
80007b84:	0c f8       	ld.bu %d15,[%a15]8
80007b86:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007b88:	54 22       	ld.w %d2,[%a2]
80007b8a:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007b8e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007b90:	4c 20       	ld.w %d15,[%a2]0
80007b92:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007b96:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007b98:	4c 20       	ld.w %d15,[%a2]0
80007b9a:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007b9e:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80007ba0:	40 e4       	mov.aa %a4,%a14
80007ba2:	02 84       	mov %d4,%d8
80007ba4:	6d ff b0 e5 	call 80004704 <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007ba8:	0c ff       	ld.bu %d15,[%a15]15
    channel->channel   = config->channelId;

    return Status;
}
80007baa:	82 02       	mov %d2,0
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007bac:	2c d1       	st.b [%a13]1,%d15
    channel->channel   = config->channelId;
80007bae:	0c fc       	ld.bu %d15,[%a15]12
80007bb0:	2c d0       	st.b [%a13]0,%d15

    return Status;
}
80007bb2:	00 90       	ret 

80007bb4 <IfxVadc_Adc_initChannelConfig>:
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
80007bb4:	40 42       	mov.aa %a2,%a4
80007bb6:	d2 02       	mov %e2,0
80007bb8:	89 22 48 01 	st.d [%a2+]8,%e2
80007bbc:	89 22 48 01 	st.d [%a2+]8,%e2
80007bc0:	89 22 48 01 	st.d [%a2+]8,%e2
    config->group = group;
80007bc4:	b5 45 14 00 	st.a [%a4]20,%a5
80007bc8:	00 90       	ret 

80007bca <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80007bca:	d4 52       	ld.a %a2,[%a5]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80007bcc:	39 58 04 00 	ld.bu %d8,[%a5]4


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80007bd0:	d4 2c       	ld.a %a12,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80007bd2:	8f a8 00 90 	sh %d9,%d8,10
80007bd6:	1b 09 48 f0 	addi %d15,%d9,1152
80007bda:	10 cd       	addsc.a %a13,%a12,%d15,0

    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
80007bdc:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];

    /* check for write access */
    group->group   = vadcG;
80007bde:	b5 4d 04 00 	st.a [%a4]4,%a13
    group->module  = *config->module;
80007be2:	6c 40       	st.w [%a4]0,%d15
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
80007be4:	e9 48 08 00 	st.b [%a4]8,%d8
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007be8:	40 c4       	mov.aa %a4,%a12
    config->group = group;
}


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
80007bea:	40 5f       	mov.aa %a15,%a5
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007bec:	6d ff 5a e6 	call 800048a0 <IfxVadc_getAdcAnalogFrequency>

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007bf0:	1b 08 01 f0 	addi %d15,%d8,16
80007bf4:	8f ff 0f a1 	and %d10,%d15,255
80007bf8:	40 c4       	mov.aa %a4,%a12
80007bfa:	02 a4       	mov %d4,%d10
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007bfc:	02 2b       	mov %d11,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007bfe:	6d ff 9f e5 	call 8000473c <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007c02:	39 ff 33 00 	ld.bu %d15,[%a15]51
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007c06:	40 d4       	mov.aa %a4,%a13
    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007c08:	5e 17       	jne %d15,1,80007c16 <IfxVadc_Adc_initGroup+0x4c>
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007c0a:	82 14       	mov %d4,1
80007c0c:	39 f5 26 00 	ld.bu %d5,[%a15]38
80007c10:	39 f6 27 00 	ld.bu %d6,[%a15]39
80007c14:	3c 03       	j 80007c1a <IfxVadc_Adc_initGroup+0x50>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80007c16:	d2 04       	mov %e4,0
80007c18:	82 06       	mov %d6,0
80007c1a:	82 07       	mov %d7,0
80007c1c:	6d ff 06 e8 	call 80004c28 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007c20:	39 ff 34 00 	ld.bu %d15,[%a15]52
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007c24:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007c26:	5e 17       	jne %d15,1,80007c34 <IfxVadc_Adc_initGroup+0x6a>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007c28:	82 14       	mov %d4,1
80007c2a:	39 f5 1e 00 	ld.bu %d5,[%a15]30
80007c2e:	39 f6 1f 00 	ld.bu %d6,[%a15]31
80007c32:	3c 03       	j 80007c38 <IfxVadc_Adc_initGroup+0x6e>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80007c34:	d2 04       	mov %e4,0
80007c36:	82 06       	mov %d6,0
80007c38:	82 17       	mov %d7,1
80007c3a:	6d ff f7 e7 	call 80004c28 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007c3e:	39 ff 35 00 	ld.bu %d15,[%a15]53
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007c42:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007c44:	5e 17       	jne %d15,1,80007c52 <IfxVadc_Adc_initGroup+0x88>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007c46:	82 14       	mov %d4,1
80007c48:	39 f5 2e 00 	ld.bu %d5,[%a15]46
80007c4c:	39 f6 2f 00 	ld.bu %d6,[%a15]47
80007c50:	3c 03       	j 80007c56 <IfxVadc_Adc_initGroup+0x8c>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
80007c52:	d2 04       	mov %e4,0
80007c54:	82 06       	mov %d6,0
80007c56:	82 27       	mov %d7,2
80007c58:	6d ff e8 e7 	call 80004c28 <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
80007c5c:	0c f5       	ld.bu %d15,[%a15]5
80007c5e:	be 8b       	jeq %d15,%d8,80007c94 <IfxVadc_Adc_initGroup+0xca>
}


IFX_INLINE IfxVadc_Adc_SYNCTR_STSEL IfxVadc_Adc_getMasterKernelIndex(IfxVadc_GroupId slave, IfxVadc_GroupId master)
{
    return IfxVadc_Adc_masterIndex[slave][master];
80007c60:	13 88 20 ff 	madd %d15,%d15,%d8,8
80007c64:	91 00 00 28 	movh.a %a2,32768
80007c68:	d9 22 d8 50 	lea %a2,[%a2]3416 <80000d58 <IfxVadc_Adc_masterIndex>>
80007c6c:	10 22       	addsc.a %a2,%a2,%d15,0
80007c6e:	0c 20       	ld.bu %d15,[%a2]0
}


IFX_INLINE void IfxVadc_setMasterIndex(Ifx_VADC_G *vadcG, uint8 masterIndex)
{
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80007c70:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007c74:	8f 3f 00 21 	and %d2,%d15,3
80007c78:	19 23 40 30 	ld.w %d3,[%a2]1216
80007c7c:	37 f3 02 f0 	insert %d15,%d3,%d15,0,2
80007c80:	59 2f 40 30 	st.w [%a2]1216,%d15
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
80007c84:	19 23 40 30 	ld.w %d3,[%a2]1216
80007c88:	da 08       	mov %d15,8
80007c8a:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007c8e:	a6 3f       	or %d15,%d3
80007c90:	59 2f 40 30 	st.w [%a2]1216,%d15
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007c94:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007c98:	19 2f 40 20 	ld.w %d15,[%a2]1152
80007c9c:	8f 3f c0 f1 	andn %d15,%d15,3
80007ca0:	59 2f 40 20 	st.w [%a2]1152,%d15
}


IFX_INLINE void IfxVadc_setArbitrationRoundLength(Ifx_VADC_G *vadcG, IfxVadc_ArbitrationRounds arbiterRoundLength)
{
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80007ca4:	39 ff 32 00 	ld.bu %d15,[%a15]50
80007ca8:	19 22 40 20 	ld.w %d2,[%a2]1152
80007cac:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007cb0:	59 2f 40 20 	st.w [%a2]1152,%d15
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007cb4:	39 ff 33 00 	ld.bu %d15,[%a15]51
80007cb8:	df 1f 5a 80 	jne %d15,1,80007d6c <IfxVadc_Adc_initGroup+0x1a2>
    {
        const IfxVadc_Adc_QueueConfig *queueSlot = &config->queueRequest;

        /* configure external Trigger if enabled */
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007cbc:	39 ff 25 00 	ld.bu %d15,[%a15]37
80007cc0:	6e 28       	jz %d15,80007d10 <IfxVadc_Adc_initGroup+0x146>
}


IFX_INLINE void IfxVadc_enableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80007cc2:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007cc6:	96 04       	or %d15,4
80007cc8:	59 2f 44 40 	st.w [%a2]1284,%d15


IFX_INLINE void IfxVadc_setQueueSlotTriggerOperatingConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U        = vadcG->QCTRL0.U;
80007ccc:	19 23 40 40 	ld.w %d3,[%a2]1280
        {
            /* enable external trigger */
            IfxVadc_enableQueueSlotExternalTrigger(vadcG);
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
80007cd0:	39 f2 25 00 	ld.bu %d2,[%a15]37
80007cd4:	39 ff 23 00 	ld.bu %d15,[%a15]35
    qctrl0.B.XTWC   = 1;
80007cd8:	b7 13 81 37 	insert %d3,%d3,1,15,1
    qctrl0.B.XTMODE = triggerMode;
80007cdc:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    qctrl0.B.XTSEL  = triggerSource;
80007ce0:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80007ce4:	59 23 40 40 	st.w [%a2]1280,%d3

            /* if last input is used the trigger input selection is extend by Gating inputs */
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80007ce8:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007cec:	8b ff 20 f2 	ne %d15,%d15,15
80007cf0:	ee 16       	jnz %d15,80007d1c <IfxVadc_Adc_initGroup+0x152>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007cf2:	19 23 40 40 	ld.w %d3,[%a2]1280
            {
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007cf6:	39 ff 22 00 	ld.bu %d15,[%a15]34
    qctrl0.B.GTWC      = 1;
80007cfa:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007cfe:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007d02:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007d06:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007d0a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007d0e:	3c 05       	j 80007d18 <IfxVadc_Adc_initGroup+0x14e>
}


IFX_INLINE void IfxVadc_disableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
80007d10:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007d14:	8f 4f c0 f1 	andn %d15,%d15,4
80007d18:	59 2f 44 40 	st.w [%a2]1284,%d15
            /* disable external trigger */
            IfxVadc_disableQueueSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007d1c:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007d20:	8b ff 00 f2 	eq %d15,%d15,15
80007d24:	ee 15       	jnz %d15,80007d4e <IfxVadc_Adc_initGroup+0x184>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007d26:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80007d2a:	39 f2 22 00 	ld.bu %d2,[%a15]34
80007d2e:	19 23 40 40 	ld.w %d3,[%a2]1280
80007d32:	39 ff 24 00 	ld.bu %d15,[%a15]36
    qctrl0.B.GTWC      = 1;
80007d36:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007d3a:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007d3e:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007d42:	19 22 44 40 	ld.w %d2,[%a2]1284
80007d46:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007d4a:	59 2f 44 40 	st.w [%a2]1284,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80007d4e:	39 f2 20 00 	ld.bu %d2,[%a15]32
}


IFX_INLINE void IfxVadc_clearQueue(Ifx_VADC_G *vadcG, boolean flushQueue)
{
    vadcG->QMR0.B.FLUSH = flushQueue;
80007d52:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007d56:	3b 00 40 f0 	mov %d15,1024
80007d5a:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80007d5e:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007d62:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80007d66:	a6 2f       	or %d15,%d2
80007d68:	59 2f 44 40 	st.w [%a2]1284,%d15
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007d6c:	39 ff 34 00 	ld.bu %d15,[%a15]52
80007d70:	df 1f 5a 80 	jne %d15,1,80007e24 <IfxVadc_Adc_initGroup+0x25a>
    {
        const IfxVadc_Adc_ScanConfig *scanSlot = &config->scanRequest;

        /* configure external Trigger if enabled */
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007d74:	39 ff 1d 00 	ld.bu %d15,[%a15]29
}


IFX_INLINE void IfxVadc_enableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
80007d78:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007d7c:	6e 28       	jz %d15,80007dcc <IfxVadc_Adc_initGroup+0x202>
80007d7e:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d82:	96 04       	or %d15,4
80007d84:	59 2f 64 40 	st.w [%a2]1316,%d15


IFX_INLINE void IfxVadc_setScanSlotTriggerConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U        = vadcG->ASCTRL.U;
80007d88:	19 23 60 40 	ld.w %d3,[%a2]1312
        {
            /* enable external trigger */
            IfxVadc_enableScanSlotExternalTrigger(vadcG);

            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80007d8c:	39 f2 1d 00 	ld.bu %d2,[%a15]29
80007d90:	39 ff 1b 00 	ld.bu %d15,[%a15]27
    asctrl.B.XTWC   = 1;
80007d94:	b7 13 81 37 	insert %d3,%d3,1,15,1
    asctrl.B.XTMODE = triggerMode;
80007d98:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    asctrl.B.XTSEL  = triggerSource;
80007d9c:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->ASCTRL.U = asctrl.U;
80007da0:	59 23 60 40 	st.w [%a2]1312,%d3

            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007da4:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007da8:	8b ff 20 f2 	ne %d15,%d15,15
80007dac:	ee 16       	jnz %d15,80007dd8 <IfxVadc_Adc_initGroup+0x20e>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007dae:	19 23 60 40 	ld.w %d3,[%a2]1312
            {
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007db2:	39 ff 1a 00 	ld.bu %d15,[%a15]26
    asctrl.B.GTWC      = 1;
80007db6:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007dba:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007dbe:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007dc2:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007dc6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007dca:	3c 05       	j 80007dd4 <IfxVadc_Adc_initGroup+0x20a>
}


IFX_INLINE void IfxVadc_disableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80007dcc:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007dd0:	8f 4f c0 f1 	andn %d15,%d15,4
80007dd4:	59 2f 64 40 	st.w [%a2]1316,%d15
        {
            IfxVadc_disableScanSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007dd8:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007ddc:	8b ff 00 f2 	eq %d15,%d15,15
80007de0:	ee 15       	jnz %d15,80007e0a <IfxVadc_Adc_initGroup+0x240>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007de2:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80007de6:	39 f2 1a 00 	ld.bu %d2,[%a15]26
80007dea:	19 23 60 40 	ld.w %d3,[%a2]1312
80007dee:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    asctrl.B.GTWC      = 1;
80007df2:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007df6:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007dfa:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007dfe:	19 22 64 40 	ld.w %d2,[%a2]1316
80007e02:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007e06:	59 2f 64 40 	st.w [%a2]1316,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80007e0a:	39 ff 18 00 	ld.bu %d15,[%a15]24
}


IFX_INLINE void IfxVadc_setAutoScan(Ifx_VADC_G *vadcG, boolean autoscanEnable)
{
    vadcG->ASMR.B.SCAN = autoscanEnable;
80007e0e:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007e12:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007e16:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007e1a:	8f 0f c1 f1 	andn %d15,%d15,16
80007e1e:	a6 2f       	or %d15,%d2
80007e20:	59 2f 64 40 	st.w [%a2]1316,%d15
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007e24:	39 ff 35 00 	ld.bu %d15,[%a15]53
80007e28:	df 1f 4f 80 	jne %d15,1,80007ec6 <IfxVadc_Adc_initGroup+0x2fc>
    {
        const IfxVadc_Adc_BackgroundScanConfig *backgroundScanSlot = &config->backgroundScanRequest;

        /* configure external Trigger if enabled */
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007e2c:	39 ff 2d 00 	ld.bu %d15,[%a15]45
80007e30:	6e 29       	jz %d15,80007e82 <IfxVadc_Adc_initGroup+0x2b8>
}


IFX_INLINE void IfxVadc_enableBackgroundScanSlotExternalTrigger(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80007e32:	19 cf 04 80 	ld.w %d15,[%a12]516
80007e36:	96 04       	or %d15,4
80007e38:	59 cf 04 80 	st.w [%a12]516,%d15


IFX_INLINE void IfxVadc_setBackgroundScanSlotTriggerConfig(Ifx_VADC *vadc, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U        = vadc->BRSCTRL.U;
80007e3c:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_enableBackgroundScanSlotExternalTrigger(vadc);

            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80007e40:	39 f2 2d 00 	ld.bu %d2,[%a15]45
80007e44:	39 ff 2b 00 	ld.bu %d15,[%a15]43
    brsctrl.B.XTWC   = 1;
80007e48:	b7 13 81 37 	insert %d3,%d3,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80007e4c:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    brsctrl.B.XTSEL  = triggerSource;
80007e50:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
80007e54:	59 c3 00 80 	st.w [%a12]512,%d3

            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007e58:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007e5c:	8b ff 20 f2 	ne %d15,%d15,15
80007e60:	ee 11       	jnz %d15,80007e82 <IfxVadc_Adc_initGroup+0x2b8>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007e62:	19 c3 00 80 	ld.w %d3,[%a12]512
            {
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007e66:	39 ff 2a 00 	ld.bu %d15,[%a15]42
    brsctrl.B.GTWC     = 1;
80007e6a:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007e6e:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
80007e72:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007e76:	19 cf 04 80 	ld.w %d15,[%a12]516
80007e7a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007e7e:	59 cf 04 80 	st.w [%a12]516,%d15
        {
            /* do nothing */
        }

        /* configure Gating if enabled */
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007e82:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007e86:	8b ff 00 f2 	eq %d15,%d15,15
80007e8a:	ee 13       	jnz %d15,80007eb0 <IfxVadc_Adc_initGroup+0x2e6>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007e8c:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80007e90:	39 f2 2a 00 	ld.bu %d2,[%a15]42
    brsctrl.B.GTWC     = 1;
80007e94:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007e98:	37 23 04 38 	insert %d3,%d3,%d2,16,4
80007e9c:	39 ff 2c 00 	ld.bu %d15,[%a15]44
    vadc->BRSCTRL.U    = brsctrl.U;
80007ea0:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007ea4:	19 c2 04 80 	ld.w %d2,[%a12]516
80007ea8:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007eac:	59 cf 04 80 	st.w [%a12]516,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
80007eb0:	39 ff 28 00 	ld.bu %d15,[%a15]40
}


IFX_INLINE void IfxVadc_setAutoBackgroundScan(Ifx_VADC *vadc, boolean autoBackgroundScanEnable)
{
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80007eb4:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007eb8:	19 cf 04 80 	ld.w %d15,[%a12]516
80007ebc:	8f 0f c1 f1 	andn %d15,%d15,16
80007ec0:	a6 2f       	or %d15,%d2
80007ec2:	59 cf 04 80 	st.w [%a12]516,%d15
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80007ec6:	0c f5       	ld.bu %d15,[%a15]5
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007ec8:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007ecc:	3a 8f       	eq %d15,%d15,%d8
80007ece:	ab 3f a0 2f 	seln %d2,%d15,%d15,3
80007ed2:	19 2f 40 20 	ld.w %d15,[%a2]1152
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80007ed6:	02 84       	mov %d4,%d8
80007ed8:	8f 3f c0 f1 	andn %d15,%d15,3
80007edc:	a6 2f       	or %d15,%d2
80007ede:	59 2f 40 20 	st.w [%a2]1152,%d15
80007ee2:	39 f5 30 00 	ld.bu %d5,[%a15]48
80007ee6:	40 c4       	mov.aa %a4,%a12
80007ee8:	6d ff 69 e4 	call 800047ba <IfxVadc_disablePostCalibration>
}


IFX_INLINE void IfxVadc_setGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
80007eec:	8f 88 00 80 	sh %d8,%d8,8
80007ef0:	82 05       	mov %d5,0
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80007ef2:	3b f0 0f 40 	mov %d4,255

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
80007ef6:	01 f5 03 26 	addsc.a %a2,%a15,%d5,3
80007efa:	0b 58 00 20 	add %d2,%d8,%d5
80007efe:	1b 82 12 20 	addi %d2,%d2,296
80007f02:	0c 2c       	ld.bu %d15,[%a2]12
80007f04:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
80007f08:	54 22       	ld.w %d2,[%a2]
80007f0a:	37 f2 03 f4 	insert %d15,%d2,%d15,8,3
80007f0e:	6c 20       	st.w [%a2]0,%d15
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
80007f10:	9a 15       	add %d15,%d5,1
80007f12:	d0 f2       	addsc.a %a2,%a15,%d15,3

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007f14:	54 23       	ld.w %d3,[%a2]
80007f16:	4b 3b 41 30 	mul.f %d3,%d11,%d3
80007f1a:	4b 03 71 31 	ftouz %d3,%d3
80007f1e:	c2 e3       	add %d3,-2

    if (ticks > 31)
80007f20:	8b 03 62 f2 	lt.u %d15,%d3,32
80007f24:	ee 04       	jnz %d15,80007f2c <IfxVadc_Adc_initGroup+0x362>
    {
        ticks = (ticks / 16) + 15;
80007f26:	06 c3       	sh %d3,-4
80007f28:	1b f3 00 30 	addi %d3,%d3,15
80007f2c:	0b 43 90 31 	min.u %d3,%d3,%d4
}


IFX_INLINE void IfxVadc_setGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007f30:	1a 58       	add %d15,%d8,%d5
80007f32:	1b 8f 12 f0 	addi %d15,%d15,296
80007f36:	90 c2       	addsc.a %a2,%a12,%d15,2
80007f38:	4c 20       	ld.w %d15,[%a2]0
80007f3a:	37 3f 05 30 	insert %d3,%d15,%d3,0,5
80007f3e:	74 23       	st.w [%a2],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80007f40:	df 15 04 00 	jeq %d5,1,80007f48 <IfxVadc_Adc_initGroup+0x37e>
80007f44:	82 15       	mov %d5,1
80007f46:	3c d8       	j 80007ef6 <IfxVadc_Adc_initGroup+0x32c>
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007f48:	40 c4       	mov.aa %a4,%a12
80007f4a:	02 a4       	mov %d4,%d10
80007f4c:	6d ff dc e3 	call 80004704 <IfxVadc_disableAccess>

    return status;
}
80007f50:	82 02       	mov %d2,0
80007f52:	00 90       	ret 

80007f54 <IfxVadc_Adc_initGroupConfig>:
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80007f54:	40 42       	mov.aa %a2,%a4
80007f56:	7b 60 58 f3 	movh %d15,13702
80007f5a:	d2 02       	mov %e2,0
80007f5c:	a0 6f       	mov.a %a15,6
80007f5e:	89 22 48 01 	st.d [%a2+]8,%e2
80007f62:	fc fe       	loop %a15,80007f5e <IfxVadc_Adc_initGroupConfig+0xa>
80007f64:	1b df 7b f3 	addi %d15,%d15,14269
80007f68:	6c 42       	st.w [%a4]8,%d15
80007f6a:	6c 44       	st.w [%a4]16,%d15
80007f6c:	82 1f       	mov %d15,1
80007f6e:	e9 4f 1e 00 	st.b [%a4]30,%d15
80007f72:	e9 4f 20 00 	st.b [%a4]32,%d15
80007f76:	e9 4f 26 00 	st.b [%a4]38,%d15
80007f7a:	e9 4f 2e 00 	st.b [%a4]46,%d15
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
80007f7e:	f4 45       	st.a [%a4],%a5
80007f80:	00 90       	ret 

80007f82 <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80007f82:	cc 50       	ld.a %a15,[%a5]0
    config->disablePostCalibration = FALSE;
}


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
80007f84:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
    vadc->vadc = vadcSFR;
80007f86:	ec 40       	st.a [%a4]0,%a15
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007f88:	6d ff 0f fa 	call 800073a6 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007f8c:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007f8e:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007f90:	6d ff 0b f9 	call 800071a6 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80007f94:	82 02       	mov %d2,0
80007f96:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007f98:	02 f4       	mov %d4,%d15
80007f9a:	6d ff 3b fa 	call 80007410 <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
80007f9e:	40 f4       	mov.aa %a4,%a15
80007fa0:	39 c4 21 00 	ld.bu %d4,[%a12]33
80007fa4:	6d ff 30 e6 	call 80004c04 <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007fa8:	19 c4 18 00 	ld.w %d4,[%a12]24
80007fac:	40 f4       	mov.aa %a4,%a15
80007fae:	4b 04 71 41 	ftouz %d4,%d4
    {
        return IfxVadc_Status_notInitialised;
80007fb2:	82 1f       	mov %d15,1
    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007fb4:	6d ff 42 e5 	call 80004a38 <IfxVadc_initializeFAdcI>
80007fb8:	df 02 57 00 	jeq %d2,0,80008066 <_SMALL_DATA2_+0x66>
    {
        /* do nothing */
    }

    /* Set digital Frequency */
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
80007fbc:	19 c4 14 00 	ld.w %d4,[%a12]20
80007fc0:	40 f4       	mov.aa %a4,%a15
80007fc2:	4b 04 71 41 	ftouz %d4,%d4
80007fc6:	6d ff 24 e5 	call 80004a0e <IfxVadc_initializeFAdcD>

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
80007fca:	40 f4       	mov.aa %a4,%a15
80007fcc:	6d ff 6a e4 	call 800048a0 <IfxVadc_getAdcAnalogFrequency>
80007fd0:	82 03       	mov %d3,0
80007fd2:	3b f0 0f 60 	mov %d6,255

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
    {
        /* configure ADC channel resolution ( conversion mode ) */
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
80007fd6:	9a 13       	add %d15,%d3,1
}


IFX_INLINE void IfxVadc_setGlobalResolution(Ifx_VADC *vadc, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
80007fd8:	1b 83 02 40 	addi %d4,%d3,40
80007fdc:	d0 c2       	addsc.a %a2,%a12,%d15,3
80007fde:	01 f4 02 36 	addsc.a %a3,%a15,%d4,2
80007fe2:	0c 20       	ld.bu %d15,[%a2]0
80007fe4:	54 35       	ld.w %d5,[%a3]
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
80007fe6:	01 c3 03 26 	addsc.a %a2,%a12,%d3,3
80007fea:	37 f5 03 f4 	insert %d15,%d5,%d15,8,3
80007fee:	6c 30       	st.w [%a3]0,%d15

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007ff0:	4c 21       	ld.w %d15,[%a2]4
80007ff2:	4b f2 41 f0 	mul.f %d15,%d2,%d15
80007ff6:	4b 0f 71 f1 	ftouz %d15,%d15
80007ffa:	c2 ef       	add %d15,-2

    if (ticks > 31)
80007ffc:	8b 0f 62 52 	lt.u %d5,%d15,32
80008000:	f6 54       	jnz %d5,80008008 <_SMALL_DATA2_+0x8>
    {
        ticks = (ticks / 16) + 15;
80008002:	06 cf       	sh %d15,-4
80008004:	1b ff 00 f0 	addi %d15,%d15,15
80008008:	0b 6f 90 f1 	min.u %d15,%d15,%d6
}


IFX_INLINE void IfxVadc_setGlobalSampleTime(Ifx_VADC *vadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
8000800c:	01 f4 02 26 	addsc.a %a2,%a15,%d4,2
80008010:	54 24       	ld.w %d4,[%a2]
80008012:	37 f4 05 f0 	insert %d15,%d4,%d15,0,5
80008016:	6c 20       	st.w [%a2]0,%d15
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80008018:	df 13 04 00 	jeq %d3,1,80008020 <_SMALL_DATA2_+0x20>
8000801c:	82 13       	mov %d3,1
8000801e:	3c dc       	j 80007fd6 <IfxVadc_Adc_initModule+0x54>
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80008020:	39 c2 20 00 	ld.bu %d2,[%a12]32

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
80008024:	82 0f       	mov %d15,0
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80008026:	df 12 20 80 	jne %d2,1,80008066 <_SMALL_DATA2_+0x66>
8000802a:	82 08       	mov %d8,0
8000802c:	1b 08 01 f0 	addi %d15,%d8,16
80008030:	16 ff       	and %d15,255
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80008032:	02 f4       	mov %d4,%d15
80008034:	40 f4       	mov.aa %a4,%a15
80008036:	6d ff 83 e3 	call 8000473c <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
8000803a:	8f a8 00 20 	sh %d2,%d8,10
8000803e:	01 f2 00 26 	addsc.a %a2,%a15,%d2,0
80008042:	c2 18       	add %d8,1
80008044:	19 22 40 20 	ld.w %d2,[%a2]1152
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80008048:	02 f4       	mov %d4,%d15
8000804a:	8f 32 40 21 	or %d2,%d2,3
8000804e:	59 22 40 20 	st.w [%a2]1152,%d2
80008052:	40 f4       	mov.aa %a4,%a15

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80008054:	8b 88 20 f2 	ne %d15,%d8,8
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80008058:	6d ff 56 e3 	call 80004704 <IfxVadc_disableAccess>

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
8000805c:	ee e8       	jnz %d15,8000802c <_SMALL_DATA2_+0x2c>
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
        }

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
8000805e:	40 f4       	mov.aa %a4,%a15
80008060:	6d ff 19 e6 	call 80004c92 <IfxVadc_startupCalibration>
    }

    return status;
80008064:	82 0f       	mov %d15,0
}
80008066:	02 f2       	mov %d2,%d15
80008068:	00 90       	ret 

8000806a <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
8000806a:	7b 90 b9 f4 	movh %d15,19353
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
8000806e:	40 4f       	mov.aa %a15,%a4
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80008070:	1b 0f 68 f9 	addi %d15,%d15,-27008
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80008074:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
80008076:	e8 05       	st.a [%a15]0,%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80008078:	68 6f       	st.w [%a15]24,%d15

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
8000807a:	6d ff 1f e4 	call 800048b8 <IfxVadc_getAdcDigitalFrequency>
8000807e:	68 52       	st.w [%a15]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
80008080:	6d ff cf f0 	call 8000621e <IfxScuCcu_getSpbFrequency>
80008084:	68 72       	st.w [%a15]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    config->globalInputClass[0].sampleTime = 1.0e-6;
80008086:	7b 60 58 23 	movh %d2,13702
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
8000808a:	82 0f       	mov %d15,0
    config->globalInputClass[0].sampleTime = 1.0e-6;
8000808c:	1b d2 7b 23 	addi %d2,%d2,14269
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80008090:	28 8f       	st.b [%a15]8,%d15
    config->globalInputClass[0].sampleTime = 1.0e-6;
80008092:	68 12       	st.w [%a15]4,%d2
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
80008094:	e9 ff 10 00 	st.b [%a15]16,%d15
    config->globalInputClass[1].sampleTime = 1.0e-6;
80008098:	68 32       	st.w [%a15]12,%d2
    config->startupCalibration             = FALSE;
8000809a:	e9 ff 20 00 	st.b [%a15]32,%d15
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
8000809e:	e9 ff 21 00 	st.b [%a15]33,%d15
800080a2:	00 90       	ret 

800080a4 <IfxVadc_Adc_initExternalMultiplexerModeConfig>:
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
800080a4:	20 10       	sub.a %sp,16
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
800080a6:	82 0f       	mov %d15,0
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
800080a8:	40 a2       	mov.aa %a2,%sp


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
800080aa:	2c 49       	st.b [%a4]9,%d15
    emuxConfig->groupId               = IfxVadc_GroupId_0;
800080ac:	2c 48       	st.b [%a4]8,%d15
    emuxConfig->emuxInterface         = IfxVadc_EmuxInterface_0;
800080ae:	2c 4a       	st.b [%a4]10,%d15
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
800080b0:	2c 45       	st.b [%a4]5,%d15
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
800080b2:	2c 46       	st.b [%a4]6,%d15
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
800080b4:	2c 47       	st.b [%a4]7,%d15
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
800080b6:	2c 44       	st.b [%a4]4,%d15
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
800080b8:	e9 4f 1c 00 	st.b [%a4]28,%d15
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
800080bc:	d2 02       	mov %e2,0
800080be:	89 22 48 01 	st.d [%a2+]8,%e2
800080c2:	89 22 48 01 	st.d [%a2+]8,%e2
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
800080c6:	3b 00 f8 ff 	mov %d15,-128
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
800080ca:	f4 45       	st.a [%a4],%a5
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
800080cc:	40 af       	mov.aa %a15,%sp
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
800080ce:	2c ac       	st.b [%sp]12,%d15
800080d0:	d9 44 0c 00 	lea %a4,[%a4]12
800080d4:	09 f2 48 01 	ld.d %e2,[%a15+]8
800080d8:	89 42 48 01 	st.d [%a4+]8,%e2
800080dc:	09 f2 48 01 	ld.d %e2,[%a15+]8
800080e0:	89 42 48 01 	st.d [%a4+]8,%e2
800080e4:	00 90       	ret 

800080e6 <IfxVadc_Adc_initExternalMultiplexerMode>:


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
800080e6:	0c 58       	ld.bu %d15,[%a5]8
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
800080e8:	20 08       	sub.a %sp,8
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
800080ea:	8f af 00 20 	sh %d2,%d15,10
800080ee:	1b 02 48 20 	addi %d2,%d2,1152
800080f2:	01 42 00 e6 	addsc.a %a14,%a4,%d2,0
}


IFX_INLINE void IfxVadc_setEmuxInterfaceForGroup(Ifx_VADC *vadc, IfxVadc_EmuxInterface emuxInterface, IfxVadc_GroupId group)
{
    if (emuxInterface == IfxVadc_EmuxInterface_0)
800080f6:	39 52 0a 00 	ld.bu %d2,[%a5]10
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
800080fa:	40 4c       	mov.aa %a12,%a4
800080fc:	40 5f       	mov.aa %a15,%a5
800080fe:	16 0f       	and %d15,15
80008100:	f6 2a       	jnz %d2,80008114 <IfxVadc_Adc_initExternalMultiplexerMode+0x2e>
    {
        vadc->EMUXSEL.B.EMUXGRP0 = group;
80008102:	19 42 30 f0 	ld.w %d2,[%a4]1008
80008106:	8f f2 c0 21 	andn %d2,%d2,15
8000810a:	a6 2f       	or %d15,%d2
8000810c:	59 cf 30 f0 	st.w [%a12]1008,%d15
80008110:	82 0f       	mov %d15,0
80008112:	3c 07       	j 80008120 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
    }
    else
    {
        vadc->EMUXSEL.B.EMUXGRP1 = group;
80008114:	19 42 30 f0 	ld.w %d2,[%a4]1008
80008118:	06 4f       	sh %d15,4
8000811a:	8f 02 cf 21 	andn %d2,%d2,240
8000811e:	3c f6       	j 8000810a <IfxVadc_Adc_initExternalMultiplexerMode+0x24>
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
    {
        if (emuxControl->emuxOutPinConfig.pins[count] != NULL_PTR)
80008120:	90 f2       	addsc.a %a2,%a15,%d15,2
80008122:	99 2d 0c 00 	ld.a %a13,[%a2]12
80008126:	bd 0d 19 00 	jz.a %a13,80008158 <IfxVadc_Adc_initExternalMultiplexerMode+0x72>
8000812a:	39 d3 0c 00 	ld.bu %d3,[%a13]12
8000812e:	39 f2 18 00 	ld.bu %d2,[%a15]24
80008132:	99 d4 04 00 	ld.a %a4,[%a13]4
80008136:	0f 23 a0 50 	or %d5,%d3,%d2
8000813a:	39 d4 08 00 	ld.bu %d4,[%a13]8
8000813e:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
80008142:	39 f8 19 00 	ld.bu %d8,[%a15]25
80008146:	6d ff c4 ed 	call 80005cce <IfxPort_setPinMode>


IFX_INLINE void IfxVadc_initEmuxPin(const IfxVadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(emux->pin.port, emux->pin.pinIndex, outputMode, emux->select);
    IfxPort_setPinPadDriver(emux->pin.port, emux->pin.pinIndex, padDriver);
8000814a:	99 d4 04 00 	ld.a %a4,[%a13]4
8000814e:	39 d4 08 00 	ld.bu %d4,[%a13]8
80008152:	02 85       	mov %d5,%d8
80008154:	6d ff 3b ee 	call 80005dca <IfxPort_setPinPadDriver>
80008158:	c2 1f       	add %d15,1
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
8000815a:	df 3f e3 ff 	jne %d15,3,80008120 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
        }
    }

    IfxVadc_configExternalMultiplexerMode(vadc, vadcG, emuxControl->mode, emuxControl->channels, emuxControl->startChannel, emuxControl->code, emuxControl->sampleTimeControl, emuxControl->channelSelectionStyle);
8000815e:	0c f7       	ld.bu %d15,[%a15]7
80008160:	08 44       	ld.bu %d4,[%a15]4
80008162:	78 00       	st.w [%sp]0,%d15
80008164:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80008168:	08 95       	ld.bu %d5,[%a15]9
8000816a:	08 56       	ld.bu %d6,[%a15]5
8000816c:	08 67       	ld.bu %d7,[%a15]6
8000816e:	78 01       	st.w [%sp]4,%d15
80008170:	40 c4       	mov.aa %a4,%a12
80008172:	40 e5       	mov.aa %a5,%a14
80008174:	1d ff 00 e3 	j 80004774 <IfxVadc_configExternalMultiplexerMode>

80008178 <Ifx_CircularBuffer_get32>:

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80008178:	cc 40       	ld.a %a15,[%a4]0
8000817a:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 4;

    if (buffer->index >= buffer->length)
8000817e:	b9 43 06 00 	ld.hu %d3,[%a4]6

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80008182:	90 ff       	addsc.a %a15,%a15,%d15,2

    buffer->index += 4;
80008184:	c2 4f       	add %d15,4
80008186:	37 0f 70 f0 	extr.u %d15,%d15,0,16

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
8000818a:	48 02       	ld.w %d2,[%a15]0

    buffer->index += 4;
8000818c:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
8000818e:	3f 3f 04 80 	jlt.u %d15,%d3,80008196 <Ifx_CircularBuffer_get32+0x1e>
    {
        buffer->index = 0;
80008192:	82 0f       	mov %d15,0
80008194:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
80008196:	00 90       	ret 

80008198 <Ifx_CircularBuffer_get16>:


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80008198:	cc 40       	ld.a %a15,[%a4]0
8000819a:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 2;

    if (buffer->index >= buffer->length)
8000819e:	b9 43 06 00 	ld.hu %d3,[%a4]6
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
800081a2:	50 ff       	addsc.a %a15,%a15,%d15,1

    buffer->index += 2;
800081a4:	c2 2f       	add %d15,2
800081a6:	37 0f 70 f0 	extr.u %d15,%d15,0,16
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
800081aa:	b9 f2 00 00 	ld.hu %d2,[%a15]0

    buffer->index += 2;
800081ae:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
800081b0:	3f 3f 04 80 	jlt.u %d15,%d3,800081b8 <Ifx_CircularBuffer_get16+0x20>
    {
        buffer->index = 0;
800081b4:	82 0f       	mov %d15,0
800081b6:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
800081b8:	00 90       	ret 

800081ba <Ifx_CircularBuffer_addDataIncr>:
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
800081ba:	cc 40       	ld.a %a15,[%a4]0
800081bc:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    buffer->index                          += 4;

    if (buffer->index >= buffer->length)
800081c0:	b9 42 06 00 	ld.hu %d2,[%a4]6
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
800081c4:	90 ff       	addsc.a %a15,%a15,%d15,2
    buffer->index                          += 4;
800081c6:	c2 4f       	add %d15,4
800081c8:	37 0f 70 f0 	extr.u %d15,%d15,0,16
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
800081cc:	68 04       	st.w [%a15]0,%d4
    buffer->index                          += 4;
800081ce:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
800081d0:	3f 2f 04 80 	jlt.u %d15,%d2,800081d8 <Ifx_CircularBuffer_addDataIncr+0x1e>
    {
        buffer->index = 0;
800081d4:	82 0f       	mov %d15,0
800081d6:	ac 42       	st.h [%a4]4,%d15
800081d8:	00 90       	ret 

800081da <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
800081da:	80 52       	mov.d %d2,%a5
800081dc:	37 04 70 40 	extr.u %d4,%d4,0,16
800081e0:	8f 02 60 31 	nor %d3,%d2,0
800081e4:	1a 42       	add %d15,%d2,%d4
800081e6:	42 3f       	add %d15,%d3
800081e8:	42 23       	add %d3,%d2
800081ea:	42 43       	add %d3,%d4
    uint8 *Dest = (uint8 *)data;
800081ec:	40 5f       	mov.aa %a15,%a5
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
800081ee:	82 06       	mov %d6,0
800081f0:	37 0f 70 f0 	extr.u %d15,%d15,0,16
800081f4:	6f f3 03 00 	jz.t %d3,15,800081fa <Ifx_CircularBuffer_read8+0x20>
800081f8:	82 0f       	mov %d15,0
    uint8 *Dest = (uint8 *)data;

    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
800081fa:	b9 43 04 00 	ld.hu %d3,[%a4]4
800081fe:	d4 42       	ld.a %a2,[%a4]
80008200:	60 33       	mov.a %a3,%d3
80008202:	30 32       	add.a %a2,%a3
80008204:	14 23       	ld.bu %d3,[%a2]
80008206:	24 f3       	st.b [%a15+],%d3
        Dest  = &Dest[1];
        buffer->index++;
80008208:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
8000820c:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
        Dest  = &Dest[1];
        buffer->index++;
80008210:	c2 13       	add %d3,1
80008212:	37 03 70 30 	extr.u %d3,%d3,0,16
80008216:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
8000821a:	3f 53 04 80 	jlt.u %d3,%d5,80008222 <Ifx_CircularBuffer_read8+0x48>
        {
            buffer->index = 0;
8000821e:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
80008222:	9f 0f ec ff 	jned %d15,0,800081fa <Ifx_CircularBuffer_read8+0x20>
80008226:	c2 f4       	add %d4,-1
80008228:	37 04 50 40 	extr %d4,%d4,0,16
8000822c:	8b 04 40 43 	max %d4,%d4,0
80008230:	c2 14       	add %d4,1

    return Dest;
}
80008232:	1a 42       	add %d15,%d2,%d4
80008234:	60 f2       	mov.a %a2,%d15
80008236:	00 90       	ret 

80008238 <Ifx_CircularBuffer_read32>:


void *Ifx_CircularBuffer_read32(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
80008238:	37 04 70 40 	extr.u %d4,%d4,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;
8000823c:	d4 42       	ld.a %a2,[%a4]
8000823e:	1b f4 ff 5f 	addi %d5,%d4,-1
80008242:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
80008246:	b9 46 06 00 	ld.hu %d6,[%a4]6
8000824a:	82 03       	mov %d3,0
8000824c:	37 05 70 20 	extr.u %d2,%d5,0,16
80008250:	6f f5 03 00 	jz.t %d5,15,80008256 <Ifx_CircularBuffer_read32+0x1e>
80008254:	82 02       	mov %d2,0
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
80008256:	10 2f       	addsc.a %a15,%a2,%d15,0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
80008258:	c2 4f       	add %d15,4
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
8000825a:	48 05       	ld.w %d5,[%a15]0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
8000825c:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
80008260:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
80008264:	c2 13       	add %d3,1
80008266:	68 05       	st.w [%a15]0,%d5
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008268:	0b 6f 30 51 	lt.u %d5,%d15,%d6
8000826c:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
80008270:	9f 02 f3 ff 	jned %d2,0,80008256 <Ifx_CircularBuffer_read32+0x1e>
80008274:	c2 f4       	add %d4,-1
80008276:	37 04 50 40 	extr %d4,%d4,0,16
8000827a:	ac 42       	st.h [%a4]4,%d15
8000827c:	8b 04 40 43 	max %d4,%d4,0
80008280:	c2 14       	add %d4,1

    return Dest;
}
80008282:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
80008286:	00 90       	ret 

80008288 <Ifx_CircularBuffer_write8>:


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
80008288:	80 52       	mov.d %d2,%a5
8000828a:	37 04 70 40 	extr.u %d4,%d4,0,16
8000828e:	8f 02 60 31 	nor %d3,%d2,0
80008292:	1a 42       	add %d15,%d2,%d4
80008294:	42 3f       	add %d15,%d3
80008296:	42 23       	add %d3,%d2
80008298:	42 43       	add %d3,%d4
    const uint8 *source = (const uint8 *)data;
8000829a:	40 5f       	mov.aa %a15,%a5
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
8000829c:	82 06       	mov %d6,0
8000829e:	37 0f 70 f0 	extr.u %d15,%d15,0,16
800082a2:	6f f3 03 00 	jz.t %d3,15,800082a8 <Ifx_CircularBuffer_write8+0x20>
800082a6:	82 0f       	mov %d15,0
    const uint8 *source = (const uint8 *)data;

    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
800082a8:	b9 43 04 00 	ld.hu %d3,[%a4]4
800082ac:	d4 42       	ld.a %a2,[%a4]
800082ae:	60 33       	mov.a %a3,%d3
800082b0:	04 f5       	ld.bu %d5,[%a15+]
800082b2:	30 32       	add.a %a2,%a3
800082b4:	34 25       	st.b [%a2],%d5
        source                                 = &source[1];
        buffer->index++;
800082b6:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
800082ba:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
        source                                 = &source[1];
        buffer->index++;
800082be:	c2 13       	add %d3,1
800082c0:	37 03 70 30 	extr.u %d3,%d3,0,16
800082c4:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
800082c8:	3f 53 04 80 	jlt.u %d3,%d5,800082d0 <Ifx_CircularBuffer_write8+0x48>
        {
            buffer->index = 0;
800082cc:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
800082d0:	9f 0f ec ff 	jned %d15,0,800082a8 <Ifx_CircularBuffer_write8+0x20>
800082d4:	c2 f4       	add %d4,-1
800082d6:	37 04 50 40 	extr %d4,%d4,0,16
800082da:	8b 04 40 43 	max %d4,%d4,0
800082de:	c2 14       	add %d4,1

    return source;
}
800082e0:	1a 42       	add %d15,%d2,%d4
800082e2:	60 f2       	mov.a %a2,%d15
800082e4:	00 90       	ret 

800082e6 <Ifx_CircularBuffer_write32>:


const void *Ifx_CircularBuffer_write32(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
800082e6:	37 04 70 40 	extr.u %d4,%d4,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;
800082ea:	d4 42       	ld.a %a2,[%a4]
800082ec:	1b f4 ff 5f 	addi %d5,%d4,-1
800082f0:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *((uint32 *)(&base[buffer->index])) = *source;
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
800082f4:	b9 46 06 00 	ld.hu %d6,[%a4]6
800082f8:	82 03       	mov %d3,0
800082fa:	37 05 70 20 	extr.u %d2,%d5,0,16
800082fe:	6f f5 03 00 	jz.t %d5,15,80008304 <Ifx_CircularBuffer_write32+0x1e>
80008302:	82 02       	mov %d2,0
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
80008304:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
80008308:	c2 13       	add %d3,1
8000830a:	48 05       	ld.w %d5,[%a15]0
8000830c:	10 2f       	addsc.a %a15,%a2,%d15,0
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;
8000830e:	c2 4f       	add %d15,4
80008310:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
80008314:	68 05       	st.w [%a15]0,%d5
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008316:	0b 6f 30 51 	lt.u %d5,%d15,%d6
8000831a:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
8000831e:	9f 02 f3 ff 	jned %d2,0,80008304 <Ifx_CircularBuffer_write32+0x1e>
80008322:	c2 f4       	add %d4,-1
80008324:	37 04 50 40 	extr %d4,%d4,0,16
80008328:	ac 42       	st.h [%a4]4,%d15
8000832a:	8b 04 40 43 	max %d4,%d4,0
8000832e:	c2 14       	add %d4,1

    return source;
}
80008330:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
80008334:	00 90       	ret 

80008336 <Ifx_Fifo_destroy>:
}


void Ifx_Fifo_destroy(Ifx_Fifo *fifo)
{
    free(fifo);
80008336:	1d 00 a0 18 	j 8000b476 <free>

8000833a <Ifx_Fifo_init>:
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
8000833a:	82 0f       	mov %d15,0
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
8000833c:	80 42       	mov.d %d2,%a4
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
8000833e:	e9 4f 1c 00 	st.b [%a4]28,%d15
        fifo->eventWriter        = TRUE;
80008342:	82 1f       	mov %d15,1
80008344:	e9 4f 1d 00 	st.b [%a4]29,%d15
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80008348:	1b 72 02 f0 	addi %d15,%d2,39
8000834c:	8f 7f c0 f1 	andn %d15,%d15,7
80008350:	6c 40       	st.w [%a4]0,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
80008352:	c2 34       	add %d4,3
    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
80008354:	82 0f       	mov %d15,0
80008356:	ac 42       	st.h [%a4]4,%d15
        fifo->shared.maxcount    = 0;
80008358:	ac 48       	st.h [%a4]16,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
8000835a:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
8000835e:	82 0f       	mov %d15,0
    free(fifo);
}


Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
80008360:	40 42       	mov.aa %a2,%a4
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
80008362:	6c 43       	st.w [%a4]12,%d15
80008364:	6c 42       	st.w [%a4]8,%d15
        fifo->startIndex         = fifo->endIndex = 0;
80008366:	ac 4b       	st.h [%a4]22,%d15
80008368:	ac 4a       	st.h [%a4]20,%d15
        fifo->size               = size;
8000836a:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
8000836e:	f9 45 1a 00 	st.h [%a4]26,%d5
    }

    return fifo;
}
80008372:	00 90       	ret 

80008374 <Ifx_Fifo_create>:
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80008374:	c2 34       	add %d4,3
80008376:	37 04 50 f0 	extr %d15,%d4,0,16
 * This is valid is an OS is used.
 *
 */
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
8000837a:	02 58       	mov %d8,%d5
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
8000837c:	8f 3f c0 f1 	andn %d15,%d15,3

    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
80008380:	1b 8f 02 40 	addi %d4,%d15,40
80008384:	6d 00 73 18 	call 8000b46a <malloc>
80008388:	40 24       	mov.aa %a4,%a2

    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
8000838a:	bc 25       	jz.a %a2,80008394 <Ifx_Fifo_create+0x20>
    {
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
8000838c:	0b f8 10 48 	mov %e4,%d8,%d15
80008390:	1d ff d5 ff 	j 8000833a <Ifx_Fifo_init>
    }

    return fifo;
}
80008394:	00 90       	ret 

80008396 <Ifx_Fifo_canReadCount>:
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
80008396:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be read from the buffer */
        result = FALSE;
80008398:	82 02       	mov %d2,0
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
8000839a:	3f f4 6a 00 	jlt %d4,%d15,8000846e <Ifx_Fifo_canReadCount+0xd8>
8000839e:	8c 4c       	ld.h %d15,[%a4]24
800083a0:	3f 4f 67 00 	jlt %d15,%d4,8000846e <Ifx_Fifo_canReadCount+0xd8>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083a4:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
800083a8:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083ac:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800083b0:	00 00       	nop 
    else
    {
        boolean interruptState;
        sint32  waitCount;
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);
800083b2:	8c 42       	ld.h %d15,[%a4]4
800083b4:	a2 f4       	sub %d4,%d15

        if (waitCount <= 0)
800083b6:	4e 4c       	jgtz %d4,800083ce <Ifx_Fifo_canReadCount+0x38>
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE;
800083b8:	82 1f       	mov %d15,1
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);

        if (waitCount <= 0)
        {
            fifo->shared.readerWaitx = 0;
800083ba:	59 42 08 00 	st.w [%a4]8,%d2
            fifo->eventReader        = TRUE;
800083be:	e9 4f 1c 00 	st.b [%a4]28,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
800083c2:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083c4:	df 00 55 00 	jeq %d0,0,8000846e <Ifx_Fifo_canReadCount+0xd8>
    {
        __enable();
800083c8:	0d 00 00 03 	enable 
800083cc:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800083ce:	82 f2       	mov %d2,-1
800083d0:	06 f2       	sh %d2,-1
800083d2:	ba f6       	eq %d15,%d6,-1
800083d4:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800083d8:	82 f5       	mov %d5,-1
800083da:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800083dc:	ee 16       	jnz %d15,80008408 <Ifx_Fifo_canReadCount+0x72>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083de:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800083e2:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083e6:	0d 00 40 03 	disable 
800083ea:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800083ec:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800083f0:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800083f4:	02 15       	mov %d5,%d1
800083f6:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083fa:	76 23       	jz %d2,80008400 <Ifx_Fifo_canReadCount+0x6a>
    {
        __enable();
800083fc:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008400:	0b 65 40 50 	addx %d5,%d5,%d6
80008404:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
80008408:	82 0f       	mov %d15,0
8000840a:	e9 4f 1c 00 	st.b [%a4]28,%d15
            fifo->shared.readerWaitx = waitCount;
8000840e:	59 44 08 00 	st.w [%a4]8,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008412:	76 03       	jz %d0,80008418 <Ifx_Fifo_canReadCount+0x82>
    {
        __enable();
80008414:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008418:	82 f6       	mov %d6,-1
8000841a:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
8000841c:	39 4f 1c 00 	ld.bu %d15,[%a4]28
80008420:	6e 08       	jz %d15,80008430 <Ifx_Fifo_canReadCount+0x9a>
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
            result = fifo->eventReader == TRUE;
80008422:	39 42 1c 00 	ld.bu %d2,[%a4]28
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
80008426:	82 0f       	mov %d15,0
80008428:	6c 42       	st.w [%a4]8,%d15
            result = fifo->eventReader == TRUE;
8000842a:	8b 12 00 22 	eq %d2,%d2,1
8000842e:	00 90       	ret 
80008430:	ba f5       	eq %d15,%d5,-1
80008432:	0b 36 00 f2 	and.eq %d15,%d6,%d3
80008436:	ee f3       	jnz %d15,8000841c <Ifx_Fifo_canReadCount+0x86>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008438:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000843c:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008440:	0d 00 40 03 	disable 
80008444:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008446:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000844a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000844e:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008452:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008456:	76 23       	jz %d2,8000845c <Ifx_Fifo_canReadCount+0xc6>
    {
        __enable();
80008458:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
            fifo->shared.readerWaitx = waitCount;
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
8000845c:	0b 3f 00 21 	eq %d2,%d15,%d3
80008460:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
80008464:	0b 3f 90 22 	or.lt %d2,%d15,%d3
80008468:	df 02 da ff 	jne %d2,0,8000841c <Ifx_Fifo_canReadCount+0x86>
8000846c:	3c db       	j 80008422 <Ifx_Fifo_canReadCount+0x8c>
            result = fifo->eventReader == TRUE;
        }
    }

    return result;
}
8000846e:	00 90       	ret 

80008470 <Ifx_Fifo_read>:
    return count - blockSize;
}

#include <stdio.h>
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80008470:	20 08       	sub.a %sp,8
80008472:	40 4f       	mov.aa %a15,%a4
80008474:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80008476:	df 04 b6 00 	jeq %d4,0,800085e2 <Ifx_Fifo_read+0x172>
    {

        buffer.base   = fifo->buffer;
8000847a:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000847c:	82 f2       	mov %d2,-1
8000847e:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
80008480:	8c 4c       	ld.h %d15,[%a4]24
80008482:	06 f2       	sh %d2,-1
80008484:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
80008486:	8c 4a       	ld.h %d15,[%a4]20
    {
        deadLine = TIME_INFINITE;
80008488:	82 fa       	mov %d10,-1
8000848a:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000848c:	ba f6       	eq %d15,%d6,-1
8000848e:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
80008492:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008494:	ee 16       	jnz %d15,800084c0 <Ifx_Fifo_read+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008496:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000849a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000849e:	0d 00 40 03 	disable 
800084a2:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800084a4:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800084a8:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800084ac:	02 3a       	mov %d10,%d3
800084ae:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800084b2:	76 23       	jz %d2,800084b8 <Ifx_Fifo_read+0x48>
    {
        __enable();
800084b4:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800084b8:	0b 6a 40 a0 	addx %d10,%d10,%d6
800084bc:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800084c0:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
800084c2:	82 0d       	mov %d13,0
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventReader        = FALSE;
800084c4:	82 0e       	mov %d14,0
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
800084c6:	a0 0c       	mov.a %a12,0
800084c8:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800084ca:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
800084ce:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084d2:	0d 00 40 03 	disable 
800084d6:	00 00       	nop 
{
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
800084d8:	88 2b       	ld.h %d11,[%a15]4
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800084da:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
800084de:	8c fd       	ld.h %d15,[%a15]26
800084e0:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventReader        = FALSE;
800084e4:	e9 fe 1c 00 	st.b [%a15]28,%d14
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800084e8:	4b f2 01 22 	div %e2,%d2,%d15
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
800084ec:	88 c2       	ld.h %d2,[%a15]24
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800084ee:	a2 3b       	sub %d11,%d3
800084f0:	37 0b 70 b0 	extr.u %d11,%d11,0,16
800084f4:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
800084f8:	0b f9 80 30 	sub %d3,%d9,%d15
800084fc:	0b 23 80 21 	min %d2,%d3,%d2
80008500:	68 22       	st.w [%a15]8,%d2
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008502:	76 43       	jz %d4,80008508 <Ifx_Fifo_read+0x98>
    {
        __enable();
80008504:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginRead(fifo, count);

            if (blockSize != 0)
80008508:	6e 20       	jz %d15,80008548 <Ifx_Fifo_read+0xd8>
            {
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
8000850a:	40 a4       	mov.aa %a4,%sp
8000850c:	02 f4       	mov %d4,%d15
8000850e:	6d ff 66 fe 	call 800081da <Ifx_CircularBuffer_read8>
80008512:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008514:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008518:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000851c:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008520:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
80008522:	88 23       	ld.h %d3,[%a15]4
80008524:	a2 b3       	sub %d3,%d11
80008526:	a8 23       	st.h [%a15]4,%d3

    if (fifo->shared.writerWaitx != 0)
80008528:	48 33       	ld.w %d3,[%a15]12
8000852a:	76 39       	jz %d3,8000853c <Ifx_Fifo_read+0xcc>
    {
        fifo->shared.writerWaitx -= blockSize;
8000852c:	5a f3       	sub %d15,%d3,%d15

        if (fifo->shared.writerWaitx <= 0)
8000852e:	8e f3       	jlez %d15,80008534 <Ifx_Fifo_read+0xc4>

    fifo->shared.count -= blockSize;

    if (fifo->shared.writerWaitx != 0)
    {
        fifo->shared.writerWaitx -= blockSize;
80008530:	68 3f       	st.w [%a15]12,%d15
80008532:	3c 05       	j 8000853c <Ifx_Fifo_read+0xcc>

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE; /* Signal the writer */
80008534:	82 1f       	mov %d15,1
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
80008536:	e8 3c       	st.a [%a15]12,%a12
            fifo->eventWriter        = TRUE; /* Signal the writer */
80008538:	e9 ff 1d 00 	st.b [%a15]29,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000853c:	76 23       	jz %d2,80008542 <Ifx_Fifo_read+0xd2>
    {
        __enable();
8000853e:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
80008542:	a2 b9       	sub %d9,%d11
80008544:	37 09 50 90 	extr %d9,%d9,0,16
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008548:	76 d4       	jz %d13,80008550 <Ifx_Fifo_read+0xe0>
            {
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
8000854a:	82 0f       	mov %d15,0
8000854c:	68 2f       	st.w [%a15]8,%d15
                break;
8000854e:	3c 48       	j 800085de <Ifx_Fifo_read+0x16e>
80008550:	ba fa       	eq %d15,%d10,-1
80008552:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008556:	ee 1b       	jnz %d15,8000858c <Ifx_Fifo_read+0x11c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008558:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000855c:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008560:	0d 00 40 03 	disable 
80008564:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008566:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000856a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000856e:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008572:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008576:	76 23       	jz %d2,8000857c <Ifx_Fifo_read+0x10c>
    {
        __enable();
80008578:	0d 00 00 03 	enable 
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
8000857c:	0b 8f 00 21 	eq %d2,%d15,%d8
80008580:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
80008584:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008588:	df 02 e1 ff 	jne %d2,0,8000854a <Ifx_Fifo_read+0xda>
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
                break;
            }

            if (count != 0)
8000858c:	df 09 29 00 	jeq %d9,0,800085de <Ifx_Fifo_read+0x16e>
            {
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008590:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80008594:	ee 1f       	jnz %d15,800085d2 <Ifx_Fifo_read+0x162>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008596:	ba fa       	eq %d15,%d10,-1
80008598:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
8000859c:	ee fa       	jnz %d15,80008590 <Ifx_Fifo_read+0x120>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000859e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800085a2:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085a6:	0d 00 40 03 	disable 
800085aa:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800085ac:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800085b0:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800085b4:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800085b8:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085bc:	76 23       	jz %d2,800085c2 <Ifx_Fifo_read+0x152>
    {
        __enable();
800085be:	0d 00 00 03 	enable 
800085c2:	0b 8f 00 21 	eq %d2,%d15,%d8
800085c6:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
800085ca:	0b 8f 90 22 	or.lt %d2,%d15,%d8
800085ce:	df 02 e1 ff 	jne %d2,0,80008590 <Ifx_Fifo_read+0x120>
                {}

                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
800085d2:	39 fd 1c 00 	ld.bu %d13,[%a15]28
800085d6:	8b 0d 00 d2 	eq %d13,%d13,0
800085da:	1d ff 78 ff 	j 800084ca <Ifx_Fifo_read+0x5a>
            }
        } while (count != 0);

        fifo->startIndex = buffer.index;
800085de:	8c a2       	ld.h %d15,[%sp]4
800085e0:	a8 af       	st.h [%a15]20,%d15
    }

    return count;
}
800085e2:	02 92       	mov %d2,%d9
800085e4:	00 90       	ret 

800085e6 <Ifx_Fifo_clear>:
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800085e6:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800085ea:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085ee:	0d 00 40 03 	disable 
800085f2:	00 00       	nop 
{
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();

    if (fifo->shared.writerWaitx != 0)
800085f4:	4c 43       	ld.w %d15,[%a4]12
800085f6:	6e 06       	jz %d15,80008602 <Ifx_Fifo_clear+0x1c>
    {
        fifo->shared.writerWaitx = 0;
800085f8:	82 0f       	mov %d15,0
800085fa:	6c 43       	st.w [%a4]12,%d15
        fifo->eventWriter        = TRUE; /* Signal the writer */
800085fc:	82 1f       	mov %d15,1
800085fe:	e9 4f 1d 00 	st.b [%a4]29,%d15
    }

    fifo->eventReader        = FALSE;
80008602:	82 0f       	mov %d15,0
80008604:	e9 4f 1c 00 	st.b [%a4]28,%d15
    fifo->shared.readerWaitx = 0;
80008608:	82 0f       	mov %d15,0
8000860a:	6c 42       	st.w [%a4]8,%d15
    fifo->shared.count       = 0;
8000860c:	ac 42       	st.h [%a4]4,%d15
    fifo->shared.maxcount    = 0;
8000860e:	ac 48       	st.h [%a4]16,%d15
    fifo->startIndex         = fifo->endIndex;
80008610:	8c 4b       	ld.h %d15,[%a4]22
80008612:	ac 4a       	st.h [%a4]20,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008614:	76 23       	jz %d2,8000861a <Ifx_Fifo_clear+0x34>
    {
        __enable();
80008616:	0d 00 00 03 	enable 
8000861a:	00 90       	ret 

8000861c <Ifx_Fifo_canWriteCount>:
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
8000861c:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be written to the buffer */
        result = FALSE;
8000861e:	82 02       	mov %d2,0
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
80008620:	3f f4 75 00 	jlt %d4,%d15,8000870a <Ifx_Fifo_canWriteCount+0xee>
80008624:	8c 4c       	ld.h %d15,[%a4]24
80008626:	3f 4f 72 00 	jlt %d15,%d4,8000870a <Ifx_Fifo_canWriteCount+0xee>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000862a:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
8000862e:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008632:	0d 00 40 03 	disable 
80008636:	00 00       	nop 
    else
    {
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
80008638:	c9 43 18 00 	ld.h %d3,[%a4]24
8000863c:	8c 42       	ld.h %d15,[%a4]4
8000863e:	5a f3       	sub %d15,%d3,%d15
80008640:	3f 4f 0d 00 	jlt %d15,%d4,8000865a <Ifx_Fifo_canWriteCount+0x3e>
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE;
80008644:	82 1f       	mov %d15,1
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
        {
            fifo->shared.writerWaitx = 0;
80008646:	59 42 0c 00 	st.w [%a4]12,%d2
            fifo->eventWriter        = TRUE;
8000864a:	e9 4f 1d 00 	st.b [%a4]29,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
8000864e:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008650:	df 00 5d 00 	jeq %d0,0,8000870a <Ifx_Fifo_canWriteCount+0xee>
    {
        __enable();
80008654:	0d 00 00 03 	enable 
80008658:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000865a:	82 f2       	mov %d2,-1
8000865c:	06 f2       	sh %d2,-1
8000865e:	ba f6       	eq %d15,%d6,-1
80008660:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
80008664:	82 f5       	mov %d5,-1
80008666:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008668:	ee 16       	jnz %d15,80008694 <Ifx_Fifo_canWriteCount+0x78>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000866a:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000866e:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008672:	0d 00 40 03 	disable 
80008676:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008678:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000867c:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008680:	02 15       	mov %d5,%d1
80008682:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008686:	76 23       	jz %d2,8000868c <Ifx_Fifo_canWriteCount+0x70>
    {
        __enable();
80008688:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
8000868c:	0b 65 40 50 	addx %d5,%d5,%d6
80008690:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
80008694:	82 0f       	mov %d15,0
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
80008696:	c9 42 04 00 	ld.h %d2,[%a4]4
            result                   = TRUE;
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
8000869a:	e9 4f 1d 00 	st.b [%a4]29,%d15
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
8000869e:	8c 4c       	ld.h %d15,[%a4]24
800086a0:	5a f2       	sub %d15,%d2,%d15
800086a2:	42 f4       	add %d4,%d15
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800086a4:	82 02       	mov %d2,0
800086a6:	0b 42 a0 41 	max %d4,%d2,%d4
800086aa:	59 44 0c 00 	st.w [%a4]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800086ae:	76 03       	jz %d0,800086b4 <Ifx_Fifo_canWriteCount+0x98>
    {
        __enable();
800086b0:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800086b4:	82 f6       	mov %d6,-1
800086b6:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800086b8:	39 4f 1d 00 	ld.bu %d15,[%a4]29
800086bc:	6e 08       	jz %d15,800086cc <Ifx_Fifo_canWriteCount+0xb0>
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
            result = fifo->eventWriter == TRUE;
800086be:	39 42 1d 00 	ld.bu %d2,[%a4]29
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
800086c2:	82 0f       	mov %d15,0
800086c4:	6c 43       	st.w [%a4]12,%d15
            result = fifo->eventWriter == TRUE;
800086c6:	8b 12 00 22 	eq %d2,%d2,1
800086ca:	00 90       	ret 
800086cc:	ba f5       	eq %d15,%d5,-1
800086ce:	0b 36 00 f2 	and.eq %d15,%d6,%d3
800086d2:	ee f3       	jnz %d15,800086b8 <Ifx_Fifo_canWriteCount+0x9c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800086d4:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800086d8:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800086dc:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800086e0:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800086e2:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800086e6:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800086ea:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800086ee:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800086f2:	76 23       	jz %d2,800086f8 <Ifx_Fifo_canWriteCount+0xdc>
    {
        __enable();
800086f4:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800086f8:	0b 3f 00 21 	eq %d2,%d15,%d3
800086fc:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
80008700:	0b 3f 90 22 	or.lt %d2,%d15,%d3
80008704:	df 02 da ff 	jne %d2,0,800086b8 <Ifx_Fifo_canWriteCount+0x9c>
80008708:	3c db       	j 800086be <Ifx_Fifo_canWriteCount+0xa2>
            result = fifo->eventWriter == TRUE;
        }
    }

    return result;
}
8000870a:	00 90       	ret 

8000870c <Ifx_Fifo_write>:
}


#include <stdio.h>
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
8000870c:	20 08       	sub.a %sp,8
8000870e:	40 4f       	mov.aa %a15,%a4
80008710:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80008712:	df 04 be 00 	jeq %d4,0,8000888e <Ifx_Fifo_write+0x182>
    {
        buffer.base   = fifo->buffer;
80008716:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008718:	82 f2       	mov %d2,-1
8000871a:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
8000871c:	8c 4c       	ld.h %d15,[%a4]24
8000871e:	06 f2       	sh %d2,-1
80008720:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
80008722:	8c 4b       	ld.h %d15,[%a4]22
    {
        deadLine = TIME_INFINITE;
80008724:	82 fa       	mov %d10,-1
80008726:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008728:	ba f6       	eq %d15,%d6,-1
8000872a:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000872e:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008730:	ee 16       	jnz %d15,8000875c <Ifx_Fifo_write+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008732:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008736:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000873a:	0d 00 40 03 	disable 
8000873e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008740:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008744:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008748:	02 3a       	mov %d10,%d3
8000874a:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000874e:	76 23       	jz %d2,80008754 <Ifx_Fifo_write+0x48>
    {
        __enable();
80008750:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008754:	0b 6a 40 a0 	addx %d10,%d10,%d6
80008758:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000875c:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
8000875e:	82 0d       	mov %d13,0
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventWriter        = FALSE;
80008760:	82 0e       	mov %d14,0
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
80008762:	a0 0c       	mov.a %a12,0
80008764:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008766:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
8000876a:	37 05 e1 57 	extr.u %d5,%d5,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000876e:	0d 00 40 03 	disable 
80008772:	00 00       	nop 
{
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
80008774:	88 c4       	ld.h %d4,[%a15]24
80008776:	88 2b       	ld.h %d11,[%a15]4
80008778:	0b b4 80 b0 	sub %d11,%d4,%d11
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000877c:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
80008780:	8c fd       	ld.h %d15,[%a15]26
80008782:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventWriter        = FALSE;
80008786:	e9 fe 1d 00 	st.b [%a15]29,%d14
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
8000878a:	4b f2 01 22 	div %e2,%d2,%d15
8000878e:	a2 3b       	sub %d11,%d3
80008790:	37 0b 70 b0 	extr.u %d11,%d11,0,16
80008794:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventWriter        = FALSE;
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
80008798:	0b f9 80 20 	sub %d2,%d9,%d15
8000879c:	0b 42 80 41 	min %d4,%d2,%d4
800087a0:	68 34       	st.w [%a15]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800087a2:	76 53       	jz %d5,800087a8 <Ifx_Fifo_write+0x9c>
    {
        __enable();
800087a4:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
800087a8:	6e 26       	jz %d15,800087f4 <Ifx_Fifo_write+0xe8>
            {

                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
800087aa:	40 a4       	mov.aa %a4,%sp
800087ac:	02 f4       	mov %d4,%d15
800087ae:	6d ff 6d fd 	call 80008288 <Ifx_CircularBuffer_write8>
800087b2:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800087b4:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800087b8:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800087bc:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800087c0:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800087c2:	88 22       	ld.h %d2,[%a15]4
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800087c4:	88 84       	ld.h %d4,[%a15]16
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800087c6:	42 b2       	add %d2,%d11
800087c8:	37 02 50 20 	extr %d2,%d2,0,16
800087cc:	a8 22       	st.h [%a15]4,%d2
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800087ce:	0b 24 a0 21 	max %d2,%d4,%d2
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800087d2:	a8 82       	st.h [%a15]16,%d2

    if (fifo->shared.readerWaitx != 0)
800087d4:	48 22       	ld.w %d2,[%a15]8
800087d6:	76 29       	jz %d2,800087e8 <Ifx_Fifo_write+0xdc>
    {
        fifo->shared.readerWaitx -= blockSize;
800087d8:	5a f2       	sub %d15,%d2,%d15

        if (fifo->shared.readerWaitx <= 0)
800087da:	8e f3       	jlez %d15,800087e0 <Ifx_Fifo_write+0xd4>
    fifo->shared.count   += blockSize;
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */

    if (fifo->shared.readerWaitx != 0)
    {
        fifo->shared.readerWaitx -= blockSize;
800087dc:	68 2f       	st.w [%a15]8,%d15
800087de:	3c 05       	j 800087e8 <Ifx_Fifo_write+0xdc>

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800087e0:	82 1f       	mov %d15,1
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
800087e2:	e8 2c       	st.a [%a15]8,%a12
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800087e4:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800087e8:	76 33       	jz %d3,800087ee <Ifx_Fifo_write+0xe2>
    {
        __enable();
800087ea:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
800087ee:	a2 b9       	sub %d9,%d11
800087f0:	37 09 50 90 	extr %d9,%d9,0,16
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800087f4:	76 d4       	jz %d13,800087fc <Ifx_Fifo_write+0xf0>
            {
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
800087f6:	82 0f       	mov %d15,0
800087f8:	68 3f       	st.w [%a15]12,%d15
                break;
800087fa:	3c 48       	j 8000888a <Ifx_Fifo_write+0x17e>
800087fc:	ba fa       	eq %d15,%d10,-1
800087fe:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008802:	ee 1b       	jnz %d15,80008838 <Ifx_Fifo_write+0x12c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008804:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008808:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000880c:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008810:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008812:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008816:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000881a:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000881e:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008822:	76 23       	jz %d2,80008828 <Ifx_Fifo_write+0x11c>
    {
        __enable();
80008824:	0d 00 00 03 	enable 
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008828:	0b 8f 00 21 	eq %d2,%d15,%d8
8000882c:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
80008830:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008834:	df 02 e1 ff 	jne %d2,0,800087f6 <Ifx_Fifo_write+0xea>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
80008838:	df 09 29 00 	jeq %d9,0,8000888a <Ifx_Fifo_write+0x17e>
            {
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
8000883c:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80008840:	ee 1f       	jnz %d15,8000887e <Ifx_Fifo_write+0x172>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008842:	ba fa       	eq %d15,%d10,-1
80008844:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008848:	ee fa       	jnz %d15,8000883c <Ifx_Fifo_write+0x130>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000884a:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000884e:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008852:	0d 00 40 03 	disable 
80008856:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008858:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000885c:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008860:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008864:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008868:	76 23       	jz %d2,8000886e <Ifx_Fifo_write+0x162>
    {
        __enable();
8000886a:	0d 00 00 03 	enable 
8000886e:	0b 8f 00 21 	eq %d2,%d15,%d8
80008872:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
80008876:	0b 8f 90 22 	or.lt %d2,%d15,%d8
8000887a:	df 02 e1 ff 	jne %d2,0,8000883c <Ifx_Fifo_write+0x130>
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
8000887e:	39 fd 1d 00 	ld.bu %d13,[%a15]29
80008882:	8b 0d 00 d2 	eq %d13,%d13,0
80008886:	1d ff 70 ff 	j 80008766 <Ifx_Fifo_write+0x5a>
            }
        } while (count != 0);

        fifo->endIndex = buffer.index;
8000888a:	8c a2       	ld.h %d15,[%sp]4
8000888c:	a8 bf       	st.h [%a15]22,%d15
    }

    return count;
}
8000888e:	02 92       	mov %d2,%d9
80008890:	00 90       	ret 
	...

80008894 <setActuatorPacket>:
    }
}

void setActuatorPacket(struct ActuatorPacket *packet)
{
    packet->start_byte = 0xAA;
80008894:	3b a0 fa ff 	mov %d15,-86
    packet->packet_id = 0x01;
    if (infotainmentArr[4] == 0)
80008898:	91 00 00 27 	movh.a %a2,28672
    }
}

void setActuatorPacket(struct ActuatorPacket *packet)
{
    packet->start_byte = 0xAA;
8000889c:	2c 40       	st.b [%a4]0,%d15
    packet->packet_id = 0x01;
    if (infotainmentArr[4] == 0)
8000889e:	d9 2f 10 40 	lea %a15,[%a2]272 <70000110 <infotainmentArr>>
}

void setActuatorPacket(struct ActuatorPacket *packet)
{
    packet->start_byte = 0xAA;
    packet->packet_id = 0x01;
800088a2:	82 1f       	mov %d15,1
800088a4:	2c 41       	st.b [%a4]1,%d15
    if (infotainmentArr[4] == 0)
800088a6:	4c f4       	ld.w %d15,[%a15]16
800088a8:	ee 05       	jnz %d15,800088b2 <setActuatorPacket+0x1e>
    { // led red
        packet->led_rgb = 1;
800088aa:	0c 42       	ld.bu %d15,[%a4]2
800088ac:	b7 1f 03 f0 	insert %d15,%d15,1,0,3
800088b0:	3c 0a       	j 800088c4 <setActuatorPacket+0x30>
    }
    else if (infotainmentArr[4] == 1)
800088b2:	5e 15       	jne %d15,1,800088bc <setActuatorPacket+0x28>
    { // led green
        packet->led_rgb = 2;
800088b4:	0c 42       	ld.bu %d15,[%a4]2
800088b6:	b7 2f 03 f0 	insert %d15,%d15,2,0,3
800088ba:	3c 05       	j 800088c4 <setActuatorPacket+0x30>
    }
    else if (infotainmentArr[4] == 2)
800088bc:	5e 25       	jne %d15,2,800088c6 <setActuatorPacket+0x32>
    { // led blue
        packet->led_rgb = 4;
800088be:	0c 42       	ld.bu %d15,[%a4]2
800088c0:	b7 4f 03 f0 	insert %d15,%d15,4,0,3
800088c4:	2c 42       	st.b [%a4]2,%d15
    }
    packet->driving_mode = infotainmentArr[0];
800088c6:	19 22 10 40 	ld.w %d2,[%a2]272 <70000110 <infotainmentArr>>
800088ca:	0c 43       	ld.bu %d15,[%a4]3
800088cc:	37 2f 04 f2 	insert %d15,%d15,%d2,4,4
    packet->fan = infotainmentArr[1]; //(data 0 ~ 3)
800088d0:	48 12       	ld.w %d2,[%a15]4
800088d2:	37 2f 02 f0 	insert %d15,%d15,%d2,0,2
    packet->servo_chair = infotainmentArr[2];
800088d6:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800088da:	e9 42 04 00 	st.b [%a4]4,%d2
800088de:	06 82       	sh %d2,-8
800088e0:	e9 42 05 00 	st.b [%a4]5,%d2
    packet->servo_window = infotainmentArr[3];
800088e4:	b9 f2 0c 00 	ld.hu %d2,[%a15]12
800088e8:	e9 42 06 00 	st.b [%a4]6,%d2
800088ec:	06 82       	sh %d2,-8
800088ee:	e9 42 07 00 	st.b [%a4]7,%d2
    packet->servo_air = infotainmentArr[5];
800088f2:	b9 f2 14 00 	ld.hu %d2,[%a15]20
800088f6:	e9 42 08 00 	st.b [%a4]8,%d2
800088fa:	06 82       	sh %d2,-8
800088fc:	e9 42 09 00 	st.b [%a4]9,%d2
    packet->led = infotainmentArr[6];
80008900:	48 62       	ld.w %d2,[%a15]24
80008902:	67 2f 02 f0 	ins.t %d15,%d15,2,%d2,0
    packet->buzzer = 0;
80008906:	8f 8f c0 f1 	andn %d15,%d15,8
8000890a:	2c 43       	st.b [%a4]3,%d15
8000890c:	00 90       	ret 

8000890e <printStateLv1>:
    }
}

void printStateLv1()
{
    sprintf(buf, "\xDB\xDB");
8000890e:	91 00 00 f7 	movh.a %a15,28672
80008912:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
80008916:	91 00 00 28 	movh.a %a2,32768
8000891a:	d9 22 d8 60 	lea %a2,[%a2]3480 <80000d98 <IfxVadc_Adc_masterIndex+0x40>>
8000891e:	40 f4       	mov.aa %a4,%a15
80008920:	04 2f       	ld.bu %d15,[%a2+]
80008922:	24 ff       	st.b [%a15+],%d15
80008924:	ee fe       	jnz %d15,80008920 <printStateLv1+0x12>
    lcd_print(buf);
80008926:	1d ff 61 dc 	j 800041e8 <lcd_print>

8000892a <printStateLv2>:
}
void printStateLv2()
{
    sprintf(buf, "\xDB\xDB\xDB\xDB");
8000892a:	91 00 00 f7 	movh.a %a15,28672
8000892e:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
80008932:	91 00 00 28 	movh.a %a2,32768
80008936:	d9 22 db 60 	lea %a2,[%a2]3483 <80000d9b <IfxVadc_Adc_masterIndex+0x43>>
8000893a:	40 f4       	mov.aa %a4,%a15
8000893c:	04 2f       	ld.bu %d15,[%a2+]
8000893e:	24 ff       	st.b [%a15+],%d15
80008940:	ee fe       	jnz %d15,8000893c <printStateLv2+0x12>
    lcd_print(buf);
80008942:	1d ff 53 dc 	j 800041e8 <lcd_print>

80008946 <printStateLv3>:
}
void printStateLv3()
{
    sprintf(buf, "\xDB\xDB\xDB\xDB\xDB\xDB");
80008946:	91 00 00 f7 	movh.a %a15,28672
8000894a:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
8000894e:	91 00 00 28 	movh.a %a2,32768
80008952:	d9 22 e0 60 	lea %a2,[%a2]3488 <80000da0 <IfxVadc_Adc_masterIndex+0x48>>
80008956:	40 f4       	mov.aa %a4,%a15
80008958:	04 2f       	ld.bu %d15,[%a2+]
8000895a:	24 ff       	st.b [%a15+],%d15
8000895c:	ee fe       	jnz %d15,80008958 <printStateLv3+0x12>
    lcd_print(buf);
8000895e:	1d ff 45 dc 	j 800041e8 <lcd_print>

80008962 <printStateLv4>:
}
void printStateLv4()
{
    sprintf(buf, "\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB");
80008962:	91 00 00 f7 	movh.a %a15,28672
80008966:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
8000896a:	91 00 00 28 	movh.a %a2,32768
8000896e:	d9 22 e7 60 	lea %a2,[%a2]3495 <80000da7 <IfxVadc_Adc_masterIndex+0x4f>>
80008972:	40 f4       	mov.aa %a4,%a15
80008974:	04 2f       	ld.bu %d15,[%a2+]
80008976:	24 ff       	st.b [%a15+],%d15
80008978:	ee fe       	jnz %d15,80008974 <printStateLv4+0x12>
    lcd_print(buf);
8000897a:	1d ff 37 dc 	j 800041e8 <lcd_print>

8000897e <printStateOn>:
}
void printStateOn()
{
    sprintf(buf, "mode on");
8000897e:	91 00 00 f7 	movh.a %a15,28672
80008982:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
80008986:	91 00 00 28 	movh.a %a2,32768
8000898a:	d9 22 f0 60 	lea %a2,[%a2]3504 <80000db0 <IfxVadc_Adc_masterIndex+0x58>>
8000898e:	40 f4       	mov.aa %a4,%a15
80008990:	04 2f       	ld.bu %d15,[%a2+]
80008992:	24 ff       	st.b [%a15+],%d15
80008994:	ee fe       	jnz %d15,80008990 <printStateOn+0x12>
    lcd_print(buf);
80008996:	1d ff 29 dc 	j 800041e8 <lcd_print>

8000899a <printStateOff>:
}
void printStateOff()
{
    sprintf(buf, "mode off");
8000899a:	91 00 00 f7 	movh.a %a15,28672
8000899e:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
800089a2:	91 00 00 28 	movh.a %a2,32768
800089a6:	d9 22 f8 60 	lea %a2,[%a2]3512 <80000db8 <IfxVadc_Adc_masterIndex+0x60>>
800089aa:	40 f4       	mov.aa %a4,%a15
800089ac:	04 2f       	ld.bu %d15,[%a2+]
800089ae:	24 ff       	st.b [%a15+],%d15
800089b0:	ee fe       	jnz %d15,800089ac <printStateOff+0x12>
    lcd_print(buf);
800089b2:	1d ff 1b dc 	j 800041e8 <lcd_print>

800089b6 <printStateRed>:
}
void printStateRed()
{
    sprintf(buf, "light red");
800089b6:	91 00 00 f7 	movh.a %a15,28672
800089ba:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
800089be:	91 00 00 28 	movh.a %a2,32768
800089c2:	d9 22 c1 70 	lea %a2,[%a2]3521 <80000dc1 <IfxVadc_Adc_masterIndex+0x69>>
800089c6:	40 f4       	mov.aa %a4,%a15
800089c8:	04 2f       	ld.bu %d15,[%a2+]
800089ca:	24 ff       	st.b [%a15+],%d15
800089cc:	ee fe       	jnz %d15,800089c8 <printStateRed+0x12>
    lcd_print(buf);
800089ce:	1d ff 0d dc 	j 800041e8 <lcd_print>

800089d2 <printStateGreen>:
}
void printStateGreen()
{
    sprintf(buf, "light green");
800089d2:	91 00 00 f7 	movh.a %a15,28672
800089d6:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
800089da:	91 00 00 28 	movh.a %a2,32768
800089de:	d9 22 cb 70 	lea %a2,[%a2]3531 <80000dcb <IfxVadc_Adc_masterIndex+0x73>>
800089e2:	40 f4       	mov.aa %a4,%a15
800089e4:	04 2f       	ld.bu %d15,[%a2+]
800089e6:	24 ff       	st.b [%a15+],%d15
800089e8:	ee fe       	jnz %d15,800089e4 <printStateGreen+0x12>
    lcd_print(buf);
800089ea:	1d ff ff db 	j 800041e8 <lcd_print>

800089ee <printStateBlue>:
}
void printStateBlue()
{
    sprintf(buf, "light blue");
800089ee:	91 00 00 f7 	movh.a %a15,28672
800089f2:	d9 ff d8 10 	lea %a15,[%a15]3160 <70000c58 <buf>>
800089f6:	91 00 00 28 	movh.a %a2,32768
800089fa:	d9 22 d7 70 	lea %a2,[%a2]3543 <80000dd7 <IfxVadc_Adc_masterIndex+0x7f>>
800089fe:	40 f4       	mov.aa %a4,%a15
80008a00:	04 2f       	ld.bu %d15,[%a2+]
80008a02:	24 ff       	st.b [%a15+],%d15
80008a04:	ee fe       	jnz %d15,80008a00 <printStateBlue+0x12>
    lcd_print(buf);
80008a06:	1d ff f1 db 	j 800041e8 <lcd_print>

80008a0a <printInfoDisplay>:
    packet->buzzer = 0;
}

void printInfoDisplay()
{
    lcd_goto(0, 0);
80008a0a:	d2 04       	mov %e4,0
80008a0c:	6d ff e7 db 	call 800041da <lcd_goto>
    switch (infoState)
80008a10:	91 00 00 c7 	movh.a %a12,28672
80008a14:	19 cf f8 10 	ld.w %d15,[%a12]3192 <70000c78 <infoState>>
80008a18:	91 00 00 47 	movh.a %a4,28672
80008a1c:	d9 44 d8 10 	lea %a4,[%a4]3160 <70000c58 <buf>>
80008a20:	ff 7f 54 80 	jge.u %d15,7,80008ac8 <printInfoDisplay+0xbe>
80008a24:	91 10 00 f8 	movh.a %a15,32769
80008a28:	d9 ff b0 88 	lea %a15,[%a15]-30160 <80008a30 <printInfoDisplay+0x26>>
80008a2c:	90 ff       	addsc.a %a15,%a15,%d15,2
80008a2e:	dc 0f       	ji %a15
80008a30:	1d 00 0e 00 	j 80008a4c <printInfoDisplay+0x42>
80008a34:	1d 00 15 00 	j 80008a5e <printInfoDisplay+0x54>
80008a38:	1d 00 1c 00 	j 80008a70 <printInfoDisplay+0x66>
80008a3c:	1d 00 23 00 	j 80008a82 <printInfoDisplay+0x78>
80008a40:	1d 00 2a 00 	j 80008a94 <printInfoDisplay+0x8a>
80008a44:	1d 00 31 00 	j 80008aa6 <printInfoDisplay+0x9c>
80008a48:	1d 00 38 00 	j 80008ab8 <printInfoDisplay+0xae>
    {
    case tunnelMode:
        sprintf(buf, "Tunnel Mode");
80008a4c:	91 00 00 28 	movh.a %a2,32768
80008a50:	40 4f       	mov.aa %a15,%a4
80008a52:	d9 22 e2 70 	lea %a2,[%a2]3554 <80000de2 <IfxVadc_Adc_masterIndex+0x8a>>
80008a56:	04 2f       	ld.bu %d15,[%a2+]
80008a58:	24 ff       	st.b [%a15+],%d15
80008a5a:	ee fe       	jnz %d15,80008a56 <printInfoDisplay+0x4c>
80008a5c:	3c 36       	j 80008ac8 <printInfoDisplay+0xbe>
        break;
    case airConditionMode:
        sprintf(buf, "Air Conditional");
80008a5e:	91 00 00 28 	movh.a %a2,32768
80008a62:	40 4f       	mov.aa %a15,%a4
80008a64:	d9 22 ee 70 	lea %a2,[%a2]3566 <80000dee <IfxVadc_Adc_masterIndex+0x96>>
80008a68:	04 2f       	ld.bu %d15,[%a2+]
80008a6a:	24 ff       	st.b [%a15+],%d15
80008a6c:	ee fe       	jnz %d15,80008a68 <printInfoDisplay+0x5e>
80008a6e:	3c 2d       	j 80008ac8 <printInfoDisplay+0xbe>
        break;
    case chairDegree:
        sprintf(buf, "Chair Degree");
80008a70:	91 00 00 28 	movh.a %a2,32768
80008a74:	40 4f       	mov.aa %a15,%a4
80008a76:	d9 22 fe 70 	lea %a2,[%a2]3582 <80000dfe <IfxVadc_Adc_masterIndex+0xa6>>
80008a7a:	04 2f       	ld.bu %d15,[%a2+]
80008a7c:	24 ff       	st.b [%a15+],%d15
80008a7e:	ee fe       	jnz %d15,80008a7a <printInfoDisplay+0x70>
80008a80:	3c 24       	j 80008ac8 <printInfoDisplay+0xbe>
        break;
    case window:
        sprintf(buf, "window");
80008a82:	91 00 00 28 	movh.a %a2,32768
80008a86:	40 4f       	mov.aa %a15,%a4
80008a88:	d9 22 cb 80 	lea %a2,[%a2]3595 <80000e0b <IfxVadc_Adc_masterIndex+0xb3>>
80008a8c:	04 2f       	ld.bu %d15,[%a2+]
80008a8e:	24 ff       	st.b [%a15+],%d15
80008a90:	ee fe       	jnz %d15,80008a8c <printInfoDisplay+0x82>
80008a92:	3c 1b       	j 80008ac8 <printInfoDisplay+0xbe>
        break;
    case embientLight:
        sprintf(buf, "embient light");
80008a94:	91 00 00 28 	movh.a %a2,32768
80008a98:	40 4f       	mov.aa %a15,%a4
80008a9a:	d9 22 d2 80 	lea %a2,[%a2]3602 <80000e12 <IfxVadc_Adc_masterIndex+0xba>>
80008a9e:	04 2f       	ld.bu %d15,[%a2+]
80008aa0:	24 ff       	st.b [%a15+],%d15
80008aa2:	ee fe       	jnz %d15,80008a9e <printInfoDisplay+0x94>
80008aa4:	3c 12       	j 80008ac8 <printInfoDisplay+0xbe>
        break;
    case adasSensor:
        sprintf(buf, "adas sensor");
80008aa6:	91 00 00 28 	movh.a %a2,32768
80008aaa:	40 4f       	mov.aa %a15,%a4
80008aac:	d9 22 e0 80 	lea %a2,[%a2]3616 <80000e20 <IfxVadc_Adc_masterIndex+0xc8>>
80008ab0:	04 2f       	ld.bu %d15,[%a2+]
80008ab2:	24 ff       	st.b [%a15+],%d15
80008ab4:	ee fe       	jnz %d15,80008ab0 <printInfoDisplay+0xa6>
80008ab6:	3c 09       	j 80008ac8 <printInfoDisplay+0xbe>
        break;
    case driveLight:
        sprintf(buf, "Drive Light");
80008ab8:	91 00 00 28 	movh.a %a2,32768
80008abc:	40 4f       	mov.aa %a15,%a4
80008abe:	d9 22 ec 80 	lea %a2,[%a2]3628 <80000e2c <IfxVadc_Adc_masterIndex+0xd4>>
80008ac2:	04 2f       	ld.bu %d15,[%a2+]
80008ac4:	24 ff       	st.b [%a15+],%d15
80008ac6:	ee fe       	jnz %d15,80008ac2 <printInfoDisplay+0xb8>
        break;
    }
    lcd_print(buf);
80008ac8:	6d ff 90 db 	call 800041e8 <lcd_print>
    lcd_goto(1, 0);
80008acc:	d2 14       	mov %e4,1
80008ace:	6d ff 86 db 	call 800041da <lcd_goto>
    // sprintf(buf, "state = %u", infotainmentArr[infoState]);
    // lcd_print(buf);

    if (infoState == tunnelMode || infoState == driveLight)
80008ad2:	19 cf f8 10 	ld.w %d15,[%a12]3192 <70000c78 <infoState>>
80008ad6:	91 00 00 f7 	movh.a %a15,28672
80008ada:	8b 6f 00 22 	eq %d2,%d15,6
80008ade:	8b 0f e0 24 	or.eq %d2,%d15,0
80008ae2:	d9 ff 10 40 	lea %a15,[%a15]272 <70000110 <infotainmentArr>>
80008ae6:	76 26       	jz %d2,80008af2 <printInfoDisplay+0xe8>
    {
        if (infotainmentArr[infoState] == 0)
80008ae8:	90 ff       	addsc.a %a15,%a15,%d15,2
80008aea:	4c f0       	ld.w %d15,[%a15]0
80008aec:	6e 36       	jz %d15,80008b58 <printInfoDisplay+0x14e>
        { // mode on
            printStateOff();
        }
        else
        { // mode off
            printStateOn();
80008aee:	1d ff 48 ff 	j 8000897e <printStateOn>
        }
    }
    else if (infoState == embientLight)
80008af2:	5e 4b       	jne %d15,4,80008b08 <printInfoDisplay+0xfe>
    {
        switch (infotainmentArr[infoState])
80008af4:	4c f4       	ld.w %d15,[%a15]16
80008af6:	1e 15       	jeq %d15,1,80008b00 <printInfoDisplay+0xf6>
80008af8:	1e 26       	jeq %d15,2,80008b04 <printInfoDisplay+0xfa>
80008afa:	ee 37       	jnz %d15,80008b68 <printInfoDisplay+0x15e>
        {
        case 0:
            printStateRed();
80008afc:	1d ff 5d ff 	j 800089b6 <printStateRed>
            break;
        case 1:
            printStateGreen();
80008b00:	1d ff 69 ff 	j 800089d2 <printStateGreen>
            break;
        case 2:
            printStateBlue();
80008b04:	1d ff 75 ff 	j 800089ee <printStateBlue>
            break;
        }
    }
    else if (infoState == chairDegree || infoState == window)
80008b08:	92 e2       	add %d2,%d15,-2
80008b0a:	06 2f       	sh %d15,2
    {
        switch (infotainmentArr[infoState])
80008b0c:	10 ff       	addsc.a %a15,%a15,%d15,0
80008b0e:	4c f0       	ld.w %d15,[%a15]0
        case 2:
            printStateBlue();
            break;
        }
    }
    else if (infoState == chairDegree || infoState == window)
80008b10:	ff 22 14 80 	jge.u %d2,2,80008b38 <printInfoDisplay+0x12e>
    {
        switch (infotainmentArr[infoState])
80008b14:	ff 4f 2a 80 	jge.u %d15,4,80008b68 <printInfoDisplay+0x15e>
80008b18:	91 10 00 f8 	movh.a %a15,32769
80008b1c:	d9 ff a4 c8 	lea %a15,[%a15]-29916 <80008b24 <printInfoDisplay+0x11a>>
80008b20:	90 ff       	addsc.a %a15,%a15,%d15,2
80008b22:	dc 0f       	ji %a15
80008b24:	1d 00 1c 00 	j 80008b5c <printInfoDisplay+0x152>
80008b28:	1d 00 1c 00 	j 80008b60 <printInfoDisplay+0x156>
80008b2c:	1d 00 1c 00 	j 80008b64 <printInfoDisplay+0x15a>
80008b30:	1d 00 02 00 	j 80008b34 <printInfoDisplay+0x12a>
            break;
        case 2:
            printStateLv3();
            break;
        case 3:
            printStateLv4();
80008b34:	1d ff 17 ff 	j 80008962 <printStateLv4>
            break;
        }
    }
    else
    {
        switch (infotainmentArr[infoState])
80008b38:	ff 4f 18 80 	jge.u %d15,4,80008b68 <printInfoDisplay+0x15e>
80008b3c:	91 10 00 f8 	movh.a %a15,32769
80008b40:	d9 ff 88 d8 	lea %a15,[%a15]-29880 <80008b48 <printInfoDisplay+0x13e>>
80008b44:	90 ff       	addsc.a %a15,%a15,%d15,2
80008b46:	dc 0f       	ji %a15
80008b48:	1d 00 08 00 	j 80008b58 <printInfoDisplay+0x14e>
80008b4c:	1d 00 08 00 	j 80008b5c <printInfoDisplay+0x152>
80008b50:	1d 00 08 00 	j 80008b60 <printInfoDisplay+0x156>
80008b54:	1d 00 08 00 	j 80008b64 <printInfoDisplay+0x15a>
        {
        case 0:
            printStateOff();
80008b58:	1d ff 21 ff 	j 8000899a <printStateOff>
            break;
        case 1:
            printStateLv1();
80008b5c:	1d ff d9 fe 	j 8000890e <printStateLv1>
            break;
        case 2:
            printStateLv2();
80008b60:	1d ff e5 fe 	j 8000892a <printStateLv2>
            break;
        case 3:
            printStateLv3();
80008b64:	1d ff f1 fe 	j 80008946 <printStateLv3>
80008b68:	00 90       	ret 

80008b6a <initInfotainment>:
#include "infotainment_System.h"
#include "bsw.h"

void initInfotainment(void)
{
    lcd_clear();
80008b6a:	6d ff cb da 	call 80004100 <lcd_clear>
    printInfoDisplay();
80008b6e:	1d ff 4e ff 	j 80008a0a <printInfoDisplay>

80008b72 <updateStateByPacket>:
}

void updateStateByPacket(const struct ActuatorPacket *packet)
{
    boolean isStateUpdated = FALSE;
    if (infotainmentArr[0] != packet->driving_mode)
80008b72:	39 42 03 00 	ld.bu %d2,[%a4]3
80008b76:	91 00 00 f7 	movh.a %a15,28672
80008b7a:	37 02 64 32 	extr.u %d3,%d2,4,4
80008b7e:	19 f4 10 40 	ld.w %d4,[%a15]272 <70000110 <infotainmentArr>>
    printInfoDisplay();
}

void updateStateByPacket(const struct ActuatorPacket *packet)
{
    boolean isStateUpdated = FALSE;
80008b82:	82 0f       	mov %d15,0
    if (infotainmentArr[0] != packet->driving_mode)
80008b84:	5f 34 05 00 	jeq %d4,%d3,80008b8e <updateStateByPacket+0x1c>
    {
        infotainmentArr[0] = packet->driving_mode;
80008b88:	59 f3 10 40 	st.w [%a15]272 <70000110 <infotainmentArr>>,%d3
        isStateUpdated = TRUE;
80008b8c:	82 1f       	mov %d15,1
    }
    if (infotainmentArr[1] != packet->fan)
80008b8e:	d9 ff 10 40 	lea %a15,[%a15]272 <70000110 <infotainmentArr>>
80008b92:	48 14       	ld.w %d4,[%a15]4
80008b94:	8f 32 00 31 	and %d3,%d2,3
80008b98:	5f 34 04 00 	jeq %d4,%d3,80008ba0 <updateStateByPacket+0x2e>
    {
        infotainmentArr[1] = packet->fan;
80008b9c:	68 13       	st.w [%a15]4,%d3
        isStateUpdated = TRUE;
80008b9e:	82 1f       	mov %d15,1
    }
    if (infotainmentArr[2] != packet->servo_chair)
80008ba0:	39 43 05 00 	ld.bu %d3,[%a4]5
80008ba4:	39 44 04 00 	ld.bu %d4,[%a4]4
80008ba8:	8f 83 00 30 	sh %d3,%d3,8
80008bac:	a6 43       	or %d3,%d4
80008bae:	48 24       	ld.w %d4,[%a15]8
80008bb0:	5f 34 04 00 	jeq %d4,%d3,80008bb8 <updateStateByPacket+0x46>
    {
        infotainmentArr[2] = packet->servo_chair;
80008bb4:	68 23       	st.w [%a15]8,%d3
        isStateUpdated = TRUE;
80008bb6:	82 1f       	mov %d15,1
    }
    if (infotainmentArr[3] != packet->servo_window)
80008bb8:	39 43 07 00 	ld.bu %d3,[%a4]7
80008bbc:	39 44 06 00 	ld.bu %d4,[%a4]6
80008bc0:	8f 83 00 30 	sh %d3,%d3,8
80008bc4:	a6 43       	or %d3,%d4
80008bc6:	48 34       	ld.w %d4,[%a15]12
80008bc8:	5f 34 04 00 	jeq %d4,%d3,80008bd0 <updateStateByPacket+0x5e>
    {
        infotainmentArr[3] = packet->servo_window;
80008bcc:	68 33       	st.w [%a15]12,%d3
        isStateUpdated = TRUE;
80008bce:	82 1f       	mov %d15,1
    }

    if (packet->led_rgb == 1)
80008bd0:	39 43 02 00 	ld.bu %d3,[%a4]2
80008bd4:	8f 73 00 31 	and %d3,%d3,7
80008bd8:	df 13 07 80 	jne %d3,1,80008be6 <updateStateByPacket+0x74>
    {
        if (infotainmentArr[4] != 0)
80008bdc:	48 43       	ld.w %d3,[%a15]16
80008bde:	df 03 14 00 	jeq %d3,0,80008c06 <updateStateByPacket+0x94>
        {
            infotainmentArr[4] = 0;
80008be2:	82 0f       	mov %d15,0
80008be4:	3c 0f       	j 80008c02 <updateStateByPacket+0x90>
            isStateUpdated = TRUE;
        }
    }
    else if (packet->led_rgb == 2)
80008be6:	df 23 08 80 	jne %d3,2,80008bf6 <updateStateByPacket+0x84>
    {
        if (infotainmentArr[4] != 1)
80008bea:	48 43       	ld.w %d3,[%a15]16
80008bec:	df 13 0d 00 	jeq %d3,1,80008c06 <updateStateByPacket+0x94>
        {
            infotainmentArr[4] = 1;
80008bf0:	82 1f       	mov %d15,1
80008bf2:	68 4f       	st.w [%a15]16,%d15
80008bf4:	3c 09       	j 80008c06 <updateStateByPacket+0x94>
            isStateUpdated = TRUE;
        }
    }
    else if (packet->led_rgb == 4)
80008bf6:	df 43 08 80 	jne %d3,4,80008c06 <updateStateByPacket+0x94>
    {
        if (infotainmentArr[4] != 2)
80008bfa:	48 43       	ld.w %d3,[%a15]16
80008bfc:	df 23 05 00 	jeq %d3,2,80008c06 <updateStateByPacket+0x94>
        {
            infotainmentArr[4] = 2;
80008c00:	82 2f       	mov %d15,2
80008c02:	68 4f       	st.w [%a15]16,%d15
            isStateUpdated = TRUE;
80008c04:	82 1f       	mov %d15,1
        }
    }
    if (infotainmentArr[5] != packet->servo_air)
80008c06:	39 43 09 00 	ld.bu %d3,[%a4]9
80008c0a:	39 44 08 00 	ld.bu %d4,[%a4]8
80008c0e:	8f 83 00 30 	sh %d3,%d3,8
80008c12:	a6 43       	or %d3,%d4
80008c14:	48 54       	ld.w %d4,[%a15]20
80008c16:	5f 34 04 00 	jeq %d4,%d3,80008c1e <updateStateByPacket+0xac>
    {
        infotainmentArr[5] = packet->servo_air;
80008c1a:	68 53       	st.w [%a15]20,%d3
        isStateUpdated = TRUE;
80008c1c:	82 1f       	mov %d15,1
    }
    if (infotainmentArr[6] != packet->led)
80008c1e:	37 02 61 21 	extr.u %d2,%d2,2,1
80008c22:	48 63       	ld.w %d3,[%a15]24
80008c24:	5f 23 04 00 	jeq %d3,%d2,80008c2c <updateStateByPacket+0xba>
    {
        infotainmentArr[6] = packet->led;
80008c28:	68 62       	st.w [%a15]24,%d2
80008c2a:	3c 02       	j 80008c2e <updateStateByPacket+0xbc>
        isStateUpdated = TRUE;
    }
    if (isStateUpdated == TRUE)
80008c2c:	5e 15       	jne %d15,1,80008c36 <updateStateByPacket+0xc4>
    {
        lcd_clear();
80008c2e:	6d ff 69 da 	call 80004100 <lcd_clear>
        printInfoDisplay();
80008c32:	1d ff ec fe 	j 80008a0a <printInfoDisplay>
80008c36:	00 90       	ret 

80008c38 <updateStateByButton>:

void updateStateByButton(uint8 buttonState)
{
    boolean isStateUpdated = FALSE;
    boolean isSettingUpdated = FALSE;
    switch (buttonState)
80008c38:	ff 44 51 80 	jge.u %d4,4,80008cda <updateStateByButton+0xa2>
80008c3c:	91 10 00 28 	movh.a %a2,32769
80008c40:	d9 22 d0 18 	lea %a2,[%a2]-29616 <80008c50 <updateStateByButton+0x18>>
80008c44:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80008c48:	91 00 00 f7 	movh.a %a15,28672
80008c4c:	dc 02       	ji %a2
80008c4e:	00 00       	nop 
80008c50:	1d 00 08 00 	j 80008c60 <updateStateByButton+0x28>
80008c54:	1d 00 10 00 	j 80008c74 <updateStateByButton+0x3c>
80008c58:	1d 00 19 00 	j 80008c8a <updateStateByButton+0x52>
80008c5c:	1d 00 25 00 	j 80008ca6 <updateStateByButton+0x6e>
    {
    case btnUP:
        if (infoState < driveLight)
80008c60:	19 ff f8 10 	ld.w %d15,[%a15]3192 <70000c78 <infoState>>
80008c64:	91 00 00 27 	movh.a %a2,28672
80008c68:	ff 6f 04 00 	jge %d15,6,80008c70 <updateStateByButton+0x38>
        {
            infoState = infoState + 1;
80008c6c:	c2 1f       	add %d15,1
80008c6e:	3c 0b       	j 80008c84 <updateStateByButton+0x4c>
            isStateUpdated = TRUE;
        }
        else
        {
            infoState = tunnelMode;
80008c70:	82 0f       	mov %d15,0
80008c72:	3c 09       	j 80008c84 <updateStateByButton+0x4c>
            isStateUpdated = TRUE;
        }
        break;
    case btnDOWN:
        if (infoState > tunnelMode)
80008c74:	19 ff f8 10 	ld.w %d15,[%a15]3192 <70000c78 <infoState>>
80008c78:	91 00 00 27 	movh.a %a2,28672
80008c7c:	8e f3       	jlez %d15,80008c82 <updateStateByButton+0x4a>
        {
            infoState = infoState - 1;
80008c7e:	c2 ff       	add %d15,-1
80008c80:	3c 02       	j 80008c84 <updateStateByButton+0x4c>
            isStateUpdated = TRUE;
        }
        else
        {
            infoState = driveLight;
80008c82:	82 6f       	mov %d15,6
80008c84:	59 2f f8 10 	st.w [%a2]3192 <70000c78 <infoState>>,%d15
80008c88:	3c 25       	j 80008cd2 <updateStateByButton+0x9a>
            isStateUpdated = TRUE;
        }
        break;
    case btnLEFT:
        if (infotainmentArr[infoState] > 0)
80008c8a:	19 ff f8 10 	ld.w %d15,[%a15]3192 <70000c78 <infoState>>
80008c8e:	91 00 00 f7 	movh.a %a15,28672
80008c92:	d9 ff 10 40 	lea %a15,[%a15]272 <70000110 <infotainmentArr>>
80008c96:	90 ff       	addsc.a %a15,%a15,%d15,2
80008c98:	4c f0       	ld.w %d15,[%a15]0
80008c9a:	8e f4       	jlez %d15,80008ca2 <updateStateByButton+0x6a>
        {
            infotainmentArr[infoState] = infotainmentArr[infoState] - 1;
80008c9c:	c2 ff       	add %d15,-1
80008c9e:	68 0f       	st.w [%a15]0,%d15
80008ca0:	3c 19       	j 80008cd2 <updateStateByButton+0x9a>
            isStateUpdated = TRUE;
            isSettingUpdated = TRUE;
        }
        else
        {
            infotainmentArr[infoState] = 0;
80008ca2:	82 0f       	mov %d15,0
80008ca4:	3c 15       	j 80008cce <updateStateByButton+0x96>
        }
        break;
    case btnRIGHT:
        if (infotainmentArr[infoState] < stateMaxArr[infoState])
80008ca6:	19 ff f8 10 	ld.w %d15,[%a15]3192
80008caa:	91 00 00 28 	movh.a %a2,32768
80008cae:	91 00 00 f7 	movh.a %a15,28672
80008cb2:	06 2f       	sh %d15,2
80008cb4:	d9 ff 10 40 	lea %a15,[%a15]272 <70000110 <infotainmentArr>>
80008cb8:	d9 22 f8 80 	lea %a2,[%a2]3640 <80000e38 <stateMaxArr>>
80008cbc:	10 ff       	addsc.a %a15,%a15,%d15,0
80008cbe:	10 22       	addsc.a %a2,%a2,%d15,0
80008cc0:	48 02       	ld.w %d2,[%a15]0
80008cc2:	4c 20       	ld.w %d15,[%a2]0
80008cc4:	7f f2 05 00 	jge %d2,%d15,80008cce <updateStateByButton+0x96>
        {
            infotainmentArr[infoState] = infotainmentArr[infoState] + 1;
80008cc8:	c2 12       	add %d2,1
80008cca:	68 02       	st.w [%a15]0,%d2
80008ccc:	3c 03       	j 80008cd2 <updateStateByButton+0x9a>
            isStateUpdated = TRUE;
            isSettingUpdated = TRUE;
        }
        else
        {
            infotainmentArr[infoState] = stateMaxArr[infoState];
80008cce:	68 0f       	st.w [%a15]0,%d15
80008cd0:	00 90       	ret 
    {
        // if (isSettingUpdated == TRUE)
        // {
            
        // }
        lcd_clear();
80008cd2:	6d ff 17 da 	call 80004100 <lcd_clear>
        printInfoDisplay();
80008cd6:	1d ff 9a fe 	j 80008a0a <printInfoDisplay>
80008cda:	00 90       	ret 

80008cdc <getPhotoresiter>:
#include "photoresistor_Driver.h"
#include "bsw.h"

int getPhotoresiter(){
    int adc_in;
    adc_in = readADCValue(PHOTO_CH);
80008cdc:	82 24       	mov %d4,2
    return adc_in;
80008cde:	1d ff 72 dc 	j 800045c2 <readADCValue>

80008ce2 <initUartDriver>:
App_AsclinAsc g_AsclinStm;
struct ActuatorPacket g_RecievedActuatorPacket = {};
struct SensorPacket g_RecievedSensorPacket = {};

void initUartDriver(void)
{
80008ce2:	20 60       	sub.a %sp,96
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN0);
80008ce4:	d9 a4 24 00 	lea %a4,[%sp]36
80008ce8:	c5 f5 40 80 	lea %a5,f0000600 <_SMALL_DATA4_+0x3fff8600>
80008cec:	6d ff 7c e5 	call 800057e4 <IfxAsclin_Asc_initModuleConfig>

    ascConfig.baudrate.prescaler = 1;
80008cf0:	82 1f       	mov %d15,1
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
80008cf2:	7b 00 00 27 	movh %d2,28672
80008cf6:	1b e2 db 20 	addi %d2,%d2,3518
void initUartDriver(void)
{
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN0);

    ascConfig.baudrate.prescaler = 1;
80008cfa:	f9 af 2c 00 	st.h [%sp]44,%d15
    ascConfig.baudrate.baudrate = 9600;
80008cfe:	7b 60 61 f4 	movh %d15,17942
80008d02:	78 0a       	st.w [%sp]40,%d15
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
80008d04:	59 a2 18 10 	st.w [%sp]88,%d2
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN0);

    ascConfig.baudrate.prescaler = 1;
    ascConfig.baudrate.baudrate = 9600;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
80008d08:	82 3f       	mov %d15,3
    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    const IfxAsclin_Asc_Pins pins = {
80008d0a:	7b 00 00 28 	movh %d2,32768
80008d0e:	60 23       	mov.a %a3,%d2
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN0);

    ascConfig.baudrate.prescaler = 1;
    ascConfig.baudrate.baudrate = 9600;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
80008d10:	e9 af 2e 00 	st.b [%sp]46,%d15

    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
80008d14:	da 0d       	mov %d15,13
    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    const IfxAsclin_Asc_Pins pins = {
80008d16:	d9 af 04 00 	lea %a15,[%sp]4

    ascConfig.baudrate.prescaler = 1;
    ascConfig.baudrate.baudrate = 9600;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
80008d1a:	f9 af 02 10 	st.h [%sp]66,%d15
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
80008d1e:	da 0e       	mov %d15,14
    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    const IfxAsclin_Asc_Pins pins = {
80008d20:	40 f4       	mov.aa %a4,%a15
    ascConfig.baudrate.prescaler = 1;
    ascConfig.baudrate.baudrate = 9600;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
80008d22:	f9 af 00 10 	st.h [%sp]64,%d15
    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    const IfxAsclin_Asc_Pins pins = {
80008d26:	d9 32 d4 90 	lea %a2,[%a3]3668
    ascConfig.baudrate.baudrate = 9600;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;
80008d2a:	82 0f       	mov %d15,0
80008d2c:	e9 af 06 10 	st.b [%sp]70,%d15
    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    const IfxAsclin_Asc_Pins pins = {
80008d30:	a0 33       	mov.a %a3,3
80008d32:	09 22 48 01 	ld.d %e2,[%a2+]8
80008d36:	89 42 48 01 	st.d [%a4+]8,%e2
80008d3a:	fc 3c       	loop %a3,80008d32 <initUartDriver+0x50>

    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
80008d3c:	7b 00 00 f7 	movh %d15,28672
80008d40:	1b 4f c9 f0 	addi %d15,%d15,3220
        NULL_PTR, IfxPort_OutputMode_pushPull,
        &IfxAsclin0_TX_P15_2_OUT, IfxPort_OutputMode_pushPull,
        IfxPort_PadDriver_cmosAutomotiveSpeed1};
    ascConfig.pins = &pins;

    IfxAsclin_Asc_initModule(&g_AsclinStm.drivers.asc, &ascConfig);
80008d44:	91 00 00 47 	movh.a %a4,28672

    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
80008d48:	78 14       	st.w [%sp]80,%d15
        NULL_PTR, IfxPort_OutputMode_pushPull,
        &IfxAsclin0_TX_P15_2_OUT, IfxPort_OutputMode_pushPull,
        IfxPort_PadDriver_cmosAutomotiveSpeed1};
    ascConfig.pins = &pins;

    IfxAsclin_Asc_initModule(&g_AsclinStm.drivers.asc, &ascConfig);
80008d4a:	d9 44 e8 b0 	lea %a4,[%a4]3816 <70000ee8 <g_AsclinStm+0x254>>
    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80008d4e:	3b 20 10 f0 	mov %d15,258
        NULL_PTR, IfxPort_OutputMode_pushPull,
        &IfxAsclin0_TX_P15_2_OUT, IfxPort_OutputMode_pushPull,
        IfxPort_PadDriver_cmosAutomotiveSpeed1};
    ascConfig.pins = &pins;

    IfxAsclin_Asc_initModule(&g_AsclinStm.drivers.asc, &ascConfig);
80008d52:	d9 a5 24 00 	lea %a5,[%sp]36
    ascConfig.interrupt.rxPriority = ISR_PRIORITY_ASC_0_RX;
    ascConfig.interrupt.txPriority = ISR_PRIORITY_ASC_0_TX;
    ascConfig.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    ascConfig.txBuffer = g_AsclinStm.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80008d56:	f9 af 0e 10 	st.h [%sp]78,%d15
    ascConfig.rxBuffer = g_AsclinStm.ascBuffer.rx;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;
80008d5a:	f9 af 14 10 	st.h [%sp]84,%d15
        NULL_PTR, IfxPort_InputMode_pullUp,
        &IfxAsclin0_RXB_P15_3_IN, IfxPort_InputMode_pullUp,
        NULL_PTR, IfxPort_OutputMode_pushPull,
        &IfxAsclin0_TX_P15_2_OUT, IfxPort_OutputMode_pushPull,
        IfxPort_PadDriver_cmosAutomotiveSpeed1};
    ascConfig.pins = &pins;
80008d5e:	f8 12       	st.a [%sp]72,%a15

    IfxAsclin_Asc_initModule(&g_AsclinStm.drivers.asc, &ascConfig);
80008d60:	1d ff 6b e3 	j 80005436 <IfxAsclin_Asc_initModule>

80008d64 <myprintfSerial>:
        }
    }
}

void myprintfSerial(const char *fmt, ...)
{
80008d64:	20 e8       	sub.a %sp,232
80008d66:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
80008d68:	6d 00 a8 07 	call 80009cb8 <EnableAllInterrupts>
    char buf[128];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, 128, fmt, args);
80008d6c:	40 f5       	mov.aa %a5,%a15
80008d6e:	d9 a4 28 10 	lea %a4,[%sp]104
80008d72:	3b 00 08 40 	mov %d4,128
80008d76:	d9 a6 28 30 	lea %a6,[%sp]232
80008d7a:	6d 00 12 16 	call 8000b99e <vsnprintf>
    va_end(args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinStm.count = strlen(buf);
80008d7e:	d9 a4 28 10 	lea %a4,[%sp]104
80008d82:	6d 00 df 15 	call 8000b940 <strlen>
80008d86:	91 00 00 f7 	movh.a %a15,28672
80008d8a:	d9 ff d4 20 	lea %a15,[%a15]3220 <70000c94 <g_AsclinStm>>
80008d8e:	f9 f2 30 90 	st.h [%a15]624 <70000270 <__malloc_av_+0x120>>,%d2
    unsigned int i = 0;
80008d92:	82 0f       	mov %d15,0
    for (; i < strlen(buf); i++)
80008d94:	d9 a4 28 10 	lea %a4,[%sp]104
80008d98:	6d 00 d4 15 	call 8000b940 <strlen>
80008d9c:	7f 2f 0c 80 	jge.u %d15,%d2,80008db4 <myprintfSerial+0x50>
    {
        txData[i] = buf[i];
80008da0:	d9 a3 04 00 	lea %a3,[%sp]4
80008da4:	10 32       	addsc.a %a2,%a3,%d15,0
80008da6:	d9 a3 28 10 	lea %a3,[%sp]104
80008daa:	10 3f       	addsc.a %a15,%a3,%d15,0
    va_end(args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinStm.count = strlen(buf);
    unsigned int i = 0;
    for (; i < strlen(buf); i++)
80008dac:	c2 1f       	add %d15,1
    {
        txData[i] = buf[i];
80008dae:	08 02       	ld.bu %d2,[%a15]0
80008db0:	34 22       	st.b [%a2],%d2
80008db2:	3c f1       	j 80008d94 <myprintfSerial+0x30>
    }
    /* Transmit data */
    IfxAsclin_Asc_write(&g_AsclinStm.drivers.asc, &txData, &g_AsclinStm.count, TIME_INFINITE);
80008db4:	91 00 00 47 	movh.a %a4,28672
80008db8:	91 00 00 67 	movh.a %a6,28672
80008dbc:	82 f4       	mov %d4,-1
80008dbe:	d9 44 e8 b0 	lea %a4,[%a4]3816 <70000ee8 <g_AsclinStm+0x254>>
80008dc2:	d9 a5 04 00 	lea %a5,[%sp]4 <70000ee8 <g_AsclinStm+0x254>>
80008dc6:	d9 66 c4 c0 	lea %a6,[%a6]3844 <70000f04 <g_AsclinStm+0x270>>
80008dca:	9b 04 00 58 	addih %d5,%d4,32768
80008dce:	1d ff 73 e5 	j 800058b4 <IfxAsclin_Asc_write>

80008dd2 <asclin0TxISR>:
}

ISR(asclin0TxISR)
{
    // printfSerial("onTransmit(%d) ",++sendStamp);
    IfxAsclin_Asc_isrTransmit(&g_AsclinStm.drivers.asc);
80008dd2:	91 00 00 47 	movh.a %a4,28672
80008dd6:	d9 44 e8 b0 	lea %a4,[%a4]3816 <70000ee8 <g_AsclinStm+0x254>>
80008dda:	1d ff 73 e2 	j 800052c0 <IfxAsclin_Asc_isrTransmit>

80008dde <calculate_checksum>:
/* Calculate 8-bit XOR checksum */
uint8 calculate_checksum(const uint8 *data, size_t length)
{
    uint8 checksumResult = 0;
    size_t i = 0;
    for (i = 0; i < length; ++i)
80008dde:	82 0f       	mov %d15,0
// from uart_packet

/* Calculate 8-bit XOR checksum */
uint8 calculate_checksum(const uint8 *data, size_t length)
{
    uint8 checksumResult = 0;
80008de0:	82 02       	mov %d2,0
80008de2:	9f 04 03 80 	jned %d4,0,80008de8 <calculate_checksum+0xa>
    for (i = 0; i < length; ++i)
    {
        checksumResult ^= data[i];
    }
    return checksumResult;
}
80008de6:	00 90       	ret 
{
    uint8 checksumResult = 0;
    size_t i = 0;
    for (i = 0; i < length; ++i)
    {
        checksumResult ^= data[i];
80008de8:	10 4f       	addsc.a %a15,%a4,%d15,0
/* Calculate 8-bit XOR checksum */
uint8 calculate_checksum(const uint8 *data, size_t length)
{
    uint8 checksumResult = 0;
    size_t i = 0;
    for (i = 0; i < length; ++i)
80008dea:	c2 1f       	add %d15,1
    {
        checksumResult ^= data[i];
80008dec:	08 03       	ld.bu %d3,[%a15]0
80008dee:	c6 32       	xor %d2,%d3
80008df0:	3c f9       	j 80008de2 <calculate_checksum+0x4>

80008df2 <serialize_actuator_packet>:

/* Serialize ActuatorPacket into buffer (ACTUATOR_PACKET_SIZE bytes) */
void serialize_actuator_packet(const struct ActuatorPacket *packet, uint8 *buffer)
{
    /* Copy all fields except CRC */
    memcpy(buffer, packet, ACTUATOR_PACKET_SIZE - 1);
80008df2:	40 52       	mov.aa %a2,%a5
80008df4:	a0 93       	mov.a %a3,9
80008df6:	04 4f       	ld.bu %d15,[%a4+]
80008df8:	24 2f       	st.b [%a2+],%d15
80008dfa:	fc 3e       	loop %a3,80008df6 <serialize_actuator_packet+0x4>
    /* Compute and append CRC */
    buffer[ACTUATOR_PACKET_SIZE - 1] = calculate_checksum(buffer, ACTUATOR_PACKET_SIZE - 1);
80008dfc:	40 54       	mov.aa %a4,%a5
80008dfe:	3b a0 00 40 	mov %d4,10
    return checksumResult;
}

/* Serialize ActuatorPacket into buffer (ACTUATOR_PACKET_SIZE bytes) */
void serialize_actuator_packet(const struct ActuatorPacket *packet, uint8 *buffer)
{
80008e02:	40 5f       	mov.aa %a15,%a5
    /* Copy all fields except CRC */
    memcpy(buffer, packet, ACTUATOR_PACKET_SIZE - 1);
    /* Compute and append CRC */
    buffer[ACTUATOR_PACKET_SIZE - 1] = calculate_checksum(buffer, ACTUATOR_PACKET_SIZE - 1);
80008e04:	6d ff ed ff 	call 80008dde <calculate_checksum>
80008e08:	28 a2       	st.b [%a15]10,%d2
80008e0a:	00 90       	ret 

80008e0c <sendActuatorPacket>:

    IfxAsclin_Asc_initModule(&g_AsclinStm.drivers.asc, &ascConfig);
}

void sendActuatorPacket(const struct ActuatorPacket *packet)
{
80008e0c:	20 38       	sub.a %sp,56
80008e0e:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
80008e10:	6d 00 54 07 	call 80009cb8 <EnableAllInterrupts>
    uint8 buf[ACTUATOR_PACKET_SIZE] = {};
80008e14:	d9 ac 2d 00 	lea %a12,[%sp]45
80008e18:	40 c2       	mov.aa %a2,%a12
    serialize_actuator_packet(packet, buf);
80008e1a:	40 f4       	mov.aa %a4,%a15
80008e1c:	40 c5       	mov.aa %a5,%a12
}

void sendActuatorPacket(const struct ActuatorPacket *packet)
{
    EnableAllInterrupts();
    uint8 buf[ACTUATOR_PACKET_SIZE] = {};
80008e1e:	82 0f       	mov %d15,0
80008e20:	a0 a3       	mov.a %a3,10
80008e22:	24 2f       	st.b [%a2+],%d15
80008e24:	fc 3f       	loop %a3,80008e22 <sendActuatorPacket+0x16>
    serialize_actuator_packet(packet, buf);
80008e26:	6d ff e6 ff 	call 80008df2 <serialize_actuator_packet>
    g_AsclinStm.count = ACTUATOR_PACKET_SIZE;
80008e2a:	91 00 00 27 	movh.a %a2,28672

    printfSerial("\nsendA:[ ");
80008e2e:	91 00 00 48 	movh.a %a4,32768
void sendActuatorPacket(const struct ActuatorPacket *packet)
{
    EnableAllInterrupts();
    uint8 buf[ACTUATOR_PACKET_SIZE] = {};
    serialize_actuator_packet(packet, buf);
    g_AsclinStm.count = ACTUATOR_PACKET_SIZE;
80008e32:	da 0b       	mov %d15,11
80008e34:	d9 22 d4 20 	lea %a2,[%a2]3220 <70000c94 <g_AsclinStm>>

    printfSerial("\nsendA:[ ");
80008e38:	d9 44 f4 90 	lea %a4,[%a4]3700 <80000e74 <stateMaxArr+0x3c>>
void sendActuatorPacket(const struct ActuatorPacket *packet)
{
    EnableAllInterrupts();
    uint8 buf[ACTUATOR_PACKET_SIZE] = {};
    serialize_actuator_packet(packet, buf);
    g_AsclinStm.count = ACTUATOR_PACKET_SIZE;
80008e3c:	f9 2f 30 90 	st.h [%a2]624 <70000270 <__malloc_av_+0x120>>,%d15

    printfSerial("\nsendA:[ ");
80008e40:	6d ff 10 db 	call 80004460 <printfSerial>
    int i;
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
80008e44:	91 00 00 d8 	movh.a %a13,32768
    serialize_actuator_packet(packet, buf);
    g_AsclinStm.count = ACTUATOR_PACKET_SIZE;

    printfSerial("\nsendA:[ ");
    int i;
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
80008e48:	82 0f       	mov %d15,0
    {
        printfSerial("%02x/", buf[i]);
80008e4a:	d9 dd fe 90 	lea %a13,[%a13]3710 <80000e7e <stateMaxArr+0x46>>
80008e4e:	10 c2       	addsc.a %a2,%a12,%d15,0
80008e50:	40 d4       	mov.aa %a4,%a13
80008e52:	14 22       	ld.bu %d2,[%a2]
    serialize_actuator_packet(packet, buf);
    g_AsclinStm.count = ACTUATOR_PACKET_SIZE;

    printfSerial("\nsendA:[ ");
    int i;
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
80008e54:	c2 1f       	add %d15,1
    {
        printfSerial("%02x/", buf[i]);
80008e56:	74 a2       	st.w [%sp],%d2
80008e58:	6d ff 04 db 	call 80004460 <printfSerial>
    serialize_actuator_packet(packet, buf);
    g_AsclinStm.count = ACTUATOR_PACKET_SIZE;

    printfSerial("\nsendA:[ ");
    int i;
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
80008e5c:	8b bf 20 22 	ne %d2,%d15,11
80008e60:	df 02 f7 ff 	jne %d2,0,80008e4e <sendActuatorPacket+0x42>
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
80008e64:	91 00 00 48 	movh.a %a4,32768
80008e68:	d9 44 c4 a0 	lea %a4,[%a4]3716 <80000e84 <stateMaxArr+0x4c>>
80008e6c:	6d ff fa da 	call 80004460 <printfSerial>
    printfSerial("\n[A| start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d ]",
80008e70:	0c f0       	ld.bu %d15,[%a15]0
80008e72:	91 00 00 48 	movh.a %a4,32768
80008e76:	78 00       	st.w [%sp]0,%d15
80008e78:	0c f1       	ld.bu %d15,[%a15]1
80008e7a:	d9 44 c7 a0 	lea %a4,[%a4]3719 <80000e87 <stateMaxArr+0x4f>>
80008e7e:	78 01       	st.w [%sp]4,%d15
                 packet->start_byte,
                 packet->packet_id,
                 packet->led_rgb,
80008e80:	0c f2       	ld.bu %d15,[%a15]2
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[A| start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d ]",
80008e82:	16 07       	and %d15,7
80008e84:	78 02       	st.w [%sp]8,%d15
                 packet->start_byte,
                 packet->packet_id,
                 packet->led_rgb,
                 packet->fan,
80008e86:	0c f3       	ld.bu %d15,[%a15]3
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[A| start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d ]",
80008e88:	8f 3f 00 21 	and %d2,%d15,3
80008e8c:	59 a2 0c 00 	st.w [%sp]12,%d2
80008e90:	37 0f 61 21 	extr.u %d2,%d15,2,1
80008e94:	59 a2 10 00 	st.w [%sp]16,%d2
80008e98:	37 0f e1 21 	extr.u %d2,%d15,3,1
80008e9c:	37 0f 64 f2 	extr.u %d15,%d15,4,4
80008ea0:	59 a2 14 00 	st.w [%sp]20,%d2
80008ea4:	78 06       	st.w [%sp]24,%d15
                 packet->led_rgb,
                 packet->fan,
                 packet->led,
                 packet->buzzer,
                 packet->driving_mode,
                 packet->servo_chair,
80008ea6:	0c f5       	ld.bu %d15,[%a15]5
80008ea8:	08 42       	ld.bu %d2,[%a15]4
80008eaa:	8f 8f 00 f0 	sh %d15,%d15,8
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[A| start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d ]",
80008eae:	a6 2f       	or %d15,%d2
80008eb0:	78 07       	st.w [%sp]28,%d15
                 packet->fan,
                 packet->led,
                 packet->buzzer,
                 packet->driving_mode,
                 packet->servo_chair,
                 packet->servo_window,
80008eb2:	0c f7       	ld.bu %d15,[%a15]7
80008eb4:	08 62       	ld.bu %d2,[%a15]6
80008eb6:	8f 8f 00 f0 	sh %d15,%d15,8
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[A| start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d ]",
80008eba:	a6 2f       	or %d15,%d2
80008ebc:	78 08       	st.w [%sp]32,%d15
                 packet->led,
                 packet->buzzer,
                 packet->driving_mode,
                 packet->servo_chair,
                 packet->servo_window,
                 packet->servo_air);
80008ebe:	0c f9       	ld.bu %d15,[%a15]9
80008ec0:	08 82       	ld.bu %d2,[%a15]8
80008ec2:	8f 8f 00 f0 	sh %d15,%d15,8
    for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[A| start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d ]",
80008ec6:	a6 2f       	or %d15,%d2
80008ec8:	78 09       	st.w [%sp]36,%d15
80008eca:	6d ff cb da 	call 80004460 <printfSerial>
                 packet->driving_mode,
                 packet->servo_chair,
                 packet->servo_window,
                 packet->servo_air);

    IfxAsclin_Asc_write(&g_AsclinStm.drivers.asc, &buf, &g_AsclinStm.count, TIME_INFINITE);
80008ece:	91 00 00 47 	movh.a %a4,28672
80008ed2:	91 00 00 67 	movh.a %a6,28672
80008ed6:	82 f4       	mov %d4,-1
80008ed8:	d9 44 e8 b0 	lea %a4,[%a4]3816 <70000ee8 <g_AsclinStm+0x254>>
80008edc:	40 c5       	mov.aa %a5,%a12
80008ede:	d9 66 c4 c0 	lea %a6,[%a6]3844 <70000f04 <g_AsclinStm+0x270>>
80008ee2:	9b 04 00 58 	addih %d5,%d4,32768
80008ee6:	1d ff e7 e4 	j 800058b4 <IfxAsclin_Asc_write>

80008eea <deserialize_actuator_packet>:

/* Deserialize buffer into ActuatorPacket */
void deserialize_actuator_packet(const uint8 *buffer, struct ActuatorPacket *packet)
{
    /* Copy entire packet */
    memcpy(packet, buffer, ACTUATOR_PACKET_SIZE);
80008eea:	a0 af       	mov.a %a15,10
80008eec:	04 4f       	ld.bu %d15,[%a4+]
80008eee:	24 5f       	st.b [%a5+],%d15
80008ef0:	fc fe       	loop %a15,80008eec <deserialize_actuator_packet+0x2>
80008ef2:	00 90       	ret 

80008ef4 <readActuatorPacket>:
    IfxAsclin_Asc_write(&g_AsclinStm.drivers.asc, &buf, &g_AsclinStm.count, TIME_INFINITE);
}

void readActuatorPacket(struct ActuatorPacket *packet)
{
    if (IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc) == UART_START_BYTE)
80008ef4:	91 00 00 d7 	movh.a %a13,28672
80008ef8:	d9 dd e8 b0 	lea %a13,[%a13]3816 <70000ee8 <g_AsclinStm+0x254>>

    IfxAsclin_Asc_write(&g_AsclinStm.drivers.asc, &buf, &g_AsclinStm.count, TIME_INFINITE);
}

void readActuatorPacket(struct ActuatorPacket *packet)
{
80008efc:	20 38       	sub.a %sp,56
80008efe:	40 4f       	mov.aa %a15,%a4
    if (IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc) == UART_START_BYTE)
80008f00:	40 d4       	mov.aa %a4,%a13
80008f02:	6d ff 79 e2 	call 800053f4 <IfxAsclin_Asc_blockingRead>
80008f06:	8b a2 0a 22 	eq %d2,%d2,170
80008f0a:	df 02 7d 00 	jeq %d2,0,80009004 <readActuatorPacket+0x110>
    {
        if (IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc) == ACTUATOR_PACKET_ID)
80008f0e:	40 d4       	mov.aa %a4,%a13
80008f10:	6d ff 72 e2 	call 800053f4 <IfxAsclin_Asc_blockingRead>
80008f14:	df 12 78 80 	jne %d2,1,80009004 <readActuatorPacket+0x110>
        {
            uint8 buffer[ACTUATOR_PACKET_SIZE] = {};
80008f18:	d9 ac 2d 00 	lea %a12,[%sp]45
80008f1c:	40 c2       	mov.aa %a2,%a12
80008f1e:	82 0f       	mov %d15,0
80008f20:	a0 a3       	mov.a %a3,10
80008f22:	24 2f       	st.b [%a2+],%d15
80008f24:	fc 3f       	loop %a3,80008f22 <readActuatorPacket+0x2e>
            buffer[0] = UART_START_BYTE;
80008f26:	3b a0 fa ff 	mov %d15,-86
80008f2a:	e9 af 2d 00 	st.b [%sp]45,%d15
            buffer[1] = ACTUATOR_PACKET_ID;
80008f2e:	e9 a2 2e 00 	st.b [%sp]46,%d2
80008f32:	82 2f       	mov %d15,2
            uint8 pos = 2;
            while (pos < ACTUATOR_PACKET_SIZE)
            {
                buffer[pos] = IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc);
80008f34:	40 d4       	mov.aa %a4,%a13
80008f36:	6d ff 5f e2 	call 800053f4 <IfxAsclin_Asc_blockingRead>
80008f3a:	10 c2       	addsc.a %a2,%a12,%d15,0
80008f3c:	c2 1f       	add %d15,1
80008f3e:	34 22       	st.b [%a2],%d2
        {
            uint8 buffer[ACTUATOR_PACKET_SIZE] = {};
            buffer[0] = UART_START_BYTE;
            buffer[1] = ACTUATOR_PACKET_ID;
            uint8 pos = 2;
            while (pos < ACTUATOR_PACKET_SIZE)
80008f40:	8b bf 20 22 	ne %d2,%d15,11
80008f44:	df 02 f8 ff 	jne %d2,0,80008f34 <readActuatorPacket+0x40>
                buffer[pos] = IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc);
                pos++;
            }

            // printfSerial("[RA]");
            printfSerial("\nrecieveA:[ ");
80008f48:	91 00 00 48 	movh.a %a4,32768
80008f4c:	d9 44 e3 b0 	lea %a4,[%a4]3811 <80000ee3 <stateMaxArr+0xab>>
80008f50:	6d ff 88 da 	call 80004460 <printfSerial>
            int i;
            for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
            {
                printfSerial("%02x/", buffer[i]);
80008f54:	91 00 00 d8 	movh.a %a13,32768
            }

            // printfSerial("[RA]");
            printfSerial("\nrecieveA:[ ");
            int i;
            for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
80008f58:	82 0f       	mov %d15,0
            {
                printfSerial("%02x/", buffer[i]);
80008f5a:	d9 dd fe 90 	lea %a13,[%a13]3710 <80000e7e <stateMaxArr+0x46>>
80008f5e:	10 c2       	addsc.a %a2,%a12,%d15,0
80008f60:	40 d4       	mov.aa %a4,%a13
80008f62:	14 22       	ld.bu %d2,[%a2]
            }

            // printfSerial("[RA]");
            printfSerial("\nrecieveA:[ ");
            int i;
            for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
80008f64:	c2 1f       	add %d15,1
            {
                printfSerial("%02x/", buffer[i]);
80008f66:	74 a2       	st.w [%sp],%d2
80008f68:	6d ff 7c da 	call 80004460 <printfSerial>
            }

            // printfSerial("[RA]");
            printfSerial("\nrecieveA:[ ");
            int i;
            for (i = 0; i < ACTUATOR_PACKET_SIZE; i++)
80008f6c:	8b bf 20 22 	ne %d2,%d15,11
80008f70:	df 02 f7 ff 	jne %d2,0,80008f5e <readActuatorPacket+0x6a>
            {
                printfSerial("%02x/", buffer[i]);
            }
            printfSerial(" ]");
80008f74:	91 00 00 48 	movh.a %a4,32768
80008f78:	d9 44 c4 a0 	lea %a4,[%a4]3716 <80000e84 <stateMaxArr+0x4c>>
80008f7c:	6d ff 72 da 	call 80004460 <printfSerial>

            deserialize_actuator_packet(buffer, packet);
80008f80:	40 f5       	mov.aa %a5,%a15
80008f82:	40 c4       	mov.aa %a4,%a12
80008f84:	6d ff b3 ff 	call 80008eea <deserialize_actuator_packet>
            printfSerial("\nrecieved:[start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d]",
80008f88:	0c f0       	ld.bu %d15,[%a15]0
80008f8a:	91 00 00 48 	movh.a %a4,32768
80008f8e:	78 00       	st.w [%sp]0,%d15
80008f90:	0c f1       	ld.bu %d15,[%a15]1
80008f92:	d9 44 f0 b0 	lea %a4,[%a4]3824 <80000ef0 <stateMaxArr+0xb8>>
80008f96:	78 01       	st.w [%sp]4,%d15
                         packet->start_byte,
                         packet->packet_id,
                         packet->led_rgb,
80008f98:	0c f2       	ld.bu %d15,[%a15]2
                printfSerial("%02x/", buffer[i]);
            }
            printfSerial(" ]");

            deserialize_actuator_packet(buffer, packet);
            printfSerial("\nrecieved:[start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d]",
80008f9a:	16 07       	and %d15,7
80008f9c:	78 02       	st.w [%sp]8,%d15
                         packet->start_byte,
                         packet->packet_id,
                         packet->led_rgb,
                         packet->fan,
80008f9e:	0c f3       	ld.bu %d15,[%a15]3
                printfSerial("%02x/", buffer[i]);
            }
            printfSerial(" ]");

            deserialize_actuator_packet(buffer, packet);
            printfSerial("\nrecieved:[start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d]",
80008fa0:	8f 3f 00 21 	and %d2,%d15,3
80008fa4:	59 a2 0c 00 	st.w [%sp]12,%d2
80008fa8:	37 0f 61 21 	extr.u %d2,%d15,2,1
80008fac:	59 a2 10 00 	st.w [%sp]16,%d2
80008fb0:	37 0f e1 21 	extr.u %d2,%d15,3,1
80008fb4:	37 0f 64 f2 	extr.u %d15,%d15,4,4
80008fb8:	59 a2 14 00 	st.w [%sp]20,%d2
80008fbc:	78 06       	st.w [%sp]24,%d15
                         packet->led_rgb,
                         packet->fan,
                         packet->led,
                         packet->buzzer,
                         packet->driving_mode,
                         packet->servo_chair,
80008fbe:	0c f5       	ld.bu %d15,[%a15]5
80008fc0:	08 42       	ld.bu %d2,[%a15]4
80008fc2:	8f 8f 00 f0 	sh %d15,%d15,8
                printfSerial("%02x/", buffer[i]);
            }
            printfSerial(" ]");

            deserialize_actuator_packet(buffer, packet);
            printfSerial("\nrecieved:[start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d]",
80008fc6:	a6 2f       	or %d15,%d2
80008fc8:	78 07       	st.w [%sp]28,%d15
                         packet->fan,
                         packet->led,
                         packet->buzzer,
                         packet->driving_mode,
                         packet->servo_chair,
                         packet->servo_window,
80008fca:	0c f7       	ld.bu %d15,[%a15]7
80008fcc:	08 62       	ld.bu %d2,[%a15]6
80008fce:	8f 8f 00 f0 	sh %d15,%d15,8
                printfSerial("%02x/", buffer[i]);
            }
            printfSerial(" ]");

            deserialize_actuator_packet(buffer, packet);
            printfSerial("\nrecieved:[start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d]",
80008fd2:	a6 2f       	or %d15,%d2
80008fd4:	78 08       	st.w [%sp]32,%d15
                         packet->led,
                         packet->buzzer,
                         packet->driving_mode,
                         packet->servo_chair,
                         packet->servo_window,
                         packet->servo_air);
80008fd6:	0c f9       	ld.bu %d15,[%a15]9
80008fd8:	08 82       	ld.bu %d2,[%a15]8
80008fda:	8f 8f 00 f0 	sh %d15,%d15,8
                printfSerial("%02x/", buffer[i]);
            }
            printfSerial(" ]");

            deserialize_actuator_packet(buffer, packet);
            printfSerial("\nrecieved:[start:%02x id:%02x rgb:%d fan:%d led:%d buzz:%d tunnel:%d chair:%d window:%d adas:%d]",
80008fde:	a6 2f       	or %d15,%d2
80008fe0:	78 09       	st.w [%sp]36,%d15
80008fe2:	6d ff 3f da 	call 80004460 <printfSerial>
                         packet->buzzer,
                         packet->driving_mode,
                         packet->servo_chair,
                         packet->servo_window,
                         packet->servo_air);
            if (calculate_checksum(buffer, ACTUATOR_PACKET_SIZE - 1) == buffer[ACTUATOR_PACKET_SIZE - 1]){
80008fe6:	40 c4       	mov.aa %a4,%a12
80008fe8:	3b a0 00 40 	mov %d4,10
80008fec:	6d ff f9 fe 	call 80008dde <calculate_checksum>
80008ff0:	39 af 37 00 	ld.bu %d15,[%sp]55
80008ff4:	7e 28       	jne %d15,%d2,80009004 <readActuatorPacket+0x110>
                deserialize_actuator_packet(buffer, packet);
80008ff6:	40 c4       	mov.aa %a4,%a12
80008ff8:	40 f5       	mov.aa %a5,%a15
80008ffa:	6d ff 78 ff 	call 80008eea <deserialize_actuator_packet>
                updateStateByPacket(packet);
80008ffe:	40 f4       	mov.aa %a4,%a15
80009000:	6d ff b9 fd 	call 80008b72 <updateStateByPacket>
80009004:	00 90       	ret 

80009006 <asclin0RxISR>:
}

ISR(asclin0RxISR)
{
    // printfSerial("onReceive(%d) ",++recieveStamp);
    IfxAsclin_Asc_isrReceive(&g_AsclinStm.drivers.asc);
80009006:	91 00 00 f7 	movh.a %a15,28672
8000900a:	d9 ff e8 b0 	lea %a15,[%a15]3816 <70000ee8 <g_AsclinStm+0x254>>
8000900e:	40 f4       	mov.aa %a4,%a15
80009010:	6d ff a7 e1 	call 8000535e <IfxAsclin_Asc_isrReceive>

#if defined(ACTUATOR_PACKET_RECIEVE_MODE)
    if (IfxAsclin_Asc_getReadCount(&g_AsclinStm.drivers.asc) >= ACTUATOR_PACKET_SIZE)
80009014:	40 f4       	mov.aa %a4,%a15
80009016:	6d ff 89 e0 	call 80005128 <IfxAsclin_Asc_getReadCount>
8000901a:	8b b2 40 22 	lt %d2,%d2,11
8000901e:	f6 27       	jnz %d2,8000902c <asclin0RxISR+0x26>
    {
        readActuatorPacket(&g_RecievedActuatorPacket);
80009020:	91 00 00 47 	movh.a %a4,28672
80009024:	d9 44 c9 20 	lea %a4,[%a4]3209 <70000c89 <g_RecievedActuatorPacket>>
80009028:	1d ff 66 ff 	j 80008ef4 <readActuatorPacket>
8000902c:	00 90       	ret 

8000902e <readSensorPacket>:
    }
}

void readSensorPacket(struct SensorPacket *packet)
{
    if (IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc) == UART_START_BYTE)
8000902e:	91 00 00 c7 	movh.a %a12,28672
80009032:	d9 cc e8 b0 	lea %a12,[%a12]3816 <70000ee8 <g_AsclinStm+0x254>>
        }
    }
}

void readSensorPacket(struct SensorPacket *packet)
{
80009036:	20 10       	sub.a %sp,16
80009038:	40 4d       	mov.aa %a13,%a4
    if (IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc) == UART_START_BYTE)
8000903a:	40 c4       	mov.aa %a4,%a12
8000903c:	6d ff dc e1 	call 800053f4 <IfxAsclin_Asc_blockingRead>
80009040:	8b a2 0a 22 	eq %d2,%d2,170
80009044:	df 02 29 00 	jeq %d2,0,80009096 <readSensorPacket+0x68>
    {
        if (IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc) == SENSOR_PACKET_ID)
80009048:	40 c4       	mov.aa %a4,%a12
8000904a:	6d ff d5 e1 	call 800053f4 <IfxAsclin_Asc_blockingRead>
8000904e:	df 22 24 80 	jne %d2,2,80009096 <readSensorPacket+0x68>
        {
            uint8 buffer[SENSOR_PACKET_SIZE] = {};
80009052:	d9 af 07 00 	lea %a15,[%sp]7
80009056:	40 f2       	mov.aa %a2,%a15
80009058:	82 0f       	mov %d15,0
8000905a:	a0 83       	mov.a %a3,8
8000905c:	24 2f       	st.b [%a2+],%d15
8000905e:	fc 3f       	loop %a3,8000905c <readSensorPacket+0x2e>
            buffer[0] = UART_START_BYTE;
80009060:	3b a0 fa ff 	mov %d15,-86
80009064:	2c a7       	st.b [%sp]7,%d15
            buffer[1] = SENSOR_PACKET_ID;
80009066:	e9 a2 08 00 	st.b [%sp]8,%d2
8000906a:	82 2f       	mov %d15,2
            uint8 pos = 2;
            while (pos < SENSOR_PACKET_SIZE)
            {
                buffer[pos] = IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc);
8000906c:	40 c4       	mov.aa %a4,%a12
8000906e:	6d ff c3 e1 	call 800053f4 <IfxAsclin_Asc_blockingRead>
80009072:	10 f2       	addsc.a %a2,%a15,%d15,0
80009074:	c2 1f       	add %d15,1
80009076:	34 22       	st.b [%a2],%d2
        {
            uint8 buffer[SENSOR_PACKET_SIZE] = {};
            buffer[0] = UART_START_BYTE;
            buffer[1] = SENSOR_PACKET_ID;
            uint8 pos = 2;
            while (pos < SENSOR_PACKET_SIZE)
80009078:	8b 9f 20 22 	ne %d2,%d15,9
8000907c:	df 02 f8 ff 	jne %d2,0,8000906c <readSensorPacket+0x3e>
            {
                buffer[pos] = IfxAsclin_Asc_blockingRead(&g_AsclinStm.drivers.asc);
                pos++;
            }
            if (calculate_checksum(buffer, SENSOR_PACKET_SIZE - 1) == buffer[SENSOR_PACKET_SIZE - 1]){
80009080:	40 f4       	mov.aa %a4,%a15
80009082:	3b 80 00 40 	mov %d4,8
80009086:	6d ff ac fe 	call 80008dde <calculate_checksum>
8000908a:	0c af       	ld.bu %d15,[%sp]15
8000908c:	7e 25       	jne %d15,%d2,80009096 <readSensorPacket+0x68>
                deserialize_actuator_packet(buffer, packet);
8000908e:	40 f4       	mov.aa %a4,%a15
80009090:	40 d5       	mov.aa %a5,%a13
80009092:	6d ff 2c ff 	call 80008eea <deserialize_actuator_packet>
80009096:	00 90       	ret 

80009098 <serialize_sensor_packet>:
}

/* Serialize SensorPacket into buffer (SENSOR_PACKET_SIZE bytes) */
void serialize_sensor_packet(const struct SensorPacket *packet, uint8 *buffer)
{
    memcpy(buffer, packet, SENSOR_PACKET_SIZE - 1);
80009098:	40 52       	mov.aa %a2,%a5
8000909a:	a0 73       	mov.a %a3,7
8000909c:	04 4f       	ld.bu %d15,[%a4+]
8000909e:	24 2f       	st.b [%a2+],%d15
800090a0:	fc 3e       	loop %a3,8000909c <serialize_sensor_packet+0x4>
    buffer[SENSOR_PACKET_SIZE - 1] = calculate_checksum(buffer, SENSOR_PACKET_SIZE - 1);
800090a2:	40 54       	mov.aa %a4,%a5
800090a4:	3b 80 00 40 	mov %d4,8
       } */
}

/* Serialize SensorPacket into buffer (SENSOR_PACKET_SIZE bytes) */
void serialize_sensor_packet(const struct SensorPacket *packet, uint8 *buffer)
{
800090a8:	40 5f       	mov.aa %a15,%a5
    memcpy(buffer, packet, SENSOR_PACKET_SIZE - 1);
    buffer[SENSOR_PACKET_SIZE - 1] = calculate_checksum(buffer, SENSOR_PACKET_SIZE - 1);
800090aa:	6d ff 9a fe 	call 80008dde <calculate_checksum>
800090ae:	28 82       	st.b [%a15]8,%d2
800090b0:	00 90       	ret 

800090b2 <sendSensorPacket>:

    IfxAsclin_Asc_write(&g_AsclinStm.drivers.asc, &buf, &g_AsclinStm.count, TIME_INFINITE);
}

void sendSensorPacket(const struct SensorPacket *packet)
{
800090b2:	20 28       	sub.a %sp,40
800090b4:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
800090b6:	6d 00 01 06 	call 80009cb8 <EnableAllInterrupts>
    uint8 buf[SENSOR_PACKET_SIZE] = {};
800090ba:	d9 ac 1f 00 	lea %a12,[%sp]31
800090be:	40 c2       	mov.aa %a2,%a12
    serialize_sensor_packet(packet, buf);
800090c0:	40 f4       	mov.aa %a4,%a15
800090c2:	40 c5       	mov.aa %a5,%a12
}

void sendSensorPacket(const struct SensorPacket *packet)
{
    EnableAllInterrupts();
    uint8 buf[SENSOR_PACKET_SIZE] = {};
800090c4:	82 0f       	mov %d15,0
800090c6:	a0 83       	mov.a %a3,8
800090c8:	24 2f       	st.b [%a2+],%d15
800090ca:	fc 3f       	loop %a3,800090c8 <sendSensorPacket+0x16>
    serialize_sensor_packet(packet, buf);
800090cc:	6d ff e6 ff 	call 80009098 <serialize_sensor_packet>
    g_AsclinStm.count = SENSOR_PACKET_SIZE;
800090d0:	91 00 00 27 	movh.a %a2,28672

    printfSerial("\nsendB:[ ");
800090d4:	91 00 00 48 	movh.a %a4,32768
void sendSensorPacket(const struct SensorPacket *packet)
{
    EnableAllInterrupts();
    uint8 buf[SENSOR_PACKET_SIZE] = {};
    serialize_sensor_packet(packet, buf);
    g_AsclinStm.count = SENSOR_PACKET_SIZE;
800090d8:	da 09       	mov %d15,9
800090da:	d9 22 d4 20 	lea %a2,[%a2]3220 <70000c94 <g_AsclinStm>>

    printfSerial("\nsendB:[ ");
800090de:	d9 44 d1 d0 	lea %a4,[%a4]3921 <80000f51 <stateMaxArr+0x119>>
void sendSensorPacket(const struct SensorPacket *packet)
{
    EnableAllInterrupts();
    uint8 buf[SENSOR_PACKET_SIZE] = {};
    serialize_sensor_packet(packet, buf);
    g_AsclinStm.count = SENSOR_PACKET_SIZE;
800090e2:	f9 2f 30 90 	st.h [%a2]624 <70000270 <__malloc_av_+0x120>>,%d15

    printfSerial("\nsendB:[ ");
800090e6:	6d ff bd d9 	call 80004460 <printfSerial>
    int i;
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
800090ea:	91 00 00 d8 	movh.a %a13,32768
    serialize_sensor_packet(packet, buf);
    g_AsclinStm.count = SENSOR_PACKET_SIZE;

    printfSerial("\nsendB:[ ");
    int i;
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
800090ee:	82 0f       	mov %d15,0
    {
        printfSerial("%02x/", buf[i]);
800090f0:	d9 dd fe 90 	lea %a13,[%a13]3710 <80000e7e <stateMaxArr+0x46>>
800090f4:	10 c2       	addsc.a %a2,%a12,%d15,0
800090f6:	40 d4       	mov.aa %a4,%a13
800090f8:	14 22       	ld.bu %d2,[%a2]
    serialize_sensor_packet(packet, buf);
    g_AsclinStm.count = SENSOR_PACKET_SIZE;

    printfSerial("\nsendB:[ ");
    int i;
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
800090fa:	c2 1f       	add %d15,1
    {
        printfSerial("%02x/", buf[i]);
800090fc:	74 a2       	st.w [%sp],%d2
800090fe:	6d ff b1 d9 	call 80004460 <printfSerial>
    serialize_sensor_packet(packet, buf);
    g_AsclinStm.count = SENSOR_PACKET_SIZE;

    printfSerial("\nsendB:[ ");
    int i;
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
80009102:	8b 9f 20 22 	ne %d2,%d15,9
80009106:	df 02 f7 ff 	jne %d2,0,800090f4 <sendSensorPacket+0x42>
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
8000910a:	91 00 00 48 	movh.a %a4,32768
8000910e:	d9 44 c4 a0 	lea %a4,[%a4]3716 <80000e84 <stateMaxArr+0x4c>>
80009112:	6d ff a7 d9 	call 80004460 <printfSerial>
    printfSerial("\n[S|start:%02x id:%02x photo:%d ultra1:%d ultra2:%d]",
80009116:	0c f0       	ld.bu %d15,[%a15]0
                 packet->start_byte,
                 packet->packet_id,
                 packet->photo,
80009118:	08 22       	ld.bu %d2,[%a15]2
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[S|start:%02x id:%02x photo:%d ultra1:%d ultra2:%d]",
8000911a:	78 00       	st.w [%sp]0,%d15
8000911c:	0c f1       	ld.bu %d15,[%a15]1
8000911e:	91 00 00 48 	movh.a %a4,32768
80009122:	78 01       	st.w [%sp]4,%d15
                 packet->start_byte,
                 packet->packet_id,
                 packet->photo,
80009124:	0c f3       	ld.bu %d15,[%a15]3
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[S|start:%02x id:%02x photo:%d ultra1:%d ultra2:%d]",
80009126:	d9 44 db d0 	lea %a4,[%a4]3931 <80000f5b <stateMaxArr+0x123>>
                 packet->start_byte,
                 packet->packet_id,
                 packet->photo,
8000912a:	8f 8f 00 f0 	sh %d15,%d15,8
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[S|start:%02x id:%02x photo:%d ultra1:%d ultra2:%d]",
8000912e:	a6 2f       	or %d15,%d2
80009130:	78 02       	st.w [%sp]8,%d15
                 packet->start_byte,
                 packet->packet_id,
                 packet->photo,
                 packet->ultra_sonic1,
80009132:	0c f5       	ld.bu %d15,[%a15]5
80009134:	08 42       	ld.bu %d2,[%a15]4
80009136:	8f 8f 00 f0 	sh %d15,%d15,8
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[S|start:%02x id:%02x photo:%d ultra1:%d ultra2:%d]",
8000913a:	a6 2f       	or %d15,%d2
8000913c:	78 03       	st.w [%sp]12,%d15
                 packet->start_byte,
                 packet->packet_id,
                 packet->photo,
                 packet->ultra_sonic1,
                 packet->ultra_sonic2);
8000913e:	0c f7       	ld.bu %d15,[%a15]7
80009140:	08 62       	ld.bu %d2,[%a15]6
80009142:	8f 8f 00 f0 	sh %d15,%d15,8
    for (i = 0; i < SENSOR_PACKET_SIZE; i++)
    {
        printfSerial("%02x/", buf[i]);
    }
    printfSerial(" ]");
    printfSerial("\n[S|start:%02x id:%02x photo:%d ultra1:%d ultra2:%d]",
80009146:	a6 2f       	or %d15,%d2
80009148:	78 04       	st.w [%sp]16,%d15
8000914a:	6d ff 8b d9 	call 80004460 <printfSerial>
                 packet->packet_id,
                 packet->photo,
                 packet->ultra_sonic1,
                 packet->ultra_sonic2);

    IfxAsclin_Asc_write(&g_AsclinStm.drivers.asc, &buf, &g_AsclinStm.count, TIME_INFINITE);
8000914e:	91 00 00 47 	movh.a %a4,28672
80009152:	91 00 00 67 	movh.a %a6,28672
80009156:	82 f4       	mov %d4,-1
80009158:	d9 44 e8 b0 	lea %a4,[%a4]3816 <70000ee8 <g_AsclinStm+0x254>>
8000915c:	40 c5       	mov.aa %a5,%a12
8000915e:	d9 66 c4 c0 	lea %a6,[%a6]3844 <70000f04 <g_AsclinStm+0x270>>
80009162:	9b 04 00 58 	addih %d5,%d4,32768
80009166:	1d ff a7 e3 	j 800058b4 <IfxAsclin_Asc_write>

8000916a <deserialize_sensor_packet>:
}

/* Deserialize buffer into SensorPacket */
void deserialize_sensor_packet(const uint8 *buffer, struct SensorPacket *packet)
{
    memcpy(packet, buffer, SENSOR_PACKET_SIZE);
8000916a:	a0 8f       	mov.a %a15,8
8000916c:	04 4f       	ld.bu %d15,[%a4+]
8000916e:	24 5f       	st.b [%a5+],%d15
80009170:	fc fe       	loop %a15,8000916c <deserialize_sensor_packet+0x2>
80009172:	00 90       	ret 

80009174 <initUltrasonic>:
    .ECHO_PIN = 3
};

void initUltrasonic (struct Ultrasonic* ultrasonic)
{
    IfxPort_setPinModeOutput(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
80009174:	0c 41       	ld.bu %d15,[%a4]1
80009176:	14 43       	ld.bu %d3,[%a4]
80009178:	8f 8f 00 f0 	sh %d15,%d15,8
8000917c:	0f 3f a0 20 	or %d2,%d15,%d3
80009180:	0c 42       	ld.bu %d15,[%a4]2
    .ECHO_PORT = &MODULE_P10,
    .ECHO_PIN = 3
};

void initUltrasonic (struct Ultrasonic* ultrasonic)
{
80009182:	40 4f       	mov.aa %a15,%a4
    IfxPort_setPinModeOutput(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
80009184:	8f 0f 01 f0 	sh %d15,%d15,16
80009188:	a6 2f       	or %d15,%d2
8000918a:	39 42 03 00 	ld.bu %d2,[%a4]3
8000918e:	08 44       	ld.bu %d4,[%a15]4
80009190:	8f 82 01 20 	sh %d2,%d2,24
80009194:	a6 f2       	or %d2,%d15
80009196:	60 24       	mov.a %a4,%d2
80009198:	3b 00 08 50 	mov %d5,128
8000919c:	6d ff 99 e5 	call 80005cce <IfxPort_setPinMode>
    IfxPort_setPinModeInput(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN, IfxPort_InputMode_pullDown);
800091a0:	0c f6       	ld.bu %d15,[%a15]6
800091a2:	08 53       	ld.bu %d3,[%a15]5
800091a4:	8f 8f 00 f0 	sh %d15,%d15,8
800091a8:	0f 3f a0 20 	or %d2,%d15,%d3
800091ac:	0c f7       	ld.bu %d15,[%a15]7
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800091ae:	08 94       	ld.bu %d4,[%a15]9
800091b0:	8f 0f 01 f0 	sh %d15,%d15,16
800091b4:	a6 2f       	or %d15,%d2
800091b6:	08 82       	ld.bu %d2,[%a15]8
800091b8:	3b 80 00 50 	mov %d5,8
800091bc:	8f 82 01 20 	sh %d2,%d2,24
800091c0:	a6 f2       	or %d2,%d15
800091c2:	60 24       	mov.a %a4,%d2
800091c4:	1d ff 85 e5 	j 80005cce <IfxPort_setPinMode>

800091c8 <sendTrigger>:
    return distanceCm;
}

void sendTrigger(struct Ultrasonic* ultrasonic)
{
    IfxPort_setPinHigh(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN);
800091c8:	0c 41       	ld.bu %d15,[%a4]1
800091ca:	14 43       	ld.bu %d3,[%a4]
800091cc:	8f 8f 00 f0 	sh %d15,%d15,8
800091d0:	0f 3f a0 20 	or %d2,%d15,%d3
800091d4:	0c 42       	ld.bu %d15,[%a4]2
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800091d6:	39 43 04 00 	ld.bu %d3,[%a4]4
800091da:	8f 0f 01 f0 	sh %d15,%d15,16
800091de:	a6 2f       	or %d15,%d2
800091e0:	39 42 03 00 	ld.bu %d2,[%a4]3
    delay_us(10);
800091e4:	3b a0 00 40 	mov %d4,10
    return distanceCm;
}

void sendTrigger(struct Ultrasonic* ultrasonic)
{
    IfxPort_setPinHigh(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN);
800091e8:	8f 82 01 20 	sh %d2,%d2,24
800091ec:	a6 f2       	or %d2,%d15
800091ee:	60 22       	mov.a %a2,%d2
800091f0:	82 1f       	mov %d15,1
800091f2:	0f 3f 00 30 	sh %d3,%d15,%d3
800091f6:	59 23 04 00 	st.w [%a2]4,%d3
    int distanceCm = calculateDistanceCm(echoTicks);
    return distanceCm;
}

void sendTrigger(struct Ultrasonic* ultrasonic)
{
800091fa:	40 4f       	mov.aa %a15,%a4
    IfxPort_setPinHigh(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN);
    delay_us(10);
800091fc:	6d ff c2 d8 	call 80004380 <delay_us>
    IfxPort_setPinLow(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN);
80009200:	0c f1       	ld.bu %d15,[%a15]1
80009202:	08 03       	ld.bu %d3,[%a15]0
80009204:	8f 8f 00 f0 	sh %d15,%d15,8
80009208:	0f 3f a0 20 	or %d2,%d15,%d3
8000920c:	0c f2       	ld.bu %d15,[%a15]2
8000920e:	7b 10 00 30 	movh %d3,1
80009212:	8f 0f 01 f0 	sh %d15,%d15,16
80009216:	a6 2f       	or %d15,%d2
80009218:	08 32       	ld.bu %d2,[%a15]3
8000921a:	8f 82 01 20 	sh %d2,%d2,24
8000921e:	a6 f2       	or %d2,%d15
80009220:	0c f4       	ld.bu %d15,[%a15]4
80009222:	60 22       	mov.a %a2,%d2
80009224:	0f f3 00 30 	sh %d3,%d3,%d15
80009228:	59 23 04 00 	st.w [%a2]4,%d3
8000922c:	00 90       	ret 

8000922e <measureEchoTick>:

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000922e:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80009232:	85 f8 2c 00 	ld.w %d8,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80009236:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
8000923a:	8f 0f 40 41 	or %d4,%d15,0

long measureEchoTick(struct Ultrasonic* ultrasonic)
{
    uint64 startTick = 0, elapsedTick = 0;
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 0){
8000923e:	0c 46       	ld.bu %d15,[%a4]6
80009240:	0f 38 a0 50 	or %d5,%d8,%d3
80009244:	39 43 05 00 	ld.bu %d3,[%a4]5
80009248:	8f 8f 00 f0 	sh %d15,%d15,8
8000924c:	0f 3f a0 20 	or %d2,%d15,%d3
80009250:	0c 47       	ld.bu %d15,[%a4]7
}


IFX_INLINE boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex)
{
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
80009252:	39 48 09 00 	ld.bu %d8,[%a4]9
80009256:	8f 0f 01 f0 	sh %d15,%d15,16
8000925a:	a6 2f       	or %d15,%d2
8000925c:	39 42 08 00 	ld.bu %d2,[%a4]8
80009260:	82 19       	mov %d9,1
80009262:	8f 82 01 20 	sh %d2,%d2,24
80009266:	a6 f2       	or %d2,%d15
80009268:	60 2f       	mov.a %a15,%d2
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
8000926a:	7b 40 07 a0 	movh %d10,116
    IfxPort_setPinLow(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN);
}

long measureEchoTick(struct Ultrasonic* ultrasonic)
{
    uint64 startTick = 0, elapsedTick = 0;
8000926e:	d2 02       	mov %e2,0
80009270:	0f 89 00 90 	sh %d9,%d9,%d8
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80009274:	1b 0a 78 af 	addi %d10,%d10,-2176
80009278:	4c f9       	ld.w %d15,[%a15]36
8000927a:	26 9f       	and %d15,%d9

long measureEchoTick(struct Ultrasonic* ultrasonic)
{
    uint64 startTick = 0, elapsedTick = 0;
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 0){
8000927c:	ee 16       	jnz %d15,800092a8 <measureEchoTick+0x7a>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000927e:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80009282:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80009286:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
8000928a:	8f 0f 40 01 	or %d0,%d15,0
8000928e:	0f 32 a0 10 	or %d1,%d2,%d3
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
80009292:	0b 40 c0 20 	subx %d2,%d0,%d4
80009296:	0b 51 d0 30 	subc %d3,%d1,%d5
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
8000929a:	ba 03       	eq %d15,%d3,0
8000929c:	0b a2 50 f2 	and.ge.u %d15,%d2,%d10
800092a0:	8b 03 00 f5 	or.ne %d15,%d3,0
800092a4:	6e ea       	jz %d15,80009278 <measureEchoTick+0x4a>
800092a6:	3c 29       	j 800092f8 <measureEchoTick+0xca>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800092a8:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800092ac:	85 f9 2c 00 	ld.w %d9,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800092b0:	53 1f 40 00 	mul.u %e0,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
800092b4:	8f 0f 40 41 	or %d4,%d15,0
    };
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 1){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
800092b8:	7b 40 07 00 	movh %d0,116
800092bc:	0f 19 a0 50 	or %d5,%d9,%d1
800092c0:	1b 00 78 0f 	addi %d0,%d0,-2176
800092c4:	4c f9       	ld.w %d15,[%a15]36
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
    };
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 1){
800092c6:	57 0f 61 f8 	extr.u %d15,%d15,%d8,1
800092ca:	de 16       	jne %d15,1,800092f6 <measureEchoTick+0xc8>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800092cc:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
800092d0:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
800092d4:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
800092d8:	8f 0f 40 61 	or %d6,%d15,0
800092dc:	0f 32 a0 70 	or %d7,%d2,%d3
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
800092e0:	0b 46 c0 20 	subx %d2,%d6,%d4
800092e4:	0b 57 d0 30 	subc %d3,%d7,%d5
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
800092e8:	ba 03       	eq %d15,%d3,0
800092ea:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
800092ee:	8b 03 00 f5 	or.ne %d15,%d3,0
800092f2:	6e e9       	jz %d15,800092c4 <measureEchoTick+0x96>
800092f4:	3c 02       	j 800092f8 <measureEchoTick+0xca>
    };
    return (long)elapsedTick;
800092f6:	00 90       	ret 
{
    uint64 startTick = 0, elapsedTick = 0;
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
800092f8:	82 f2       	mov %d2,-1
    while (IfxPort_getPinState(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN) == 1){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
    };
    return (long)elapsedTick;
}
800092fa:	00 90       	ret 

800092fc <getUltrasonic>:
{
    IfxPort_setPinModeOutput(ultrasonic->TRIG_PORT,ultrasonic->TRIG_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeInput(ultrasonic->ECHO_PORT,ultrasonic->ECHO_PIN, IfxPort_InputMode_pullDown);
}

int getUltrasonic(struct Ultrasonic* ultrasonic){
800092fc:	40 4f       	mov.aa %a15,%a4
    sendTrigger(ultrasonic);
800092fe:	6d ff 65 ff 	call 800091c8 <sendTrigger>
    long echoTicks = measureEchoTick(ultrasonic);
80009302:	40 f4       	mov.aa %a4,%a15
80009304:	6d ff 95 ff 	call 8000922e <measureEchoTick>
80009308:	02 2f       	mov %d15,%d2
    if(echoTicks==-1)return -1;
8000930a:	82 f2       	mov %d2,-1
8000930c:	1e fb       	jeq %d15,-1,80009322 <getUltrasonic+0x26>
    return (long)elapsedTick;
}

int calculateDistanceCm(long elapsedTicks)
{
    long timeUs = elapsedTicks / 200;
8000930e:	3b 80 0c 20 	mov %d2,200
80009312:	4b 2f 01 22 	div %e2,%d15,%d2
    long distanceCm = timeUs * 34 / 1000 / 2;
80009316:	3b 80 3e f0 	mov %d15,1000
8000931a:	53 12 21 20 	mul %d2,%d2,17
8000931e:	4b f2 01 22 	div %e2,%d2,%d15
    sendTrigger(ultrasonic);
    long echoTicks = measureEchoTick(ultrasonic);
    if(echoTicks==-1)return -1;
    int distanceCm = calculateDistanceCm(echoTicks);
    return distanceCm;
}
80009322:	00 90       	ret 

80009324 <calculateDistanceCm>:
    return (long)elapsedTick;
}

int calculateDistanceCm(long elapsedTicks)
{
    long timeUs = elapsedTicks / 200;
80009324:	3b 80 0c 20 	mov %d2,200
80009328:	4b 24 01 42 	div %e4,%d4,%d2
    long distanceCm = timeUs * 34 / 1000 / 2;
8000932c:	3b 80 3e 20 	mov %d2,1000
80009330:	53 14 21 40 	mul %d4,%d4,17
80009334:	4b 24 01 22 	div %e2,%d4,%d2
    return (int) distanceCm;
}
80009338:	00 90       	ret 

8000933a <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000933a:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000933e:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80009342:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80009346:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000934a:	54 25       	ld.w %d5,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000934c:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000934e:	37 05 6e 51 	extr.u %d5,%d5,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80009352:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80009356:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000935a:	8f f5 83 51 	xor %d5,%d5,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000935e:	8f f8 83 81 	xor %d8,%d8,63
80009362:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
80009366:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80009368:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
8000936c:	3b 00 b8 f0 	mov %d15,2944
80009370:	cd 4f e0 0f 	mtcr $psw,%d15
80009374:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80009378:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
8000937c:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80009380:	cd 0f e0 0f 	mtcr $pcxi,%d15
80009384:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009388:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
8000938c:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
8000938e:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80009392:	cd 42 20 09 	mtcr $pcon1,%d2
80009396:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000939a:	53 cf 20 f0 	mul %d15,%d15,12
8000939e:	10 22       	addsc.a %a2,%a2,%d15,0
800093a0:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
800093a2:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800093a4:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
800093a8:	d9 2f 00 46 	lea %a15,[%a2]24832
800093ac:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800093b0:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800093b2:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800093b6:	2e 16       	jz.t %d15,1,800093c2 <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800093b8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800093bc:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800093c0:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800093c2:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800093c6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800093ca:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800093cc:	4c f0       	ld.w %d15,[%a15]0
800093ce:	6f 0f ff ff 	jnz.t %d15,0,800093cc <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
800093d2:	82 0f       	mov %d15,0
800093d4:	cd cf 20 09 	mtcr $pcon0,%d15
800093d8:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800093dc:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800093de:	2e 16       	jz.t %d15,1,800093ea <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800093e0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800093e4:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800093e8:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800093ea:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800093ee:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800093f2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800093f4:	4c f0       	ld.w %d15,[%a15]0
800093f6:	6f 0f ff 7f 	jz.t %d15,0,800093f4 <osEE_tc_core0_start+0xba>
800093fa:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
800093fe:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80009402:	91 30 00 ff 	movh.a %a15,61443
80009406:	53 cf 20 f0 	mul %d15,%d15,12
8000940a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000940e:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80009410:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80009412:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80009414:	d9 2f 00 46 	lea %a15,[%a2]24832
80009418:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000941c:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80009420:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80009422:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80009426:	2e 16       	jz.t %d15,1,80009432 <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80009428:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000942c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80009430:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80009432:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80009436:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000943a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000943c:	4c f0       	ld.w %d15,[%a15]0
8000943e:	6f 0f ff ff 	jnz.t %d15,0,8000943c <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80009442:	82 0f       	mov %d15,0
80009444:	cd 0f 04 09 	mtcr $dcon0,%d15
80009448:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000944c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000944e:	2e 16       	jz.t %d15,1,8000945a <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80009450:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80009454:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80009458:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000945a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000945e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80009462:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80009464:	4c f0       	ld.w %d15,[%a15]0
80009466:	6f 0f ff 7f 	jz.t %d15,0,80009464 <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000946a:	91 30 00 ff 	movh.a %a15,61443
8000946e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80009472:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80009474:	2e 16       	jz.t %d15,1,80009480 <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80009476:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000947a:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000947e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80009480:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80009484:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80009488:	91 30 00 ff 	movh.a %a15,61443
8000948c:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80009490:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80009492:	4c f0       	ld.w %d15,[%a15]0
80009494:	91 30 00 2f 	movh.a %a2,61443
80009498:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000949c:	6f 0f fb ff 	jnz.t %d15,0,80009492 <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
800094a0:	7b 00 00 f8 	movh %d15,32768
800094a4:	1b 0f 30 f1 	addi %d15,%d15,4864
800094a8:	cd 4f e2 0f 	mtcr $btv,%d15
800094ac:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
800094b0:	7b 00 00 f8 	movh %d15,32768
800094b4:	1b 0f 00 f2 	addi %d15,%d15,8192
800094b8:	cd 0f e2 0f 	mtcr $biv,%d15
800094bc:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
800094c0:	7b 20 00 f7 	movh %d15,28674
800094c4:	1b 0f b0 f9 	addi %d15,%d15,-25856
800094c8:	cd 8f e2 0f 	mtcr $isp,%d15
800094cc:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800094d0:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800094d2:	2e 16       	jz.t %d15,1,800094de <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800094d4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800094d8:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800094dc:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800094de:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800094e2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800094e6:	91 30 00 ff 	movh.a %a15,61443
800094ea:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800094ee:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800094f0:	4c f0       	ld.w %d15,[%a15]0
800094f2:	6f 0f ff 7f 	jz.t %d15,0,800094f0 <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
800094f6:	91 10 00 f7 	movh.a %a15,28673
800094fa:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
800094fe:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80009500:	91 10 00 f8 	movh.a %a15,32769
80009504:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80009508:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
8000950a:	91 10 00 f8 	movh.a %a15,32769
8000950e:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80009512:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
80009514:	91 10 00 fb 	movh.a %a15,45057
80009518:	d9 ff 00 08 	lea %a15,[%a15]-32768 <b0008000 <_SMALL_DATA4_>>
8000951c:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
8000951e:	7b 20 00 f7 	movh %d15,28674
80009522:	7b 20 00 47 	movh %d4,28674
80009526:	1b 0f c0 69 	addi %d6,%d15,-25600
8000952a:	1b 04 c0 4b 	addi %d4,%d4,-17408
8000952e:	a2 64       	sub %d4,%d6
80009530:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80009532:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80009534:	df 04 16 00 	jeq %d4,0,80009560 <osEE_tc_core0_start+0x226>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80009538:	9a f4       	add %d15,%d4,-1
8000953a:	06 6f       	sh %d15,6
8000953c:	12 63       	add %d3,%d15,%d6

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000953e:	60 3f       	mov.a %a15,%d3
80009540:	82 00       	mov %d0,0
80009542:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80009544:	60 4f       	mov.a %a15,%d4
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80009546:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000954a:	37 03 70 73 	extr.u %d7,%d3,6,16
8000954e:	1b 0f fc ff 	addi %d15,%d15,-64

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80009552:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80009554:	37 27 10 28 	insert %d2,%d7,%d2,16,16
80009558:	42 6f       	add %d15,%d6

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000955a:	82 53       	mov %d3,5
8000955c:	fd f0 11 01 	loop %a15,8000977e <osEE_tc_core0_start+0x444>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
80009560:	cd 82 e3 0f 	mtcr $fcx,%d2
80009564:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80009568:	91 30 00 ff 	movh.a %a15,61443
8000956c:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80009570:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80009572:	2e 16       	jz.t %d15,1,8000957e <osEE_tc_core0_start+0x244>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80009574:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80009578:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000957c:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000957e:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80009582:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80009586:	91 30 00 ff 	movh.a %a15,61443
8000958a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000958e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80009590:	40 f2       	mov.aa %a2,%a15
80009592:	4c 20       	ld.w %d15,[%a2]0
80009594:	91 30 00 ff 	movh.a %a15,61443
80009598:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000959c:	6f 0f fb ff 	jnz.t %d15,0,80009592 <osEE_tc_core0_start+0x258>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
800095a0:	4c f1       	ld.w %d15,[%a15]4
800095a2:	96 08       	or %d15,8
800095a4:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800095a6:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800095a8:	2e 16       	jz.t %d15,1,800095b4 <osEE_tc_core0_start+0x27a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800095aa:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800095ae:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800095b2:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800095b4:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800095b8:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800095bc:	91 30 00 ff 	movh.a %a15,61443
800095c0:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800095c4:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800095c6:	4c f0       	ld.w %d15,[%a15]0
800095c8:	6f 0f ff 7f 	jz.t %d15,0,800095c6 <osEE_tc_core0_start+0x28c>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
800095cc:	91 30 00 ff 	movh.a %a15,61443
800095d0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800095d4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
800095d6:	2e 16       	jz.t %d15,1,800095e2 <osEE_tc_core0_start+0x2a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
800095d8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
800095dc:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
800095e0:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
800095e2:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
800095e6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
800095ea:	91 30 00 ff 	movh.a %a15,61443
800095ee:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800095f2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
800095f4:	40 f2       	mov.aa %a2,%a15
800095f6:	4c 20       	ld.w %d15,[%a2]0
800095f8:	91 30 00 ff 	movh.a %a15,61443
800095fc:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009600:	6f 0f fb ff 	jnz.t %d15,0,800095f6 <osEE_tc_core0_start+0x2bc>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80009604:	4c f1       	ld.w %d15,[%a15]4
80009606:	96 08       	or %d15,8
80009608:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000960a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000960c:	2e 16       	jz.t %d15,1,80009618 <osEE_tc_core0_start+0x2de>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000960e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80009612:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80009616:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80009618:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
8000961c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80009620:	91 30 00 ff 	movh.a %a15,61443
80009624:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009628:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000962a:	4c f0       	ld.w %d15,[%a15]0
8000962c:	6f 0f ff 7f 	jz.t %d15,0,8000962a <osEE_tc_core0_start+0x2f0>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80009630:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
80009634:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80009636:	d9 44 38 51 	lea %a4,[%a4]4472 <80001178 <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
8000963a:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
8000963c:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
8000963e:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
80009640:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
80009642:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80009644:	9e f6       	jeq %d15,-1,80009670 <osEE_tc_core0_start+0x336>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
80009646:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000964a:	76 49       	jz %d4,8000965c <osEE_tc_core0_start+0x322>
        *block_to_clear.p_ull = 0ULL;
8000964c:	60 4f       	mov.a %a15,%d4
8000964e:	40 32       	mov.aa %a2,%a3
80009650:	b0 ff       	add.a %a15,-1
80009652:	89 22 48 01 	st.d [%a2+]8,%e2
80009656:	fc fe       	loop %a15,80009652 <osEE_tc_core0_start+0x318>
80009658:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
8000965c:	2e 22       	jz.t %d15,2,80009660 <osEE_tc_core0_start+0x326>
        *block_to_clear.p_ui = 0x0U;
8000965e:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
80009660:	2e 12       	jz.t %d15,1,80009664 <osEE_tc_core0_start+0x32a>
        *block_to_clear.p_us = 0x0U;
80009662:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80009664:	2e 02       	jz.t %d15,0,80009668 <osEE_tc_core0_start+0x32e>
        *block_to_clear.p_uc = 0x0U;
80009666:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
80009668:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
8000966c:	bd 04 ea ff 	jnz.a %a4,80009640 <osEE_tc_core0_start+0x306>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
80009670:	91 00 00 68 	movh.a %a6,32768
80009674:	d9 66 20 71 	lea %a6,[%a6]4576 <800011e0 <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
80009678:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
8000967a:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
8000967c:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80009680:	df ff 21 00 	jeq %d15,-1,800096c2 <osEE_tc_core0_start+0x388>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
80009684:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
80009688:	76 4f       	jz %d4,800096a6 <osEE_tc_core0_start+0x36c>
8000968a:	60 4f       	mov.a %a15,%d4
8000968c:	40 43       	mov.aa %a3,%a4
8000968e:	40 52       	mov.aa %a2,%a5
80009690:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
80009692:	09 22 48 01 	ld.d %e2,[%a2+]8
80009696:	89 32 48 01 	st.d [%a3+]8,%e2
8000969a:	fc fc       	loop %a15,80009692 <osEE_tc_core0_start+0x358>
8000969c:	06 34       	sh %d4,3
8000969e:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
800096a2:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
800096a6:	2e 23       	jz.t %d15,2,800096ac <osEE_tc_core0_start+0x372>
        *block_dest.p_ui = *block_src.p_ui;
800096a8:	44 52       	ld.w %d2,[%a5+]
800096aa:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
800096ac:	2e 14       	jz.t %d15,1,800096b4 <osEE_tc_core0_start+0x37a>
        *block_dest.p_us = *block_src.p_us;
800096ae:	09 52 c2 00 	ld.hu %d2,[%a5+]2
800096b2:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
800096b4:	2e 03       	jz.t %d15,0,800096ba <osEE_tc_core0_start+0x380>
        *block_dest.p_uc = *block_src.p_uc;
800096b6:	0c 50       	ld.bu %d15,[%a5]0
800096b8:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
800096ba:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
800096be:	bd 06 dd ff 	jnz.a %a6,80009678 <osEE_tc_core0_start+0x33e>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
800096c2:	91 30 00 ff 	movh.a %a15,61443
800096c6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800096ca:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
800096cc:	2e 16       	jz.t %d15,1,800096d8 <osEE_tc_core0_start+0x39e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
800096ce:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
800096d2:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
800096d6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
800096d8:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
800096dc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
800096e0:	91 30 00 ff 	movh.a %a15,61443
800096e4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800096e8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
800096ea:	4c f0       	ld.w %d15,[%a15]0
800096ec:	6f 0f ff ff 	jnz.t %d15,0,800096ea <osEE_tc_core0_start+0x3b0>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
800096f0:	7b 20 22 f1 	movh %d15,4642
800096f4:	91 30 00 ff 	movh.a %a15,61443
800096f8:	1b 1f 10 f0 	addi %d15,%d15,257
800096fc:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009700:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
80009702:	7b 00 00 f5 	movh %d15,20480
80009706:	91 30 00 ff 	movh.a %a15,61443
8000970a:	1b 0f 10 f1 	addi %d15,%d15,4352
8000970e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009712:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
80009714:	7b 70 00 f0 	movh %d15,7
80009718:	91 30 00 ff 	movh.a %a15,61443
8000971c:	1b cf 01 f0 	addi %d15,%d15,28
80009720:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80009724:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
80009726:	4c f0       	ld.w %d15,[%a15]0
80009728:	6f 1f ff 7f 	jz.t %d15,1,80009726 <osEE_tc_core0_start+0x3ec>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
8000972c:	91 30 00 ff 	movh.a %a15,61443
80009730:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80009734:	4c f0       	ld.w %d15,[%a15]0
80009736:	6f 8f ff 7f 	jz.t %d15,8,80009734 <osEE_tc_core0_start+0x3fa>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
8000973a:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000973e:	91 30 00 ff 	movh.a %a15,61443
80009742:	1b 04 20 4c 	addi %d4,%d4,-15872
80009746:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000974a:	6d 00 58 00 	call 800097fa <osEE_tc_set_pll_fsource>
8000974e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80009750:	2e 16       	jz.t %d15,1,8000975c <osEE_tc_core0_start+0x422>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80009752:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80009756:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000975a:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000975c:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80009760:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80009764:	91 30 00 ff 	movh.a %a15,61443
80009768:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000976c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000976e:	4c f0       	ld.w %d15,[%a15]0
80009770:	6f 0f ff 7f 	jz.t %d15,0,8000976e <osEE_tc_core0_start+0x434>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
80009774:	6d ff 91 d7 	call 80004696 <main>
80009778:	02 24       	mov %d4,%d2
8000977a:	6d 00 ff 27 	call 8000e778 <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000977e:	60 f2       	mov.a %a2,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80009780:	8f 4f 1e 40 	sh %d4,%d15,-28
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80009784:	74 22       	st.w [%a2],%d2
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80009786:	c2 f3       	add %d3,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80009788:	37 0f 70 23 	extr.u %d2,%d15,6,16
8000978c:	37 42 10 28 	insert %d2,%d2,%d4,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80009790:	76 36       	jz %d3,8000979c <osEE_tc_core0_start+0x462>
80009792:	1b 0f fc ff 	addi %d15,%d15,-64
80009796:	fc f4       	loop %a15,8000977e <osEE_tc_core0_start+0x444>
80009798:	1d ff e4 fe 	j 80009560 <osEE_tc_core0_start+0x226>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
8000979c:	cd c2 e3 0f 	mtcr $lcx,%d2
800097a0:	0d 00 c0 04 	isync 
800097a4:	3c f7       	j 80009792 <osEE_tc_core0_start+0x458>

800097a6 <osEE_tc_stm_us_ticks>:
#if (defined(__TASKING__))
#define OS_STOP_SEC_GLOBAL_VAR_CLEARED
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
800097a6:	40 ae       	mov.aa %a14,%sp
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
800097a8:	91 00 00 f7 	movh.a %a15,28672
800097ac:	19 ff c8 c0 	ld.w %d15,[%a15]3848 <70000f08 <osEE_tc_stm_freq_khz>>
800097b0:	3b 80 3e 20 	mov %d2,1000
800097b4:	3f 2f 0c 80 	jlt.u %d15,%d2,800097cc <osEE_tc_stm_us_ticks+0x26>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
800097b8:	7b 20 06 21 	movh %d2,4194
800097bc:	1b 32 dd 24 	addi %d2,%d2,19923
800097c0:	73 2f 68 20 	mul.u %e2,%d15,%d2
800097c4:	8f a3 1f 20 	sh %d2,%d3,-6
800097c8:	e2 42       	mul %d2,%d4
800097ca:	00 90       	ret 
  } else if (usec >= OSEE_KILO) {
800097cc:	02 25       	mov %d5,%d2
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
800097ce:	73 f4 0a 20 	mul %d2,%d4,%d15
800097d2:	7b 20 06 31 	movh %d3,4194
800097d6:	1b 33 dd 34 	addi %d3,%d3,19923
800097da:	73 32 68 20 	mul.u %e2,%d2,%d3
800097de:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
800097e2:	3f 54 0b 80 	jlt.u %d4,%d5,800097f8 <osEE_tc_stm_us_ticks+0x52>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
800097e6:	7b 20 06 21 	movh %d2,4194
800097ea:	1b 32 dd 24 	addi %d2,%d2,19923
800097ee:	73 24 68 40 	mul.u %e4,%d4,%d2
800097f2:	8f a5 1f 20 	sh %d2,%d5,-6
800097f6:	e2 f2       	mul %d2,%d15
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
  }
  return ticks;
}
800097f8:	00 90       	ret 

800097fa <osEE_tc_set_pll_fsource>:
#define OSEE_TC_K2_MIN      (1U)
#define OSEE_TC_N_MAX       (128U)  /* '7 bits */
#define OSEE_TC_N_MIN       (1U)
#define OSEE_TC_DEV_ALLOWED (2U)

void osEE_tc_set_pll_fsource(OsEE_reg fpll) {
800097fa:	40 ae       	mov.aa %a14,%sp
  fPllLeastError  = OSEE_TC_CLOCK_MAX;
  fPllError       = OSEE_TC_CLOCK_MAX;

  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
800097fc:	7b e0 e4 20 	movh %d2,3662
80009800:	1b 12 c0 21 	addi %d2,%d2,7169
80009804:	0b 24 30 f1 	lt.u %d15,%d4,%d2
80009808:	82 22       	mov %d2,2
8000980a:	ab 12 80 ff 	sel %d15,%d15,%d2,1
8000980e:	60 f4       	mov.a %a4,%d15
80009810:	53 ff 20 f0 	mul %d15,%d15,15
80009814:	60 f5       	mov.a %a5,%d15
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80009816:	3b 00 01 e0 	mov %d14,16
8000981a:	82 03       	mov %d3,0
8000981c:	7b c0 be 20 	movh %d2,3052
80009820:	1b 02 20 2c 	addi %d2,%d2,-15872
80009824:	02 28       	mov %d8,%d2
80009826:	82 01       	mov %d1,0
80009828:	82 0b       	mov %d11,0
8000982a:	82 0d       	mov %d13,0
8000982c:	82 0c       	mov %d12,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000982e:	7b 10 13 a0 	movh %d10,305
80009832:	1b 0a d0 a2 	addi %d10,%d10,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80009836:	91 40 0f 60 	movh.a %a6,244
8000983a:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
    {
      for (
8000983e:	a0 1d       	mov.a %a13,1
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80009840:	53 14 40 60 	mul.u %e6,%d4,1
80009844:	60 62       	mov.a %a2,%d6
80009846:	60 73       	mov.a %a3,%d7

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80009848:	91 80 7d f1 	movh.a %a15,6104
8000984c:	d9 ff 41 08 	lea %a15,[%a15]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
        {
          for (
80009850:	a0 1c       	mov.a %a12,1
80009852:	3c 5e       	j 8000990e <osEE_tc_set_pll_fsource+0x114>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80009854:	4b ea 11 62 	div.u %e6,%d10,%d14
80009858:	82 07       	mov %d7,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000985a:	7b 60 f8 ff 	movh %d15,65414
8000985e:	1b 0f e0 fe 	addi %d15,%d15,-4608
80009862:	0b f6 40 60 	addx %d6,%d6,%d15
80009866:	8b f7 bf 50 	addc %d5,%d7,-1
8000986a:	ba 05       	eq %d15,%d5,0
8000986c:	80 67       	mov.d %d7,%a6
8000986e:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80009872:	8b 05 00 f5 	or.ne %d15,%d5,0
80009876:	ee 4a       	jnz %d15,8000990a <osEE_tc_set_pll_fsource+0x110>
    {
      for (
80009878:	df 00 56 00 	jeq %d0,0,80009924 <osEE_tc_set_pll_fsource+0x12a>
8000987c:	02 e9       	mov %d9,%d14
8000987e:	80 d0       	mov.d %d0,%a13
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80009880:	60 e7       	mov.a %a7,%d14
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80009882:	80 2f       	mov.d %d15,%a2
80009884:	73 f0 68 60 	mul.u %e6,%d0,%d15
80009888:	80 3f       	mov.d %d15,%a3
8000988a:	03 f0 0a 77 	madd %d7,%d7,%d0,%d15

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000988e:	7b 80 82 fe 	movh %d15,59432
80009892:	1b 0f c0 f7 	addi %d15,%d15,31744
80009896:	0b f6 40 60 	addx %d6,%d6,%d15
8000989a:	8b f7 bf 50 	addc %d5,%d7,-1
8000989e:	ba 05       	eq %d15,%d5,0
800098a0:	80 f7       	mov.d %d7,%a15
800098a2:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
800098a6:	8b 05 00 f5 	or.ne %d15,%d5,0
800098aa:	ee 25       	jnz %d15,800098f4 <osEE_tc_set_pll_fsource+0xfa>
        {
          for (
800098ac:	0f 23 a0 f0 	or %d15,%d3,%d2
800098b0:	6e 2d       	jz %d15,8000990a <osEE_tc_set_pll_fsource+0x110>
800098b2:	80 c6       	mov.d %d6,%a12
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
800098b4:	4b 96 11 22 	div.u %e2,%d6,%d9
800098b8:	02 2f       	mov %d15,%d2
800098ba:	e2 af       	mul %d15,%d10
800098bc:	a2 4f       	sub %d15,%d4
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
800098be:	53 1f 40 20 	mul.u %e2,%d15,1
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800098c2:	df 0f ac 00 	jeq %d15,0,80009a1a <osEE_tc_set_pll_fsource+0x220>
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
800098c6:	0b 13 00 51 	eq %d5,%d3,%d1
800098ca:	0b 8f 50 52 	and.ge.u %d5,%d15,%d8
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
800098ce:	2b f8 40 85 	sel %d8,%d5,%d8,%d15
800098d2:	ab 01 80 15 	sel %d1,%d5,%d1,0
800098d6:	2b eb 40 b5 	sel %d11,%d5,%d11,%d14
800098da:	2b 6d 40 d5 	sel %d13,%d5,%d13,%d6
800098de:	2b 0c 40 c5 	sel %d12,%d5,%d12,%d0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
800098e2:	c2 16       	add %d6,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
800098e4:	8b 16 68 52 	lt.u %d5,%d6,129
800098e8:	8b 0f 20 54 	and.ne %d5,%d15,0
800098ec:	df 05 e4 ff 	jne %d5,0,800098b4 <osEE_tc_set_pll_fsource+0xba>
800098f0:	02 d6       	mov %d6,%d13
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800098f2:	02 6d       	mov %d13,%d6
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
800098f4:	80 4f       	mov.d %d15,%a4
800098f6:	42 f0       	add %d0,%d15
800098f8:	80 56       	mov.d %d6,%a5
800098fa:	42 69       	add %d9,%d6

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
800098fc:	0f 32 a0 50 	or %d5,%d2,%d3
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
80009900:	8b d0 61 f2 	lt.u %d15,%d0,29
80009904:	8b 05 20 f4 	and.ne %d15,%d5,0
80009908:	ee bd       	jnz %d15,80009882 <osEE_tc_set_pll_fsource+0x88>
8000990a:	01 45 20 50 	sub.a %a5,%a5,%a4
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000990e:	c2 fe       	add %d14,-1
    k2Steps = 1;
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
80009910:	0f 32 a0 f0 	or %d15,%d2,%d3
80009914:	8b 0f 20 02 	ne %d0,%d15,0
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
80009918:	8b 0e 20 52 	ne %d5,%d14,0
8000991c:	8b 0f 20 54 	and.ne %d5,%d15,0
80009920:	df 05 9a ff 	jne %d5,0,80009854 <osEE_tc_set_pll_fsource+0x5a>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
80009924:	06 14       	sh %d4,1
80009926:	7b c0 1e f5 	movh %d15,20972
8000992a:	1b ff 51 f8 	addi %d15,%d15,-31457
8000992e:	73 f4 68 40 	mul.u %e4,%d4,%d15
80009932:	8f b5 1f 20 	sh %d2,%d5,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
80009936:	ba 01       	eq %d15,%d1,0
80009938:	0b 28 50 f2 	and.ge.u %d15,%d8,%d2
8000993c:	8b 01 00 f5 	or.ne %d15,%d1,0
80009940:	ee 73       	jnz %d15,80009a26 <osEE_tc_set_pll_fsource+0x22c>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
80009942:	c2 fc       	add %d12,-1
80009944:	91 30 00 ff 	movh.a %a15,61443
80009948:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000994c:	4c f0       	ld.w %d15,[%a15]0
8000994e:	37 cf 07 c0 	insert %d12,%d15,%d12,0,7
80009952:	68 0c       	st.w [%a15]0,%d12

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
80009954:	91 30 00 ff 	movh.a %a15,61443
80009958:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000995c:	4c f0       	ld.w %d15,[%a15]0
8000995e:	6f 5f ff 7f 	jz.t %d15,5,8000995c <osEE_tc_set_pll_fsource+0x162>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
80009962:	91 30 00 ff 	movh.a %a15,61443
80009966:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000996a:	4c f0       	ld.w %d15,[%a15]0
8000996c:	96 01       	or %d15,1
8000996e:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
80009970:	91 30 00 ff 	movh.a %a15,61443
80009974:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009978:	4c f0       	ld.w %d15,[%a15]0
8000997a:	6f 0f ff 7f 	jz.t %d15,0,80009978 <osEE_tc_set_pll_fsource+0x17e>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000997e:	9a fb       	add %d15,%d11,-1
80009980:	91 30 00 ff 	movh.a %a15,61443
80009984:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009988:	16 0f       	and %d15,15
8000998a:	8f 8f 01 f0 	sh %d15,%d15,24
8000998e:	48 02       	ld.w %d2,[%a15]0
80009990:	b7 02 04 2c 	insert %d2,%d2,0,24,4
80009994:	a6 2f       	or %d15,%d2
80009996:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
80009998:	9a fd       	add %d15,%d13,-1
8000999a:	16 7f       	and %d15,127
8000999c:	8f 9f 00 f0 	sh %d15,%d15,9
800099a0:	48 02       	ld.w %d2,[%a15]0
800099a2:	b7 02 87 24 	insert %d2,%d2,0,9,7
800099a6:	a6 2f       	or %d15,%d2
800099a8:	68 0f       	st.w [%a15]0,%d15

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
800099aa:	4c f0       	ld.w %d15,[%a15]0
800099ac:	8f 2f c0 f1 	andn %d15,%d15,2
800099b0:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
800099b2:	4c f0       	ld.w %d15,[%a15]0
800099b4:	96 40       	or %d15,64
800099b6:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
800099b8:	4c f0       	ld.w %d15,[%a15]0
800099ba:	96 20       	or %d15,32
800099bc:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
800099be:	91 30 00 ff 	movh.a %a15,61443
800099c2:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800099c6:	4c f0       	ld.w %d15,[%a15]0
800099c8:	6f 3f ff ff 	jnz.t %d15,3,800099c6 <osEE_tc_set_pll_fsource+0x1cc>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
800099cc:	91 30 00 ff 	movh.a %a15,61443
800099d0:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800099d4:	4c f0       	ld.w %d15,[%a15]0
800099d6:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
800099da:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
800099dc:	91 30 00 ff 	movh.a %a15,61443
800099e0:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800099e4:	4c f0       	ld.w %d15,[%a15]0
800099e6:	6f 2f ff 7f 	jz.t %d15,2,800099e4 <osEE_tc_set_pll_fsource+0x1ea>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
800099ea:	91 30 00 ff 	movh.a %a15,61443
800099ee:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800099f2:	4c f0       	ld.w %d15,[%a15]0
800099f4:	8f 1f c0 f1 	andn %d15,%d15,1
800099f8:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
800099fa:	91 30 00 ff 	movh.a %a15,61443
800099fe:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009a02:	4c f0       	ld.w %d15,[%a15]0
80009a04:	6f 0f ff ff 	jnz.t %d15,0,80009a02 <osEE_tc_set_pll_fsource+0x208>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
80009a08:	91 30 00 ff 	movh.a %a15,61443
80009a0c:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009a10:	4c f0       	ld.w %d15,[%a15]0
80009a12:	8f 0f c4 f1 	andn %d15,%d15,64
80009a16:	68 0f       	st.w [%a15]0,%d15
80009a18:	00 90       	ret 
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
            {
              fPllLeastError = fPllError;
80009a1a:	02 28       	mov %d8,%d2
80009a1c:	02 31       	mov %d1,%d3
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80009a1e:	80 7b       	mov.d %d11,%a7
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80009a20:	02 0c       	mov %d12,%d0
80009a22:	1d ff 68 ff 	j 800098f2 <osEE_tc_set_pll_fsource+0xf8>
80009a26:	00 90       	ret 

80009a28 <osEE_tc_get_fsource>:
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
  }

}

OsEE_reg osEE_tc_get_fsource(void) {
80009a28:	40 ae       	mov.aa %a14,%sp
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80009a2a:	91 30 00 ff 	movh.a %a15,61443
80009a2e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009a32:	4c f0       	ld.w %d15,[%a15]0
80009a34:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
80009a38:	7b 60 5f 20 	movh %d2,1526
80009a3c:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80009a40:	6e 45       	jz %d15,80009aca <osEE_tc_get_fsource+0xa2>
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
80009a42:	91 30 00 ff 	movh.a %a15,61443
80009a46:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009a4a:	4c f0       	ld.w %d15,[%a15]0
80009a4c:	6f 0f 11 00 	jz.t %d15,0,80009a6e <osEE_tc_get_fsource+0x46>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
80009a50:	91 30 00 ff 	movh.a %a15,61443
80009a54:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009a58:	48 02       	ld.w %d2,[%a15]0
80009a5a:	37 02 67 28 	extr.u %d2,%d2,16,7
80009a5e:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
80009a60:	7b 10 13 f0 	movh %d15,305
80009a64:	1b 0f d0 f2 	addi %d15,%d15,11520
80009a68:	4b 2f 11 22 	div.u %e2,%d15,%d2
80009a6c:	00 90       	ret 
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
80009a6e:	4c f0       	ld.w %d15,[%a15]0
80009a70:	6f 3f 11 00 	jz.t %d15,3,80009a92 <osEE_tc_get_fsource+0x6a>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009a74:	91 30 00 ff 	movh.a %a15,61443
80009a78:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009a7c:	48 02       	ld.w %d2,[%a15]0
80009a7e:	8f f2 07 21 	and %d2,%d2,127
80009a82:	9a 12       	add %d15,%d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
80009a84:	7b 10 13 20 	movh %d2,305
80009a88:	1b 02 d0 22 	addi %d2,%d2,11520
80009a8c:	4b f2 11 22 	div.u %e2,%d2,%d15
80009a90:	00 90       	ret 
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009a92:	91 30 00 ff 	movh.a %a15,61443
80009a96:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009a9a:	4c f0       	ld.w %d15,[%a15]0
80009a9c:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
80009aa0:	91 30 00 ff 	movh.a %a15,61443
80009aa4:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009aa8:	4c f0       	ld.w %d15,[%a15]0
80009aaa:	37 0f 64 3c 	extr.u %d3,%d15,24,4
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
80009aae:	48 02       	ld.w %d2,[%a15]0
80009ab0:	37 02 e7 44 	extr.u %d4,%d2,9,7
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009ab4:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
80009ab6:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80009aba:	7b 10 13 20 	movh %d2,305
80009abe:	1b 02 d0 22 	addi %d2,%d2,11520
80009ac2:	4b f2 11 22 	div.u %e2,%d2,%d15
80009ac6:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
80009aca:	00 90       	ret 

80009acc <osEE_tc_stm_set_clockpersec>:
  return ticks;
}

/* Set inside std time reference  */
void osEE_tc_stm_set_clockpersec(void)
{
80009acc:	40 ae       	mov.aa %a14,%sp
#if (defined(__TASKING__))
  /* I don't know where is declared */
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
80009ace:	6d ff ad ff 	call 80009a28 <osEE_tc_get_fsource>
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
80009ad2:	91 30 00 ff 	movh.a %a15,61443
80009ad6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009ada:	4c f0       	ld.w %d15,[%a15]0
80009adc:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80009ae0:	c2 12       	add %d2,1
80009ae2:	4b f2 11 22 	div.u %e2,%d2,%d15

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
80009ae6:	7b 20 06 f1 	movh %d15,4194
80009aea:	1b 3f dd f4 	addi %d15,%d15,19923
80009aee:	73 f2 68 20 	mul.u %e2,%d2,%d15
80009af2:	8f a3 1f f0 	sh %d15,%d3,-6
80009af6:	91 00 00 f7 	movh.a %a15,28672
80009afa:	59 ff c8 c0 	st.w [%a15]3848 <70000f08 <osEE_tc_stm_freq_khz>>,%d15
80009afe:	00 90       	ret 

80009b00 <osEE_tc_stm_set_sr0>:
    that qualifier on pointers.
 */

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0(OsEE_reg usec,
    OsEE_tc_isr_hw_prio intvec)
{
80009b00:	40 ae       	mov.aa %a14,%sp
80009b02:	02 59       	mov %d9,%d5
80009b04:	4d c0 e1 8f 	mfcr %d8,$core_id
    5U;
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80009b08:	6d ff 4f fe 	call 800097a6 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
80009b0c:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
80009b10:	8f 38 00 f1 	and %d15,%d8,3
80009b14:	9b 0f 0f 40 	addih %d4,%d15,240
80009b18:	8f 84 00 40 	sh %d4,%d4,8
80009b1c:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
80009b1e:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80009b20:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
80009b22:	68 c2       	st.w [%a15]48,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80009b24:	df 09 23 00 	jeq %d9,0,80009b6a <osEE_tc_stm_set_sr0+0x6a>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
80009b28:	48 e2       	ld.w %d2,[%a15]56
80009b2a:	b7 02 05 24 	insert %d2,%d2,0,8,5
80009b2e:	68 e2       	st.w [%a15]56,%d2
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80009b30:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
80009b34:	48 e2       	ld.w %d2,[%a15]56
80009b36:	37 32 05 30 	insert %d3,%d2,%d3,0,5
80009b3a:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
80009b3c:	48 f2       	ld.w %d2,[%a15]60
80009b3e:	8f 42 c0 21 	andn %d2,%d2,4
80009b42:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
80009b44:	48 f2       	ld.w %d2,[%a15]60
80009b46:	8f 12 40 21 	or %d2,%d2,1
80009b4a:	68 f2       	st.w [%a15]60,%d2

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
80009b4c:	06 3f       	sh %d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009b4e:	60 f2       	mov.a %a2,%d15
80009b50:	d9 2f 50 28 	lea %a15,[%a2]-31600
80009b54:	11 4f 00 ff 	addih.a %a15,%a15,61444
80009b58:	b7 89 99 93 	insert %d9,%d9,8,7,25
80009b5c:	8f 38 00 81 	and %d8,%d8,3
80009b60:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80009b64:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009b66:	68 09       	st.w [%a15]0,%d9
80009b68:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en                 = 0U;
80009b6a:	48 f2       	ld.w %d2,[%a15]60
80009b6c:	8f 12 c0 21 	andn %d2,%d2,1
80009b70:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
80009b72:	1b 2f 09 f7 	addi %d15,%d15,28818
80009b76:	9b 0f e0 f1 	addih %d15,%d15,7680
80009b7a:	06 3f       	sh %d15,3
80009b7c:	82 02       	mov %d2,0
80009b7e:	60 ff       	mov.a %a15,%d15
80009b80:	68 02       	st.w [%a15]0,%d2
80009b82:	00 90       	ret 

80009b84 <osEE_tc_stm_set_sr0_next_match>:
  }
}

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0_next_match(OsEE_reg usec)
{
80009b84:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009b86:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
80009b8a:	6d ff 0e fe 	call 800097a6 <osEE_tc_stm_us_ticks>
80009b8e:	16 03       	and %d15,3
80009b90:	9b 0f 0f f0 	addih %d15,%d15,240
80009b94:	8f 8f 00 f0 	sh %d15,%d15,8
80009b98:	60 ff       	mov.a %a15,%d15
80009b9a:	4c fc       	ld.w %d15,[%a15]48
80009b9c:	42 f2       	add %d2,%d15
80009b9e:	68 c2       	st.w [%a15]48,%d2
80009ba0:	00 90       	ret 

80009ba2 <osEE_tc_stm_set_sr1>:
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1(OsEE_reg usec,
  OsEE_tc_isr_hw_prio intvec)
{
80009ba2:	40 ae       	mov.aa %a14,%sp
80009ba4:	02 59       	mov %d9,%d5
80009ba6:	4d c0 e1 8f 	mfcr %d8,$core_id
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80009baa:	6d ff fe fd 	call 800097a6 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
80009bae:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009bb2:	8f 38 00 f1 	and %d15,%d8,3
80009bb6:	9b 0f 0f 40 	addih %d4,%d15,240
80009bba:	8f 84 00 40 	sh %d4,%d4,8
80009bbe:	60 4f       	mov.a %a15,%d4
80009bc0:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80009bc2:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009bc4:	68 d2       	st.w [%a15]52,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80009bc6:	df 09 28 00 	jeq %d9,0,80009c16 <osEE_tc_stm_set_sr1+0x74>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
80009bca:	48 e2       	ld.w %d2,[%a15]56
80009bcc:	b7 02 05 2c 	insert %d2,%d2,0,24,5
80009bd0:	68 e2       	st.w [%a15]56,%d2
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80009bd2:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
80009bd6:	8f f3 01 31 	and %d3,%d3,31
80009bda:	8f 03 01 30 	sh %d3,%d3,16
80009bde:	48 e2       	ld.w %d2,[%a15]56
80009be0:	b7 02 05 28 	insert %d2,%d2,0,16,5
80009be4:	a6 23       	or %d3,%d2
80009be6:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
80009be8:	48 f2       	ld.w %d2,[%a15]60
80009bea:	8f 02 44 21 	or %d2,%d2,64
80009bee:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
80009bf0:	48 f2       	ld.w %d2,[%a15]60
80009bf2:	8f 02 41 21 	or %d2,%d2,16
80009bf6:	68 f2       	st.w [%a15]60,%d2
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
80009bf8:	06 3f       	sh %d15,3
80009bfa:	60 f2       	mov.a %a2,%d15
80009bfc:	d9 2f 54 28 	lea %a15,[%a2]-31596
80009c00:	11 4f 00 ff 	addih.a %a15,%a15,61444
80009c04:	b7 89 99 93 	insert %d9,%d9,8,7,25
80009c08:	8f 38 00 81 	and %d8,%d8,3
80009c0c:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80009c10:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009c12:	68 09       	st.w [%a15]0,%d9
80009c14:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
80009c16:	48 f2       	ld.w %d2,[%a15]60
80009c18:	8f 02 c1 21 	andn %d2,%d2,16
80009c1c:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
80009c1e:	06 3f       	sh %d15,3
80009c20:	60 f2       	mov.a %a2,%d15
80009c22:	d9 2f 54 28 	lea %a15,[%a2]-31596
80009c26:	11 4f 00 ff 	addih.a %a15,%a15,61444
80009c2a:	82 0f       	mov %d15,0
80009c2c:	68 0f       	st.w [%a15]0,%d15
80009c2e:	00 90       	ret 

80009c30 <osEE_tc_stm_set_sr1_next_match>:
  }
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1_next_match(OsEE_reg usec)
{
80009c30:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009c32:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
80009c36:	6d ff b8 fd 	call 800097a6 <osEE_tc_stm_us_ticks>
80009c3a:	16 03       	and %d15,3
80009c3c:	9b 0f 0f f0 	addih %d15,%d15,240
80009c40:	8f 8f 00 f0 	sh %d15,%d15,8
80009c44:	60 ff       	mov.a %a15,%d15
80009c46:	4c fd       	ld.w %d15,[%a15]52
80009c48:	42 f2       	add %d2,%d15
80009c4a:	68 d2       	st.w [%a15]52,%d2
80009c4c:	00 90       	ret 

80009c4e <osEE_tc_delay>:
}

void osEE_tc_delay(OsEE_reg usec)
{
80009c4e:	40 ae       	mov.aa %a14,%sp
80009c50:	4d c0 e1 ff 	mfcr %d15,$core_id
80009c54:	16 03       	and %d15,3
80009c56:	9b 0f 0f f0 	addih %d15,%d15,240
80009c5a:	8f 8f 00 f0 	sh %d15,%d15,8
80009c5e:	60 f2       	mov.a %a2,%d15
80009c60:	d9 2f 10 00 	lea %a15,[%a2]16
80009c64:	19 28 10 00 	ld.w %d8,[%a2]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);
80009c68:	6d ff 9f fd 	call 800097a6 <osEE_tc_stm_us_ticks>
80009c6c:	4c f0       	ld.w %d15,[%a15]0

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
80009c6e:	a2 8f       	sub %d15,%d8
80009c70:	3f 2f fe ff 	jlt.u %d15,%d2,80009c6c <osEE_tc_delay+0x1e>
    ; /* Wait */
  }
}
80009c74:	00 90       	ret 

80009c76 <osEE_tc_isr2_wrapper>:

#if (defined(__GNUC__))
#pragma section
#endif /* __GNUC__ */

static void OSEE_COMPILER_KEEP osEE_tc_isr2_wrapper(TaskType isr2_tid) {
80009c76:	40 ae       	mov.aa %a14,%sp
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
80009c78:	6d 00 86 05 	call 8000a784 <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
80009c7c:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
80009c80:	00 80       	rfe 
80009c82:	00 90       	ret 

80009c84 <osEE_shutdown_os>:
  osEE_shutdown_os
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
80009c84:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009c86:	cc 40       	ld.a %a15,[%a4]0
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80009c88:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
80009c8c:	82 32       	mov %d2,3
80009c8e:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
80009c92:	e9 f4 12 00 	st.b [%a15]18,%d4

  if (os_status == OSEE_KERNEL_STARTED) {
80009c96:	5e 25       	jne %d15,2,80009ca0 <osEE_shutdown_os+0x1c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
80009c98:	99 44 04 00 	ld.a %a4,[%a4]4
80009c9c:	6d 00 89 06 	call 8000a9ae <osEE_idle_task_terminate>
  } else {
    osEE_call_shutdown_hook(p_ccb, Error);
  }
  for (;;) {
    ; /* Endless Loop (entered only if Kernel Not Started) */
  }
80009ca0:	3c 00       	j 80009ca0 <osEE_shutdown_os+0x1c>

80009ca2 <DisableAllInterrupts>:
FUNC(void, OS_CODE)
  DisableAllInterrupts
(
  void
)
{
80009ca2:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009ca4:	91 00 00 f8 	movh.a %a15,32768
80009ca8:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009cac:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
80009cb0:	82 1f       	mov %d15,1
80009cb2:	e9 ff 1e 00 	st.b [%a15]30,%d15
80009cb6:	00 90       	ret 

80009cb8 <EnableAllInterrupts>:
FUNC(void, OS_CODE)
  EnableAllInterrupts
(
  void
)
{
80009cb8:	40 ae       	mov.aa %a14,%sp
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009cba:	91 00 00 f8 	movh.a %a15,32768
80009cbe:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
80009cc2:	39 ff 1e 00 	ld.bu %d15,[%a15]30 <800000ac <osEE_cdb_var>>
80009cc6:	6e 06       	jz %d15,80009cd2 <EnableAllInterrupts+0x1a>
    p_ccb->d_isr_all_cnt = 0U;
80009cc8:	82 0f       	mov %d15,0
80009cca:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009cce:	0d 00 00 03 	enable 
80009cd2:	00 90       	ret 

80009cd4 <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
80009cd4:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009cd6:	91 00 00 f8 	movh.a %a15,32768
80009cda:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
80009cde:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000ac <osEE_cdb_var>>
80009ce2:	ee 0c       	jnz %d15,80009cfa <SuspendAllInterrupts+0x26>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009ce4:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009ce8:	0d 00 40 03 	disable 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
80009cec:	68 5f       	st.w [%a15]20,%d15
    ++p_ccb->s_isr_all_cnt;
80009cee:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80009cf2:	c2 1f       	add %d15,1
80009cf4:	e9 ff 1c 00 	st.b [%a15]28,%d15
80009cf8:	00 90       	ret 
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
80009cfa:	8b ff 0f 22 	eq %d2,%d15,255
80009cfe:	f6 25       	jnz %d2,80009d08 <SuspendAllInterrupts+0x34>
    ++p_ccb->s_isr_all_cnt;
80009d00:	c2 1f       	add %d15,1
80009d02:	e9 ff 1c 00 	st.b [%a15]28,%d15
80009d06:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
80009d08:	91 00 00 48 	movh.a %a4,32768
80009d0c:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
80009d10:	3b 90 01 40 	mov %d4,25
80009d14:	3c b8       	j 80009c84 <osEE_shutdown_os>

80009d16 <ResumeAllInterrupts>:
FUNC(void, OS_CODE)
  ResumeAllInterrupts
(
  void
)
{
80009d16:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009d18:	91 00 00 f8 	movh.a %a15,32768
80009d1c:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
80009d20:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000ac <osEE_cdb_var>>
80009d24:	6e 0b       	jz %d15,80009d3a <ResumeAllInterrupts+0x24>
    --p_ccb->s_isr_all_cnt;
80009d26:	c2 ff       	add %d15,-1
80009d28:	16 ff       	and %d15,255
80009d2a:	e9 ff 1c 00 	st.b [%a15]28,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
80009d2e:	ee 06       	jnz %d15,80009d3a <ResumeAllInterrupts+0x24>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009d30:	4c f5       	ld.w %d15,[%a15]20
80009d32:	cd cf e2 0f 	mtcr $icr,%d15
80009d36:	0d 00 c0 04 	isync 
80009d3a:	00 90       	ret 

80009d3c <SuspendOSInterrupts>:
FUNC(void, OS_CODE)
  SuspendOSInterrupts
(
  void
)
{
80009d3c:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009d3e:	91 00 00 f8 	movh.a %a15,32768
80009d42:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
80009d46:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000ac <osEE_cdb_var>>
80009d4a:	ee 18       	jnz %d15,80009d7a <SuspendOSInterrupts+0x3e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009d4c:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009d50:	8f f2 0f f1 	and %d15,%d2,255
80009d54:	8b 1f a1 f2 	ge.u %d15,%d15,17
80009d58:	ee 0a       	jnz %d15,80009d6c <SuspendOSInterrupts+0x30>
    OsEE_icr icr_temp = icr;
80009d5a:	02 2f       	mov %d15,%d2
80009d5c:	3b 10 01 30 	mov %d3,17
80009d60:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009d64:	cd cf e2 0f 	mtcr $icr,%d15
80009d68:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
80009d6c:	68 62       	st.w [%a15]24,%d2
    ++p_ccb->s_isr_os_cnt;
80009d6e:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80009d72:	c2 1f       	add %d15,1
80009d74:	e9 ff 1d 00 	st.b [%a15]29,%d15
80009d78:	00 90       	ret 
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
80009d7a:	8b ff 0f 22 	eq %d2,%d15,255
80009d7e:	f6 25       	jnz %d2,80009d88 <SuspendOSInterrupts+0x4c>
    ++p_ccb->s_isr_os_cnt;
80009d80:	c2 1f       	add %d15,1
80009d82:	e9 ff 1d 00 	st.b [%a15]29,%d15
80009d86:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
80009d88:	91 00 00 48 	movh.a %a4,32768
80009d8c:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
80009d90:	3b 90 01 40 	mov %d4,25
80009d94:	1d ff 78 ff 	j 80009c84 <osEE_shutdown_os>

80009d98 <ResumeOSInterrupts>:
FUNC(void, OS_CODE)
  ResumeOSInterrupts
(
  void
)
{
80009d98:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009d9a:	91 00 00 f8 	movh.a %a15,32768
80009d9e:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
80009da2:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000ac <osEE_cdb_var>>
80009da6:	6e 16       	jz %d15,80009dd2 <ResumeOSInterrupts+0x3a>
    --p_ccb->s_isr_os_cnt;
80009da8:	c2 ff       	add %d15,-1
80009daa:	16 ff       	and %d15,255
80009dac:	e9 ff 1d 00 	st.b [%a15]29,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
80009db0:	ee 11       	jnz %d15,80009dd2 <ResumeOSInterrupts+0x3a>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
80009db2:	48 62       	ld.w %d2,[%a15]24
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009db4:	4d c0 e2 3f 	mfcr %d3,$icr
80009db8:	02 3f       	mov %d15,%d3
80009dba:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009dbe:	8f f2 0f 21 	and %d2,%d2,255
80009dc2:	5f 23 08 00 	jeq %d3,%d2,80009dd2 <ResumeOSInterrupts+0x3a>
80009dc6:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009dca:	cd cf e2 0f 	mtcr $icr,%d15
80009dce:	0d 00 c0 04 	isync 
80009dd2:	00 90       	ret 

80009dd4 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
80009dd4:	40 ae       	mov.aa %a14,%sp
80009dd6:	02 49       	mov %d9,%d4
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009dd8:	91 00 00 f8 	movh.a %a15,32768
80009ddc:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009de0:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009de4:	8f f8 0f f1 	and %d15,%d8,255
80009de8:	8b 1f a1 f2 	ge.u %d15,%d15,17
80009dec:	ee 0a       	jnz %d15,80009e00 <StartOS+0x2c>
    OsEE_icr icr_temp = icr;
80009dee:	02 8f       	mov %d15,%d8
80009df0:	3b 10 01 20 	mov %d2,17
80009df4:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009df8:	cd cf e2 0f 	mtcr $icr,%d15
80009dfc:	0d 00 c0 04 	isync 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
80009e00:	39 ff 10 00 	ld.bu %d15,[%a15]16
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
80009e04:	82 15       	mov %d5,1
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
80009e06:	ee 21       	jnz %d15,80009e48 <StartOS+0x74>
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
80009e08:	6d 00 e6 05 	call 8000a9d4 <osEE_cpu_startos>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
80009e0c:	3b 80 01 50 	mov %d5,24
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
80009e10:	df 02 1c 00 	jeq %d2,0,80009e48 <StartOS+0x74>
80009e14:	3c 24       	j 80009e5c <StartOS+0x88>
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
      p_ccb->os_status = OSEE_KERNEL_STARTED;
80009e16:	82 2f       	mov %d15,2
80009e18:	e9 ff 10 00 	st.b [%a15]16,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
80009e1c:	39 ff 10 00 	ld.bu %d15,[%a15]16
80009e20:	5e 2a       	jne %d15,2,80009e34 <StartOS+0x60>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
80009e22:	40 c4       	mov.aa %a4,%a12
80009e24:	99 c5 04 00 	ld.a %a5,[%a12]4
80009e28:	40 56       	mov.aa %a6,%a5
80009e2a:	6d 00 3a 06 	call 8000aa9e <osEE_hal_save_ctx_and_ready2stacked>
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
80009e2e:	40 c4       	mov.aa %a4,%a12
80009e30:	6d 00 8a 04 	call 8000a744 <osEE_task_end>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009e34:	0d 00 40 03 	disable 
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
80009e38:	3c 00       	j 80009e38 <StartOS+0x64>
80009e3a:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009e3e:	cd cf e2 0f 	mtcr $icr,%d15
80009e42:	0d 00 c0 04 	isync 
80009e46:	3c 1b       	j 80009e7c <StartOS+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009e48:	4d c0 e2 4f 	mfcr %d4,$icr
80009e4c:	02 4f       	mov %d15,%d4
80009e4e:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009e52:	8f f8 0f 31 	and %d3,%d8,255
80009e56:	5f 34 f2 ff 	jne %d4,%d3,80009e3a <StartOS+0x66>
80009e5a:	3c 11       	j 80009e7c <StartOS+0xa8>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
80009e5c:	91 00 00 28 	movh.a %a2,32768
80009e60:	d9 22 2c 20 	lea %a2,[%a2]172 <800000ac <osEE_cdb_var>>
80009e64:	99 2c 04 00 	ld.a %a12,[%a2]4 <80000004 <BootModeHeader0+0x4>>
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80009e68:	82 1f       	mov %d15,1
80009e6a:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
80009e6e:	e9 f9 11 00 	st.b [%a15]17,%d9
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
80009e72:	39 ff 10 00 	ld.bu %d15,[%a15]16
80009e76:	df 1f d3 ff 	jne %d15,1,80009e1c <StartOS+0x48>
80009e7a:	3c ce       	j 80009e16 <StartOS+0x42>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
80009e7c:	02 52       	mov %d2,%d5
80009e7e:	00 90       	ret 

80009e80 <GetActiveApplicationMode>:
FUNC(AppModeType, OS_CODE)
  GetActiveApplicationMode
(
  void
)
{
80009e80:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
80009e82:	91 00 00 f8 	movh.a %a15,32768
80009e86:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80009e8a:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000ac <osEE_cdb_var>>
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
80009e8e:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80009e92:	6e 03       	jz %d15,80009e98 <GetActiveApplicationMode+0x18>
    app_mode = p_ccb->app_mode;
80009e94:	39 f2 11 00 	ld.bu %d2,[%a15]17
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
80009e98:	00 90       	ret 

80009e9a <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80009e9a:	40 ae       	mov.aa %a14,%sp
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80009e9c:	91 00 00 f8 	movh.a %a15,32768
80009ea0:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
80009ea4:	4c f2       	ld.w %d15,[%a15]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009ea6:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009ea8:	7f f4 39 80 	jge.u %d4,%d15,80009f1a <ActivateTask+0x80>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009eac:	91 00 00 f8 	movh.a %a15,32768
80009eb0:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
80009eb4:	c8 1f       	ld.a %a15,[%a15]4
80009eb6:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009eba:	c8 0f       	ld.a %a15,[%a15]0

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009ebc:	39 ff 14 00 	ld.bu %d15,[%a15]20
80009ec0:	ff 2f 2d 80 	jge.u %d15,2,80009f1a <ActivateTask+0x80>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009ec4:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009ec8:	8f f9 0f f1 	and %d15,%d9,255
80009ecc:	8b 1f a1 f2 	ge.u %d15,%d15,17
80009ed0:	ee 0a       	jnz %d15,80009ee4 <ActivateTask+0x4a>
    OsEE_icr icr_temp = icr;
80009ed2:	02 9f       	mov %d15,%d9
80009ed4:	3b 10 01 20 	mov %d2,17
80009ed8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009edc:	cd cf e2 0f 	mtcr $icr,%d15
80009ee0:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
80009ee4:	40 f4       	mov.aa %a4,%a15
80009ee6:	6d 00 23 04 	call 8000a72c <osEE_task_activated>
80009eea:	02 28       	mov %d8,%d2

      if (ev == E_OK) {
80009eec:	f6 28       	jnz %d2,80009efc <ActivateTask+0x62>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
80009eee:	91 00 00 48 	movh.a %a4,32768
80009ef2:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
80009ef6:	40 f5       	mov.aa %a5,%a15
80009ef8:	6d 00 57 04 	call 8000a7a6 <osEE_scheduler_task_activated>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009efc:	4d c0 e2 3f 	mfcr %d3,$icr
80009f00:	02 3f       	mov %d15,%d3
80009f02:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009f06:	8f f9 0f 21 	and %d2,%d9,255
80009f0a:	5f 23 08 00 	jeq %d3,%d2,80009f1a <ActivateTask+0x80>
80009f0e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009f12:	cd cf e2 0f 	mtcr $icr,%d15
80009f16:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009f1a:	02 82       	mov %d2,%d8
80009f1c:	00 90       	ret 

80009f1e <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80009f1e:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
80009f20:	91 00 00 f8 	movh.a %a15,32768
80009f24:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
80009f28:	48 03       	ld.w %d3,[%a15]0
80009f2a:	91 00 00 28 	movh.a %a2,32768
80009f2e:	d9 22 18 20 	lea %a2,[%a2]152 <80000098 <osEE_kdb_var>>
80009f32:	4c 22       	ld.w %d15,[%a2]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009f34:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009f36:	7f f4 5e 80 	jge.u %d4,%d15,80009ff2 <ChainTask+0xd4>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009f3a:	91 00 00 28 	movh.a %a2,32768
80009f3e:	d9 22 18 20 	lea %a2,[%a2]152 <80000098 <osEE_kdb_var>>
80009f42:	99 22 04 00 	ld.a %a2,[%a2]4 <80000004 <BootModeHeader0+0x4>>
80009f46:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80009f4a:	d4 2c       	ld.a %a12,[%a2]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009f4c:	39 cf 14 00 	ld.bu %d15,[%a12]20
80009f50:	ff 2f 51 80 	jge.u %d15,2,80009ff2 <ChainTask+0xd4>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80009f54:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80009f58:	6e 09       	jz %d15,80009f6a <ChainTask+0x4c>
        p_ccb->s_isr_all_cnt = 0U;
80009f5a:	82 0f       	mov %d15,0
80009f5c:	e9 ff 1c 00 	st.b [%a15]28,%d15
80009f60:	4c f5       	ld.w %d15,[%a15]20
80009f62:	cd cf e2 0f 	mtcr $icr,%d15
80009f66:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
80009f6a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
80009f6e:	6e 06       	jz %d15,80009f7a <ChainTask+0x5c>
        p_ccb->d_isr_all_cnt = 0U;
80009f70:	82 0f       	mov %d15,0
80009f72:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009f76:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009f7a:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009f7e:	8f f8 0f f1 	and %d15,%d8,255
80009f82:	8b 1f a1 f2 	ge.u %d15,%d15,17
80009f86:	ee 0a       	jnz %d15,80009f9a <ChainTask+0x7c>
    OsEE_icr icr_temp = icr;
80009f88:	02 8f       	mov %d15,%d8
80009f8a:	3b 10 01 20 	mov %d2,17
80009f8e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009f92:	cd cf e2 0f 	mtcr $icr,%d15
80009f96:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
80009f9a:	80 cf       	mov.d %d15,%a12
80009f9c:	7e 35       	jne %d15,%d3,80009fa6 <ChainTask+0x88>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
80009f9e:	cc c3       	ld.a %a15,[%a12]12
80009fa0:	82 5f       	mov %d15,5
80009fa2:	28 2f       	st.b [%a15]2,%d15
80009fa4:	3c 15       	j 80009fce <ChainTask+0xb0>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
80009fa6:	40 c4       	mov.aa %a4,%a12
80009fa8:	6d 00 c2 03 	call 8000a72c <osEE_task_activated>
        if (ev == E_OK) {
80009fac:	df 02 1a 80 	jne %d2,0,80009fe0 <ChainTask+0xc2>
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
80009fb0:	91 00 00 48 	movh.a %a4,32768
80009fb4:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
80009fb8:	40 c5       	mov.aa %a5,%a12
80009fba:	6d 00 2a 04 	call 8000a80e <osEE_scheduler_task_insert>
80009fbe:	3c 08       	j 80009fce <ChainTask+0xb0>
80009fc0:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
80009fc4:	cd cf e2 0f 	mtcr $icr,%d15
80009fc8:	0d 00 c0 04 	isync 
80009fcc:	00 90       	ret 
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80009fce:	91 00 00 f8 	movh.a %a15,32768
80009fd2:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
80009fd6:	c8 0f       	ld.a %a15,[%a15]0
80009fd8:	c8 14       	ld.a %a4,[%a15]4
80009fda:	a0 05       	mov.a %a5,0
80009fdc:	1d 00 98 05 	j 8000ab0c <osEE_hal_terminate_ctx>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009fe0:	4d c0 e2 3f 	mfcr %d3,$icr
80009fe4:	02 3f       	mov %d15,%d3
80009fe6:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009fea:	8f f8 0f 81 	and %d8,%d8,255
80009fee:	5f 83 e9 ff 	jne %d3,%d8,80009fc0 <ChainTask+0xa2>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
80009ff2:	00 90       	ret 

80009ff4 <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
80009ff4:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
80009ff6:	91 00 00 f8 	movh.a %a15,32768
80009ffa:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009ffe:	c8 02       	ld.a %a2,[%a15]0
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
8000a000:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000ac <osEE_cdb_var>>
8000a004:	6e 09       	jz %d15,8000a016 <TerminateTask+0x22>
        p_ccb->s_isr_all_cnt = 0U;
8000a006:	82 0f       	mov %d15,0
8000a008:	e9 ff 1c 00 	st.b [%a15]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a00c:	4c f5       	ld.w %d15,[%a15]20
8000a00e:	cd cf e2 0f 	mtcr $icr,%d15
8000a012:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000a016:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000a01a:	6e 06       	jz %d15,8000a026 <TerminateTask+0x32>
        p_ccb->d_isr_all_cnt = 0U;
8000a01c:	82 0f       	mov %d15,0
8000a01e:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000a022:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a026:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a02a:	8f ff 0f 21 	and %d2,%d15,255
8000a02e:	8b 12 a1 22 	ge.u %d2,%d2,17
8000a032:	f6 29       	jnz %d2,8000a044 <TerminateTask+0x50>
8000a034:	3b 10 01 20 	mov %d2,17
8000a038:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a03c:	cd cf e2 0f 	mtcr $icr,%d15
8000a040:	0d 00 c0 04 	isync 
8000a044:	99 24 04 00 	ld.a %a4,[%a2]4
8000a048:	a0 05       	mov.a %a5,0
8000a04a:	1d 00 61 05 	j 8000ab0c <osEE_hal_terminate_ctx>

8000a04e <Schedule>:
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
8000a04e:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
8000a050:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
8000a054:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
8000a058:	c8 0f       	ld.a %a15,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
8000a05a:	c8 3c       	ld.a %a12,[%a15]12
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
8000a05c:	39 c2 01 00 	ld.bu %d2,[%a12]1 <800000ac <osEE_cdb_var>>
8000a060:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000ac <osEE_cdb_var>>
8000a064:	5f f2 2d 80 	jne %d2,%d15,8000a0be <Schedule+0x70>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a068:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a06c:	8f f8 0f f1 	and %d15,%d8,255
8000a070:	8b 1f a1 f2 	ge.u %d15,%d15,17
8000a074:	ee 0a       	jnz %d15,8000a088 <Schedule+0x3a>
    OsEE_icr icr_temp = icr;
8000a076:	02 8f       	mov %d15,%d8
8000a078:	3b 10 01 20 	mov %d2,17
8000a07c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a080:	cd cf e2 0f 	mtcr $icr,%d15
8000a084:	0d 00 c0 04 	isync 
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
8000a088:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000a08c:	2c c1       	st.b [%a12]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
8000a08e:	91 00 00 48 	movh.a %a4,32768
8000a092:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
8000a096:	6d 00 36 04 	call 8000a902 <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
8000a09a:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000a09e:	2c c1       	st.b [%a12]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a0a0:	4d c0 e2 3f 	mfcr %d3,$icr
8000a0a4:	02 3f       	mov %d15,%d3
8000a0a6:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a0aa:	8f f8 0f 21 	and %d2,%d8,255
8000a0ae:	5f 23 08 00 	jeq %d3,%d2,8000a0be <Schedule+0x70>
8000a0b2:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a0b6:	cd cf e2 0f 	mtcr $icr,%d15
8000a0ba:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000a0be:	82 02       	mov %d2,0
8000a0c0:	00 90       	ret 

8000a0c2 <GetResource>:
FUNC(StatusType, OS_CODE)
  GetResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
8000a0c2:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a0c4:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000a0c8:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
8000a0cc:	c8 04       	ld.a %a4,[%a15]0
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (res_id < p_kdb->p_kcb->free_res_index);
#else
  return (res_id < p_kdb->res_array_size);
8000a0ce:	91 00 00 f8 	movh.a %a15,32768
8000a0d2:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a0d6:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
8000a0d8:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000a0da:	7f f4 4c 80 	jge.u %d4,%d15,8000a172 <GetResource+0xb0>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
8000a0de:	91 00 00 f8 	movh.a %a15,32768
8000a0e2:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a0e6:	c8 3f       	ld.a %a15,[%a15]12
8000a0e8:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000a0ec:	c8 03       	ld.a %a3,[%a15]0
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
8000a0ee:	d4 32       	ld.a %a2,[%a3]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
8000a0f0:	cc 43       	ld.a %a15,[%a4]12
    CONST(TaskPrio, AUTOMATIC)
      reso_prio     = p_reso_db->prio;
8000a0f2:	0c 34       	ld.bu %d15,[%a3]4
    CONST(TaskPrio, AUTOMATIC)
      current_prio  = p_curr_tcb->current_prio;
8000a0f4:	08 14       	ld.bu %d4,[%a15]1
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a0f6:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a0fa:	8f f2 0f 31 	and %d3,%d2,255
8000a0fe:	8b 13 a1 32 	ge.u %d3,%d3,17
8000a102:	f6 3a       	jnz %d3,8000a116 <GetResource+0x54>
    OsEE_icr icr_temp = icr;
8000a104:	02 23       	mov %d3,%d2
8000a106:	3b 10 01 50 	mov %d5,17
8000a10a:	37 53 08 30 	insert %d3,%d3,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a10e:	cd c3 e2 0f 	mtcr $icr,%d3
8000a112:	0d 00 c0 04 	isync 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
8000a116:	02 23       	mov %d3,%d2
      ev = E_OS_CORE;
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
8000a118:	7f f4 16 80 	jge.u %d4,%d15,8000a144 <GetResource+0x82>
        p_curr_tcb->current_prio = reso_prio;
8000a11c:	28 1f       	st.b [%a15]1,%d15

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000a11e:	37 0f 48 50 	extr %d5,%d15,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000a122:	8b ff 2f 72 	ne %d7,%d15,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000a126:	16 7f       	and %d15,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000a128:	c2 1f       	add %d15,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000a12a:	8f 02 d0 61 	andn %d6,%d2,256
8000a12e:	8f f2 cf 31 	andn %d3,%d2,255
8000a132:	a6 f3       	or %d3,%d15
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000a134:	8f f2 cf 21 	andn %d2,%d2,255
8000a138:	2b 63 40 37 	sel %d3,%d7,%d3,%d6
8000a13c:	8b 05 40 52 	lt %d5,%d5,0
8000a140:	2b 23 40 35 	sel %d3,%d5,%d3,%d2
        flags = osEE_hal_prepare_ipl(flags, reso_prio);
      }

      p_reso_cb->p_owner    = p_curr;
8000a144:	b5 24 08 00 	st.a [%a2]8,%a4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a148:	4d c0 e2 5f 	mfcr %d5,$icr
8000a14c:	02 5f       	mov %d15,%d5
8000a14e:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a152:	8f f3 0f 21 	and %d2,%d3,255
8000a156:	5f 25 08 00 	jeq %d5,%d2,8000a166 <GetResource+0xa4>
8000a15a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a15e:	cd cf e2 0f 	mtcr $icr,%d15
8000a162:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
8000a166:	4c f1       	ld.w %d15,[%a15]4
8000a168:	6c 20       	st.w [%a2]0,%d15
      p_reso_cb->prev_prio  = current_prio;
8000a16a:	e9 24 04 00 	st.b [%a2]4,%d4
      p_curr_tcb->p_last_m  = p_reso_db;
8000a16e:	e8 13       	st.a [%a15]4,%a3

      ev = E_OK;
8000a170:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
8000a172:	00 90       	ret 

8000a174 <ReleaseResource>:
FUNC(StatusType, OS_CODE)
  ReleaseResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
8000a174:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a176:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_curr = p_ccb->p_curr;
8000a17a:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
8000a17e:	c8 03       	ld.a %a3,[%a15]0
8000a180:	91 00 00 f8 	movh.a %a15,32768
8000a184:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a188:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
8000a18a:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000a18c:	7f f4 69 80 	jge.u %d4,%d15,8000a25e <ReleaseResource+0xea>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
8000a190:	cc 33       	ld.a %a15,[%a3]12
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
8000a192:	91 00 00 28 	movh.a %a2,32768
8000a196:	d9 22 18 20 	lea %a2,[%a2]152 <80000098 <osEE_kdb_var>>
8000a19a:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
8000a19e:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, TYPEDEF)
      p_reso_cb   = p_reso_db->p_cb;
8000a1a2:	d4 22       	ld.a %a2,[%a2]
8000a1a4:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a1a6:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a1aa:	8f ff 0f 21 	and %d2,%d15,255
8000a1ae:	8b 12 a1 22 	ge.u %d2,%d2,17
8000a1b2:	f6 2a       	jnz %d2,8000a1c6 <ReleaseResource+0x52>
    OsEE_icr icr_temp = icr;
8000a1b4:	02 f2       	mov %d2,%d15
8000a1b6:	3b 10 01 30 	mov %d3,17
8000a1ba:	37 32 08 20 	insert %d2,%d2,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a1be:	cd c2 e2 0f 	mtcr $icr,%d2
8000a1c2:	0d 00 c0 04 	isync 
    {
      VAR(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      /* Pop the Resources head */
      p_curr_tcb->p_last_m = p_curr_tcb->p_last_m->p_cb->p_next;
8000a1c6:	c8 14       	ld.a %a4,[%a15]4
8000a1c8:	d4 44       	ld.a %a4,[%a4]
8000a1ca:	54 42       	ld.w %d2,[%a4]
8000a1cc:	68 12       	st.w [%a15]4,%d2

      if (p_curr_tcb->p_last_m != NULL) {
8000a1ce:	df 02 1a 00 	jeq %d2,0,8000a202 <ReleaseResource+0x8e>
        CONST(TaskPrio, AUTOMATIC)
          prev_prio = p_reso_cb->prev_prio;
8000a1d2:	39 23 04 00 	ld.bu %d3,[%a2]4

        p_curr_tcb->current_prio = prev_prio;
8000a1d6:	28 13       	st.b [%a15]1,%d3

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000a1d8:	37 03 48 40 	extr %d4,%d3,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000a1dc:	8b f3 2f 62 	ne %d6,%d3,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000a1e0:	8f f3 07 31 	and %d3,%d3,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000a1e4:	c2 13       	add %d3,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000a1e6:	8f 0f d0 51 	andn %d5,%d15,256
8000a1ea:	8f ff cf 21 	andn %d2,%d15,255
8000a1ee:	a6 32       	or %d2,%d3
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000a1f0:	8f ff cf f1 	andn %d15,%d15,255
8000a1f4:	2b 52 40 26 	sel %d2,%d6,%d2,%d5
8000a1f8:	8b 04 40 42 	lt %d4,%d4,0
8000a1fc:	2b f2 40 f4 	sel %d15,%d4,%d2,%d15
8000a200:	3c 17       	j 8000a22e <ReleaseResource+0xba>
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;
8000a202:	39 35 1d 00 	ld.bu %d5,[%a3]29

        p_curr_tcb->current_prio = dispatch_prio;
8000a206:	28 15       	st.b [%a15]1,%d5

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000a208:	37 05 48 60 	extr %d6,%d5,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000a20c:	8b f5 2f 42 	ne %d4,%d5,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000a210:	8f f5 07 51 	and %d5,%d5,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000a214:	c2 15       	add %d5,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000a216:	8f 0f d0 21 	andn %d2,%d15,256
8000a21a:	8f ff cf 31 	andn %d3,%d15,255
8000a21e:	a6 53       	or %d3,%d5
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000a220:	8f ff cf 51 	andn %d5,%d15,255
8000a224:	2b 23 40 34 	sel %d3,%d4,%d3,%d2
8000a228:	fa 06       	lt %d15,%d6,0
8000a22a:	2b 53 40 ff 	sel %d15,%d15,%d3,%d5
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_reso_cb->p_owner = NULL;
8000a22e:	82 02       	mov %d2,0
8000a230:	59 22 08 00 	st.w [%a2]8,%d2

      /* Preemption point */
      (void)osEE_scheduler_task_preemption_point(p_kdb);
8000a234:	91 00 00 48 	movh.a %a4,32768
8000a238:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
8000a23c:	6d 00 63 03 	call 8000a902 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a240:	4d c0 e2 5f 	mfcr %d5,$icr
8000a244:	02 53       	mov %d3,%d5
8000a246:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a24a:	16 ff       	and %d15,255
8000a24c:	5f f5 08 00 	jeq %d5,%d15,8000a25c <ReleaseResource+0xe8>
8000a250:	37 f3 08 30 	insert %d3,%d3,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a254:	cd c3 e2 0f 	mtcr $icr,%d3
8000a258:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      ev = E_OK;
8000a25c:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
8000a25e:	00 90       	ret 

8000a260 <ShutdownOS>:
FUNC(StatusType, OS_CODE)
  ShutdownOS
(
  VAR(StatusType, AUTOMATIC) Error
)
{
8000a260:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a262:	91 00 00 f8 	movh.a %a15,32768
8000a266:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a26a:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a26e:	8f f2 0f f1 	and %d15,%d2,255
8000a272:	8b 1f a1 f2 	ge.u %d15,%d15,17
8000a276:	ee 0a       	jnz %d15,8000a28a <ShutdownOS+0x2a>
    OsEE_icr icr_temp = icr;
8000a278:	02 2f       	mov %d15,%d2
8000a27a:	3b 10 01 30 	mov %d3,17
8000a27e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a282:	cd cf e2 0f 	mtcr $icr,%d15
8000a286:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000a28a:	39 ff 10 00 	ld.bu %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
8000a28e:	c2 ff       	add %d15,-1
8000a290:	16 ff       	and %d15,255
8000a292:	ff 2f 08 80 	jge.u %d15,2,8000a2a2 <ShutdownOS+0x42>
        (os_status == OSEE_KERNEL_STARTING))
    {
      osEE_shutdown_os(p_cdb, Error);
8000a296:	91 00 00 48 	movh.a %a4,32768
8000a29a:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
8000a29e:	1d ff f3 fc 	j 80009c84 <osEE_shutdown_os>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a2a2:	4d c0 e2 3f 	mfcr %d3,$icr
8000a2a6:	02 3f       	mov %d15,%d3
8000a2a8:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a2ac:	8f f2 0f 21 	and %d2,%d2,255
8000a2b0:	5f 23 08 00 	jeq %d3,%d2,8000a2c0 <ShutdownOS+0x60>
8000a2b4:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a2b8:	cd cf e2 0f 	mtcr $icr,%d15
8000a2bc:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
8000a2c0:	82 72       	mov %d2,7
8000a2c2:	00 90       	ret 

8000a2c4 <GetTaskID>:
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
8000a2c4:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a2c6:	91 00 00 f8 	movh.a %a15,32768
8000a2ca:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
8000a2ce:	3b e0 00 20 	mov %d2,14
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
8000a2d2:	bd 04 24 00 	jz.a %a4,8000a31a <GetTaskID+0x56>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
8000a2d6:	c8 02       	ld.a %a2,[%a15]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000a2d8:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000a2dc:	ff 2f 05 80 	jge.u %d15,2,8000a2e6 <GetTaskID+0x22>
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
8000a2e0:	19 22 10 00 	ld.w %d2,[%a2]16
8000a2e4:	3c 19       	j 8000a316 <GetTaskID+0x52>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000a2e6:	82 f2       	mov %d2,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a2e8:	de 27       	jne %d15,2,8000a316 <GetTaskID+0x52>
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
8000a2ea:	c8 3f       	ld.a %a15,[%a15]12
8000a2ec:	c8 0f       	ld.a %a15,[%a15]0

      while (p_sn != NULL) {
8000a2ee:	bd 0f 14 00 	jz.a %a15,8000a316 <GetTaskID+0x52>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
8000a2f2:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000a2f4:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000a2f8:	ff 2f 0b 80 	jge.u %d15,2,8000a30e <GetTaskID+0x4a>
8000a2fc:	3c 06       	j 8000a308 <GetTaskID+0x44>
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
8000a2fe:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000a300:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000a304:	ff 2f 05 80 	jge.u %d15,2,8000a30e <GetTaskID+0x4a>
          tid = p_searched_tdb->tid;
8000a308:	19 22 10 00 	ld.w %d2,[%a2]16
          break;
8000a30c:	3c 05       	j 8000a316 <GetTaskID+0x52>
        } else {
          p_sn = p_sn->p_next;
8000a30e:	c8 0f       	ld.a %a15,[%a15]0
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
8000a310:	bd 0f f7 ff 	jnz.a %a15,8000a2fe <GetTaskID+0x3a>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000a314:	82 f2       	mov %d2,-1
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
8000a316:	74 42       	st.w [%a4],%d2
    ev = E_OK;
8000a318:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
8000a31a:	00 90       	ret 

8000a31c <GetTaskState>:
  GetTaskState
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(TaskStateRefType, AUTOMATIC)  State
)
{
8000a31c:	40 ae       	mov.aa %a14,%sp
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
8000a31e:	3b e0 00 20 	mov %d2,14
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
8000a322:	bd 04 38 00 	jz.a %a4,8000a392 <GetTaskState+0x76>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000a326:	91 00 00 f8 	movh.a %a15,32768
8000a32a:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a32e:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000a330:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000a332:	7f f4 30 80 	jge.u %d4,%d15,8000a392 <GetTaskState+0x76>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000a336:	91 00 00 f8 	movh.a %a15,32768
8000a33a:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a33e:	c8 1f       	ld.a %a15,[%a15]4
8000a340:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
8000a344:	c8 0f       	ld.a %a15,[%a15]0
8000a346:	c8 3f       	ld.a %a15,[%a15]12
    switch (local_state) {
8000a348:	0c f2       	ld.bu %d15,[%a15]2
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000a34a:	82 02       	mov %d2,0
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
8000a34c:	ff 6f 23 80 	jge.u %d15,6,8000a392 <GetTaskState+0x76>
8000a350:	91 10 00 f8 	movh.a %a15,32769
8000a354:	d9 ff 1c da 	lea %a15,[%a15]-23716 <8000a35c <GetTaskState+0x40>>
8000a358:	90 ff       	addsc.a %a15,%a15,%d15,2
8000a35a:	dc 0f       	ji %a15
8000a35c:	1d 00 0c 00 	j 8000a374 <GetTaskState+0x58>
8000a360:	1d 00 0e 00 	j 8000a37c <GetTaskState+0x60>
8000a364:	1d 00 0c 00 	j 8000a37c <GetTaskState+0x60>
8000a368:	1d 00 0e 00 	j 8000a384 <GetTaskState+0x68>
8000a36c:	1d 00 10 00 	j 8000a38c <GetTaskState+0x70>
8000a370:	1d 00 0e 00 	j 8000a38c <GetTaskState+0x70>
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
8000a374:	82 0f       	mov %d15,0
8000a376:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000a378:	82 02       	mov %d2,0
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
8000a37a:	00 90       	ret 
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
8000a37c:	82 1f       	mov %d15,1
8000a37e:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000a380:	82 02       	mov %d2,0
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
8000a382:	00 90       	ret 
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
8000a384:	82 3f       	mov %d15,3
8000a386:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000a388:	82 02       	mov %d2,0
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
8000a38a:	00 90       	ret 
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
8000a38c:	82 4f       	mov %d15,4
8000a38e:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000a390:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
8000a392:	00 90       	ret 

8000a394 <WaitEvent>:
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000a394:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
8000a396:	91 00 00 f8 	movh.a %a15,32768
8000a39a:	99 fc 2c 20 	ld.a %a12,[%a15]172 <800000ac <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000a39e:	d4 cd       	ld.a %a13,[%a12]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000a3a0:	cc d3       	ld.a %a15,[%a13]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a3a2:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a3a6:	8f f8 0f f1 	and %d15,%d8,255
8000a3aa:	8b 1f a1 f2 	ge.u %d15,%d15,17
8000a3ae:	ee 0a       	jnz %d15,8000a3c2 <WaitEvent+0x2e>
    OsEE_icr icr_temp = icr;
8000a3b0:	02 8f       	mov %d15,%d8
8000a3b2:	3b 10 01 20 	mov %d2,17
8000a3b6:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a3ba:	cd cf e2 0f 	mtcr $icr,%d15
8000a3be:	0d 00 c0 04 	isync 
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
8000a3c2:	4c f3       	ld.w %d15,[%a15]12
8000a3c4:	26 4f       	and %d15,%d4
8000a3c6:	ee 13       	jnz %d15,8000a3ec <WaitEvent+0x58>
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
8000a3c8:	68 24       	st.w [%a15]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000a3ca:	91 00 00 48 	movh.a %a4,32768
8000a3ce:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
8000a3d2:	d9 c5 04 00 	lea %a5,[%a12]4 <800000ac <osEE_cdb_var>>
8000a3d6:	6d 00 98 01 	call 8000a706 <osEE_scheduler_core_pop_running>
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
8000a3da:	e8 42       	st.a [%a15]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
8000a3dc:	82 3f       	mov %d15,3
8000a3de:	28 2f       	st.b [%a15]2,%d15

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
8000a3e0:	40 d4       	mov.aa %a4,%a13
8000a3e2:	d4 c5       	ld.a %a5,[%a12]
8000a3e4:	6d 00 c1 02 	call 8000a966 <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
8000a3e8:	82 0f       	mov %d15,0
8000a3ea:	68 2f       	st.w [%a15]8,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a3ec:	4d c0 e2 3f 	mfcr %d3,$icr
8000a3f0:	02 3f       	mov %d15,%d3
8000a3f2:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a3f6:	8f f8 0f 21 	and %d2,%d8,255
8000a3fa:	5f 23 08 00 	jeq %d3,%d2,8000a40a <WaitEvent+0x76>
8000a3fe:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a402:	cd cf e2 0f 	mtcr $icr,%d15
8000a406:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
8000a40a:	82 02       	mov %d2,0
8000a40c:	00 90       	ret 

8000a40e <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000a40e:	40 ae       	mov.aa %a14,%sp
8000a410:	20 08       	sub.a %sp,8
8000a412:	91 00 00 f8 	movh.a %a15,32768
8000a416:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a41a:	4c f2       	ld.w %d15,[%a15]8
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000a41c:	3f f4 06 80 	jlt.u %d4,%d15,8000a428 <SetEvent+0x1a>
    ev = E_OS_ID;
8000a420:	82 3f       	mov %d15,3
8000a422:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000a426:	3c 3c       	j 8000a49e <SetEvent+0x90>
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000a428:	91 00 00 f8 	movh.a %a15,32768
8000a42c:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a430:	c8 1f       	ld.a %a15,[%a15]4
8000a432:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000a436:	c8 04       	ld.a %a4,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a438:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a43c:	8f f8 0f f1 	and %d15,%d8,255
8000a440:	8b 1f a1 f2 	ge.u %d15,%d15,17
8000a444:	ee 0a       	jnz %d15,8000a458 <SetEvent+0x4a>
    OsEE_icr icr_temp = icr;
8000a446:	02 8f       	mov %d15,%d8
8000a448:	3b 10 01 20 	mov %d2,17
8000a44c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a450:	cd cf e2 0f 	mtcr $icr,%d15
8000a454:	0d 00 c0 04 	isync 
8000a458:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
8000a45a:	d9 e5 ff ff 	lea %a5,[%a14]-1
8000a45e:	6d 00 82 01 	call 8000a762 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
8000a462:	bc 2f       	jz.a %a2,8000a480 <SetEvent+0x72>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
8000a464:	91 00 00 48 	movh.a %a4,32768
8000a468:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
8000a46c:	40 25       	mov.aa %a5,%a2
8000a46e:	6d 00 e7 01 	call 8000a83c <osEE_scheduler_task_unblocked>
8000a472:	76 27       	jz %d2,8000a480 <SetEvent+0x72>
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000a474:	91 00 00 48 	movh.a %a4,32768
8000a478:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
8000a47c:	6d 00 43 02 	call 8000a902 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a480:	4d c0 e2 3f 	mfcr %d3,$icr
8000a484:	02 3f       	mov %d15,%d3
8000a486:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a48a:	8f f8 0f 21 	and %d2,%d8,255
8000a48e:	5f 23 08 00 	jeq %d3,%d2,8000a49e <SetEvent+0x90>
8000a492:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a496:	cd cf e2 0f 	mtcr $icr,%d15
8000a49a:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000a49e:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8000a4a2:	00 90       	ret 

8000a4a4 <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
8000a4a4:	40 ae       	mov.aa %a14,%sp
8000a4a6:	91 00 00 f8 	movh.a %a15,32768
8000a4aa:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a4ae:	4c f2       	ld.w %d15,[%a15]8
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000a4b0:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000a4b2:	7f f4 11 80 	jge.u %d4,%d15,8000a4d4 <GetEvent+0x30>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000a4b6:	91 00 00 f8 	movh.a %a15,32768
8000a4ba:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a4be:	c8 1f       	ld.a %a15,[%a15]4
8000a4c0:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
8000a4c4:	c8 0f       	ld.a %a15,[%a15]0
8000a4c6:	c8 3f       	ld.a %a15,[%a15]12
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
8000a4c8:	3b e0 00 20 	mov %d2,14
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
8000a4cc:	bc 44       	jz.a %a4,8000a4d4 <GetEvent+0x30>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
8000a4ce:	4c f3       	ld.w %d15,[%a15]12
8000a4d0:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
8000a4d2:	82 02       	mov %d2,0
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000a4d4:	00 90       	ret 

8000a4d6 <ClearEvent>:
FUNC(StatusType, OS_CODE)
  ClearEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000a4d6:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
8000a4d8:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000a4dc:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000a4e0:	c8 0f       	ld.a %a15,[%a15]0
8000a4e2:	c8 3f       	ld.a %a15,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a4e4:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a4e8:	8f f2 0f f1 	and %d15,%d2,255
8000a4ec:	8b 1f a1 f2 	ge.u %d15,%d15,17
8000a4f0:	ee 0a       	jnz %d15,8000a504 <ClearEvent+0x2e>
    OsEE_icr icr_temp = icr;
8000a4f2:	02 2f       	mov %d15,%d2
8000a4f4:	3b 10 01 30 	mov %d3,17
8000a4f8:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a4fc:	cd cf e2 0f 	mtcr $icr,%d15
8000a500:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
8000a504:	4c f3       	ld.w %d15,[%a15]12
8000a506:	0f 4f e0 40 	andn %d4,%d15,%d4
8000a50a:	68 34       	st.w [%a15]12,%d4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a50c:	4d c0 e2 3f 	mfcr %d3,$icr
8000a510:	02 3f       	mov %d15,%d3
8000a512:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a516:	8f f2 0f 21 	and %d2,%d2,255
8000a51a:	5f 23 08 00 	jeq %d3,%d2,8000a52a <ClearEvent+0x54>
8000a51e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a522:	cd cf e2 0f 	mtcr $icr,%d15
8000a526:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
8000a52a:	82 02       	mov %d2,0
8000a52c:	00 90       	ret 

8000a52e <GetISRID>:
FUNC(ISRType, OS_CODE)
  GetISRID
(
  void
)
{
8000a52e:	40 ae       	mov.aa %a14,%sp
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000a530:	91 00 00 f8 	movh.a %a15,32768
8000a534:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
8000a538:	c8 0f       	ld.a %a15,[%a15]0
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a53a:	39 ff 14 00 	ld.bu %d15,[%a15]20 <800000ac <osEE_cdb_var>>
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
8000a53e:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a540:	5e 22       	jne %d15,2,8000a544 <GetISRID+0x16>
    isr_id = p_tdb->tid;
8000a542:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
8000a544:	00 90       	ret 
	...

8000a548 <osEE_release_all_m>:
static FUNC_P2VAR(OsEE_MDB, OS_APPL_CONST, OS_CODE)
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
8000a548:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000a54a:	99 43 0c 00 	ld.a %a3,[%a4]12

  while ((p_tcb->p_last_m != NULL)
8000a54e:	cc 31       	ld.a %a15,[%a3]4
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
8000a550:	a0 02       	mov.a %a2,0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000a552:	bc fb       	jz.a %a15,8000a568 <osEE_release_all_m+0x20>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000a554:	82 0f       	mov %d15,0
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
8000a556:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000a558:	68 2f       	st.w [%a15]8,%d15
    /* Save the first M not realesed */
    if (p_mdb == NULL) {
8000a55a:	7c 23       	jnz.a %a2,8000a560 <osEE_release_all_m+0x18>
      p_mdb = p_tcb->p_last_m;
8000a55c:	99 32 04 00 	ld.a %a2,[%a3]4
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
8000a560:	c8 0f       	ld.a %a15,[%a15]0
8000a562:	ec 31       	st.a [%a3]4,%a15
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000a564:	bd 0f f9 ff 	jnz.a %a15,8000a556 <osEE_release_all_m+0xe>
    p_tcb->p_last_m = NULL;
  }
#endif /* OSEE_HAS_SPINLOCKS */

  return p_mdb;
}
8000a568:	00 90       	ret 

8000a56a <osEE_scheduler_task_wrapper_restore>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_restore
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
8000a56a:	40 ae       	mov.aa %a14,%sp
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000a56c:	cc 43       	ld.a %a15,[%a4]12
8000a56e:	82 4f       	mov %d15,4
8000a570:	28 2f       	st.b [%a15]2,%d15
8000a572:	00 90       	ret 

8000a574 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
8000a574:	40 ae       	mov.aa %a14,%sp
8000a576:	40 4f       	mov.aa %a15,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
8000a578:	99 42 0c 00 	ld.a %a2,[%a4]12
8000a57c:	39 22 01 00 	ld.bu %d2,[%a2]1
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000a580:	82 4f       	mov %d15,4
8000a582:	2c 22       	st.b [%a2]2,%d15
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_priority < OSEE_ISR_ALL_PRIO) {
8000a584:	8b f2 0f f2 	eq %d15,%d2,255
8000a588:	ee 13       	jnz %d15,8000a5ae <osEE_scheduler_task_wrapper_run+0x3a>
8000a58a:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
8000a58e:	37 02 48 40 	extr %d4,%d2,0,8
8000a592:	82 03       	mov %d3,0
8000a594:	ce 45       	jgez %d4,8000a59e <osEE_scheduler_task_wrapper_run+0x2a>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000a596:	8f f2 07 21 	and %d2,%d2,127
8000a59a:	1b 12 00 30 	addi %d3,%d2,1
8000a59e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a5a2:	cd cf e2 0f 	mtcr $icr,%d15
8000a5a6:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000a5aa:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000a5ae:	c8 62       	ld.a %a2,[%a15]24
8000a5b0:	2d 02 00 00 	calli %a2
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000a5b4:	91 00 00 28 	movh.a %a2,32768
8000a5b8:	99 22 2c 20 	ld.a %a2,[%a2]172 <800000ac <osEE_cdb_var>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
8000a5bc:	82 0f       	mov %d15,0
8000a5be:	e9 2f 1d 00 	st.b [%a2]29,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000a5c2:	39 2f 1c 00 	ld.bu %d15,[%a2]28
8000a5c6:	6e 09       	jz %d15,8000a5d8 <osEE_scheduler_task_wrapper_run+0x64>
    p_ccb->s_isr_all_cnt = 0U;
8000a5c8:	82 0f       	mov %d15,0
8000a5ca:	e9 2f 1c 00 	st.b [%a2]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a5ce:	4c 25       	ld.w %d15,[%a2]20
8000a5d0:	cd cf e2 0f 	mtcr $icr,%d15
8000a5d4:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
8000a5d8:	39 2f 1e 00 	ld.bu %d15,[%a2]30
8000a5dc:	6e 06       	jz %d15,8000a5e8 <osEE_scheduler_task_wrapper_run+0x74>
    p_ccb->d_isr_all_cnt = 0U;
8000a5de:	82 0f       	mov %d15,0
8000a5e0:	e9 2f 1e 00 	st.b [%a2]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000a5e4:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a5e8:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a5ec:	8f ff 0f 21 	and %d2,%d15,255
8000a5f0:	8b 12 a1 22 	ge.u %d2,%d2,17
8000a5f4:	f6 29       	jnz %d2,8000a606 <osEE_scheduler_task_wrapper_run+0x92>
8000a5f6:	3b 10 01 20 	mov %d2,17
8000a5fa:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a5fe:	cd cf e2 0f 	mtcr $icr,%d15
8000a602:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000a606:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000a60a:	5e 24       	jne %d15,2,8000a612 <osEE_scheduler_task_wrapper_run+0x9e>
  /* [SWS_Os_00369]: If a Category 2 ISR calls GetResource() and ends (returns)
      without calling the corresponding ReleaseResource(), the Operating System
      module shall perform the ReleaseResource() call and shall call the
      ErrorHook() E_OS_RESOURCE */
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_mdb = osEE_release_all_m(p_to_term);
8000a60c:	40 f4       	mov.aa %a4,%a15
8000a60e:	5c 9d       	call 8000a548 <osEE_release_all_m>
8000a610:	3c 03       	j 8000a616 <osEE_scheduler_task_wrapper_run+0xa2>
    osEE_call_error_hook(p_ccb, E_OS_MISSINGEND);
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
/* [SWS_Os_0070]: If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and still holds OSEK Resources,
    the Operating System shall release them. */
    (void)osEE_release_all_m(p_to_term);
8000a612:	40 f4       	mov.aa %a4,%a15
8000a614:	5c 9a       	call 8000a548 <osEE_release_all_m>
8000a616:	c8 14       	ld.a %a4,[%a15]4
8000a618:	a0 05       	mov.a %a5,0
8000a61a:	1d 00 79 02 	j 8000ab0c <osEE_hal_terminate_ctx>

8000a61e <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
8000a61e:	40 ae       	mov.aa %a14,%sp
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000a620:	91 00 00 f8 	movh.a %a15,32768
8000a624:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
8000a628:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000ac <osEE_cdb_var>>
8000a62c:	df 2f fe 7f 	jeq %d15,2,8000a628 <osEE_idle_hook_wrapper+0xa>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
8000a630:	91 00 00 f8 	movh.a %a15,32768
8000a634:	d9 ff 2c 20 	lea %a15,[%a15]172 <800000ac <osEE_cdb_var>>
8000a638:	c8 14       	ld.a %a4,[%a15]4
8000a63a:	6d 00 ba 01 	call 8000a9ae <osEE_idle_task_terminate>
8000a63e:	00 90       	ret 

8000a640 <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
8000a640:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a642:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000a644:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
8000a646:	99 32 0c 00 	ld.a %a2,[%a3]12

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000a64a:	bd 02 13 00 	jz.a %a2,8000a670 <osEE_scheduler_core_rq_preempt_stk+0x30>
    p_ret_tdb = p_ret_sn->p_tdb;
8000a64e:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
8000a652:	bd 0f 1b 00 	jz.a %a15,8000a688 <osEE_scheduler_core_rq_preempt_stk+0x48>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000a656:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000a65a:	c8 16       	ld.a %a6,[%a15]4
8000a65c:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000a660:	39 42 01 00 	ld.bu %d2,[%a4]1
8000a664:	0c 61       	ld.bu %d15,[%a6]1
8000a666:	7f f2 13 80 	jge.u %d2,%d15,8000a68c <osEE_scheduler_core_rq_preempt_stk+0x4c>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
8000a66a:	82 2f       	mov %d15,2
8000a66c:	2c 42       	st.b [%a4]2,%d15
8000a66e:	3c 11       	j 8000a690 <osEE_scheduler_core_rq_preempt_stk+0x50>
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000a670:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000a672:	bd 0f 1e 00 	jz.a %a15,8000a6ae <osEE_scheduler_core_rq_preempt_stk+0x6e>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
8000a676:	99 42 04 00 	ld.a %a2,[%a4]4
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000a67a:	99 24 0c 00 	ld.a %a4,[%a2]12
8000a67e:	82 2f       	mov %d15,2
8000a680:	2c 42       	st.b [%a4]2,%d15
8000a682:	3c 07       	j 8000a690 <osEE_scheduler_core_rq_preempt_stk+0x50>
  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
    if (p_tcb->current_prio < dispatch_prio) {
      p_tcb->current_prio = dispatch_prio;
8000a684:	2c 51       	st.b [%a5]1,%d15
8000a686:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000a688:	a0 02       	mov.a %a2,0
8000a68a:	00 90       	ret 
8000a68c:	a0 02       	mov.a %a2,0
8000a68e:	00 90       	ret 
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000a690:	4c f0       	ld.w %d15,[%a15]0
8000a692:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000a694:	c8 14       	ld.a %a4,[%a15]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000a696:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000a69a:	4c 33       	ld.w %d15,[%a3]12
8000a69c:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000a69e:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000a6a0:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000a6a2:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000a6a6:	39 52 01 00 	ld.bu %d2,[%a5]1
8000a6aa:	3f f2 ed ff 	jlt.u %d2,%d15,8000a684 <osEE_scheduler_core_rq_preempt_stk+0x44>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
8000a6ae:	00 90       	ret 

8000a6b0 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
8000a6b0:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
8000a6b2:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
8000a6b4:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000a6b6:	76 44       	jz %d4,8000a6be <osEE_sn_priority_insert+0xe>
8000a6b8:	39 f2 1c 00 	ld.bu %d2,[%a15]28
8000a6bc:	3c 03       	j 8000a6c2 <osEE_sn_priority_insert+0x12>
8000a6be:	39 22 01 00 	ld.bu %d2,[%a2]1
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000a6c2:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000a6c4:	a0 06       	mov.a %a6,0
8000a6c6:	7c f3       	jnz.a %a15,8000a6cc <osEE_sn_priority_insert+0x1c>
8000a6c8:	3c 14       	j 8000a6f0 <osEE_sn_priority_insert+0x40>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000a6ca:	60 ff       	mov.a %a15,%d15
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
8000a6cc:	c8 12       	ld.a %a2,[%a15]4
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000a6ce:	99 23 0c 00 	ld.a %a3,[%a2]12

    if (as_ready) {
8000a6d2:	76 44       	jz %d4,8000a6da <osEE_sn_priority_insert+0x2a>
      prio_to_check = p_cur_tdb->ready_prio;
8000a6d4:	39 2f 1c 00 	ld.bu %d15,[%a2]28
8000a6d8:	3c 02       	j 8000a6dc <osEE_sn_priority_insert+0x2c>
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000a6da:	0c 31       	ld.bu %d15,[%a3]1
    }

    if (new_task_prio <= prio_to_check)
8000a6dc:	3f 2f 06 80 	jlt.u %d15,%d2,8000a6e8 <osEE_sn_priority_insert+0x38>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000a6e0:	4c f0       	ld.w %d15,[%a15]0
8000a6e2:	40 f6       	mov.aa %a6,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000a6e4:	ee f3       	jnz %d15,8000a6ca <osEE_sn_priority_insert+0x1a>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000a6e6:	60 ff       	mov.a %a15,%d15
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
8000a6e8:	bc 64       	jz.a %a6,8000a6f0 <osEE_sn_priority_insert+0x40>
    p_prev->p_next = p_sn_new;
8000a6ea:	f4 65       	st.a [%a6],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000a6ec:	82 02       	mov %d2,0
8000a6ee:	3c 03       	j 8000a6f4 <osEE_sn_priority_insert+0x44>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000a6f0:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
8000a6f2:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
8000a6f4:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000a6f6:	00 90       	ret 

8000a6f8 <osEE_scheduler_rq_insert>:
(
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
8000a6f8:	40 ae       	mov.aa %a14,%sp
  p_sn_new->p_tdb = p_tdb_new;
8000a6fa:	b5 56 04 00 	st.a [%a5]4,%a6

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
8000a6fe:	82 14       	mov %d4,1
8000a700:	6d ff d8 ff 	call 8000a6b0 <osEE_sn_priority_insert>
#else
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_FALSE);
#endif /* !OSEE_SCHEDULER_GLOBAL */
}
8000a704:	00 90       	ret 

8000a706 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
8000a706:	40 ae       	mov.aa %a14,%sp
8000a708:	40 4d       	mov.aa %a13,%a4
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
8000a70a:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
8000a70c:	c8 3c       	ld.a %a12,[%a15]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
8000a70e:	4c c0       	ld.w %d15,[%a12]0
8000a710:	68 3f       	st.w [%a15]12,%d15
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
8000a712:	6d ff 97 ff 	call 8000a640 <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
8000a716:	4c f3       	ld.w %d15,[%a15]12

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
8000a718:	7c 28       	jnz.a %a2,8000a728 <osEE_scheduler_core_pop_running+0x22>
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
8000a71a:	80 d3       	mov.d %d3,%a13
8000a71c:	c2 43       	add %d3,4
8000a71e:	92 42       	add %d2,%d15,4
8000a720:	6a 32       	cmovn %d2,%d15,%d3
8000a722:	60 2d       	mov.a %a13,%d2
8000a724:	4c d0       	ld.w %d15,[%a13]0
8000a726:	68 0f       	st.w [%a15]0,%d15
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
8000a728:	40 c2       	mov.aa %a2,%a12
8000a72a:	00 90       	ret 

8000a72c <osEE_task_activated>:

FUNC(StatusType, OS_CODE) osEE_task_activated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000a72c:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
8000a72e:	cc 43       	ld.a %a15,[%a4]12
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000a730:	0c f0       	ld.bu %d15,[%a15]0
8000a732:	39 43 1e 00 	ld.bu %d3,[%a4]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
8000a736:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000a738:	7f 3f 05 80 	jge.u %d15,%d3,8000a742 <osEE_task_activated+0x16>
    ++p_tcb_act->current_num_of_act;
8000a73c:	c2 1f       	add %d15,1
8000a73e:	28 0f       	st.b [%a15]0,%d15
    ev = E_OK;
8000a740:	82 02       	mov %d2,0
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000a742:	00 90       	ret 

8000a744 <osEE_task_end>:
FUNC(void, OS_CODE)
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
8000a744:	40 ae       	mov.aa %a14,%sp
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000a746:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
8000a748:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000a74c:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
8000a74e:	0c f0       	ld.bu %d15,[%a15]0
8000a750:	c2 ff       	add %d15,-1
8000a752:	16 ff       	and %d15,255
8000a754:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
8000a756:	ee 03       	jnz %d15,8000a75c <osEE_task_end+0x18>
    p_tcb->status = OSEE_TASK_SUSPENDED;
8000a758:	28 2f       	st.b [%a15]2,%d15
8000a75a:	00 90       	ret 
  } else {
    p_tcb->status = OSEE_TASK_READY;
8000a75c:	82 1f       	mov %d15,1
8000a75e:	28 2f       	st.b [%a15]2,%d15
8000a760:	00 90       	ret 

8000a762 <osEE_task_event_set_mask>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)    p_tdb_waking_up,
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
8000a762:	40 ae       	mov.aa %a14,%sp
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
8000a764:	cc 43       	ld.a %a15,[%a4]12
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000a766:	02 42       	mov %d2,%d4
8000a768:	02 43       	mov %d3,%d4
8000a76a:	49 f2 4c 08 	ldmst [%a15]12,%e2

    *p_ev = E_OK;
8000a76e:	82 0f       	mov %d15,0
8000a770:	2c 50       	st.b [%a5]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000a772:	4c f2       	ld.w %d15,[%a15]8
8000a774:	26 f4       	and %d4,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000a776:	a0 02       	mov.a %a2,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000a778:	76 45       	jz %d4,8000a782 <osEE_task_event_set_mask+0x20>
      p_own_sn = p_tcb_waking_up->p_own_sn;
8000a77a:	c8 42       	ld.a %a2,[%a15]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
8000a77c:	bc 23       	jz.a %a2,8000a782 <osEE_task_event_set_mask+0x20>
        p_tcb_waking_up->p_own_sn = NULL;
8000a77e:	82 0f       	mov %d15,0
8000a780:	68 4f       	st.w [%a15]16,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
8000a782:	00 90       	ret 

8000a784 <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
8000a784:	40 ae       	mov.aa %a14,%sp
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000a786:	91 00 00 48 	movh.a %a4,32768
8000a78a:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
8000a78e:	cc 41       	ld.a %a15,[%a4]4
8000a790:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000a794:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
8000a796:	cc 53       	ld.a %a15,[%a5]12
8000a798:	0c f0       	ld.bu %d15,[%a15]0
8000a79a:	c2 1f       	add %d15,1
8000a79c:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000a79e:	a0 06       	mov.a %a6,0
8000a7a0:	6d 00 c4 00 	call 8000a928 <osEE_scheduler_task_set_running>
8000a7a4:	00 90       	ret 

8000a7a6 <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000a7a6:	40 ae       	mov.aa %a14,%sp
8000a7a8:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
8000a7aa:	99 52 0c 00 	ld.a %a2,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000a7ae:	91 00 00 f8 	movh.a %a15,32768
8000a7b2:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
8000a7b6:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
8000a7b8:	99 43 0c 00 	ld.a %a3,[%a4]12 <800000ac <osEE_cdb_var>>
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
8000a7bc:	39 32 01 00 	ld.bu %d2,[%a3]1 <800000ac <osEE_cdb_var>>
8000a7c0:	0c 21       	ld.bu %d15,[%a2]1
8000a7c2:	7f f2 15 80 	jge.u %d2,%d15,8000a7ec <osEE_scheduler_task_activated+0x46>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a7c6:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a7c8:	4c 20       	ld.w %d15,[%a2]0
8000a7ca:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a7cc:	82 02       	mov %d2,0
8000a7ce:	74 22       	st.w [%a2],%d2
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
8000a7d0:	82 2f       	mov %d15,2
8000a7d2:	2c 32       	st.b [%a3]2,%d15

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
8000a7d4:	b5 25 04 00 	st.a [%a2]4,%a5
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000a7d8:	4c f3       	ld.w %d15,[%a15]12
8000a7da:	6c 20       	st.w [%a2]0,%d15
    p_ccb->p_stk_sn             = p_new_stk;
8000a7dc:	e8 32       	st.a [%a15]12,%a2
    p_ccb->p_curr               = p_tdb_act;
8000a7de:	e8 05       	st.a [%a15]0,%a5
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
8000a7e0:	cc 53       	ld.a %a15,[%a5]12
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
8000a7e2:	68 32       	st.w [%a15]12,%d2

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
8000a7e4:	6d 00 c1 00 	call 8000a966 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000a7e8:	82 12       	mov %d2,1
8000a7ea:	00 90       	ret 
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000a7ec:	0c 22       	ld.bu %d15,[%a2]2
8000a7ee:	ee 05       	jnz %d15,8000a7f8 <osEE_scheduler_task_activated+0x52>
    p_tcb_act->status = OSEE_TASK_READY;
8000a7f0:	82 1f       	mov %d15,1
8000a7f2:	2c 22       	st.b [%a2]2,%d15
8000a7f4:	82 0f       	mov %d15,0
8000a7f6:	6c 23       	st.w [%a2]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a7f8:	c8 25       	ld.a %a5,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a7fa:	4c 50       	ld.w %d15,[%a5]0
8000a7fc:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a7fe:	82 0f       	mov %d15,0
8000a800:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000a802:	d9 f4 04 00 	lea %a4,[%a15]4
8000a806:	6d ff 79 ff 	call 8000a6f8 <osEE_scheduler_rq_insert>
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
8000a80a:	82 02       	mov %d2,0
  }

  return is_preemption;
}
8000a80c:	00 90       	ret 

8000a80e <osEE_scheduler_task_insert>:
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000a80e:	40 ae       	mov.aa %a14,%sp
8000a810:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
8000a812:	cc 53       	ld.a %a15,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000a814:	91 00 00 28 	movh.a %a2,32768
8000a818:	99 24 2c 20 	ld.a %a4,[%a2]172 <800000ac <osEE_cdb_var>>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000a81c:	0c f2       	ld.bu %d15,[%a15]2
8000a81e:	ee 05       	jnz %d15,8000a828 <osEE_scheduler_task_insert+0x1a>
    p_tcb_act->status = OSEE_TASK_READY;
8000a820:	82 1f       	mov %d15,1
8000a822:	28 2f       	st.b [%a15]2,%d15
8000a824:	82 0f       	mov %d15,0
8000a826:	68 3f       	st.w [%a15]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a828:	99 45 08 00 	ld.a %a5,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a82c:	4c 50       	ld.w %d15,[%a5]0
8000a82e:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a830:	82 0f       	mov %d15,0
8000a832:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000a834:	b0 44       	add.a %a4,4
8000a836:	6d ff 61 ff 	call 8000a6f8 <osEE_scheduler_rq_insert>

    osEE_unlock_core(p_cdb);
  }

  return head_changed;
}
8000a83a:	00 90       	ret 

8000a83c <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
8000a83c:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
8000a83e:	99 56 04 00 	ld.a %a6,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
8000a842:	cc 63       	ld.a %a15,[%a6]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000a844:	91 00 00 28 	movh.a %a2,32768
8000a848:	99 2c 2c 20 	ld.a %a12,[%a2]172 <800000ac <osEE_cdb_var>>

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
8000a84c:	82 2f       	mov %d15,2
8000a84e:	28 2f       	st.b [%a15]2,%d15
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000a850:	39 6f 1c 00 	ld.bu %d15,[%a6]28
8000a854:	28 1f       	st.b [%a15]1,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000a856:	d9 c4 04 00 	lea %a4,[%a12]4
8000a85a:	6d ff 4f ff 	call 8000a6f8 <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
8000a85e:	82 0f       	mov %d15,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
8000a860:	df 12 0a 80 	jne %d2,1,8000a874 <osEE_scheduler_task_unblocked+0x38>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
8000a864:	d4 c2       	ld.a %a2,[%a12]
8000a866:	99 22 0c 00 	ld.a %a2,[%a2]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
8000a86a:	0c f1       	ld.bu %d15,[%a15]1
8000a86c:	39 22 01 00 	ld.bu %d2,[%a2]1
8000a870:	0b f2 30 f1 	lt.u %d15,%d2,%d15
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
8000a874:	02 f2       	mov %d2,%d15
8000a876:	00 90       	ret 

8000a878 <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
8000a878:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a87a:	91 00 00 f8 	movh.a %a15,32768
8000a87e:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
8000a882:	c8 0d       	ld.a %a13,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
8000a884:	99 dc 0c 00 	ld.a %a12,[%a13]12 <800000ac <osEE_cdb_var>>

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
8000a888:	f4 5d       	st.a [%a5],%a13

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
8000a88a:	0c c2       	ld.bu %d15,[%a12]2
8000a88c:	de 4a       	jne %d15,4,8000a8c0 <osEE_scheduler_task_terminated+0x48>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000a88e:	91 00 00 48 	movh.a %a4,32768
8000a892:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
8000a896:	d9 f5 04 00 	lea %a5,[%a15]4 <800000ac <osEE_cdb_var>>
8000a89a:	6d ff 36 ff 	call 8000a706 <osEE_scheduler_core_pop_running>
8000a89e:	80 28       	mov.d %d8,%a2

      p_tdb_to = p_ccb->p_curr;
8000a8a0:	4c f0       	ld.w %d15,[%a15]0

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000a8a2:	80 d2       	mov.d %d2,%a13
8000a8a4:	5f f2 06 00 	jeq %d2,%d15,8000a8b0 <osEE_scheduler_task_terminated+0x38>
        osEE_task_end(p_tdb_term);
8000a8a8:	40 d4       	mov.aa %a4,%a13
8000a8aa:	6d ff 4d ff 	call 8000a744 <osEE_task_end>
8000a8ae:	3c 04       	j 8000a8b6 <osEE_scheduler_task_terminated+0x3e>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
8000a8b0:	14 c2       	ld.bu %d2,[%a12]
8000a8b2:	c2 f2       	add %d2,-1
8000a8b4:	34 c2       	st.b [%a12],%d2
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
8000a8b6:	48 22       	ld.w %d2,[%a15]8
8000a8b8:	60 82       	mov.a %a2,%d8
8000a8ba:	74 22       	st.w [%a2],%d2
  (*pp_first)       = p_to_free;
8000a8bc:	68 28       	st.w [%a15]8,%d8
8000a8be:	3c 20       	j 8000a8fe <osEE_scheduler_task_terminated+0x86>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
8000a8c0:	c8 35       	ld.a %a5,[%a15]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
8000a8c2:	54 52       	ld.w %d2,[%a5]
8000a8c4:	68 32       	st.w [%a15]12,%d2
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
8000a8c6:	39 df 1c 00 	ld.bu %d15,[%a13]28
8000a8ca:	2c c1       	st.b [%a12]1,%d15
      p_tcb_term->status = OSEE_TASK_READY;
8000a8cc:	82 1f       	mov %d15,1
8000a8ce:	2c c2       	st.b [%a12]2,%d15
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
8000a8d0:	0c c0       	ld.bu %d15,[%a12]0
8000a8d2:	5e 13       	jne %d15,1,8000a8d8 <osEE_scheduler_task_terminated+0x60>
8000a8d4:	82 0f       	mov %d15,0
8000a8d6:	6c c3       	st.w [%a12]12,%d15
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
8000a8d8:	d9 fc 04 00 	lea %a12,[%a15]4
8000a8dc:	40 c4       	mov.aa %a4,%a12
8000a8de:	40 d6       	mov.aa %a6,%a13
8000a8e0:	6d ff 0c ff 	call 8000a6f8 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000a8e4:	91 00 00 48 	movh.a %a4,32768
8000a8e8:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
8000a8ec:	40 c5       	mov.aa %a5,%a12
8000a8ee:	6d ff a9 fe 	call 8000a640 <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
8000a8f2:	7c 25       	jnz.a %a2,8000a8fc <osEE_scheduler_task_terminated+0x84>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
8000a8f4:	c8 32       	ld.a %a2,[%a15]12
8000a8f6:	4c 21       	ld.w %d15,[%a2]4
          p_ccb->p_curr           = p_tdb_to;
8000a8f8:	68 0f       	st.w [%a15]0,%d15
8000a8fa:	3c 02       	j 8000a8fe <osEE_scheduler_task_terminated+0x86>
        } else {
          p_tdb_to = p_ccb->p_curr;
8000a8fc:	4c f0       	ld.w %d15,[%a15]0
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
8000a8fe:	60 f2       	mov.a %a2,%d15
8000a900:	00 90       	ret 

8000a902 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
8000a902:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a904:	91 00 00 48 	movh.a %a4,32768
8000a908:	99 4f 2c 20 	ld.a %a15,[%a4]172 <800000ac <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000a90c:	d9 44 2c 20 	lea %a4,[%a4]172 <800000ac <osEE_cdb_var>>
8000a910:	d9 f5 04 00 	lea %a5,[%a15]4 <800000ac <osEE_cdb_var>>
8000a914:	6d ff 96 fe 	call 8000a640 <osEE_scheduler_core_rq_preempt_stk>

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
8000a918:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
8000a91a:	bc 26       	jz.a %a2,8000a926 <osEE_scheduler_task_preemption_point+0x24>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
8000a91c:	40 24       	mov.aa %a4,%a2
8000a91e:	c8 05       	ld.a %a5,[%a15]0
8000a920:	6d 00 23 00 	call 8000a966 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000a924:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
8000a926:	00 90       	ret 

8000a928 <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
8000a928:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a92a:	91 00 00 f8 	movh.a %a15,32768
8000a92e:	99 ff 2c 20 	ld.a %a15,[%a15]172 <800000ac <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
8000a932:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
8000a934:	48 32       	ld.w %d2,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000a936:	99 42 0c 00 	ld.a %a2,[%a4]12 <800000ac <osEE_cdb_var>>
8000a93a:	0c 22       	ld.bu %d15,[%a2]2
8000a93c:	5e 43       	jne %d15,4,8000a942 <osEE_scheduler_task_set_running+0x1a>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000a93e:	82 2f       	mov %d15,2
8000a940:	2c 22       	st.b [%a2]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
8000a942:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000a944:	7c 68       	jnz.a %a6,8000a954 <osEE_scheduler_task_set_running+0x2c>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a946:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a948:	4c 20       	ld.w %d15,[%a2]0
8000a94a:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a94c:	82 0f       	mov %d15,0
8000a94e:	6c 20       	st.w [%a2]0,%d15
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
8000a950:	e8 32       	st.a [%a15]12,%a2
8000a952:	3c 02       	j 8000a956 <osEE_scheduler_task_set_running+0x2e>
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
8000a954:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000a956:	c8 32       	ld.a %a2,[%a15]12
8000a958:	b5 25 04 00 	st.a [%a2]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000a95c:	c8 3f       	ld.a %a15,[%a15]12
8000a95e:	68 02       	st.w [%a15]0,%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000a960:	6d 00 03 00 	call 8000a966 <osEE_change_context_from_running>
8000a964:	00 90       	ret 

8000a966 <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a966:	40 ae       	mov.aa %a14,%sp
8000a968:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a96a:	99 52 0c 00 	ld.a %a2,[%a5]12
8000a96e:	0c 22       	ld.bu %d15,[%a2]2
8000a970:	5e 28       	jne %d15,2,8000a980 <osEE_change_context_from_running+0x1a>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000a972:	40 54       	mov.aa %a4,%a5
8000a974:	99 55 04 00 	ld.a %a5,[%a5]4
8000a978:	c8 16       	ld.a %a6,[%a15]4
8000a97a:	6d 00 73 00 	call 8000aa60 <osEE_hal_save_ctx_and_restore_ctx>
8000a97e:	00 90       	ret 
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
8000a980:	40 54       	mov.aa %a4,%a5
8000a982:	99 55 04 00 	ld.a %a5,[%a5]4
8000a986:	c8 16       	ld.a %a6,[%a15]4
8000a988:	6d 00 8b 00 	call 8000aa9e <osEE_hal_save_ctx_and_ready2stacked>
8000a98c:	00 90       	ret 

8000a98e <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a98e:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a990:	cc 53       	ld.a %a15,[%a5]12
8000a992:	0c f2       	ld.bu %d15,[%a15]2
8000a994:	5e 27       	jne %d15,2,8000a9a2 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000a996:	40 54       	mov.aa %a4,%a5
8000a998:	99 55 04 00 	ld.a %a5,[%a5]4
8000a99c:	6d 00 74 00 	call 8000aa84 <osEE_hal_restore_ctx>
8000a9a0:	00 90       	ret 
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
8000a9a2:	40 54       	mov.aa %a4,%a5
8000a9a4:	99 55 04 00 	ld.a %a5,[%a5]4
8000a9a8:	6d 00 8d 00 	call 8000aac2 <osEE_hal_ready2stacked>
8000a9ac:	00 90       	ret 

8000a9ae <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
8000a9ae:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
8000a9b0:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000a9b4:	cc 40       	ld.a %a15,[%a4]0
8000a9b6:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000a9b8:	cc 50       	ld.a %a15,[%a5]0
8000a9ba:	3c 02       	j 8000a9be <osEE_idle_task_terminate+0x10>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000a9bc:	60 ff       	mov.a %a15,%d15
8000a9be:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
8000a9c0:	8b 0f 20 22 	ne %d2,%d15,0
8000a9c4:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000a9c8:	df 02 fa ff 	jne %d2,0,8000a9bc <osEE_idle_task_terminate+0xe>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000a9cc:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
8000a9ce:	6d 00 5b 00 	call 8000aa84 <osEE_hal_restore_ctx>
8000a9d2:	00 90       	ret 

8000a9d4 <osEE_cpu_startos>:
}
#endif /* OSEE_SINGLECORE */
#endif /* OSEE_TC_HAS_ISR1_TO_CONF */

OsEE_bool osEE_cpu_startos(void)
{
8000a9d4:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000a9d6:	4d c0 e1 5f 	mfcr %d5,$core_id
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000a9da:	91 00 00 f8 	movh.a %a15,32768
8000a9de:	d9 ff 18 20 	lea %a15,[%a15]152 <80000098 <osEE_kdb_var>>
8000a9e2:	c8 2f       	ld.a %a15,[%a15]8
8000a9e4:	b0 ff       	add.a %a15,-1
  for (i = 0U; i < tdb_size; ++i) {
8000a9e6:	bd 0f 2a 00 	jz.a %a15,8000aa3a <osEE_cpu_startos+0x66>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000a9ea:	91 00 00 28 	movh.a %a2,32768
8000a9ee:	d9 22 18 20 	lea %a2,[%a2]152 <80000098 <osEE_kdb_var>>
8000a9f2:	19 23 04 00 	ld.w %d3,[%a2]4 <80000004 <BootModeHeader0+0x4>>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000a9f6:	8f 35 00 51 	and %d5,%d5,3
8000a9fa:	8f b5 00 50 	sh %d5,%d5,11
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000a9fe:	bb f0 ff 4f 	mov.u %d4,65535
8000aa02:	82 0f       	mov %d15,0
8000aa04:	b0 ff       	add.a %a15,-1
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000aa06:	60 33       	mov.a %a3,%d3
8000aa08:	90 32       	addsc.a %a2,%a3,%d15,2
8000aa0a:	d4 22       	ld.a %a2,[%a2]
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000aa0c:	39 22 14 00 	ld.bu %d2,[%a2]20
8000aa10:	df 22 12 80 	jne %d2,2,8000aa34 <osEE_cpu_startos+0x60>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000aa14:	b9 22 08 00 	ld.hu %d2,[%a2]8
8000aa18:	5f 42 0e 00 	jeq %d2,%d4,8000aa34 <osEE_cpu_startos+0x60>
8000aa1c:	60 24       	mov.a %a4,%d2
8000aa1e:	d9 43 00 08 	lea %a3,[%a4]-32768
8000aa22:	11 43 00 3f 	addih.a %a3,%a3,61444
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000aa26:	39 22 1c 00 	ld.bu %d2,[%a2]28
8000aa2a:	c2 12       	add %d2,1
8000aa2c:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000aa30:	a6 52       	or %d2,%d5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000aa32:	74 32       	st.w [%a3],%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000aa34:	c2 1f       	add %d15,1
8000aa36:	fd f0 e8 7f 	loop %a15,8000aa06 <osEE_cpu_startos+0x32>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000aa3a:	82 12       	mov %d2,1
8000aa3c:	00 90       	ret 

8000aa3e <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000aa3e:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000aa42:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000aa44:	0c 22       	ld.bu %d15,[%a2]2
8000aa46:	1e 27       	jeq %d15,2,8000aa54 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000aa48:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000aa4a:	c8 1f       	ld.a %a15,[%a15]4
8000aa4c:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
8000aa4e:	1d 00 3a 00 	j 8000aac2 <osEE_hal_ready2stacked>
8000aa52:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
8000aa54:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000aa56:	c8 1f       	ld.a %a15,[%a15]4
8000aa58:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000aa5a:	1d 00 15 00 	j 8000aa84 <osEE_hal_restore_ctx>
8000aa5e:	00 90       	ret 

8000aa60 <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000aa60:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000aa62:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000aa66:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000aa68:	4c 60       	ld.w %d15,[%a6]0
8000aa6a:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000aa6e:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000aa72:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000aa76:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000aa78:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000aa7c:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
8000aa7e:	1d 00 03 00 	j 8000aa84 <osEE_hal_restore_ctx>
8000aa82:	00 90       	ret 

8000aa84 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
8000aa84:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000aa86:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
8000aa88:	4c f2       	ld.w %d15,[%a15]8
8000aa8a:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000aa8c:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000aa90:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
8000aa94:	4c f0       	ld.w %d15,[%a15]0
8000aa96:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
8000aa98:	1d ff 69 fd 	j 8000a56a <osEE_scheduler_task_wrapper_restore>
8000aa9c:	00 90       	ret 

8000aa9e <osEE_hal_save_ctx_and_ready2stacked>:
8000aa9e:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000aaa0:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000aaa4:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000aaa6:	4c 60       	ld.w %d15,[%a6]0
8000aaa8:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000aaac:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000aab0:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000aab4:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000aab6:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000aaba:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
8000aabc:	1d 00 03 00 	j 8000aac2 <osEE_hal_ready2stacked>
8000aac0:	00 90       	ret 

8000aac2 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000aac2:	cc 50       	ld.a %a15,[%a5]0
8000aac4:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
8000aac6:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000aaca:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000aacc:	d9 f2 f0 ff 	lea %a2,[%a15]-16
8000aad0:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000aad2:	4c 50       	ld.w %d15,[%a5]0
8000aad4:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000aad8:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000aadc:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000aae0:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000aae2:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000aae6:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000aae8:	1d ff 46 fd 	j 8000a574 <osEE_scheduler_task_wrapper_run>
8000aaec:	00 90       	ret 

8000aaee <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
8000aaee:	4d 40 e0 ff 	mfcr %d15,$psw
8000aaf2:	8f ff c7 f1 	andn %d15,%d15,127
8000aaf6:	cd 4f e0 0f 	mtcr $psw,%d15
8000aafa:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000aafe:	91 10 00 f8 	movh.a %a15,32769
8000ab02:	d9 ff be 8a 	lea %a15,[%a15]-21954 <8000aa3e <osEE_tc_change_context_from_task_end>>
8000ab06:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000ab08:	00 80       	rfe 
8000ab0a:	00 90       	ret 

8000ab0c <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000ab0c:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
8000ab0e:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000ab12:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
8000ab16:	cc 40       	ld.a %a15,[%a4]0
8000ab18:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000ab1a:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000ab1e:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000ab22:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000ab24:	8f c3 01 30 	sh %d3,%d3,28
8000ab28:	a6 43       	or %d3,%d4
8000ab2a:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000ab2c:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
8000ab2e:	bc f3       	jz.a %a15,8000ab34 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
8000ab30:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
8000ab32:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
8000ab34:	cd 8f e3 0f 	mtcr $fcx,%d15
8000ab38:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000ab3c:	cd 03 e0 0f 	mtcr $pcxi,%d3
8000ab40:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
8000ab44:	cc 40       	ld.a %a15,[%a4]0
8000ab46:	4c f0       	ld.w %d15,[%a15]0
8000ab48:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000ab4a:	91 00 00 48 	movh.a %a4,32768
8000ab4e:	d9 44 18 20 	lea %a4,[%a4]152 <80000098 <osEE_kdb_var>>
8000ab52:	d9 a5 04 00 	lea %a5,[%sp]4 <80000098 <osEE_kdb_var>>
8000ab56:	6d ff 91 fe 	call 8000a878 <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000ab5a:	d8 01       	ld.a %a15,[%sp]4
8000ab5c:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000ab60:	1e 25       	jeq %d15,2,8000ab6a <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
8000ab62:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
8000ab64:	1d ff 6d ff 	j 8000aa3e <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000ab68:	3c 00       	j 8000ab68 <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000ab6a:	40 24       	mov.aa %a4,%a2
8000ab6c:	6d ff c1 ff 	call 8000aaee <osEE_tc_change_context_from_isr2_end>
8000ab70:	3c fc       	j 8000ab68 <osEE_hal_terminate_ctx+0x5c>

8000ab72 <__lshrdi3>:
8000ab72:	6f 56 0c 80 	jnz.t %d6,5,8000ab8a <__lshrdi3+0x18>
8000ab76:	8b 06 02 71 	rsub %d7,%d6,32
8000ab7a:	32 56       	rsub %d6
8000ab7c:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
8000ab80:	0f 65 00 30 	sh %d3,%d5,%d6
8000ab84:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
8000ab88:	00 90       	ret 
8000ab8a:	8b 06 02 60 	add %d6,%d6,32
8000ab8e:	32 56       	rsub %d6
8000ab90:	0f 65 00 20 	sh %d2,%d5,%d6
8000ab94:	82 03       	mov %d3,0
8000ab96:	00 90       	ret 

8000ab98 <__extendsfdf2>:
8000ab98:	20 20       	sub.a %sp,32
8000ab9a:	d9 a4 20 00 	lea %a4,[%sp]32
8000ab9e:	89 44 2c f5 	st.w [+%a4]-20,%d4
8000aba2:	d9 a5 10 00 	lea %a5,[%sp]16
8000aba6:	6d 00 d8 02 	call 8000b156 <__unpack_f>
8000abaa:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000abae:	39 a4 10 00 	ld.bu %d4,[%sp]16
8000abb2:	8f e2 1f f0 	sh %d15,%d2,-2
8000abb6:	8f e2 01 20 	sh %d2,%d2,30
8000abba:	74 a2       	st.w [%sp],%d2
8000abbc:	78 01       	st.w [%sp]4,%d15
8000abbe:	19 a5 14 00 	ld.w %d5,[%sp]20
8000abc2:	19 a6 18 00 	ld.w %d6,[%sp]24
8000abc6:	1d 00 8e 02 	j 8000b0e2 <__make_dp>

8000abca <_fpadd_parts>:
8000abca:	0c 40       	ld.bu %d15,[%a4]0
8000abcc:	40 42       	mov.aa %a2,%a4
8000abce:	bf 2f cb 80 	jlt.u %d15,2,8000ad64 <_fpadd_parts+0x19a>
8000abd2:	14 52       	ld.bu %d2,[%a5]
8000abd4:	40 52       	mov.aa %a2,%a5
8000abd6:	bf 22 c7 80 	jlt.u %d2,2,8000ad64 <_fpadd_parts+0x19a>
8000abda:	5e 4e       	jne %d15,4,8000abf6 <_fpadd_parts+0x2c>
8000abdc:	40 42       	mov.aa %a2,%a4
8000abde:	df 42 c3 80 	jne %d2,4,8000ad64 <_fpadd_parts+0x19a>
8000abe2:	19 42 04 00 	ld.w %d2,[%a4]4
8000abe6:	4c 51       	ld.w %d15,[%a5]4
8000abe8:	5f f2 be 00 	jeq %d2,%d15,8000ad64 <_fpadd_parts+0x19a>
8000abec:	91 00 00 f8 	movh.a %a15,32768
8000abf0:	d9 f2 d0 e0 	lea %a2,[%a15]3984 <80000f90 <__thenan_df>>
8000abf4:	00 90       	ret 
8000abf6:	40 52       	mov.aa %a2,%a5
8000abf8:	df 42 b6 00 	jeq %d2,4,8000ad64 <_fpadd_parts+0x19a>
8000abfc:	df 22 11 80 	jne %d2,2,8000ac1e <_fpadd_parts+0x54>
8000ac00:	40 42       	mov.aa %a2,%a4
8000ac02:	df 2f b1 80 	jne %d15,2,8000ad64 <_fpadd_parts+0x19a>
8000ac06:	40 63       	mov.aa %a3,%a6
8000ac08:	a0 4f       	mov.a %a15,4
8000ac0a:	44 4f       	ld.w %d15,[%a4+]
8000ac0c:	64 3f       	st.w [%a3+],%d15
8000ac0e:	fc fe       	loop %a15,8000ac0a <_fpadd_parts+0x40>
8000ac10:	4c 21       	ld.w %d15,[%a2]4
8000ac12:	19 52 04 00 	ld.w %d2,[%a5]4
8000ac16:	40 62       	mov.aa %a2,%a6
8000ac18:	26 2f       	and %d15,%d2
8000ac1a:	6c 61       	st.w [%a6]4,%d15
8000ac1c:	00 90       	ret 
8000ac1e:	40 52       	mov.aa %a2,%a5
8000ac20:	df 2f a2 00 	jeq %d15,2,8000ad64 <_fpadd_parts+0x19a>
8000ac24:	4c 42       	ld.w %d15,[%a4]8
8000ac26:	19 52 08 00 	ld.w %d2,[%a5]8
8000ac2a:	40 6f       	mov.aa %a15,%a6
8000ac2c:	52 23       	sub %d3,%d15,%d2
8000ac2e:	0b 30 c0 c1 	abs %d12,%d3
8000ac32:	8b 0c 84 42 	ge %d4,%d12,64
8000ac36:	40 5c       	mov.aa %a12,%a5
8000ac38:	40 4d       	mov.aa %a13,%a4
8000ac3a:	09 4a 4c 09 	ld.d %e10,[%a4]12
8000ac3e:	09 58 4c 09 	ld.d %e8,[%a5]12
8000ac42:	df 04 35 80 	jne %d4,0,8000acac <_fpadd_parts+0xe2>
8000ac46:	bf 13 19 00 	jlt %d3,1,8000ac78 <_fpadd_parts+0xae>
8000ac4a:	0b 89 10 48 	mov %e4,%d9,%d8
8000ac4e:	02 c6       	mov %d6,%d12
8000ac50:	6d ff 91 ff 	call 8000ab72 <__lshrdi3>
8000ac54:	d2 14       	mov %e4,1
8000ac56:	02 c6       	mov %d6,%d12
8000ac58:	02 2e       	mov %d14,%d2
8000ac5a:	02 3d       	mov %d13,%d3
8000ac5c:	6d 00 70 02 	call 8000b13c <__ashldi3>
8000ac60:	8b f2 9f 20 	addx %d2,%d2,-1
8000ac64:	8b f3 bf 30 	addc %d3,%d3,-1
8000ac68:	26 82       	and %d2,%d8
8000ac6a:	26 93       	and %d3,%d9
8000ac6c:	a6 23       	or %d3,%d2
8000ac6e:	02 e8       	mov %d8,%d14
8000ac70:	8b 03 00 85 	or.ne %d8,%d3,0
8000ac74:	02 d9       	mov %d9,%d13
8000ac76:	3c 21       	j 8000acb8 <_fpadd_parts+0xee>
8000ac78:	df 03 20 00 	jeq %d3,0,8000acb8 <_fpadd_parts+0xee>
8000ac7c:	0b ab 10 48 	mov %e4,%d11,%d10
8000ac80:	02 c6       	mov %d6,%d12
8000ac82:	6d ff 78 ff 	call 8000ab72 <__lshrdi3>
8000ac86:	d2 14       	mov %e4,1
8000ac88:	02 c6       	mov %d6,%d12
8000ac8a:	02 2e       	mov %d14,%d2
8000ac8c:	02 3d       	mov %d13,%d3
8000ac8e:	6d 00 57 02 	call 8000b13c <__ashldi3>
8000ac92:	8b f2 9f 20 	addx %d2,%d2,-1
8000ac96:	8b f3 bf 30 	addc %d3,%d3,-1
8000ac9a:	26 a2       	and %d2,%d10
8000ac9c:	26 b3       	and %d3,%d11
8000ac9e:	a6 23       	or %d3,%d2
8000aca0:	02 ea       	mov %d10,%d14
8000aca2:	42 cf       	add %d15,%d12
8000aca4:	8b 03 00 a5 	or.ne %d10,%d3,0
8000aca8:	02 db       	mov %d11,%d13
8000acaa:	3c 07       	j 8000acb8 <_fpadd_parts+0xee>
8000acac:	3f f2 05 00 	jlt %d2,%d15,8000acb6 <_fpadd_parts+0xec>
8000acb0:	02 2f       	mov %d15,%d2
8000acb2:	d2 0a       	mov %e10,0
8000acb4:	3c 02       	j 8000acb8 <_fpadd_parts+0xee>
8000acb6:	d2 08       	mov %e8,0
8000acb8:	19 d4 04 00 	ld.w %d4,[%a13]4
8000acbc:	19 c2 04 00 	ld.w %d2,[%a12]4
8000acc0:	5f 24 34 00 	jeq %d4,%d2,8000ad28 <_fpadd_parts+0x15e>
8000acc4:	0b 8a c0 20 	subx %d2,%d10,%d8
8000acc8:	0b 9b d0 30 	subc %d3,%d11,%d9
8000accc:	76 45       	jz %d4,8000acd6 <_fpadd_parts+0x10c>
8000acce:	0b a8 c0 20 	subx %d2,%d8,%d10
8000acd2:	0b b9 d0 30 	subc %d3,%d9,%d11
8000acd6:	0e 37       	jltz %d3,8000ace4 <_fpadd_parts+0x11a>
8000acd8:	82 04       	mov %d4,0
8000acda:	68 14       	st.w [%a15]4,%d4
8000acdc:	68 2f       	st.w [%a15]8,%d15
8000acde:	89 f2 4c 09 	st.d [%a15]12,%e2
8000ace2:	3c 0c       	j 8000acfa <_fpadd_parts+0x130>
8000ace4:	68 2f       	st.w [%a15]8,%d15
8000ace6:	8b 03 00 f1 	rsub %d15,%d3,0
8000acea:	82 14       	mov %d4,1
8000acec:	8b 02 00 31 	rsub %d3,%d2,0
8000acf0:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
8000acf4:	68 14       	st.w [%a15]4,%d4
8000acf6:	68 33       	st.w [%a15]12,%d3
8000acf8:	68 4f       	st.w [%a15]16,%d15
8000acfa:	82 f5       	mov %d5,-1
8000acfc:	06 c5       	sh %d5,-4
8000acfe:	48 32       	ld.w %d2,[%a15]12
8000ad00:	48 43       	ld.w %d3,[%a15]16
8000ad02:	8b f2 9f 60 	addx %d6,%d2,-1
8000ad06:	8b f3 bf 40 	addc %d4,%d3,-1
8000ad0a:	3a 54       	eq %d15,%d4,%d5
8000ad0c:	8b f6 3f f4 	and.ne %d15,%d6,-1
8000ad10:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
8000ad14:	6e 12       	jz %d15,8000ad38 <_fpadd_parts+0x16e>
8000ad16:	4c f2       	ld.w %d15,[%a15]8
8000ad18:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000ad1c:	c2 ff       	add %d15,-1
8000ad1e:	06 12       	sh %d2,1
8000ad20:	68 32       	st.w [%a15]12,%d2
8000ad22:	68 43       	st.w [%a15]16,%d3
8000ad24:	68 2f       	st.w [%a15]8,%d15
8000ad26:	3c ec       	j 8000acfe <_fpadd_parts+0x134>
8000ad28:	0b a8 40 20 	addx %d2,%d8,%d10
8000ad2c:	68 2f       	st.w [%a15]8,%d15
8000ad2e:	0b b9 50 f0 	addc %d15,%d9,%d11
8000ad32:	68 14       	st.w [%a15]4,%d4
8000ad34:	68 32       	st.w [%a15]12,%d2
8000ad36:	68 4f       	st.w [%a15]16,%d15
8000ad38:	82 3f       	mov %d15,3
8000ad3a:	28 0f       	st.b [%a15]0,%d15
8000ad3c:	4c f4       	ld.w %d15,[%a15]16
8000ad3e:	7b 00 00 42 	movh %d4,8192
8000ad42:	0b 4f 30 31 	lt.u %d3,%d15,%d4
8000ad46:	48 32       	ld.w %d2,[%a15]12
8000ad48:	40 f2       	mov.aa %a2,%a15
8000ad4a:	f6 3d       	jnz %d3,8000ad64 <_fpadd_parts+0x19a>
8000ad4c:	8f 12 00 31 	and %d3,%d2,1
8000ad50:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
8000ad54:	06 ff       	sh %d15,-1
8000ad56:	96 00       	or %d15,0
8000ad58:	68 4f       	st.w [%a15]16,%d15
8000ad5a:	4c f2       	ld.w %d15,[%a15]8
8000ad5c:	a6 32       	or %d2,%d3
8000ad5e:	c2 1f       	add %d15,1
8000ad60:	68 32       	st.w [%a15]12,%d2
8000ad62:	68 2f       	st.w [%a15]8,%d15
8000ad64:	00 90       	ret 

8000ad66 <__adddf3>:
8000ad66:	20 50       	sub.a %sp,80
8000ad68:	d9 a4 04 00 	lea %a4,[%sp]4
8000ad6c:	d9 a5 14 00 	lea %a5,[%sp]20
8000ad70:	89 a4 44 09 	st.d [%sp]4,%e4
8000ad74:	89 a6 4c 09 	st.d [%sp]12,%e6
8000ad78:	6d 00 c0 02 	call 8000b2f8 <__unpack_d>
8000ad7c:	d9 a4 0c 00 	lea %a4,[%sp]12
8000ad80:	d9 a5 28 00 	lea %a5,[%sp]40
8000ad84:	6d 00 ba 02 	call 8000b2f8 <__unpack_d>
8000ad88:	d9 a4 14 00 	lea %a4,[%sp]20
8000ad8c:	d9 a5 28 00 	lea %a5,[%sp]40
8000ad90:	d9 a6 3c 00 	lea %a6,[%sp]60
8000ad94:	6d ff 1b ff 	call 8000abca <_fpadd_parts>
8000ad98:	40 24       	mov.aa %a4,%a2
8000ad9a:	1d 00 26 02 	j 8000b1e6 <__pack_d>

8000ad9e <__subdf3>:
8000ad9e:	20 50       	sub.a %sp,80
8000ada0:	d9 a4 04 00 	lea %a4,[%sp]4
8000ada4:	d9 a5 14 00 	lea %a5,[%sp]20
8000ada8:	89 a4 44 09 	st.d [%sp]4,%e4
8000adac:	89 a6 4c 09 	st.d [%sp]12,%e6
8000adb0:	6d 00 a4 02 	call 8000b2f8 <__unpack_d>
8000adb4:	d9 a4 0c 00 	lea %a4,[%sp]12
8000adb8:	d9 a5 28 00 	lea %a5,[%sp]40
8000adbc:	6d 00 9e 02 	call 8000b2f8 <__unpack_d>
8000adc0:	58 0b       	ld.w %d15,[%sp]44
8000adc2:	d9 a4 14 00 	lea %a4,[%sp]20
8000adc6:	8f 1f 80 f1 	xor %d15,%d15,1
8000adca:	d9 a5 28 00 	lea %a5,[%sp]40
8000adce:	d9 a6 3c 00 	lea %a6,[%sp]60
8000add2:	78 0b       	st.w [%sp]44,%d15
8000add4:	6d ff fb fe 	call 8000abca <_fpadd_parts>
8000add8:	40 24       	mov.aa %a4,%a2
8000adda:	1d 00 06 02 	j 8000b1e6 <__pack_d>

8000adde <__muldf3>:
8000adde:	20 50       	sub.a %sp,80
8000ade0:	d9 a4 04 00 	lea %a4,[%sp]4
8000ade4:	d9 a5 14 00 	lea %a5,[%sp]20
8000ade8:	89 a4 44 09 	st.d [%sp]4,%e4
8000adec:	89 a6 4c 09 	st.d [%sp]12,%e6
8000adf0:	6d 00 84 02 	call 8000b2f8 <__unpack_d>
8000adf4:	d9 a4 0c 00 	lea %a4,[%sp]12
8000adf8:	d9 a5 28 00 	lea %a5,[%sp]40
8000adfc:	6d 00 7e 02 	call 8000b2f8 <__unpack_d>
8000ae00:	39 a3 14 00 	ld.bu %d3,[%sp]20
8000ae04:	ff 23 0c 80 	jge.u %d3,2,8000ae1c <__muldf3+0x3e>
8000ae08:	19 a2 18 00 	ld.w %d2,[%sp]24
8000ae0c:	58 0b       	ld.w %d15,[%sp]44
8000ae0e:	d9 a4 14 00 	lea %a4,[%sp]20
8000ae12:	0b f2 10 f1 	ne %d15,%d2,%d15
8000ae16:	78 06       	st.w [%sp]24,%d15
8000ae18:	1d 00 b3 00 	j 8000af7e <__muldf3+0x1a0>
8000ae1c:	39 af 28 00 	ld.bu %d15,[%sp]40
8000ae20:	ff 2f 0c 80 	jge.u %d15,2,8000ae38 <__muldf3+0x5a>
8000ae24:	58 0b       	ld.w %d15,[%sp]44
8000ae26:	19 a2 18 00 	ld.w %d2,[%sp]24
8000ae2a:	d9 a4 28 00 	lea %a4,[%sp]40
8000ae2e:	0b f2 10 f1 	ne %d15,%d2,%d15
8000ae32:	78 0b       	st.w [%sp]44,%d15
8000ae34:	1d 00 a5 00 	j 8000af7e <__muldf3+0x1a0>
8000ae38:	df 43 09 80 	jne %d3,4,8000ae4a <__muldf3+0x6c>
8000ae3c:	91 00 00 48 	movh.a %a4,32768
8000ae40:	d9 44 d0 e0 	lea %a4,[%a4]3984 <80000f90 <__thenan_df>>
8000ae44:	df 2f 9d 00 	jeq %d15,2,8000af7e <__muldf3+0x1a0>
8000ae48:	3c e0       	j 8000ae08 <__muldf3+0x2a>
8000ae4a:	5e 48       	jne %d15,4,8000ae5a <__muldf3+0x7c>
8000ae4c:	91 00 00 48 	movh.a %a4,32768
8000ae50:	d9 44 d0 e0 	lea %a4,[%a4]3984 <80000f90 <__thenan_df>>
8000ae54:	df 23 95 00 	jeq %d3,2,8000af7e <__muldf3+0x1a0>
8000ae58:	3c e6       	j 8000ae24 <__muldf3+0x46>
8000ae5a:	df 23 d7 7f 	jeq %d3,2,8000ae08 <__muldf3+0x2a>
8000ae5e:	df 2f e3 7f 	jeq %d15,2,8000ae24 <__muldf3+0x46>
8000ae62:	58 08       	ld.w %d15,[%sp]32
8000ae64:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
8000ae68:	d2 00       	mov %e0,0
8000ae6a:	19 a0 34 00 	ld.w %d0,[%sp]52
8000ae6e:	73 bf 68 60 	mul.u %e6,%d15,%d11
8000ae72:	82 0c       	mov %d12,0
8000ae74:	73 0f 68 40 	mul.u %e4,%d15,%d0
8000ae78:	19 aa 24 00 	ld.w %d10,[%sp]36
8000ae7c:	82 02       	mov %d2,0
8000ae7e:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
8000ae82:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
8000ae86:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
8000ae8a:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
8000ae8e:	82 0d       	mov %d13,0
8000ae90:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
8000ae94:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
8000ae98:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
8000ae9c:	0b 54 10 08 	mov %e0,%d4,%d5
8000aea0:	42 20       	add %d0,%d2
8000aea2:	3a 73       	eq %d15,%d3,%d7
8000aea4:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
8000aea8:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
8000aeac:	8b 0f 00 62 	eq %d6,%d15,0
8000aeb0:	3a 50       	eq %d15,%d0,%d5
8000aeb2:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
8000aeb6:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
8000aeba:	ba 0f       	eq %d15,%d15,0
8000aebc:	53 1f 40 40 	mul.u %e4,%d15,1
8000aec0:	02 38       	mov %d8,%d3
8000aec2:	82 09       	mov %d9,0
8000aec4:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
8000aec8:	02 5f       	mov %d15,%d5
8000aeca:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
8000aece:	42 6f       	add %d15,%d6
8000aed0:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
8000aed4:	0b 4f 10 68 	mov %e6,%d15,%d4
8000aed8:	0b 62 40 40 	addx %d4,%d2,%d6
8000aedc:	0b 73 50 20 	addc %d2,%d3,%d7
8000aee0:	58 07       	ld.w %d15,[%sp]28
8000aee2:	19 a3 30 00 	ld.w %d3,[%sp]48
8000aee6:	19 a5 18 00 	ld.w %d5,[%sp]24
8000aeea:	42 3f       	add %d15,%d3
8000aeec:	19 a3 2c 00 	ld.w %d3,[%sp]44
8000aef0:	c2 4f       	add %d15,4
8000aef2:	0b 35 10 31 	ne %d3,%d5,%d3
8000aef6:	59 a3 00 10 	st.w [%sp]64,%d3
8000aefa:	7b 00 00 52 	movh %d5,8192
8000aefe:	0b 52 50 31 	ge.u %d3,%d2,%d5
8000af02:	df 03 1b 00 	jeq %d3,0,8000af38 <__muldf3+0x15a>
8000af06:	8f 14 00 31 	and %d3,%d4,1
8000af0a:	76 37       	jz %d3,8000af18 <__muldf3+0x13a>
8000af0c:	8f f0 1f 30 	sh %d3,%d0,-1
8000af10:	77 10 80 1f 	dextr %d1,%d0,%d1,31
8000af14:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
8000af18:	77 42 80 4f 	dextr %d4,%d2,%d4,31
8000af1c:	c2 1f       	add %d15,1
8000af1e:	06 f2       	sh %d2,-1
8000af20:	3c ed       	j 8000aefa <__muldf3+0x11c>
8000af22:	77 42 80 20 	dextr %d2,%d2,%d4,1
8000af26:	06 14       	sh %d4,1
8000af28:	ce 04       	jgez %d0,8000af30 <__muldf3+0x152>
8000af2a:	8f 14 40 51 	or %d5,%d4,1
8000af2e:	02 54       	mov %d4,%d5
8000af30:	77 10 80 00 	dextr %d0,%d0,%d1,1
8000af34:	c2 ff       	add %d15,-1
8000af36:	06 11       	sh %d1,1
8000af38:	7b 00 00 51 	movh %d5,4096
8000af3c:	0b 52 30 31 	lt.u %d3,%d2,%d5
8000af40:	df 03 f1 ff 	jne %d3,0,8000af22 <__muldf3+0x144>
8000af44:	78 11       	st.w [%sp]68,%d15
8000af46:	02 4f       	mov %d15,%d4
8000af48:	16 ff       	and %d15,255
8000af4a:	8b 0f 28 f2 	ne %d15,%d15,128
8000af4e:	ee 0f       	jnz %d15,8000af6c <__muldf3+0x18e>
8000af50:	a6 10       	or %d0,%d1
8000af52:	77 42 00 fc 	dextr %d15,%d2,%d4,24
8000af56:	8b 00 20 02 	ne %d0,%d0,0
8000af5a:	0f f0 e0 00 	andn %d0,%d0,%d15
8000af5e:	76 07       	jz %d0,8000af6c <__muldf3+0x18e>
8000af60:	8b 04 88 40 	addx %d4,%d4,128
8000af64:	8b 02 a0 20 	addc %d2,%d2,0
8000af68:	8f f4 cf 41 	andn %d4,%d4,255
8000af6c:	d9 a4 10 10 	lea %a4,[%sp]80
8000af70:	82 3f       	mov %d15,3
8000af72:	59 a4 08 10 	st.w [%sp]72,%d4
8000af76:	59 a2 0c 10 	st.w [%sp]76,%d2
8000af7a:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <IfxAsclin1_TX_P33_13_OUT+0xc>>,%d15
8000af7e:	1d 00 34 01 	j 8000b1e6 <__pack_d>

8000af82 <__divdf3>:
8000af82:	20 38       	sub.a %sp,56
8000af84:	40 a4       	mov.aa %a4,%sp
8000af86:	d9 a5 10 00 	lea %a5,[%sp]16
8000af8a:	89 a4 40 09 	st.d [%sp],%e4
8000af8e:	89 a6 48 09 	st.d [%sp]8,%e6
8000af92:	6d 00 b3 01 	call 8000b2f8 <__unpack_d>
8000af96:	d9 a4 08 00 	lea %a4,[%sp]8
8000af9a:	d9 a5 24 00 	lea %a5,[%sp]36
8000af9e:	6d 00 ad 01 	call 8000b2f8 <__unpack_d>
8000afa2:	39 a2 10 00 	ld.bu %d2,[%sp]16
8000afa6:	bf 22 76 80 	jlt.u %d2,2,8000b092 <__divdf3+0x110>
8000afaa:	39 af 24 00 	ld.bu %d15,[%sp]36
8000afae:	d9 a4 24 00 	lea %a4,[%sp]36
8000afb2:	bf 2f 72 80 	jlt.u %d15,2,8000b096 <__divdf3+0x114>
8000afb6:	19 a4 14 00 	ld.w %d4,[%sp]20
8000afba:	19 a3 28 00 	ld.w %d3,[%sp]40
8000afbe:	c6 43       	xor %d3,%d4
8000afc0:	59 a3 14 00 	st.w [%sp]20,%d3
8000afc4:	1b e2 ff 3f 	addi %d3,%d2,-2
8000afc8:	8f d3 0f 31 	and %d3,%d3,253
8000afcc:	f6 38       	jnz %d3,8000afdc <__divdf3+0x5a>
8000afce:	91 00 00 48 	movh.a %a4,32768
8000afd2:	d9 44 d0 e0 	lea %a4,[%a4]3984 <80000f90 <__thenan_df>>
8000afd6:	5f f2 5e 80 	jne %d2,%d15,8000b092 <__divdf3+0x110>
8000afda:	3c 5e       	j 8000b096 <__divdf3+0x114>
8000afdc:	5e 47       	jne %d15,4,8000afea <__divdf3+0x68>
8000afde:	d2 02       	mov %e2,0
8000afe0:	82 0f       	mov %d15,0
8000afe2:	89 a2 5c 09 	st.d [%sp]28,%e2
8000afe6:	78 06       	st.w [%sp]24,%d15
8000afe8:	3c 55       	j 8000b092 <__divdf3+0x110>
8000afea:	5e 25       	jne %d15,2,8000aff4 <__divdf3+0x72>
8000afec:	82 4f       	mov %d15,4
8000afee:	e9 af 10 00 	st.b [%sp]16,%d15
8000aff2:	3c 50       	j 8000b092 <__divdf3+0x110>
8000aff4:	58 06       	ld.w %d15,[%sp]24
8000aff6:	09 a2 5c 09 	ld.d %e2,[%sp]28
8000affa:	09 a4 70 09 	ld.d %e4,[%sp]48
8000affe:	19 a6 2c 00 	ld.w %d6,[%sp]44
8000b002:	52 66       	sub %d6,%d15,%d6
8000b004:	3a 53       	eq %d15,%d3,%d5
8000b006:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
8000b00a:	59 a6 18 00 	st.w [%sp]24,%d6
8000b00e:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
8000b012:	ee 07       	jnz %d15,8000b020 <__divdf3+0x9e>
8000b014:	c2 f6       	add %d6,-1
8000b016:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000b01a:	59 a6 18 00 	st.w [%sp]24,%d6
8000b01e:	06 12       	sh %d2,1
8000b020:	82 01       	mov %d1,0
8000b022:	7b 00 00 f1 	movh %d15,4096
8000b026:	82 00       	mov %d0,0
8000b028:	82 07       	mov %d7,0
8000b02a:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
8000b02e:	0b 53 00 61 	eq %d6,%d3,%d5
8000b032:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8000b036:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8000b03a:	f6 6b       	jnz %d6,8000b050 <__divdf3+0xce>
8000b03c:	0f 10 a0 80 	or %d8,%d0,%d1
8000b040:	0f f7 a0 60 	or %d6,%d7,%d15
8000b044:	0b 42 c0 20 	subx %d2,%d2,%d4
8000b048:	02 80       	mov %d0,%d8
8000b04a:	02 67       	mov %d7,%d6
8000b04c:	0b 53 d0 30 	subc %d3,%d3,%d5
8000b050:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
8000b054:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000b058:	06 ff       	sh %d15,-1
8000b05a:	06 12       	sh %d2,1
8000b05c:	fd f0 e9 7f 	loop %a15,8000b02e <__divdf3+0xac>
8000b060:	02 0f       	mov %d15,%d0
8000b062:	16 ff       	and %d15,255
8000b064:	8b 0f 28 f2 	ne %d15,%d15,128
8000b068:	0b 70 10 48 	mov %e4,%d0,%d7
8000b06c:	ee 0f       	jnz %d15,8000b08a <__divdf3+0x108>
8000b06e:	a6 32       	or %d2,%d3
8000b070:	77 07 00 fc 	dextr %d15,%d7,%d0,24
8000b074:	8b 02 20 22 	ne %d2,%d2,0
8000b078:	0f f2 e0 20 	andn %d2,%d2,%d15
8000b07c:	76 27       	jz %d2,8000b08a <__divdf3+0x108>
8000b07e:	8b 00 88 00 	addx %d0,%d0,128
8000b082:	8b 07 a0 40 	addc %d4,%d7,0
8000b086:	8f f0 cf 51 	andn %d5,%d0,255
8000b08a:	59 a5 1c 00 	st.w [%sp]28,%d5
8000b08e:	59 a4 20 00 	st.w [%sp]32,%d4
8000b092:	d9 a4 10 00 	lea %a4,[%sp]16
8000b096:	1d 00 a8 00 	j 8000b1e6 <__pack_d>

8000b09a <__floatsidf>:
8000b09a:	20 18       	sub.a %sp,24
8000b09c:	82 3f       	mov %d15,3
8000b09e:	2c a4       	st.b [%sp]4,%d15
8000b0a0:	8f 14 1e f0 	sh %d15,%d4,-31
8000b0a4:	78 02       	st.w [%sp]8,%d15
8000b0a6:	f6 44       	jnz %d4,8000b0ae <__floatsidf+0x14>
8000b0a8:	82 2f       	mov %d15,2
8000b0aa:	2c a4       	st.b [%sp]4,%d15
8000b0ac:	3c 16       	j 8000b0d8 <__floatsidf+0x3e>
8000b0ae:	6e 09       	jz %d15,8000b0c0 <__floatsidf+0x26>
8000b0b0:	7b 00 00 f8 	movh %d15,32768
8000b0b4:	82 02       	mov %d2,0
8000b0b6:	7b 00 1e 3c 	movh %d3,49632
8000b0ba:	5f f4 13 00 	jeq %d4,%d15,8000b0e0 <__floatsidf+0x46>
8000b0be:	32 54       	rsub %d4
8000b0c0:	0f 04 b0 f1 	clz %d15,%d4
8000b0c4:	1b df 01 60 	addi %d6,%d15,29
8000b0c8:	82 05       	mov %d5,0
8000b0ca:	6d 00 39 00 	call 8000b13c <__ashldi3>
8000b0ce:	8b ff 01 f1 	rsub %d15,%d15,31
8000b0d2:	89 a2 50 09 	st.d [%sp]16,%e2
8000b0d6:	78 03       	st.w [%sp]12,%d15
8000b0d8:	d9 a4 04 00 	lea %a4,[%sp]4
8000b0dc:	6d 00 85 00 	call 8000b1e6 <__pack_d>
8000b0e0:	00 90       	ret 

8000b0e2 <__make_dp>:
8000b0e2:	20 18       	sub.a %sp,24
8000b0e4:	09 a2 58 09 	ld.d %e2,[%sp]24
8000b0e8:	d9 a4 04 00 	lea %a4,[%sp]4
8000b0ec:	e9 a4 04 00 	st.b [%sp]4,%d4
8000b0f0:	59 a5 08 00 	st.w [%sp]8,%d5
8000b0f4:	59 a6 0c 00 	st.w [%sp]12,%d6
8000b0f8:	89 a2 50 09 	st.d [%sp]16,%e2
8000b0fc:	1d 00 75 00 	j 8000b1e6 <__pack_d>

8000b100 <__truncdfsf2>:
8000b100:	20 20       	sub.a %sp,32
8000b102:	d9 a4 20 00 	lea %a4,[%sp]32
8000b106:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000b10a:	d9 a5 0c 00 	lea %a5,[%sp]12
8000b10e:	6d 00 f5 00 	call 8000b2f8 <__unpack_d>
8000b112:	19 a7 18 00 	ld.w %d7,[%sp]24
8000b116:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000b11a:	39 a4 0c 00 	ld.bu %d4,[%sp]12
8000b11e:	77 72 00 21 	dextr %d2,%d2,%d7,2
8000b122:	b7 07 02 7f 	insert %d7,%d7,0,30,2
8000b126:	02 23       	mov %d3,%d2
8000b128:	8f 12 40 21 	or %d2,%d2,1
8000b12c:	19 a5 10 00 	ld.w %d5,[%sp]16
8000b130:	19 a6 14 00 	ld.w %d6,[%sp]20
8000b134:	2b 32 40 77 	sel %d7,%d7,%d2,%d3
8000b138:	1d 00 4c 00 	j 8000b1d0 <__make_fp>

8000b13c <__ashldi3>:
8000b13c:	6f 56 07 80 	jnz.t %d6,5,8000b14a <__ashldi3+0xe>
8000b140:	0f 64 00 20 	sh %d2,%d4,%d6
8000b144:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
8000b148:	00 90       	ret 
8000b14a:	8b 06 1e 60 	add %d6,%d6,-32
8000b14e:	82 02       	mov %d2,0
8000b150:	0f 64 00 30 	sh %d3,%d4,%d6
8000b154:	00 90       	ret 

8000b156 <__unpack_f>:
8000b156:	54 43       	ld.w %d3,[%a4]
8000b158:	37 03 77 f0 	extr.u %d15,%d3,0,23
8000b15c:	37 03 e8 2b 	extr.u %d2,%d3,23,8
8000b160:	8f 13 1e 30 	sh %d3,%d3,-31
8000b164:	59 53 04 00 	st.w [%a5]4,%d3
8000b168:	df 02 18 80 	jne %d2,0,8000b198 <__unpack_f+0x42>
8000b16c:	ee 03       	jnz %d15,8000b172 <__unpack_f+0x1c>
8000b16e:	82 2f       	mov %d15,2
8000b170:	3c 19       	j 8000b1a2 <__unpack_f+0x4c>
8000b172:	3b 20 f8 2f 	mov %d2,-126
8000b176:	59 52 08 00 	st.w [%a5]8,%d2
8000b17a:	82 32       	mov %d2,3
8000b17c:	34 52       	st.b [%a5],%d2
8000b17e:	06 7f       	sh %d15,7
8000b180:	3b 10 f8 2f 	mov %d2,-127
8000b184:	7b 00 00 44 	movh %d4,16384
8000b188:	06 1f       	sh %d15,1
8000b18a:	02 23       	mov %d3,%d2
8000b18c:	c2 f2       	add %d2,-1
8000b18e:	3f 4f fd ff 	jlt.u %d15,%d4,8000b188 <__unpack_f+0x32>
8000b192:	59 53 08 00 	st.w [%a5]8,%d3
8000b196:	3c 1b       	j 8000b1cc <__unpack_f+0x76>
8000b198:	8b f2 2f 32 	ne %d3,%d2,255
8000b19c:	f6 3f       	jnz %d3,8000b1ba <__unpack_f+0x64>
8000b19e:	ee 04       	jnz %d15,8000b1a6 <__unpack_f+0x50>
8000b1a0:	82 4f       	mov %d15,4
8000b1a2:	2c 50       	st.b [%a5]0,%d15
8000b1a4:	00 90       	ret 
8000b1a6:	7b 00 04 20 	movh %d2,64
8000b1aa:	26 f2       	and %d2,%d15
8000b1ac:	76 22       	jz %d2,8000b1b0 <__unpack_f+0x5a>
8000b1ae:	82 12       	mov %d2,1
8000b1b0:	b7 0f 01 fb 	insert %d15,%d15,0,22,1
8000b1b4:	34 52       	st.b [%a5],%d2
8000b1b6:	06 7f       	sh %d15,7
8000b1b8:	3c 0a       	j 8000b1cc <__unpack_f+0x76>
8000b1ba:	1b 12 f8 2f 	addi %d2,%d2,-127
8000b1be:	06 7f       	sh %d15,7
8000b1c0:	59 52 08 00 	st.w [%a5]8,%d2
8000b1c4:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000b1c8:	82 32       	mov %d2,3
8000b1ca:	34 52       	st.b [%a5],%d2
8000b1cc:	6c 53       	st.w [%a5]12,%d15
8000b1ce:	00 90       	ret 

8000b1d0 <__make_fp>:
8000b1d0:	20 10       	sub.a %sp,16
8000b1d2:	40 a4       	mov.aa %a4,%sp
8000b1d4:	34 a4       	st.b [%sp],%d4
8000b1d6:	59 a5 04 00 	st.w [%sp]4,%d5
8000b1da:	59 a6 08 00 	st.w [%sp]8,%d6
8000b1de:	59 a7 0c 00 	st.w [%sp]12,%d7
8000b1e2:	1d 00 e1 00 	j 8000b3a4 <__pack_f>

8000b1e6 <__pack_d>:
8000b1e6:	14 42       	ld.bu %d2,[%a4]
8000b1e8:	19 49 0c 00 	ld.w %d9,[%a4]12
8000b1ec:	19 48 10 00 	ld.w %d8,[%a4]16
8000b1f0:	19 4c 04 00 	ld.w %d12,[%a4]4
8000b1f4:	ff 22 0b 80 	jge.u %d2,2,8000b20a <__pack_d+0x24>
8000b1f8:	77 98 00 9c 	dextr %d9,%d8,%d9,24
8000b1fc:	06 88       	sh %d8,-8
8000b1fe:	02 95       	mov %d5,%d9
8000b200:	b7 18 8d 49 	insert %d4,%d8,1,19,13
8000b204:	3b f0 7f f0 	mov %d15,2047
8000b208:	3c 6f       	j 8000b2e6 <__pack_d+0x100>
8000b20a:	3b f0 7f f0 	mov %d15,2047
8000b20e:	d2 04       	mov %e4,0
8000b210:	df 42 6b 00 	jeq %d2,4,8000b2e6 <__pack_d+0x100>
8000b214:	0f 89 a0 f0 	or %d15,%d9,%d8
8000b218:	8b 22 00 32 	eq %d3,%d2,2
8000b21c:	8b 0f e0 34 	or.eq %d3,%d15,0
8000b220:	82 0f       	mov %d15,0
8000b222:	df 03 62 80 	jne %d3,0,8000b2e6 <__pack_d+0x100>
8000b226:	19 42 08 00 	ld.w %d2,[%a4]8
8000b22a:	3b 20 c0 ff 	mov %d15,-1022
8000b22e:	7f f2 36 00 	jge %d2,%d15,8000b29a <__pack_d+0xb4>
8000b232:	a2 2f       	sub %d15,%d2
8000b234:	8b 9f 83 42 	ge %d4,%d15,57
8000b238:	82 02       	mov %d2,0
8000b23a:	df 04 18 80 	jne %d4,0,8000b26a <__pack_d+0x84>
8000b23e:	0b 98 10 48 	mov %e4,%d8,%d9
8000b242:	02 f6       	mov %d6,%d15
8000b244:	6d ff 97 fc 	call 8000ab72 <__lshrdi3>
8000b248:	d2 14       	mov %e4,1
8000b24a:	02 f6       	mov %d6,%d15
8000b24c:	0b 32 10 a8 	mov %e10,%d2,%d3
8000b250:	6d ff 76 ff 	call 8000b13c <__ashldi3>
8000b254:	8b f2 9f 20 	addx %d2,%d2,-1
8000b258:	8b f3 bf 30 	addc %d3,%d3,-1
8000b25c:	26 29       	and %d9,%d2
8000b25e:	26 38       	and %d8,%d3
8000b260:	a6 98       	or %d8,%d9
8000b262:	02 b2       	mov %d2,%d11
8000b264:	8b 08 00 25 	or.ne %d2,%d8,0
8000b268:	02 a3       	mov %d3,%d10
8000b26a:	02 2f       	mov %d15,%d2
8000b26c:	16 ff       	and %d15,255
8000b26e:	8b 0f 28 f2 	ne %d15,%d15,128
8000b272:	ee 07       	jnz %d15,8000b280 <__pack_d+0x9a>
8000b274:	8f 02 10 f1 	and %d15,%d2,256
8000b278:	6e 08       	jz %d15,8000b288 <__pack_d+0xa2>
8000b27a:	8b 02 88 20 	addx %d2,%d2,128
8000b27e:	3c 03       	j 8000b284 <__pack_d+0x9e>
8000b280:	8b f2 87 20 	addx %d2,%d2,127
8000b284:	8b 03 a0 30 	addc %d3,%d3,0
8000b288:	7b 00 00 41 	movh %d4,4096
8000b28c:	0b 43 50 f1 	ge.u %d15,%d3,%d4
8000b290:	77 23 00 5c 	dextr %d5,%d3,%d2,24
8000b294:	8f 83 1f 40 	sh %d4,%d3,-8
8000b298:	3c 27       	j 8000b2e6 <__pack_d+0x100>
8000b29a:	3b 00 40 30 	mov %d3,1024
8000b29e:	3b f0 7f f0 	mov %d15,2047
8000b2a2:	7f 32 22 00 	jge %d2,%d3,8000b2e6 <__pack_d+0x100>
8000b2a6:	02 9f       	mov %d15,%d9
8000b2a8:	16 ff       	and %d15,255
8000b2aa:	8b 0f 28 f2 	ne %d15,%d15,128
8000b2ae:	ee 07       	jnz %d15,8000b2bc <__pack_d+0xd6>
8000b2b0:	8f 09 10 f1 	and %d15,%d9,256
8000b2b4:	6e 08       	jz %d15,8000b2c4 <__pack_d+0xde>
8000b2b6:	8b 09 88 90 	addx %d9,%d9,128
8000b2ba:	3c 03       	j 8000b2c0 <__pack_d+0xda>
8000b2bc:	8b f9 87 90 	addx %d9,%d9,127
8000b2c0:	8b 08 a0 80 	addc %d8,%d8,0
8000b2c4:	7b 00 00 32 	movh %d3,8192
8000b2c8:	0b 38 50 f1 	ge.u %d15,%d8,%d3
8000b2cc:	ee 04       	jnz %d15,8000b2d4 <__pack_d+0xee>
8000b2ce:	1b f2 3f f0 	addi %d15,%d2,1023
8000b2d2:	3c 06       	j 8000b2de <__pack_d+0xf8>
8000b2d4:	77 98 80 9f 	dextr %d9,%d8,%d9,31
8000b2d8:	1b 02 40 f0 	addi %d15,%d2,1024
8000b2dc:	06 f8       	sh %d8,-1
8000b2de:	77 98 00 5c 	dextr %d5,%d8,%d9,24
8000b2e2:	8f 88 1f 40 	sh %d4,%d8,-8
8000b2e6:	d2 02       	mov %e2,0
8000b2e8:	37 43 14 40 	insert %d4,%d3,%d4,0,20
8000b2ec:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
8000b2f0:	02 52       	mov %d2,%d5
8000b2f2:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
8000b2f6:	00 90       	ret 

8000b2f8 <__unpack_d>:
8000b2f8:	19 44 04 00 	ld.w %d4,[%a4]4
8000b2fc:	54 42       	ld.w %d2,[%a4]
8000b2fe:	37 04 74 50 	extr.u %d5,%d4,0,20
8000b302:	37 04 6b fa 	extr.u %d15,%d4,20,11
8000b306:	8f 14 1e 40 	sh %d4,%d4,-31
8000b30a:	59 54 04 00 	st.w [%a5]4,%d4
8000b30e:	02 53       	mov %d3,%d5
8000b310:	ee 21       	jnz %d15,8000b352 <__unpack_d+0x5a>
8000b312:	0f 25 a0 f0 	or %d15,%d5,%d2
8000b316:	ee 03       	jnz %d15,8000b31c <__unpack_d+0x24>
8000b318:	82 2f       	mov %d15,2
8000b31a:	3c 23       	j 8000b360 <__unpack_d+0x68>
8000b31c:	3b 20 c0 ff 	mov %d15,-1022
8000b320:	6c 52       	st.w [%a5]8,%d15
8000b322:	82 3f       	mov %d15,3
8000b324:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000b328:	2c 50       	st.b [%a5]0,%d15
8000b32a:	8f 82 00 20 	sh %d2,%d2,8
8000b32e:	3b 10 c0 ff 	mov %d15,-1023
8000b332:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000b336:	7b 00 00 61 	movh %d6,4096
8000b33a:	0b 63 30 51 	lt.u %d5,%d3,%d6
8000b33e:	02 f4       	mov %d4,%d15
8000b340:	06 12       	sh %d2,1
8000b342:	c2 ff       	add %d15,-1
8000b344:	df 05 f7 ff 	jne %d5,0,8000b332 <__unpack_d+0x3a>
8000b348:	59 54 08 00 	st.w [%a5]8,%d4
8000b34c:	59 52 0c 00 	st.w [%a5]12,%d2
8000b350:	3c 27       	j 8000b39e <__unpack_d+0xa6>
8000b352:	3b f0 7f 40 	mov %d4,2047
8000b356:	fe 47       	jne %d15,%d4,8000b384 <__unpack_d+0x8c>
8000b358:	0f 25 a0 f0 	or %d15,%d5,%d2
8000b35c:	ee 04       	jnz %d15,8000b364 <__unpack_d+0x6c>
8000b35e:	82 4f       	mov %d15,4
8000b360:	2c 50       	st.b [%a5]0,%d15
8000b362:	00 90       	ret 
8000b364:	7b 80 00 f0 	movh %d15,8
8000b368:	26 5f       	and %d15,%d5
8000b36a:	6e 02       	jz %d15,8000b36e <__unpack_d+0x76>
8000b36c:	82 1f       	mov %d15,1
8000b36e:	2c 50       	st.b [%a5]0,%d15
8000b370:	b7 03 81 f9 	insert %d15,%d3,0,19,1
8000b374:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
8000b378:	8f 82 00 40 	sh %d4,%d2,8
8000b37c:	59 54 0c 00 	st.w [%a5]12,%d4
8000b380:	6c 54       	st.w [%a5]16,%d15
8000b382:	00 90       	ret 
8000b384:	1b 1f c0 ff 	addi %d15,%d15,-1023
8000b388:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000b38c:	6c 52       	st.w [%a5]8,%d15
8000b38e:	8f 82 00 20 	sh %d2,%d2,8
8000b392:	82 3f       	mov %d15,3
8000b394:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
8000b398:	2c 50       	st.b [%a5]0,%d15
8000b39a:	59 52 0c 00 	st.w [%a5]12,%d2
8000b39e:	59 53 10 00 	st.w [%a5]16,%d3
8000b3a2:	00 90       	ret 

8000b3a4 <__pack_f>:
8000b3a4:	14 45       	ld.bu %d5,[%a4]
8000b3a6:	4c 43       	ld.w %d15,[%a4]12
8000b3a8:	19 47 04 00 	ld.w %d7,[%a4]4
8000b3ac:	ff 25 09 80 	jge.u %d5,2,8000b3be <__pack_f+0x1a>
8000b3b0:	37 0f f6 33 	extr.u %d3,%d15,7,22
8000b3b4:	b7 f3 01 3b 	insert %d3,%d3,15,22,1
8000b3b8:	3b f0 0f 40 	mov %d4,255
8000b3bc:	3c 4f       	j 8000b45a <__pack_f+0xb6>
8000b3be:	3b f0 0f 40 	mov %d4,255
8000b3c2:	82 03       	mov %d3,0
8000b3c4:	df 45 4b 00 	jeq %d5,4,8000b45a <__pack_f+0xb6>
8000b3c8:	8b 25 00 62 	eq %d6,%d5,2
8000b3cc:	8b 0f e0 64 	or.eq %d6,%d15,0
8000b3d0:	82 04       	mov %d4,0
8000b3d2:	df 06 44 80 	jne %d6,0,8000b45a <__pack_f+0xb6>
8000b3d6:	19 45 08 00 	ld.w %d5,[%a4]8
8000b3da:	8b 25 98 42 	ge %d4,%d5,-126
8000b3de:	df 04 24 80 	jne %d4,0,8000b426 <__pack_f+0x82>
8000b3e2:	8b 25 18 51 	rsub %d5,%d5,-126
8000b3e6:	8b a5 81 42 	ge %d4,%d5,26
8000b3ea:	f6 4c       	jnz %d4,8000b402 <__pack_f+0x5e>
8000b3ec:	82 12       	mov %d2,1
8000b3ee:	0f 52 00 20 	sh %d2,%d2,%d5
8000b3f2:	8b 05 00 31 	rsub %d3,%d5,0
8000b3f6:	c2 f2       	add %d2,-1
8000b3f8:	0f 3f 00 30 	sh %d3,%d15,%d3
8000b3fc:	26 2f       	and %d15,%d2
8000b3fe:	8b 0f 00 35 	or.ne %d3,%d15,0
8000b402:	8f f3 07 f1 	and %d15,%d3,127
8000b406:	8b 0f 24 f2 	ne %d15,%d15,64
8000b40a:	ee 06       	jnz %d15,8000b416 <__pack_f+0x72>
8000b40c:	8f 03 08 f1 	and %d15,%d3,128
8000b410:	ab 03 04 3f 	cadd %d3,%d15,%d3,64
8000b414:	3c 03       	j 8000b41a <__pack_f+0x76>
8000b416:	1b f3 03 30 	addi %d3,%d3,63
8000b41a:	7b 00 00 f4 	movh %d15,16384
8000b41e:	0b f3 50 41 	ge.u %d4,%d3,%d15
8000b422:	06 93       	sh %d3,-7
8000b424:	3c 1b       	j 8000b45a <__pack_f+0xb6>
8000b426:	8b 05 88 62 	ge %d6,%d5,128
8000b42a:	3b f0 0f 40 	mov %d4,255
8000b42e:	df 06 16 80 	jne %d6,0,8000b45a <__pack_f+0xb6>
8000b432:	8f ff 07 31 	and %d3,%d15,127
8000b436:	8b 03 24 32 	ne %d3,%d3,64
8000b43a:	f6 36       	jnz %d3,8000b446 <__pack_f+0xa2>
8000b43c:	8f 0f 08 31 	and %d3,%d15,128
8000b440:	ab 0f 04 f3 	cadd %d15,%d3,%d15,64
8000b444:	3c 03       	j 8000b44a <__pack_f+0xa6>
8000b446:	1b ff 03 f0 	addi %d15,%d15,63
8000b44a:	1b f5 07 40 	addi %d4,%d5,127
8000b44e:	ce f4       	jgez %d15,8000b456 <__pack_f+0xb2>
8000b450:	06 ff       	sh %d15,-1
8000b452:	1b 05 08 40 	addi %d4,%d5,128
8000b456:	8f 9f 1f 30 	sh %d3,%d15,-7
8000b45a:	82 02       	mov %d2,0
8000b45c:	37 32 17 20 	insert %d2,%d2,%d3,0,23
8000b460:	37 42 88 2b 	insert %d2,%d2,%d4,23,8
8000b464:	37 72 81 2f 	insert %d2,%d2,%d7,31,1
8000b468:	00 90       	ret 

8000b46a <malloc>:
8000b46a:	91 00 00 f7 	movh.a %a15,28672
8000b46e:	99 f4 58 50 	ld.a %a4,[%a15]1368 <70000558 <_impure_ptr>>
8000b472:	1d 00 09 00 	j 8000b484 <_malloc_r>

8000b476 <free>:
8000b476:	91 00 00 f7 	movh.a %a15,28672
8000b47a:	40 45       	mov.aa %a5,%a4
8000b47c:	99 f4 58 50 	ld.a %a4,[%a15]1368 <70000558 <_impure_ptr>>
8000b480:	1d 00 f7 02 	j 8000ba6e <_free_r>

8000b484 <_malloc_r>:
8000b484:	1b b4 00 f0 	addi %d15,%d4,11
8000b488:	8b 7f 61 82 	lt.u %d8,%d15,23
8000b48c:	8f 7f c0 f1 	andn %d15,%d15,7
8000b490:	ab 0f a1 88 	seln %d8,%d8,%d15,16
8000b494:	0b 48 30 41 	lt.u %d4,%d8,%d4
8000b498:	8b 08 20 45 	or.lt %d4,%d8,0
8000b49c:	40 4d       	mov.aa %a13,%a4
8000b49e:	76 45       	jz %d4,8000b4a8 <_malloc_r+0x24>
8000b4a0:	da 0c       	mov %d15,12
8000b4a2:	6c 40       	st.w [%a4]0,%d15
8000b4a4:	1d 00 2a 02 	j 8000b8f8 <_malloc_r+0x474>
8000b4a8:	91 00 00 f7 	movh.a %a15,28672
8000b4ac:	8b 88 bf f2 	ge.u %d15,%d8,504
8000b4b0:	6d 00 37 02 	call 8000b91e <__malloc_lock>
8000b4b4:	d9 ff 10 50 	lea %a15,[%a15]336 <70000150 <__malloc_av_>>
8000b4b8:	ee 19       	jnz %d15,8000b4ea <_malloc_r+0x66>
8000b4ba:	8f d8 1f 20 	sh %d2,%d8,-3
8000b4be:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000b4c2:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000b4c6:	7d 2c 09 80 	jne.a %a12,%a2,8000b4d8 <_malloc_r+0x54>
8000b4ca:	d9 c2 08 00 	lea %a2,[%a12]8
8000b4ce:	99 cc 14 00 	ld.a %a12,[%a12]20
8000b4d2:	c2 22       	add %d2,2
8000b4d4:	7d 2c 58 00 	jeq.a %a12,%a2,8000b584 <_malloc_r+0x100>
8000b4d8:	cc c3       	ld.a %a15,[%a12]12
8000b4da:	99 c2 08 00 	ld.a %a2,[%a12]8
8000b4de:	4c c1       	ld.w %d15,[%a12]4
8000b4e0:	ec 23       	st.a [%a2]12,%a15
8000b4e2:	8f 3f c0 f1 	andn %d15,%d15,3
8000b4e6:	e8 22       	st.a [%a15]8,%a2
8000b4e8:	3c 74       	j 8000b5d0 <_malloc_r+0x14c>
8000b4ea:	8f 78 1f f0 	sh %d15,%d8,-9
8000b4ee:	3b f0 03 20 	mov %d2,63
8000b4f2:	6e 27       	jz %d15,8000b540 <_malloc_r+0xbc>
8000b4f4:	8f a8 1f 20 	sh %d2,%d8,-6
8000b4f8:	1b 82 03 20 	addi %d2,%d2,56
8000b4fc:	bf 5f 22 80 	jlt.u %d15,5,8000b540 <_malloc_r+0xbc>
8000b500:	8b 5f a1 22 	ge.u %d2,%d15,21
8000b504:	f6 24       	jnz %d2,8000b50c <_malloc_r+0x88>
8000b506:	1b bf 05 20 	addi %d2,%d15,91
8000b50a:	3c 1b       	j 8000b540 <_malloc_r+0xbc>
8000b50c:	8b 5f a5 22 	ge.u %d2,%d15,85
8000b510:	f6 26       	jnz %d2,8000b51c <_malloc_r+0x98>
8000b512:	8f 48 1f 20 	sh %d2,%d8,-12
8000b516:	1b e2 06 20 	addi %d2,%d2,110
8000b51a:	3c 13       	j 8000b540 <_malloc_r+0xbc>
8000b51c:	8b 5f b5 22 	ge.u %d2,%d15,341
8000b520:	f6 26       	jnz %d2,8000b52c <_malloc_r+0xa8>
8000b522:	8f 18 1f 20 	sh %d2,%d8,-15
8000b526:	1b 72 07 20 	addi %d2,%d2,119
8000b52a:	3c 0b       	j 8000b540 <_malloc_r+0xbc>
8000b52c:	3b 50 55 30 	mov %d3,1365
8000b530:	3b e0 07 20 	mov %d2,126
8000b534:	7f 3f 06 80 	jge.u %d15,%d3,8000b540 <_malloc_r+0xbc>
8000b538:	8f e8 1e 20 	sh %d2,%d8,-18
8000b53c:	1b c2 07 20 	addi %d2,%d2,124
8000b540:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000b544:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000b548:	7d 2c 1d 00 	jeq.a %a12,%a2,8000b582 <_malloc_r+0xfe>
8000b54c:	19 c4 04 00 	ld.w %d4,[%a12]4
8000b550:	8f 34 c0 41 	andn %d4,%d4,3
8000b554:	5a 84       	sub %d15,%d4,%d8
8000b556:	8b 0f 41 32 	lt %d3,%d15,16
8000b55a:	f6 33       	jnz %d3,8000b560 <_malloc_r+0xdc>
8000b55c:	c2 f2       	add %d2,-1
8000b55e:	3c 12       	j 8000b582 <_malloc_r+0xfe>
8000b560:	0e fe       	jltz %d15,8000b57c <_malloc_r+0xf8>
8000b562:	cc c3       	ld.a %a15,[%a12]12
8000b564:	99 c2 08 00 	ld.a %a2,[%a12]8
8000b568:	ec 23       	st.a [%a2]12,%a15
8000b56a:	e8 22       	st.a [%a15]8,%a2
8000b56c:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
8000b570:	b7 10 21 20 	imask %e2,1,0,1
8000b574:	49 f2 44 08 	ldmst [%a15]4,%e2
8000b578:	1d 00 cc 01 	j 8000b910 <_malloc_r+0x48c>
8000b57c:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000b580:	3c e4       	j 8000b548 <_malloc_r+0xc4>
8000b582:	c2 12       	add %d2,1
8000b584:	c8 4c       	ld.a %a12,[%a15]16
8000b586:	91 00 00 37 	movh.a %a3,28672
8000b58a:	d9 33 18 50 	lea %a3,[%a3]344 <70000158 <__malloc_av_+0x8>>
8000b58e:	7d 3c 83 00 	jeq.a %a12,%a3,8000b694 <_malloc_r+0x210>
8000b592:	4c c1       	ld.w %d15,[%a12]4
8000b594:	8f 3f c0 f1 	andn %d15,%d15,3
8000b598:	52 83       	sub %d3,%d15,%d8
8000b59a:	8b 03 41 42 	lt %d4,%d3,16
8000b59e:	df 04 16 80 	jne %d4,0,8000b5ca <_malloc_r+0x146>
8000b5a2:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b5a6:	8f 18 40 81 	or %d8,%d8,1
8000b5aa:	59 c8 04 00 	st.w [%a12]4,%d8
8000b5ae:	e8 52       	st.a [%a15]20,%a2
8000b5b0:	e8 42       	st.a [%a15]16,%a2
8000b5b2:	8f 13 40 f1 	or %d15,%d3,1
8000b5b6:	b5 23 0c 00 	st.a [%a2]12,%a3
8000b5ba:	b5 23 08 00 	st.a [%a2]8,%a3
8000b5be:	6c 21       	st.w [%a2]4,%d15
8000b5c0:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000b5c4:	74 23       	st.w [%a2],%d3
8000b5c6:	1d 00 a5 01 	j 8000b910 <_malloc_r+0x48c>
8000b5ca:	e8 53       	st.a [%a15]20,%a3
8000b5cc:	e8 43       	st.a [%a15]16,%a3
8000b5ce:	0e 33       	jltz %d3,8000b5d4 <_malloc_r+0x150>
8000b5d0:	10 cf       	addsc.a %a15,%a12,%d15,0
8000b5d2:	3c cf       	j 8000b570 <_malloc_r+0xec>
8000b5d4:	3b 00 20 30 	mov %d3,512
8000b5d8:	7f 3f 15 80 	jge.u %d15,%d3,8000b602 <_malloc_r+0x17e>
8000b5dc:	06 df       	sh %d15,-3
8000b5de:	d0 f2       	addsc.a %a2,%a15,%d15,3
8000b5e0:	48 14       	ld.w %d4,[%a15]4
8000b5e2:	99 24 08 00 	ld.a %a4,[%a2]8
8000b5e6:	8f ef 3f 30 	sha %d3,%d15,-2
8000b5ea:	b5 c2 0c 00 	st.a [%a12]12,%a2
8000b5ee:	b5 c4 08 00 	st.a [%a12]8,%a4
8000b5f2:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
8000b5f6:	b5 2c 08 00 	st.a [%a2]8,%a12
8000b5fa:	68 13       	st.w [%a15]4,%d3
8000b5fc:	b5 4c 0c 00 	st.a [%a4]12,%a12
8000b600:	3c 4a       	j 8000b694 <_malloc_r+0x210>
8000b602:	8f af 1f 40 	sh %d4,%d15,-6
8000b606:	8f 7f 1f 30 	sh %d3,%d15,-9
8000b60a:	1b 84 03 40 	addi %d4,%d4,56
8000b60e:	bf 53 22 80 	jlt.u %d3,5,8000b652 <_malloc_r+0x1ce>
8000b612:	8b 53 a1 42 	ge.u %d4,%d3,21
8000b616:	f6 44       	jnz %d4,8000b61e <_malloc_r+0x19a>
8000b618:	1b b3 05 40 	addi %d4,%d3,91
8000b61c:	3c 1b       	j 8000b652 <_malloc_r+0x1ce>
8000b61e:	8b 53 a5 42 	ge.u %d4,%d3,85
8000b622:	f6 46       	jnz %d4,8000b62e <_malloc_r+0x1aa>
8000b624:	8f 4f 1f 40 	sh %d4,%d15,-12
8000b628:	1b e4 06 40 	addi %d4,%d4,110
8000b62c:	3c 13       	j 8000b652 <_malloc_r+0x1ce>
8000b62e:	8b 53 b5 42 	ge.u %d4,%d3,341
8000b632:	f6 46       	jnz %d4,8000b63e <_malloc_r+0x1ba>
8000b634:	8f 1f 1f 40 	sh %d4,%d15,-15
8000b638:	1b 74 07 40 	addi %d4,%d4,119
8000b63c:	3c 0b       	j 8000b652 <_malloc_r+0x1ce>
8000b63e:	3b 50 55 50 	mov %d5,1365
8000b642:	3b e0 07 40 	mov %d4,126
8000b646:	7f 53 06 80 	jge.u %d3,%d5,8000b652 <_malloc_r+0x1ce>
8000b64a:	8f ef 1e 40 	sh %d4,%d15,-18
8000b64e:	1b c4 07 40 	addi %d4,%d4,124
8000b652:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
8000b656:	99 42 08 00 	ld.a %a2,[%a4]8
8000b65a:	7d 42 0d 80 	jne.a %a2,%a4,8000b674 <_malloc_r+0x1f0>
8000b65e:	4c f1       	ld.w %d15,[%a15]4
8000b660:	86 e4       	sha %d4,-2
8000b662:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
8000b666:	40 24       	mov.aa %a4,%a2
8000b668:	68 14       	st.w [%a15]4,%d4
8000b66a:	3c 0d       	j 8000b684 <_malloc_r+0x200>
8000b66c:	99 22 08 00 	ld.a %a2,[%a2]8
8000b670:	7d 42 08 00 	jeq.a %a2,%a4,8000b680 <_malloc_r+0x1fc>
8000b674:	19 23 04 00 	ld.w %d3,[%a2]4
8000b678:	8f 33 c0 31 	andn %d3,%d3,3
8000b67c:	3f 3f f8 ff 	jlt.u %d15,%d3,8000b66c <_malloc_r+0x1e8>
8000b680:	99 24 0c 00 	ld.a %a4,[%a2]12
8000b684:	b5 c4 0c 00 	st.a [%a12]12,%a4
8000b688:	b5 c2 08 00 	st.a [%a12]8,%a2
8000b68c:	b5 4c 08 00 	st.a [%a4]8,%a12
8000b690:	b5 2c 0c 00 	st.a [%a2]12,%a12
8000b694:	8f e2 3f 30 	sha %d3,%d2,-2
8000b698:	82 1f       	mov %d15,1
8000b69a:	0f 3f 00 f0 	sh %d15,%d15,%d3
8000b69e:	48 13       	ld.w %d3,[%a15]4
8000b6a0:	3f f3 73 80 	jlt.u %d3,%d15,8000b786 <_malloc_r+0x302>
8000b6a4:	0f 3f 80 40 	and %d4,%d15,%d3
8000b6a8:	f6 49       	jnz %d4,8000b6ba <_malloc_r+0x236>
8000b6aa:	8f 32 c0 21 	andn %d2,%d2,3
8000b6ae:	06 1f       	sh %d15,1
8000b6b0:	0f 3f 80 40 	and %d4,%d15,%d3
8000b6b4:	c2 42       	add %d2,4
8000b6b6:	df 04 fc 7f 	jeq %d4,0,8000b6ae <_malloc_r+0x22a>
8000b6ba:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000b6be:	02 24       	mov %d4,%d2
8000b6c0:	40 24       	mov.aa %a4,%a2
8000b6c2:	99 4c 0c 00 	ld.a %a12,[%a4]12
8000b6c6:	7d 4c 3c 00 	jeq.a %a12,%a4,8000b73e <_malloc_r+0x2ba>
8000b6ca:	19 c6 04 00 	ld.w %d6,[%a12]4
8000b6ce:	8f 36 c0 61 	andn %d6,%d6,3
8000b6d2:	0b 86 80 30 	sub %d3,%d6,%d8
8000b6d6:	8b 03 41 52 	lt %d5,%d3,16
8000b6da:	df 05 1d 80 	jne %d5,0,8000b714 <_malloc_r+0x290>
8000b6de:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b6e2:	8f 18 40 81 	or %d8,%d8,1
8000b6e6:	59 c8 04 00 	st.w [%a12]4,%d8
8000b6ea:	99 c4 0c 00 	ld.a %a4,[%a12]12
8000b6ee:	09 c5 88 05 	ld.a %a5,[+%a12]8
8000b6f2:	8f 13 40 f1 	or %d15,%d3,1
8000b6f6:	b5 54 0c 00 	st.a [%a5]12,%a4
8000b6fa:	b5 45 08 00 	st.a [%a4]8,%a5
8000b6fe:	e8 52       	st.a [%a15]20,%a2
8000b700:	e8 42       	st.a [%a15]16,%a2
8000b702:	b5 23 0c 00 	st.a [%a2]12,%a3
8000b706:	b5 23 08 00 	st.a [%a2]8,%a3
8000b70a:	6c 21       	st.w [%a2]4,%d15
8000b70c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000b710:	74 23       	st.w [%a2],%d3
8000b712:	3c 0e       	j 8000b72e <_malloc_r+0x2aa>
8000b714:	bf 03 12 00 	jlt %d3,0,8000b738 <_malloc_r+0x2b4>
8000b718:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
8000b71c:	b7 10 21 20 	imask %e2,1,0,1
8000b720:	49 f2 44 08 	ldmst [%a15]4,%e2
8000b724:	cc c3       	ld.a %a15,[%a12]12
8000b726:	09 c2 88 05 	ld.a %a2,[+%a12]8
8000b72a:	ec 23       	st.a [%a2]12,%a15
8000b72c:	e8 22       	st.a [%a15]8,%a2
8000b72e:	40 d4       	mov.aa %a4,%a13
8000b730:	6d 00 f8 00 	call 8000b920 <__malloc_unlock>
8000b734:	1d 00 f3 00 	j 8000b91a <_malloc_r+0x496>
8000b738:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000b73c:	3c c5       	j 8000b6c6 <_malloc_r+0x242>
8000b73e:	c2 14       	add %d4,1
8000b740:	8f 34 00 31 	and %d3,%d4,3
8000b744:	d9 44 08 00 	lea %a4,[%a4]8
8000b748:	df 03 bd ff 	jne %d3,0,8000b6c2 <_malloc_r+0x23e>
8000b74c:	8f 32 00 31 	and %d3,%d2,3
8000b750:	f6 36       	jnz %d3,8000b75c <_malloc_r+0x2d8>
8000b752:	48 12       	ld.w %d2,[%a15]4
8000b754:	0f f2 e0 20 	andn %d2,%d2,%d15
8000b758:	68 12       	st.w [%a15]4,%d2
8000b75a:	3c 07       	j 8000b768 <_malloc_r+0x2e4>
8000b75c:	d9 24 f8 ff 	lea %a4,[%a2]-8
8000b760:	d4 22       	ld.a %a2,[%a2]
8000b762:	c2 f2       	add %d2,-1
8000b764:	7d 42 f4 7f 	jeq.a %a2,%a4,8000b74c <_malloc_r+0x2c8>
8000b768:	06 1f       	sh %d15,1
8000b76a:	48 12       	ld.w %d2,[%a15]4
8000b76c:	8b 0f 20 32 	ne %d3,%d15,0
8000b770:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
8000b774:	76 39       	jz %d3,8000b786 <_malloc_r+0x302>
8000b776:	0f 2f 80 30 	and %d3,%d15,%d2
8000b77a:	f6 34       	jnz %d3,8000b782 <_malloc_r+0x2fe>
8000b77c:	c2 44       	add %d4,4
8000b77e:	06 1f       	sh %d15,1
8000b780:	3c fb       	j 8000b776 <_malloc_r+0x2f2>
8000b782:	02 42       	mov %d2,%d4
8000b784:	3c 9b       	j 8000b6ba <_malloc_r+0x236>
8000b786:	c8 2c       	ld.a %a12,[%a15]8
8000b788:	19 ca 04 00 	ld.w %d10,[%a12]4
8000b78c:	8f 3a c0 a1 	andn %d10,%d10,3
8000b790:	5a 8a       	sub %d15,%d10,%d8
8000b792:	8b 0f 41 22 	lt %d2,%d15,16
8000b796:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
8000b79a:	df 02 b1 00 	jeq %d2,0,8000b8fc <_malloc_r+0x478>
8000b79e:	91 00 00 27 	movh.a %a2,28672
8000b7a2:	19 2b c0 d0 	ld.w %d11,[%a2]3904 <70000f40 <__malloc_top_pad>>
8000b7a6:	91 00 00 27 	movh.a %a2,28672
8000b7aa:	42 8b       	add %d11,%d8
8000b7ac:	19 23 08 50 	ld.w %d3,[%a2]328 <70000148 <__malloc_sbrk_base>>
8000b7b0:	1b fb 00 f1 	addi %d15,%d11,4111
8000b7b4:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000b7b8:	1b 0b 01 20 	addi %d2,%d11,16
8000b7bc:	8b f3 3f b2 	ne %d11,%d3,-1
8000b7c0:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
8000b7c4:	40 d4       	mov.aa %a4,%a13
8000b7c6:	02 b4       	mov %d4,%d11
8000b7c8:	80 2c       	mov.d %d12,%a2
8000b7ca:	6d 00 ac 00 	call 8000b922 <_sbrk_r>
8000b7ce:	80 29       	mov.d %d9,%a2
8000b7d0:	df f9 86 00 	jeq %d9,-1,8000b8dc <_malloc_r+0x458>
8000b7d4:	80 c2       	mov.d %d2,%a12
8000b7d6:	80 c3       	mov.d %d3,%a12
8000b7d8:	42 a2       	add %d2,%d10
8000b7da:	80 f4       	mov.d %d4,%a15
8000b7dc:	0b 29 30 f1 	lt.u %d15,%d9,%d2
8000b7e0:	0b 43 10 f2 	and.ne %d15,%d3,%d4
8000b7e4:	01 fc 10 d4 	ne.a %d13,%a12,%a15
8000b7e8:	ee 7a       	jnz %d15,8000b8dc <_malloc_r+0x458>
8000b7ea:	91 00 00 e7 	movh.a %a14,28672
8000b7ee:	19 e3 d0 c0 	ld.w %d3,[%a14]3856 <70000f10 <__malloc_current_mallinfo>>
8000b7f2:	42 b3       	add %d3,%d11
8000b7f4:	59 e3 d0 c0 	st.w [%a14]3856 <70000f10 <__malloc_current_mallinfo>>,%d3
8000b7f8:	5f 29 0c 80 	jne %d9,%d2,8000b810 <_malloc_r+0x38c>
8000b7fc:	b7 09 14 f6 	insert %d15,%d9,0,12,20
8000b800:	ee 08       	jnz %d15,8000b810 <_malloc_r+0x38c>
8000b802:	c8 22       	ld.a %a2,[%a15]8
8000b804:	42 ba       	add %d10,%d11
8000b806:	8f 1a 40 a1 	or %d10,%d10,1
8000b80a:	59 2a 04 00 	st.w [%a2]4,%d10
8000b80e:	3c 55       	j 8000b8b8 <_malloc_r+0x434>
8000b810:	60 c2       	mov.a %a2,%d12
8000b812:	19 2f 08 50 	ld.w %d15,[%a2]328
8000b816:	5e f6       	jne %d15,-1,8000b822 <_malloc_r+0x39e>
8000b818:	91 00 00 27 	movh.a %a2,28672
8000b81c:	59 29 08 50 	st.w [%a2]328 <70000148 <__malloc_sbrk_base>>,%d9
8000b820:	3c 06       	j 8000b82c <_malloc_r+0x3a8>
8000b822:	0b 29 80 20 	sub %d2,%d9,%d2
8000b826:	42 23       	add %d3,%d2
8000b828:	59 e3 d0 c0 	st.w [%a14]3856 <70000f10 <__malloc_current_mallinfo>>,%d3
8000b82c:	8f 79 00 21 	and %d2,%d9,7
8000b830:	82 0f       	mov %d15,0
8000b832:	76 24       	jz %d2,8000b83a <_malloc_r+0x3b6>
8000b834:	8b 82 00 f1 	rsub %d15,%d2,8
8000b838:	42 f9       	add %d9,%d15
8000b83a:	42 9b       	add %d11,%d9
8000b83c:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
8000b840:	1b 0f 00 21 	addi %d2,%d15,4096
8000b844:	5a b2       	sub %d15,%d2,%d11
8000b846:	40 d4       	mov.aa %a4,%a13
8000b848:	02 f4       	mov %d4,%d15
8000b84a:	6d 00 6c 00 	call 8000b922 <_sbrk_r>
8000b84e:	80 22       	mov.d %d2,%a2
8000b850:	df f2 04 80 	jne %d2,-1,8000b858 <_malloc_r+0x3d4>
8000b854:	60 92       	mov.a %a2,%d9
8000b856:	82 0f       	mov %d15,0
8000b858:	80 2b       	mov.d %d11,%a2
8000b85a:	19 e2 d0 c0 	ld.w %d2,[%a14]3856 <70000f10 <__malloc_current_mallinfo>>
8000b85e:	a2 9b       	sub %d11,%d9
8000b860:	42 f2       	add %d2,%d15
8000b862:	60 92       	mov.a %a2,%d9
8000b864:	42 bf       	add %d15,%d11
8000b866:	68 29       	st.w [%a15]8,%d9
8000b868:	8f 1f 40 31 	or %d3,%d15,1
8000b86c:	59 e2 d0 c0 	st.w [%a14]3856 <70000f10 <__malloc_current_mallinfo>>,%d2
8000b870:	59 23 04 00 	st.w [%a2]4 <70000f10 <__malloc_current_mallinfo>>,%d3
8000b874:	df 0d 22 00 	jeq %d13,0,8000b8b8 <_malloc_r+0x434>
8000b878:	8b 0a a1 f2 	ge.u %d15,%d10,16
8000b87c:	ee 05       	jnz %d15,8000b886 <_malloc_r+0x402>
8000b87e:	82 12       	mov %d2,1
8000b880:	59 22 04 00 	st.w [%a2]4,%d2
8000b884:	3c 2c       	j 8000b8dc <_malloc_r+0x458>
8000b886:	1b 4a ff af 	addi %d10,%d10,-12
8000b88a:	8f 7a c0 f1 	andn %d15,%d10,7
8000b88e:	10 c2       	addsc.a %a2,%a12,%d15,0
8000b890:	82 52       	mov %d2,5
8000b892:	59 22 04 00 	st.w [%a2]4,%d2
8000b896:	59 22 08 00 	st.w [%a2]8,%d2
8000b89a:	19 c2 04 00 	ld.w %d2,[%a12]4
8000b89e:	8f 12 00 21 	and %d2,%d2,1
8000b8a2:	a6 f2       	or %d2,%d15
8000b8a4:	59 c2 04 00 	st.w [%a12]4,%d2
8000b8a8:	8b 0f 61 f2 	lt.u %d15,%d15,16
8000b8ac:	ee 06       	jnz %d15,8000b8b8 <_malloc_r+0x434>
8000b8ae:	40 d4       	mov.aa %a4,%a13
8000b8b0:	d9 c5 08 00 	lea %a5,[%a12]8
8000b8b4:	6d 00 dd 00 	call 8000ba6e <_free_r>
8000b8b8:	91 00 00 27 	movh.a %a2,28672
8000b8bc:	19 ef d0 c0 	ld.w %d15,[%a14]3856 <70000f10 <__malloc_current_mallinfo>>
8000b8c0:	19 22 fc c0 	ld.w %d2,[%a2]3900 <70000f3c <__malloc_max_sbrked_mem>>
8000b8c4:	7f f2 04 80 	jge.u %d2,%d15,8000b8cc <_malloc_r+0x448>
8000b8c8:	59 2f fc c0 	st.w [%a2]3900 <70000f3c <__malloc_max_sbrked_mem>>,%d15
8000b8cc:	91 00 00 27 	movh.a %a2,28672
8000b8d0:	19 22 f8 c0 	ld.w %d2,[%a2]3896 <70000f38 <__malloc_max_total_mem>>
8000b8d4:	7f f2 04 80 	jge.u %d2,%d15,8000b8dc <_malloc_r+0x458>
8000b8d8:	59 2f f8 c0 	st.w [%a2]3896 <70000f38 <__malloc_max_total_mem>>,%d15
8000b8dc:	c8 22       	ld.a %a2,[%a15]8
8000b8de:	19 22 04 00 	ld.w %d2,[%a2]4 <70000f38 <__malloc_max_total_mem>>
8000b8e2:	8f 32 c0 21 	andn %d2,%d2,3
8000b8e6:	5a 82       	sub %d15,%d2,%d8
8000b8e8:	8b 0f 41 32 	lt %d3,%d15,16
8000b8ec:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
8000b8f0:	76 36       	jz %d3,8000b8fc <_malloc_r+0x478>
8000b8f2:	40 d4       	mov.aa %a4,%a13
8000b8f4:	6d 00 16 00 	call 8000b920 <__malloc_unlock>
8000b8f8:	a0 0c       	mov.a %a12,0
8000b8fa:	3c 10       	j 8000b91a <_malloc_r+0x496>
8000b8fc:	c8 2c       	ld.a %a12,[%a15]8
8000b8fe:	8f 18 40 21 	or %d2,%d8,1
8000b902:	96 01       	or %d15,1
8000b904:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b908:	59 c2 04 00 	st.w [%a12]4,%d2
8000b90c:	e8 22       	st.a [%a15]8,%a2
8000b90e:	6c 21       	st.w [%a2]4,%d15
8000b910:	40 d4       	mov.aa %a4,%a13
8000b912:	6d 00 07 00 	call 8000b920 <__malloc_unlock>
8000b916:	d9 cc 08 00 	lea %a12,[%a12]8
8000b91a:	40 c2       	mov.aa %a2,%a12
8000b91c:	00 90       	ret 

8000b91e <__malloc_lock>:
8000b91e:	00 90       	ret 

8000b920 <__malloc_unlock>:
8000b920:	00 90       	ret 

8000b922 <_sbrk_r>:
8000b922:	82 0f       	mov %d15,0
8000b924:	91 00 00 c7 	movh.a %a12,28672
8000b928:	59 cf c8 d0 	st.w [%a12]3912 <70000f48 <errno>>,%d15
8000b92c:	40 4f       	mov.aa %a15,%a4
8000b92e:	6d 00 2d 17 	call 8000e788 <sbrk>
8000b932:	80 2f       	mov.d %d15,%a2
8000b934:	5e f5       	jne %d15,-1,8000b93e <_sbrk_r+0x1c>
8000b936:	19 cf c8 d0 	ld.w %d15,[%a12]3912 <70000f48 <errno>>
8000b93a:	6e 02       	jz %d15,8000b93e <_sbrk_r+0x1c>
8000b93c:	68 0f       	st.w [%a15]0,%d15
8000b93e:	00 90       	ret 

8000b940 <strlen>:
8000b940:	80 42       	mov.d %d2,%a4
8000b942:	80 4f       	mov.d %d15,%a4
8000b944:	60 ff       	mov.a %a15,%d15
8000b946:	79 f3 00 00 	ld.b %d3,[%a15]0
8000b94a:	76 33       	jz %d3,8000b950 <strlen+0x10>
8000b94c:	c2 1f       	add %d15,1
8000b94e:	3c fb       	j 8000b944 <strlen+0x4>
8000b950:	52 22       	sub %d2,%d15,%d2
8000b952:	00 90       	ret 

8000b954 <_vsnprintf_r>:
8000b954:	20 68       	sub.a %sp,104
8000b956:	40 4f       	mov.aa %a15,%a4
8000b958:	ce 45       	jgez %d4,8000b962 <_vsnprintf_r+0xe>
8000b95a:	da 8b       	mov %d15,139
8000b95c:	6c 40       	st.w [%a4]0,%d15
8000b95e:	82 f2       	mov %d2,-1
8000b960:	00 90       	ret 
8000b962:	02 4f       	mov %d15,%d4
8000b964:	3b 80 20 20 	mov %d2,520
8000b968:	f9 a2 0c 00 	st.h [%sp]12,%d2
8000b96c:	92 f2       	add %d2,%d15,-1
8000b96e:	ea 02       	cmovn %d2,%d15,0
8000b970:	f4 a5       	st.a [%sp],%a5
8000b972:	b5 a5 10 00 	st.a [%sp]16,%a5
8000b976:	59 a2 08 00 	st.w [%sp]8,%d2
8000b97a:	59 a2 14 00 	st.w [%sp]20,%d2
8000b97e:	40 a5       	mov.aa %a5,%sp
8000b980:	82 f2       	mov %d2,-1
8000b982:	f9 a2 0e 00 	st.h [%sp]14,%d2
8000b986:	6d 00 4b 01 	call 8000bc1c <_svfprintf_r>
8000b98a:	ff f2 05 00 	jge %d2,-1,8000b994 <_vsnprintf_r+0x40>
8000b98e:	3b b0 08 30 	mov %d3,139
8000b992:	68 03       	st.w [%a15]0,%d3
8000b994:	6e 04       	jz %d15,8000b99c <_vsnprintf_r+0x48>
8000b996:	d8 00       	ld.a %a15,[%sp]0
8000b998:	82 0f       	mov %d15,0
8000b99a:	28 0f       	st.b [%a15]0,%d15
8000b99c:	00 90       	ret 

8000b99e <vsnprintf>:
8000b99e:	91 00 00 37 	movh.a %a3,28672
8000b9a2:	40 42       	mov.aa %a2,%a4
8000b9a4:	99 34 58 50 	ld.a %a4,[%a3]1368 <70000558 <_impure_ptr>>
8000b9a8:	40 5f       	mov.aa %a15,%a5
8000b9aa:	40 67       	mov.aa %a7,%a6
8000b9ac:	40 25       	mov.aa %a5,%a2
8000b9ae:	40 f6       	mov.aa %a6,%a15
8000b9b0:	1d ff d2 ff 	j 8000b954 <_vsnprintf_r>

8000b9b4 <_malloc_trim_r>:
8000b9b4:	02 4f       	mov %d15,%d4
8000b9b6:	40 4f       	mov.aa %a15,%a4
8000b9b8:	6d ff b3 ff 	call 8000b91e <__malloc_lock>
8000b9bc:	91 00 00 c7 	movh.a %a12,28672
8000b9c0:	d9 cc 10 50 	lea %a12,[%a12]336 <70000150 <__malloc_av_>>
8000b9c4:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <g_vadcChannelIDs>>
8000b9c8:	3b 00 00 21 	mov %d2,4096
8000b9cc:	19 28 04 00 	ld.w %d8,[%a2]4
8000b9d0:	8f 38 c0 81 	andn %d8,%d8,3
8000b9d4:	5a f8       	sub %d15,%d8,%d15
8000b9d6:	1b ff fe f0 	addi %d15,%d15,4079
8000b9da:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000b9de:	1b 0f 00 ff 	addi %d15,%d15,-4096
8000b9e2:	7f 2f 07 00 	jge %d15,%d2,8000b9f0 <_malloc_trim_r+0x3c>
8000b9e6:	40 f4       	mov.aa %a4,%a15
8000b9e8:	6d ff 9c ff 	call 8000b920 <__malloc_unlock>
8000b9ec:	82 02       	mov %d2,0
8000b9ee:	00 90       	ret 
8000b9f0:	40 f4       	mov.aa %a4,%a15
8000b9f2:	82 04       	mov %d4,0
8000b9f4:	6d ff 97 ff 	call 8000b922 <_sbrk_r>
8000b9f8:	99 c3 08 00 	ld.a %a3,[%a12]8
8000b9fc:	60 84       	mov.a %a4,%d8
8000b9fe:	30 43       	add.a %a3,%a4
8000ba00:	7d 32 f3 ff 	jne.a %a2,%a3,8000b9e6 <_malloc_trim_r+0x32>
8000ba04:	40 f4       	mov.aa %a4,%a15
8000ba06:	8b 0f 00 41 	rsub %d4,%d15,0
8000ba0a:	6d ff 8c ff 	call 8000b922 <_sbrk_r>
8000ba0e:	80 22       	mov.d %d2,%a2
8000ba10:	df f2 1c 80 	jne %d2,-1,8000ba48 <_malloc_trim_r+0x94>
8000ba14:	40 f4       	mov.aa %a4,%a15
8000ba16:	82 04       	mov %d4,0
8000ba18:	6d ff 85 ff 	call 8000b922 <_sbrk_r>
8000ba1c:	99 c3 08 00 	ld.a %a3,[%a12]8
8000ba20:	01 32 20 40 	sub.a %a4,%a2,%a3
8000ba24:	80 4f       	mov.d %d15,%a4
8000ba26:	8b 0f 41 22 	lt %d2,%d15,16
8000ba2a:	df 02 de ff 	jne %d2,0,8000b9e6 <_malloc_trim_r+0x32>
8000ba2e:	91 00 00 47 	movh.a %a4,28672
8000ba32:	99 44 08 50 	ld.a %a4,[%a4]328 <70000148 <__malloc_sbrk_base>>
8000ba36:	96 01       	or %d15,1
8000ba38:	6c 31       	st.w [%a3]4,%d15
8000ba3a:	01 42 20 20 	sub.a %a2,%a2,%a4
8000ba3e:	91 00 00 47 	movh.a %a4,28672
8000ba42:	b5 42 d0 c0 	st.a [%a4]3856 <70000f10 <__malloc_current_mallinfo>>,%a2
8000ba46:	3c d0       	j 8000b9e6 <_malloc_trim_r+0x32>
8000ba48:	99 c2 08 00 	ld.a %a2,[%a12]8
8000ba4c:	a2 f8       	sub %d8,%d15
8000ba4e:	8f 18 40 81 	or %d8,%d8,1
8000ba52:	59 28 04 00 	st.w [%a2]4,%d8
8000ba56:	91 00 00 27 	movh.a %a2,28672
8000ba5a:	19 22 d0 c0 	ld.w %d2,[%a2]3856 <70000f10 <__malloc_current_mallinfo>>
8000ba5e:	40 f4       	mov.aa %a4,%a15
8000ba60:	5a f2       	sub %d15,%d2,%d15
8000ba62:	59 2f d0 c0 	st.w [%a2]3856 <70000f10 <__malloc_current_mallinfo>>,%d15
8000ba66:	6d ff 5d ff 	call 8000b920 <__malloc_unlock>
8000ba6a:	82 12       	mov %d2,1
8000ba6c:	00 90       	ret 

8000ba6e <_free_r>:
8000ba6e:	40 4d       	mov.aa %a13,%a4
8000ba70:	bd 05 d4 00 	jz.a %a5,8000bc18 <_free_r+0x1aa>
8000ba74:	40 5c       	mov.aa %a12,%a5
8000ba76:	6d ff 54 ff 	call 8000b91e <__malloc_lock>
8000ba7a:	19 c4 fc ff 	ld.w %d4,[%a12]-4
8000ba7e:	d9 cf f8 ff 	lea %a15,[%a12]-8
8000ba82:	8f 14 c0 f1 	andn %d15,%d4,1
8000ba86:	91 00 00 27 	movh.a %a2,28672
8000ba8a:	10 f3       	addsc.a %a3,%a15,%d15,0
8000ba8c:	d9 22 10 50 	lea %a2,[%a2]336 <70000150 <__malloc_av_>>
8000ba90:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <g_vadcChannelIDs>>
8000ba94:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <g_vadcChannelIDs>>
8000ba98:	8f 14 00 41 	and %d4,%d4,1
8000ba9c:	8f 33 c0 31 	andn %d3,%d3,3
8000baa0:	7d 43 24 80 	jne.a %a3,%a4,8000bae8 <_free_r+0x7a>
8000baa4:	42 3f       	add %d15,%d3
8000baa6:	f6 4d       	jnz %d4,8000bac0 <_free_r+0x52>
8000baa8:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000baac:	60 23       	mov.a %a3,%d2
8000baae:	42 2f       	add %d15,%d2
8000bab0:	01 3f 20 f0 	sub.a %a15,%a15,%a3
8000bab4:	c8 33       	ld.a %a3,[%a15]12
8000bab6:	c8 24       	ld.a %a4,[%a15]8
8000bab8:	b5 43 0c 00 	st.a [%a4]12,%a3
8000babc:	b5 34 08 00 	st.a [%a3]8,%a4
8000bac0:	8f 1f 40 21 	or %d2,%d15,1
8000bac4:	68 12       	st.w [%a15]4,%d2
8000bac6:	ec 22       	st.a [%a2]8,%a15
8000bac8:	91 00 00 f7 	movh.a %a15,28672
8000bacc:	19 f2 0c 50 	ld.w %d2,[%a15]332 <7000014c <__malloc_trim_threshold>>
8000bad0:	3f 2f 09 80 	jlt.u %d15,%d2,8000bae2 <_free_r+0x74>
8000bad4:	91 00 00 f7 	movh.a %a15,28672
8000bad8:	40 d4       	mov.aa %a4,%a13
8000bada:	19 f4 c0 d0 	ld.w %d4,[%a15]3904 <70000f40 <__malloc_top_pad>>
8000bade:	6d ff 6b ff 	call 8000b9b4 <_malloc_trim_r>
8000bae2:	40 d4       	mov.aa %a4,%a13
8000bae4:	1d ff 1e ff 	j 8000b920 <__malloc_unlock>
8000bae8:	59 33 04 00 	st.w [%a3]4,%d3
8000baec:	82 02       	mov %d2,0
8000baee:	df 04 16 80 	jne %d4,0,8000bb1a <_free_r+0xac>
8000baf2:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000baf6:	60 24       	mov.a %a4,%d2
8000baf8:	42 2f       	add %d15,%d2
8000bafa:	01 4f 20 f0 	sub.a %a15,%a15,%a4
8000bafe:	c8 25       	ld.a %a5,[%a15]8
8000bb00:	91 00 00 47 	movh.a %a4,28672
8000bb04:	d9 44 18 50 	lea %a4,[%a4]344 <70000158 <__malloc_av_+0x8>>
8000bb08:	82 12       	mov %d2,1
8000bb0a:	7d 45 08 00 	jeq.a %a5,%a4,8000bb1a <_free_r+0xac>
8000bb0e:	c8 34       	ld.a %a4,[%a15]12
8000bb10:	82 02       	mov %d2,0
8000bb12:	b5 54 0c 00 	st.a [%a5]12,%a4
8000bb16:	b5 45 08 00 	st.a [%a4]8,%a5
8000bb1a:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
8000bb1e:	19 44 04 00 	ld.w %d4,[%a4]4
8000bb22:	6f 04 18 80 	jnz.t %d4,0,8000bb52 <_free_r+0xe4>
8000bb26:	42 3f       	add %d15,%d3
8000bb28:	99 35 08 00 	ld.a %a5,[%a3]8
8000bb2c:	f6 2d       	jnz %d2,8000bb46 <_free_r+0xd8>
8000bb2e:	91 00 00 47 	movh.a %a4,28672
8000bb32:	d9 44 18 50 	lea %a4,[%a4]344 <70000158 <__malloc_av_+0x8>>
8000bb36:	7d 45 08 80 	jne.a %a5,%a4,8000bb46 <_free_r+0xd8>
8000bb3a:	ec 25       	st.a [%a2]20,%a15
8000bb3c:	ec 24       	st.a [%a2]16,%a15
8000bb3e:	e8 35       	st.a [%a15]12,%a5
8000bb40:	e8 25       	st.a [%a15]8,%a5
8000bb42:	82 12       	mov %d2,1
8000bb44:	3c 07       	j 8000bb52 <_free_r+0xe4>
8000bb46:	99 33 0c 00 	ld.a %a3,[%a3]12
8000bb4a:	b5 53 0c 00 	st.a [%a5]12,%a3
8000bb4e:	b5 35 08 00 	st.a [%a3]8,%a5
8000bb52:	8f 1f 40 31 	or %d3,%d15,1
8000bb56:	10 f3       	addsc.a %a3,%a15,%d15,0
8000bb58:	68 13       	st.w [%a15]4,%d3
8000bb5a:	6c 30       	st.w [%a3]0,%d15
8000bb5c:	df 02 c3 ff 	jne %d2,0,8000bae2 <_free_r+0x74>
8000bb60:	3b 00 20 20 	mov %d2,512
8000bb64:	7f 2f 12 80 	jge.u %d15,%d2,8000bb88 <_free_r+0x11a>
8000bb68:	19 23 04 00 	ld.w %d3,[%a2]4
8000bb6c:	06 df       	sh %d15,-3
8000bb6e:	8f ef 3f 20 	sha %d2,%d15,-2
8000bb72:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
8000bb76:	59 22 04 00 	st.w [%a2]4,%d2
8000bb7a:	d0 22       	addsc.a %a2,%a2,%d15,3
8000bb7c:	99 23 08 00 	ld.a %a3,[%a2]8
8000bb80:	e8 32       	st.a [%a15]12,%a2
8000bb82:	e8 23       	st.a [%a15]8,%a3
8000bb84:	ec 22       	st.a [%a2]8,%a15
8000bb86:	3c 46       	j 8000bc12 <_free_r+0x1a4>
8000bb88:	8f af 1f 30 	sh %d3,%d15,-6
8000bb8c:	8f 7f 1f 20 	sh %d2,%d15,-9
8000bb90:	1b 83 03 30 	addi %d3,%d3,56
8000bb94:	bf 52 22 80 	jlt.u %d2,5,8000bbd8 <_free_r+0x16a>
8000bb98:	8b 52 a1 32 	ge.u %d3,%d2,21
8000bb9c:	f6 34       	jnz %d3,8000bba4 <_free_r+0x136>
8000bb9e:	1b b2 05 30 	addi %d3,%d2,91
8000bba2:	3c 1b       	j 8000bbd8 <_free_r+0x16a>
8000bba4:	8b 52 a5 32 	ge.u %d3,%d2,85
8000bba8:	f6 36       	jnz %d3,8000bbb4 <_free_r+0x146>
8000bbaa:	8f 4f 1f 30 	sh %d3,%d15,-12
8000bbae:	1b e3 06 30 	addi %d3,%d3,110
8000bbb2:	3c 13       	j 8000bbd8 <_free_r+0x16a>
8000bbb4:	8b 52 b5 32 	ge.u %d3,%d2,341
8000bbb8:	f6 36       	jnz %d3,8000bbc4 <_free_r+0x156>
8000bbba:	8f 1f 1f 30 	sh %d3,%d15,-15
8000bbbe:	1b 73 07 30 	addi %d3,%d3,119
8000bbc2:	3c 0b       	j 8000bbd8 <_free_r+0x16a>
8000bbc4:	3b 50 55 40 	mov %d4,1365
8000bbc8:	3b e0 07 30 	mov %d3,126
8000bbcc:	7f 42 06 80 	jge.u %d2,%d4,8000bbd8 <_free_r+0x16a>
8000bbd0:	8f ef 1e 30 	sh %d3,%d15,-18
8000bbd4:	1b c3 07 30 	addi %d3,%d3,124
8000bbd8:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
8000bbdc:	99 65 08 00 	ld.a %a5,[%a6]8
8000bbe0:	40 53       	mov.aa %a3,%a5
8000bbe2:	7d 65 0d 80 	jne.a %a5,%a6,8000bbfc <_free_r+0x18e>
8000bbe6:	4c 21       	ld.w %d15,[%a2]4
8000bbe8:	86 e3       	sha %d3,-2
8000bbea:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
8000bbee:	59 23 04 00 	st.w [%a2]4,%d3
8000bbf2:	3c 0d       	j 8000bc0c <_free_r+0x19e>
8000bbf4:	99 33 08 00 	ld.a %a3,[%a3]8
8000bbf8:	7d 63 08 00 	jeq.a %a3,%a6,8000bc08 <_free_r+0x19a>
8000bbfc:	19 32 04 00 	ld.w %d2,[%a3]4
8000bc00:	8f 32 c0 21 	andn %d2,%d2,3
8000bc04:	3f 2f f8 ff 	jlt.u %d15,%d2,8000bbf4 <_free_r+0x186>
8000bc08:	99 35 0c 00 	ld.a %a5,[%a3]12
8000bc0c:	e8 35       	st.a [%a15]12,%a5
8000bc0e:	e8 23       	st.a [%a15]8,%a3
8000bc10:	ec 52       	st.a [%a5]8,%a15
8000bc12:	ec 33       	st.a [%a3]12,%a15
8000bc14:	1d ff 67 ff 	j 8000bae2 <_free_r+0x74>
8000bc18:	00 90       	ret 
	...

8000bc1c <_svfprintf_r>:
8000bc1c:	20 d0       	sub.a %sp,208
8000bc1e:	80 5b       	mov.d %d11,%a5
8000bc20:	80 4c       	mov.d %d12,%a4
8000bc22:	b5 a6 18 00 	st.a [%sp]24,%a6
8000bc26:	40 7f       	mov.aa %a15,%a7
8000bc28:	6d 00 c4 0f 	call 8000dbb0 <_localeconv_r>
8000bc2c:	d4 22       	ld.a %a2,[%a2]
8000bc2e:	40 24       	mov.aa %a4,%a2
8000bc30:	b5 a2 34 00 	st.a [%sp]52,%a2
8000bc34:	6d ff 86 fe 	call 8000b940 <strlen>
8000bc38:	60 b2       	mov.a %a2,%d11
8000bc3a:	59 a2 20 00 	st.w [%sp]32,%d2
8000bc3e:	8c 26       	ld.h %d15,[%a2]12
8000bc40:	6f 7f 16 00 	jz.t %d15,7,8000bc6c <_svfprintf_r+0x50>
8000bc44:	4c 24       	ld.w %d15,[%a2]16
8000bc46:	ee 13       	jnz %d15,8000bc6c <_svfprintf_r+0x50>
8000bc48:	60 c4       	mov.a %a4,%d12
8000bc4a:	3b 00 04 40 	mov %d4,64
8000bc4e:	6d ff 1b fc 	call 8000b484 <_malloc_r>
8000bc52:	60 b3       	mov.a %a3,%d11
8000bc54:	f4 32       	st.a [%a3],%a2
8000bc56:	b5 32 10 00 	st.a [%a3]16,%a2
8000bc5a:	7c 26       	jnz.a %a2,8000bc66 <_svfprintf_r+0x4a>
8000bc5c:	60 cf       	mov.a %a15,%d12
8000bc5e:	da 0c       	mov %d15,12
8000bc60:	68 0f       	st.w [%a15]0,%d15
8000bc62:	82 f2       	mov %d2,-1
8000bc64:	00 90       	ret 
8000bc66:	60 b2       	mov.a %a2,%d11
8000bc68:	da 40       	mov %d15,64
8000bc6a:	6c 25       	st.w [%a2]20,%d15
8000bc6c:	82 0f       	mov %d15,0
8000bc6e:	d9 a2 10 20 	lea %a2,[%sp]144
8000bc72:	a0 03       	mov.a %a3,0
8000bc74:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000bc78:	78 19       	st.w [%sp]100,%d15
8000bc7a:	78 18       	st.w [%sp]96,%d15
8000bc7c:	78 05       	st.w [%sp]20,%d15
8000bc7e:	78 0b       	st.w [%sp]44,%d15
8000bc80:	78 0c       	st.w [%sp]48,%d15
8000bc82:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000bc86:	78 0e       	st.w [%sp]56,%d15
8000bc88:	78 0a       	st.w [%sp]40,%d15
8000bc8a:	40 2e       	mov.aa %a14,%a2
8000bc8c:	99 ac 18 00 	ld.a %a12,[%sp]24
8000bc90:	79 cf 00 00 	ld.b %d15,[%a12]0
8000bc94:	8b 0f 20 32 	ne %d3,%d15,0
8000bc98:	8b 5f 22 34 	and.ne %d3,%d15,37
8000bc9c:	76 33       	jz %d3,8000bca2 <_svfprintf_r+0x86>
8000bc9e:	b0 1c       	add.a %a12,1
8000bca0:	3c f8       	j 8000bc90 <_svfprintf_r+0x74>
8000bca2:	99 a3 18 00 	ld.a %a3,[%sp]24
8000bca6:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000bcaa:	80 3f       	mov.d %d15,%a3
8000bcac:	6e 23       	jz %d15,8000bcf2 <_svfprintf_r+0xd6>
8000bcae:	19 a3 24 10 	ld.w %d3,[%sp]100
8000bcb2:	99 a3 18 00 	ld.a %a3,[%sp]24
8000bcb6:	42 f3       	add %d3,%d15
8000bcb8:	59 a3 24 10 	st.w [%sp]100,%d3
8000bcbc:	19 a3 20 10 	ld.w %d3,[%sp]96
8000bcc0:	f4 e3       	st.a [%a14],%a3
8000bcc2:	c2 13       	add %d3,1
8000bcc4:	6c e1       	st.w [%a14]4,%d15
8000bcc6:	59 a3 20 10 	st.w [%sp]96,%d3
8000bcca:	8b 83 80 32 	ge %d3,%d3,8
8000bcce:	d9 ee 08 00 	lea %a14,[%a14]8
8000bcd2:	76 3b       	jz %d3,8000bce8 <_svfprintf_r+0xcc>
8000bcd4:	60 c4       	mov.a %a4,%d12
8000bcd6:	60 b5       	mov.a %a5,%d11
8000bcd8:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bcdc:	6d 00 7d 12 	call 8000e1d6 <__ssprint_r>
8000bce0:	df 02 69 88 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000bce4:	d9 ae 10 20 	lea %a14,[%sp]144
8000bce8:	19 a2 28 00 	ld.w %d2,[%sp]40
8000bcec:	42 f2       	add %d2,%d15
8000bcee:	59 a2 28 00 	st.w [%sp]40,%d2
8000bcf2:	79 cf 00 00 	ld.b %d15,[%a12]0
8000bcf6:	df 0f 56 08 	jeq %d15,0,8000cda2 <_svfprintf_r+0x1186>
8000bcfa:	82 0f       	mov %d15,0
8000bcfc:	82 02       	mov %d2,0
8000bcfe:	e9 af 01 10 	st.b [%sp]65,%d15
8000bd02:	d9 c2 01 00 	lea %a2,[%a12]1
8000bd06:	82 0f       	mov %d15,0
8000bd08:	82 fe       	mov %d14,-1
8000bd0a:	59 a2 1c 00 	st.w [%sp]28,%d2
8000bd0e:	82 0a       	mov %d10,0
8000bd10:	79 22 00 00 	ld.b %d2,[%a2]0
8000bd14:	d9 23 01 00 	lea %a3,[%a2]1
8000bd18:	b5 a3 18 00 	st.a [%sp]24,%a3
8000bd1c:	59 a2 10 00 	st.w [%sp]16,%d2
8000bd20:	19 a2 10 00 	ld.w %d2,[%sp]16
8000bd24:	1b 02 fe 3f 	addi %d3,%d2,-32
8000bd28:	8b 93 a5 42 	ge.u %d4,%d3,89
8000bd2c:	df 04 19 84 	jne %d4,0,8000c55e <_svfprintf_r+0x942>
8000bd30:	91 10 00 28 	movh.a %a2,32769
8000bd34:	d9 22 c0 5b 	lea %a2,[%a2]-17088 <8000bd40 <_svfprintf_r+0x124>>
8000bd38:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000bd3c:	dc 07       	ji %a7
8000bd3e:	00 00       	nop 
8000bd40:	1d 00 c3 00 	j 8000bec6 <_svfprintf_r+0x2aa>
8000bd44:	1d 00 0d 04 	j 8000c55e <_svfprintf_r+0x942>
8000bd48:	1d 00 0b 04 	j 8000c55e <_svfprintf_r+0x942>
8000bd4c:	1d 00 c0 00 	j 8000becc <_svfprintf_r+0x2b0>
8000bd50:	1d 00 07 04 	j 8000c55e <_svfprintf_r+0x942>
8000bd54:	1d 00 05 04 	j 8000c55e <_svfprintf_r+0x942>
8000bd58:	1d 00 03 04 	j 8000c55e <_svfprintf_r+0x942>
8000bd5c:	1d 00 01 04 	j 8000c55e <_svfprintf_r+0x942>
8000bd60:	1d 00 ff 03 	j 8000c55e <_svfprintf_r+0x942>
8000bd64:	1d 00 fd 03 	j 8000c55e <_svfprintf_r+0x942>
8000bd68:	1d 00 b5 00 	j 8000bed2 <_svfprintf_r+0x2b6>
8000bd6c:	1d 00 9c 00 	j 8000bea4 <_svfprintf_r+0x288>
8000bd70:	1d 00 f7 03 	j 8000c55e <_svfprintf_r+0x942>
8000bd74:	1d 00 b8 00 	j 8000bee4 <_svfprintf_r+0x2c8>
8000bd78:	1d 00 b9 00 	j 8000beea <_svfprintf_r+0x2ce>
8000bd7c:	1d 00 f1 03 	j 8000c55e <_svfprintf_r+0x942>
8000bd80:	1d 00 de 00 	j 8000bf3c <_svfprintf_r+0x320>
8000bd84:	1d 00 df 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bd88:	1d 00 dd 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bd8c:	1d 00 db 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bd90:	1d 00 d9 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bd94:	1d 00 d7 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bd98:	1d 00 d5 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bd9c:	1d 00 d3 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bda0:	1d 00 d1 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bda4:	1d 00 cf 00 	j 8000bf42 <_svfprintf_r+0x326>
8000bda8:	1d 00 db 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdac:	1d 00 d9 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdb0:	1d 00 d7 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdb4:	1d 00 d5 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdb8:	1d 00 d3 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdbc:	1d 00 d1 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdc0:	1d 00 cf 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdc4:	1d 00 cd 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdc8:	1d 00 cb 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdcc:	1d 00 c9 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdd0:	1d 00 f9 00 	j 8000bfc2 <_svfprintf_r+0x3a6>
8000bdd4:	1d 00 21 01 	j 8000c016 <_svfprintf_r+0x3fa>
8000bdd8:	1d 00 c3 03 	j 8000c55e <_svfprintf_r+0x942>
8000bddc:	1d 00 1d 01 	j 8000c016 <_svfprintf_r+0x3fa>
8000bde0:	1d 00 bf 03 	j 8000c55e <_svfprintf_r+0x942>
8000bde4:	1d 00 bd 03 	j 8000c55e <_svfprintf_r+0x942>
8000bde8:	1d 00 bb 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdec:	1d 00 b9 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdf0:	1d 00 c6 00 	j 8000bf7c <_svfprintf_r+0x360>
8000bdf4:	1d 00 b5 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdf8:	1d 00 b3 03 	j 8000c55e <_svfprintf_r+0x942>
8000bdfc:	1d 00 92 02 	j 8000c320 <_svfprintf_r+0x704>
8000be00:	1d 00 af 03 	j 8000c55e <_svfprintf_r+0x942>
8000be04:	1d 00 ad 03 	j 8000c55e <_svfprintf_r+0x942>
8000be08:	1d 00 ab 03 	j 8000c55e <_svfprintf_r+0x942>
8000be0c:	1d 00 a9 03 	j 8000c55e <_svfprintf_r+0x942>
8000be10:	1d 00 a7 03 	j 8000c55e <_svfprintf_r+0x942>
8000be14:	1d 00 d0 02 	j 8000c3b4 <_svfprintf_r+0x798>
8000be18:	1d 00 a3 03 	j 8000c55e <_svfprintf_r+0x942>
8000be1c:	1d 00 a1 03 	j 8000c55e <_svfprintf_r+0x942>
8000be20:	1d 00 4b 00 	j 8000beb6 <_svfprintf_r+0x29a>
8000be24:	1d 00 9d 03 	j 8000c55e <_svfprintf_r+0x942>
8000be28:	1d 00 9b 03 	j 8000c55e <_svfprintf_r+0x942>
8000be2c:	1d 00 99 03 	j 8000c55e <_svfprintf_r+0x942>
8000be30:	1d 00 97 03 	j 8000c55e <_svfprintf_r+0x942>
8000be34:	1d 00 95 03 	j 8000c55e <_svfprintf_r+0x942>
8000be38:	1d 00 93 03 	j 8000c55e <_svfprintf_r+0x942>
8000be3c:	1d 00 91 03 	j 8000c55e <_svfprintf_r+0x942>
8000be40:	1d 00 8f 03 	j 8000c55e <_svfprintf_r+0x942>
8000be44:	1d 00 8d 03 	j 8000c55e <_svfprintf_r+0x942>
8000be48:	1d 00 8b 03 	j 8000c55e <_svfprintf_r+0x942>
8000be4c:	1d 00 b0 00 	j 8000bfac <_svfprintf_r+0x390>
8000be50:	1d 00 2f 00 	j 8000beae <_svfprintf_r+0x292>
8000be54:	1d 00 e1 00 	j 8000c016 <_svfprintf_r+0x3fa>
8000be58:	1d 00 df 00 	j 8000c016 <_svfprintf_r+0x3fa>
8000be5c:	1d 00 dd 00 	j 8000c016 <_svfprintf_r+0x3fa>
8000be60:	1d 00 91 00 	j 8000bf82 <_svfprintf_r+0x366>
8000be64:	1d 00 25 00 	j 8000beae <_svfprintf_r+0x292>
8000be68:	1d 00 7b 03 	j 8000c55e <_svfprintf_r+0x942>
8000be6c:	1d 00 79 03 	j 8000c55e <_svfprintf_r+0x942>
8000be70:	1d 00 8c 00 	j 8000bf88 <_svfprintf_r+0x36c>
8000be74:	1d 00 75 03 	j 8000c55e <_svfprintf_r+0x942>
8000be78:	1d 00 39 02 	j 8000c2ea <_svfprintf_r+0x6ce>
8000be7c:	1d 00 54 02 	j 8000c324 <_svfprintf_r+0x708>
8000be80:	1d 00 66 02 	j 8000c34c <_svfprintf_r+0x730>
8000be84:	1d 00 90 00 	j 8000bfa4 <_svfprintf_r+0x388>
8000be88:	1d 00 6b 03 	j 8000c55e <_svfprintf_r+0x942>
8000be8c:	1d 00 77 02 	j 8000c37a <_svfprintf_r+0x75e>
8000be90:	1d 00 67 03 	j 8000c55e <_svfprintf_r+0x942>
8000be94:	1d 00 92 02 	j 8000c3b8 <_svfprintf_r+0x79c>
8000be98:	1d 00 63 03 	j 8000c55e <_svfprintf_r+0x942>
8000be9c:	1d 00 61 03 	j 8000c55e <_svfprintf_r+0x942>
8000bea0:	1d 00 a0 02 	j 8000c3e0 <_svfprintf_r+0x7c4>
8000bea4:	da 2b       	mov %d15,43
8000bea6:	99 a2 18 00 	ld.a %a2,[%sp]24
8000beaa:	1d ff 33 ff 	j 8000bd10 <_svfprintf_r+0xf4>
8000beae:	e9 af 01 10 	st.b [%sp]65,%d15
8000beb2:	1d 00 8c 00 	j 8000bfca <_svfprintf_r+0x3ae>
8000beb6:	e9 af 01 10 	st.b [%sp]65,%d15
8000beba:	7b 00 00 f8 	movh %d15,32768
8000bebe:	1b cf fb f0 	addi %d15,%d15,4028
8000bec2:	1d 00 95 02 	j 8000c3ec <_svfprintf_r+0x7d0>
8000bec6:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000beca:	3c ee       	j 8000bea6 <_svfprintf_r+0x28a>
8000becc:	8f 1a 40 a1 	or %d10,%d10,1
8000bed0:	3c eb       	j 8000bea6 <_svfprintf_r+0x28a>
8000bed2:	48 02       	ld.w %d2,[%a15]0
8000bed4:	b0 4f       	add.a %a15,4
8000bed6:	59 a2 1c 00 	st.w [%sp]28,%d2
8000beda:	ff 02 e6 7f 	jge %d2,0,8000bea6 <_svfprintf_r+0x28a>
8000bede:	32 52       	rsub %d2
8000bee0:	59 a2 1c 00 	st.w [%sp]28,%d2
8000bee4:	8f 4a 40 a1 	or %d10,%d10,4
8000bee8:	3c df       	j 8000bea6 <_svfprintf_r+0x28a>
8000beea:	99 a3 18 00 	ld.a %a3,[%sp]24
8000beee:	99 a2 18 00 	ld.a %a2,[%sp]24
8000bef2:	79 32 00 00 	ld.b %d2,[%a3]0
8000bef6:	b0 12       	add.a %a2,1
8000bef8:	59 a2 10 00 	st.w [%sp]16,%d2
8000befc:	8b a2 02 32 	eq %d3,%d2,42
8000bf00:	f6 33       	jnz %d3,8000bf06 <_svfprintf_r+0x2ea>
8000bf02:	82 05       	mov %d5,0
8000bf04:	3c 08       	j 8000bf14 <_svfprintf_r+0x2f8>
8000bf06:	48 0e       	ld.w %d14,[%a15]0
8000bf08:	b5 a2 18 00 	st.a [%sp]24,%a2
8000bf0c:	b0 4f       	add.a %a15,4
8000bf0e:	8b fe 5f e3 	max %d14,%d14,-1
8000bf12:	3c ca       	j 8000bea6 <_svfprintf_r+0x28a>
8000bf14:	19 a2 10 00 	ld.w %d2,[%sp]16
8000bf18:	1b 02 fd 3f 	addi %d3,%d2,-48
8000bf1c:	ff a3 0a 80 	jge.u %d3,10,8000bf30 <_svfprintf_r+0x314>
8000bf20:	79 22 00 00 	ld.b %d2,[%a2]0
8000bf24:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000bf28:	59 a2 10 00 	st.w [%sp]16,%d2
8000bf2c:	b0 12       	add.a %a2,1
8000bf2e:	3c f3       	j 8000bf14 <_svfprintf_r+0x2f8>
8000bf30:	8b f5 5f e3 	max %d14,%d5,-1
8000bf34:	b5 a2 18 00 	st.a [%sp]24,%a2
8000bf38:	1d ff f4 fe 	j 8000bd20 <_svfprintf_r+0x104>
8000bf3c:	8f 0a 48 a1 	or %d10,%d10,128
8000bf40:	3c b3       	j 8000bea6 <_svfprintf_r+0x28a>
8000bf42:	82 02       	mov %d2,0
8000bf44:	59 a2 1c 00 	st.w [%sp]28,%d2
8000bf48:	19 a2 10 00 	ld.w %d2,[%sp]16
8000bf4c:	99 a3 18 00 	ld.a %a3,[%sp]24
8000bf50:	1b 02 fd 4f 	addi %d4,%d2,-48
8000bf54:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000bf58:	99 a2 18 00 	ld.a %a2,[%sp]24
8000bf5c:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000bf60:	b0 12       	add.a %a2,1
8000bf62:	59 a2 1c 00 	st.w [%sp]28,%d2
8000bf66:	79 32 00 00 	ld.b %d2,[%a3]0
8000bf6a:	b5 a2 18 00 	st.a [%sp]24,%a2
8000bf6e:	59 a2 10 00 	st.w [%sp]16,%d2
8000bf72:	1b 02 fd 4f 	addi %d4,%d2,-48
8000bf76:	bf a4 e9 ff 	jlt.u %d4,10,8000bf48 <_svfprintf_r+0x32c>
8000bf7a:	3c dd       	j 8000bf34 <_svfprintf_r+0x318>
8000bf7c:	8f 8a 40 a1 	or %d10,%d10,8
8000bf80:	3c 93       	j 8000bea6 <_svfprintf_r+0x28a>
8000bf82:	8f 0a 44 a1 	or %d10,%d10,64
8000bf86:	3c 90       	j 8000bea6 <_svfprintf_r+0x28a>
8000bf88:	99 a3 18 00 	ld.a %a3,[%sp]24
8000bf8c:	79 33 00 00 	ld.b %d3,[%a3]0
8000bf90:	8b c3 26 32 	ne %d3,%d3,108
8000bf94:	f6 35       	jnz %d3,8000bf9e <_svfprintf_r+0x382>
8000bf96:	b0 13       	add.a %a3,1
8000bf98:	b5 a3 18 00 	st.a [%sp]24,%a3
8000bf9c:	3c 04       	j 8000bfa4 <_svfprintf_r+0x388>
8000bf9e:	8f 0a 41 a1 	or %d10,%d10,16
8000bfa2:	3c 82       	j 8000bea6 <_svfprintf_r+0x28a>
8000bfa4:	8f 0a 42 a1 	or %d10,%d10,32
8000bfa8:	1d ff 7f ff 	j 8000bea6 <_svfprintf_r+0x28a>
8000bfac:	48 03       	ld.w %d3,[%a15]0
8000bfae:	d9 fc 04 00 	lea %a12,[%a15]4
8000bfb2:	e9 a3 28 10 	st.b [%sp]104,%d3
8000bfb6:	82 03       	mov %d3,0
8000bfb8:	e9 a3 01 10 	st.b [%sp]65,%d3
8000bfbc:	60 ad       	mov.a %a13,%d10
8000bfbe:	1d 00 dc 02 	j 8000c576 <_svfprintf_r+0x95a>
8000bfc2:	e9 af 01 10 	st.b [%sp]65,%d15
8000bfc6:	8f 0a 41 a1 	or %d10,%d10,16
8000bfca:	60 ad       	mov.a %a13,%d10
8000bfcc:	6f 5a 07 00 	jz.t %d10,5,8000bfda <_svfprintf_r+0x3be>
8000bfd0:	d9 fc 08 00 	lea %a12,[%a15]8
8000bfd4:	09 f8 40 09 	ld.d %e8,[%a15]
8000bfd8:	3c 12       	j 8000bffc <_svfprintf_r+0x3e0>
8000bfda:	d9 f2 04 00 	lea %a2,[%a15]4
8000bfde:	6f 4a 05 00 	jz.t %d10,4,8000bfe8 <_svfprintf_r+0x3cc>
8000bfe2:	40 2c       	mov.aa %a12,%a2
8000bfe4:	48 08       	ld.w %d8,[%a15]0
8000bfe6:	3c 09       	j 8000bff8 <_svfprintf_r+0x3dc>
8000bfe8:	48 03       	ld.w %d3,[%a15]0
8000bfea:	40 2c       	mov.aa %a12,%a2
8000bfec:	0b 30 00 88 	mov %e8,%d3
8000bff0:	6f 6a 06 00 	jz.t %d10,6,8000bffc <_svfprintf_r+0x3e0>
8000bff4:	37 03 50 80 	extr %d8,%d3,0,16
8000bff8:	0b 80 00 88 	mov %e8,%d8
8000bffc:	82 13       	mov %d3,1
8000bffe:	ff 09 1d 02 	jge %d9,0,8000c438 <_svfprintf_r+0x81c>
8000c002:	32 59       	rsub %d9
8000c004:	32 58       	rsub %d8
8000c006:	3b d0 02 70 	mov %d7,45
8000c00a:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000c00e:	e9 a7 01 10 	st.b [%sp]65,%d7
8000c012:	1d 00 13 02 	j 8000c438 <_svfprintf_r+0x81c>
8000c016:	e9 af 01 10 	st.b [%sp]65,%d15
8000c01a:	4c f0       	ld.w %d15,[%a15]0
8000c01c:	d9 fc 08 00 	lea %a12,[%a15]8
8000c020:	78 0b       	st.w [%sp]44,%d15
8000c022:	4c f1       	ld.w %d15,[%a15]4
8000c024:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000c028:	78 0c       	st.w [%sp]48,%d15
8000c02a:	19 a5 30 00 	ld.w %d5,[%sp]48
8000c02e:	6d 00 b3 10 	call 8000e194 <__fpclassifyd>
8000c032:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000c036:	19 a5 30 00 	ld.w %d5,[%sp]48
8000c03a:	df 12 18 80 	jne %d2,1,8000c06a <_svfprintf_r+0x44e>
8000c03e:	d2 06       	mov %e6,0
8000c040:	6d 00 50 14 	call 8000e8e0 <__ltdf2>
8000c044:	ce 25       	jgez %d2,8000c04e <_svfprintf_r+0x432>
8000c046:	3b d0 02 30 	mov %d3,45
8000c04a:	e9 a3 01 10 	st.b [%sp]65,%d3
8000c04e:	58 04       	ld.w %d15,[%sp]16
8000c050:	7b 00 00 78 	movh %d7,32768
8000c054:	8b 8f 84 32 	ge %d3,%d15,72
8000c058:	1b 07 fb d0 	addi %d13,%d7,4016
8000c05c:	df 03 17 80 	jne %d3,0,8000c08a <_svfprintf_r+0x46e>
8000c060:	7b 00 00 78 	movh %d7,32768
8000c064:	1b c7 fa d0 	addi %d13,%d7,4012
8000c068:	3c 11       	j 8000c08a <_svfprintf_r+0x46e>
8000c06a:	6d 00 95 10 	call 8000e194 <__fpclassifyd>
8000c06e:	58 04       	ld.w %d15,[%sp]16
8000c070:	df 02 13 80 	jne %d2,0,8000c096 <_svfprintf_r+0x47a>
8000c074:	7b 00 00 78 	movh %d7,32768
8000c078:	8b 8f 84 32 	ge %d3,%d15,72
8000c07c:	1b 87 fb d0 	addi %d13,%d7,4024
8000c080:	f6 35       	jnz %d3,8000c08a <_svfprintf_r+0x46e>
8000c082:	7b 00 00 78 	movh %d7,32768
8000c086:	1b 47 fb d0 	addi %d13,%d7,4020
8000c08a:	8f 0a c8 a1 	andn %d10,%d10,128
8000c08e:	60 ad       	mov.a %a13,%d10
8000c090:	82 39       	mov %d9,3
8000c092:	1d 00 78 02 	j 8000c582 <_svfprintf_r+0x966>
8000c096:	8f 0f c2 f1 	andn %d15,%d15,32
8000c09a:	78 01       	st.w [%sp]4,%d15
8000c09c:	df fe 09 00 	jeq %d14,-1,8000c0ae <_svfprintf_r+0x492>
8000c0a0:	8b 0e 00 72 	eq %d7,%d14,0
8000c0a4:	8b 7f 04 74 	and.eq %d7,%d15,71
8000c0a8:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000c0ac:	3c 02       	j 8000c0b0 <_svfprintf_r+0x494>
8000c0ae:	82 6e       	mov %d14,6
8000c0b0:	19 a3 30 00 	ld.w %d3,[%sp]48
8000c0b4:	8f 0a 50 21 	or %d2,%d10,256
8000c0b8:	60 2d       	mov.a %a13,%d2
8000c0ba:	d8 0b       	ld.a %a15,[%sp]44
8000c0bc:	82 0f       	mov %d15,0
8000c0be:	ce 34       	jgez %d3,8000c0c6 <_svfprintf_r+0x4aa>
8000c0c0:	9b 03 00 38 	addih %d3,%d3,32768
8000c0c4:	da 2d       	mov %d15,45
8000c0c6:	78 09       	st.w [%sp]36,%d15
8000c0c8:	58 01       	ld.w %d15,[%sp]4
8000c0ca:	02 e9       	mov %d9,%d14
8000c0cc:	8b 6f 04 22 	eq %d2,%d15,70
8000c0d0:	82 36       	mov %d6,3
8000c0d2:	f6 28       	jnz %d2,8000c0e2 <_svfprintf_r+0x4c6>
8000c0d4:	8b 5f 24 12 	ne %d1,%d15,69
8000c0d8:	1b 1e 00 50 	addi %d5,%d14,1
8000c0dc:	82 26       	mov %d6,2
8000c0de:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000c0e2:	60 c4       	mov.a %a4,%d12
8000c0e4:	80 f4       	mov.d %d4,%a15
8000c0e6:	02 35       	mov %d5,%d3
8000c0e8:	02 97       	mov %d7,%d9
8000c0ea:	d9 a5 04 10 	lea %a5,[%sp]68
8000c0ee:	d9 a6 08 10 	lea %a6,[%sp]72
8000c0f2:	d9 a7 14 10 	lea %a7,[%sp]84
8000c0f6:	59 a2 0c 00 	st.w [%sp]12,%d2
8000c0fa:	59 a3 08 00 	st.w [%sp]8,%d3
8000c0fe:	6d 00 ef 06 	call 8000cedc <_dtoa_r>
8000c102:	58 01       	ld.w %d15,[%sp]4
8000c104:	80 2d       	mov.d %d13,%a2
8000c106:	8b 7f 24 12 	ne %d1,%d15,71
8000c10a:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c10e:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c112:	df 01 11 80 	jne %d1,0,8000c134 <_svfprintf_r+0x518>
8000c116:	6f 0a 0f 80 	jnz.t %d10,0,8000c134 <_svfprintf_r+0x518>
8000c11a:	19 a2 14 10 	ld.w %d2,[%sp]84
8000c11e:	58 01       	ld.w %d15,[%sp]4
8000c120:	a2 d2       	sub %d2,%d13
8000c122:	59 a2 14 00 	st.w [%sp]20,%d2
8000c126:	8b 7f 04 42 	eq %d4,%d15,71
8000c12a:	19 a5 04 10 	ld.w %d5,[%sp]68
8000c12e:	df 04 36 80 	jne %d4,0,8000c19a <_svfprintf_r+0x57e>
8000c132:	3c 3e       	j 8000c1ae <_svfprintf_r+0x592>
8000c134:	0b 9d 00 80 	add %d8,%d13,%d9
8000c138:	df 02 1c 00 	jeq %d2,0,8000c170 <_svfprintf_r+0x554>
8000c13c:	60 d2       	mov.a %a2,%d13
8000c13e:	80 f4       	mov.d %d4,%a15
8000c140:	79 20 00 00 	ld.b %d0,[%a2]0
8000c144:	d2 06       	mov %e6,0
8000c146:	02 35       	mov %d5,%d3
8000c148:	8b 00 03 f2 	eq %d15,%d0,48
8000c14c:	59 a3 08 00 	st.w [%sp]8,%d3
8000c150:	6d 00 68 13 	call 8000e820 <__nedf2>
8000c154:	8b 02 20 22 	ne %d2,%d2,0
8000c158:	0f 2f 80 00 	and %d0,%d15,%d2
8000c15c:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c160:	76 05       	jz %d0,8000c16a <_svfprintf_r+0x54e>
8000c162:	8b 19 00 01 	rsub %d0,%d9,1
8000c166:	59 a0 04 10 	st.w [%sp]68,%d0
8000c16a:	19 a2 04 10 	ld.w %d2,[%sp]68
8000c16e:	42 28       	add %d8,%d2
8000c170:	80 f4       	mov.d %d4,%a15
8000c172:	d2 06       	mov %e6,0
8000c174:	02 35       	mov %d5,%d3
8000c176:	6d 00 35 13 	call 8000e7e0 <__eqdf2>
8000c17a:	f6 23       	jnz %d2,8000c180 <_svfprintf_r+0x564>
8000c17c:	59 a8 14 10 	st.w [%sp]84,%d8
8000c180:	3b 00 03 00 	mov %d0,48
8000c184:	19 a3 14 10 	ld.w %d3,[%sp]84
8000c188:	7f 83 c9 ff 	jge.u %d3,%d8,8000c11a <_svfprintf_r+0x4fe>
8000c18c:	1b 13 00 10 	addi %d1,%d3,1
8000c190:	60 32       	mov.a %a2,%d3
8000c192:	59 a1 14 10 	st.w [%sp]84,%d1
8000c196:	34 20       	st.b [%a2],%d0
8000c198:	3c f6       	j 8000c184 <_svfprintf_r+0x568>
8000c19a:	0b 5e 20 31 	lt %d3,%d14,%d5
8000c19e:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000c1a2:	df 03 88 00 	jeq %d3,0,8000c2b2 <_svfprintf_r+0x696>
8000c1a6:	58 04       	ld.w %d15,[%sp]16
8000c1a8:	c2 ef       	add %d15,-2
8000c1aa:	78 04       	st.w [%sp]16,%d15
8000c1ac:	3c 06       	j 8000c1b8 <_svfprintf_r+0x59c>
8000c1ae:	58 04       	ld.w %d15,[%sp]16
8000c1b0:	8b 6f 86 32 	ge %d3,%d15,102
8000c1b4:	df 03 69 80 	jne %d3,0,8000c286 <_svfprintf_r+0x66a>
8000c1b8:	19 a2 10 00 	ld.w %d2,[%sp]16
8000c1bc:	9a f5       	add %d15,%d5,-1
8000c1be:	78 11       	st.w [%sp]68,%d15
8000c1c0:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000c1c4:	3b b0 02 30 	mov %d3,43
8000c1c8:	ce f4       	jgez %d15,8000c1d0 <_svfprintf_r+0x5b4>
8000c1ca:	32 5f       	rsub %d15
8000c1cc:	3b d0 02 30 	mov %d3,45
8000c1d0:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000c1d4:	8b af 40 32 	lt %d3,%d15,10
8000c1d8:	df 03 3e 80 	jne %d3,0,8000c254 <_svfprintf_r+0x638>
8000c1dc:	82 06       	mov %d6,0
8000c1de:	3b a0 00 00 	mov %d0,10
8000c1e2:	4b 0f 01 42 	div %e4,%d15,%d0
8000c1e6:	8b 66 00 71 	rsub %d7,%d6,6
8000c1ea:	60 72       	mov.a %a2,%d7
8000c1ec:	d9 af 14 10 	lea %a15,[%sp]84
8000c1f0:	1b 05 03 30 	addi %d3,%d5,48
8000c1f4:	30 2f       	add.a %a15,%a2
8000c1f6:	28 03       	st.b [%a15]0,%d3
8000c1f8:	8b a4 80 32 	ge %d3,%d4,10
8000c1fc:	02 4f       	mov %d15,%d4
8000c1fe:	c2 16       	add %d6,1
8000c200:	df 03 f1 ff 	jne %d3,0,8000c1e2 <_svfprintf_r+0x5c6>
8000c204:	60 74       	mov.a %a4,%d7
8000c206:	d9 a2 10 30 	lea %a2,[%sp]208
8000c20a:	1b 04 03 f0 	addi %d15,%d4,48
8000c20e:	30 42       	add.a %a2,%a4
8000c210:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000c214:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000c218:	80 22       	mov.d %d2,%a2
8000c21a:	d9 af 1b 10 	lea %a15,[%sp]91
8000c21e:	80 ff       	mov.d %d15,%a15
8000c220:	1b 32 f8 4f 	addi %d4,%d2,-125
8000c224:	82 03       	mov %d3,0
8000c226:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000c22a:	3f 4f 08 80 	jlt.u %d15,%d4,8000c23a <_svfprintf_r+0x61e>
8000c22e:	80 a2       	mov.d %d2,%sp
8000c230:	1b 02 0d 20 	addi %d2,%d2,208
8000c234:	8b 52 07 42 	eq %d4,%d2,117
8000c238:	76 46       	jz %d4,8000c244 <_svfprintf_r+0x628>
8000c23a:	a0 03       	mov.a %a3,0
8000c23c:	3c 04       	j 8000c244 <_svfprintf_r+0x628>
8000c23e:	0c 70       	ld.bu %d15,[%a7]0
8000c240:	b0 17       	add.a %a7,1
8000c242:	28 0f       	st.b [%a15]0,%d15
8000c244:	60 3f       	mov.a %a15,%d3
8000c246:	d9 a2 0d 10 	lea %a2,[%sp]77
8000c24a:	b0 2f       	add.a %a15,2
8000c24c:	30 2f       	add.a %a15,%a2
8000c24e:	c2 13       	add %d3,1
8000c250:	fc 37       	loop %a3,8000c23e <_svfprintf_r+0x622>
8000c252:	3c 0b       	j 8000c268 <_svfprintf_r+0x64c>
8000c254:	3b 00 03 30 	mov %d3,48
8000c258:	1b 0f 03 f0 	addi %d15,%d15,48
8000c25c:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000c260:	e9 af 10 10 	st.b [%sp]80,%d15
8000c264:	d9 af 11 10 	lea %a15,[%sp]81
8000c268:	d9 a7 0d 10 	lea %a7,[%sp]77
8000c26c:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000c270:	80 79       	mov.d %d9,%a7
8000c272:	58 05       	ld.w %d15,[%sp]20
8000c274:	b5 a7 38 00 	st.a [%sp]56,%a7
8000c278:	42 f9       	add %d9,%d15
8000c27a:	ff 2f 04 00 	jge %d15,2,8000c282 <_svfprintf_r+0x666>
8000c27e:	6f 0a 2c 00 	jz.t %d10,0,8000c2d6 <_svfprintf_r+0x6ba>
8000c282:	c2 19       	add %d9,1
8000c284:	3c 29       	j 8000c2d6 <_svfprintf_r+0x6ba>
8000c286:	58 04       	ld.w %d15,[%sp]16
8000c288:	8b 6f 26 42 	ne %d4,%d15,102
8000c28c:	df 04 15 80 	jne %d4,0,8000c2b6 <_svfprintf_r+0x69a>
8000c290:	02 59       	mov %d9,%d5
8000c292:	8e 59       	jlez %d5,8000c2a4 <_svfprintf_r+0x688>
8000c294:	f6 e3       	jnz %d14,8000c29a <_svfprintf_r+0x67e>
8000c296:	6f 0a 20 00 	jz.t %d10,0,8000c2d6 <_svfprintf_r+0x6ba>
8000c29a:	1b 1e 00 30 	addi %d3,%d14,1
8000c29e:	0b 35 00 90 	add %d9,%d5,%d3
8000c2a2:	3c 1a       	j 8000c2d6 <_svfprintf_r+0x6ba>
8000c2a4:	f6 e4       	jnz %d14,8000c2ac <_svfprintf_r+0x690>
8000c2a6:	82 19       	mov %d9,1
8000c2a8:	6f 0a 17 00 	jz.t %d10,0,8000c2d6 <_svfprintf_r+0x6ba>
8000c2ac:	1b 2e 00 90 	addi %d9,%d14,2
8000c2b0:	3c 13       	j 8000c2d6 <_svfprintf_r+0x6ba>
8000c2b2:	da 67       	mov %d15,103
8000c2b4:	78 04       	st.w [%sp]16,%d15
8000c2b6:	58 05       	ld.w %d15,[%sp]20
8000c2b8:	8f 1a 00 a1 	and %d10,%d10,1
8000c2bc:	0b a5 00 90 	add %d9,%d5,%d10
8000c2c0:	7f f5 0b 00 	jge %d5,%d15,8000c2d6 <_svfprintf_r+0x6ba>
8000c2c4:	8b 15 40 92 	lt %d9,%d5,1
8000c2c8:	8b 25 00 31 	rsub %d3,%d5,2
8000c2cc:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000c2d0:	19 a9 14 00 	ld.w %d9,[%sp]20
8000c2d4:	42 39       	add %d9,%d3
8000c2d6:	58 09       	ld.w %d15,[%sp]36
8000c2d8:	82 0e       	mov %d14,0
8000c2da:	df 0f 55 01 	jeq %d15,0,8000c584 <_svfprintf_r+0x968>
8000c2de:	3b d0 02 70 	mov %d7,45
8000c2e2:	e9 a7 01 10 	st.b [%sp]65,%d7
8000c2e6:	1d 00 4f 01 	j 8000c584 <_svfprintf_r+0x968>
8000c2ea:	e9 af 01 10 	st.b [%sp]65,%d15
8000c2ee:	d9 f2 04 00 	lea %a2,[%a15]4
8000c2f2:	6f 5a 09 00 	jz.t %d10,5,8000c304 <_svfprintf_r+0x6e8>
8000c2f6:	58 0a       	ld.w %d15,[%sp]40
8000c2f8:	c8 03       	ld.a %a3,[%a15]0
8000c2fa:	0b f0 00 48 	mov %e4,%d15
8000c2fe:	89 34 40 09 	st.d [%a3],%e4
8000c302:	3c 0c       	j 8000c31a <_svfprintf_r+0x6fe>
8000c304:	6f 4a 08 80 	jnz.t %d10,4,8000c314 <_svfprintf_r+0x6f8>
8000c308:	6f 6a 06 00 	jz.t %d10,6,8000c314 <_svfprintf_r+0x6f8>
8000c30c:	c8 03       	ld.a %a3,[%a15]0
8000c30e:	58 0a       	ld.w %d15,[%sp]40
8000c310:	ac 30       	st.h [%a3]0,%d15
8000c312:	3c 04       	j 8000c31a <_svfprintf_r+0x6fe>
8000c314:	c8 03       	ld.a %a3,[%a15]0
8000c316:	58 0a       	ld.w %d15,[%sp]40
8000c318:	6c 30       	st.w [%a3]0,%d15
8000c31a:	40 2f       	mov.aa %a15,%a2
8000c31c:	1d ff b8 fc 	j 8000bc8c <_svfprintf_r+0x70>
8000c320:	8f 0a 41 a1 	or %d10,%d10,16
8000c324:	6f 5a 07 00 	jz.t %d10,5,8000c332 <_svfprintf_r+0x716>
8000c328:	d9 fc 08 00 	lea %a12,[%a15]8
8000c32c:	09 f8 40 09 	ld.d %e8,[%a15]
8000c330:	3c 0c       	j 8000c348 <_svfprintf_r+0x72c>
8000c332:	d9 fc 04 00 	lea %a12,[%a15]4
8000c336:	6f 4a 07 80 	jnz.t %d10,4,8000c344 <_svfprintf_r+0x728>
8000c33a:	6f 6a 05 00 	jz.t %d10,6,8000c344 <_svfprintf_r+0x728>
8000c33e:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000c342:	3c 02       	j 8000c346 <_svfprintf_r+0x72a>
8000c344:	48 08       	ld.w %d8,[%a15]0
8000c346:	82 09       	mov %d9,0
8000c348:	82 03       	mov %d3,0
8000c34a:	3c 73       	j 8000c430 <_svfprintf_r+0x814>
8000c34c:	3b 00 03 40 	mov %d4,48
8000c350:	7b 00 00 f8 	movh %d15,32768
8000c354:	1b df fc f0 	addi %d15,%d15,4045
8000c358:	e9 a4 02 10 	st.b [%sp]66,%d4
8000c35c:	3b 80 07 40 	mov %d4,120
8000c360:	78 0f       	st.w [%sp]60,%d15
8000c362:	02 4f       	mov %d15,%d4
8000c364:	d9 fc 04 00 	lea %a12,[%a15]4
8000c368:	48 08       	ld.w %d8,[%a15]0
8000c36a:	82 09       	mov %d9,0
8000c36c:	8f 2a 40 a1 	or %d10,%d10,2
8000c370:	e9 a4 03 10 	st.b [%sp]67,%d4
8000c374:	82 23       	mov %d3,2
8000c376:	78 04       	st.w [%sp]16,%d15
8000c378:	3c 5c       	j 8000c430 <_svfprintf_r+0x814>
8000c37a:	82 07       	mov %d7,0
8000c37c:	48 0d       	ld.w %d13,[%a15]0
8000c37e:	e9 a7 01 10 	st.b [%sp]65,%d7
8000c382:	02 e9       	mov %d9,%d14
8000c384:	60 ad       	mov.a %a13,%d10
8000c386:	d9 fc 04 00 	lea %a12,[%a15]4
8000c38a:	60 d4       	mov.a %a4,%d13
8000c38c:	0e ef       	jltz %d14,8000c3aa <_svfprintf_r+0x78e>
8000c38e:	82 04       	mov %d4,0
8000c390:	02 e5       	mov %d5,%d14
8000c392:	6d 00 14 0c 	call 8000dbba <memchr>
8000c396:	bd 02 f6 00 	jz.a %a2,8000c582 <_svfprintf_r+0x966>
8000c39a:	60 d4       	mov.a %a4,%d13
8000c39c:	01 42 20 30 	sub.a %a3,%a2,%a4
8000c3a0:	80 32       	mov.d %d2,%a3
8000c3a2:	0b e2 80 91 	min %d9,%d2,%d14
8000c3a6:	1d 00 ee 00 	j 8000c582 <_svfprintf_r+0x966>
8000c3aa:	6d ff cb fa 	call 8000b940 <strlen>
8000c3ae:	02 29       	mov %d9,%d2
8000c3b0:	1d 00 e9 00 	j 8000c582 <_svfprintf_r+0x966>
8000c3b4:	8f 0a 41 a1 	or %d10,%d10,16
8000c3b8:	6f 5a 07 00 	jz.t %d10,5,8000c3c6 <_svfprintf_r+0x7aa>
8000c3bc:	d9 fc 08 00 	lea %a12,[%a15]8
8000c3c0:	09 f8 40 09 	ld.d %e8,[%a15]
8000c3c4:	3c 0c       	j 8000c3dc <_svfprintf_r+0x7c0>
8000c3c6:	d9 fc 04 00 	lea %a12,[%a15]4
8000c3ca:	6f 4a 07 80 	jnz.t %d10,4,8000c3d8 <_svfprintf_r+0x7bc>
8000c3ce:	6f 6a 05 00 	jz.t %d10,6,8000c3d8 <_svfprintf_r+0x7bc>
8000c3d2:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000c3d6:	3c 02       	j 8000c3da <_svfprintf_r+0x7be>
8000c3d8:	48 08       	ld.w %d8,[%a15]0
8000c3da:	82 09       	mov %d9,0
8000c3dc:	82 13       	mov %d3,1
8000c3de:	3c 29       	j 8000c430 <_svfprintf_r+0x814>
8000c3e0:	e9 af 01 10 	st.b [%sp]65,%d15
8000c3e4:	7b 00 00 f8 	movh %d15,32768
8000c3e8:	1b df fc f0 	addi %d15,%d15,4045
8000c3ec:	78 0f       	st.w [%sp]60,%d15
8000c3ee:	6f 5a 07 00 	jz.t %d10,5,8000c3fc <_svfprintf_r+0x7e0>
8000c3f2:	d9 fc 08 00 	lea %a12,[%a15]8
8000c3f6:	09 f8 40 09 	ld.d %e8,[%a15]
8000c3fa:	3c 0c       	j 8000c412 <_svfprintf_r+0x7f6>
8000c3fc:	d9 fc 04 00 	lea %a12,[%a15]4
8000c400:	6f 4a 07 80 	jnz.t %d10,4,8000c40e <_svfprintf_r+0x7f2>
8000c404:	6f 6a 05 00 	jz.t %d10,6,8000c40e <_svfprintf_r+0x7f2>
8000c408:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000c40c:	3c 02       	j 8000c410 <_svfprintf_r+0x7f4>
8000c40e:	48 08       	ld.w %d8,[%a15]0
8000c410:	82 09       	mov %d9,0
8000c412:	82 23       	mov %d3,2
8000c414:	6f 0a 0e 00 	jz.t %d10,0,8000c430 <_svfprintf_r+0x814>
8000c418:	0f 89 a0 40 	or %d4,%d9,%d8
8000c41c:	76 4a       	jz %d4,8000c430 <_svfprintf_r+0x814>
8000c41e:	58 04       	ld.w %d15,[%sp]16
8000c420:	3b 00 03 70 	mov %d7,48
8000c424:	e9 a7 02 10 	st.b [%sp]66,%d7
8000c428:	e9 af 03 10 	st.b [%sp]67,%d15
8000c42c:	8f 2a 40 a1 	or %d10,%d10,2
8000c430:	82 07       	mov %d7,0
8000c432:	60 ad       	mov.a %a13,%d10
8000c434:	e9 a7 01 10 	st.b [%sp]65,%d7
8000c438:	80 d2       	mov.d %d2,%a13
8000c43a:	8b 0e 80 72 	ge %d7,%d14,0
8000c43e:	8f 02 c8 41 	andn %d4,%d2,128
8000c442:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000c446:	0f 98 a0 60 	or %d6,%d8,%d9
8000c44a:	8b 0e 20 42 	ne %d4,%d14,0
8000c44e:	8b 06 00 45 	or.ne %d4,%d6,0
8000c452:	60 2d       	mov.a %a13,%d2
8000c454:	df 04 72 00 	jeq %d4,0,8000c538 <_svfprintf_r+0x91c>
8000c458:	df 13 06 00 	jeq %d3,1,8000c464 <_svfprintf_r+0x848>
8000c45c:	df 23 57 00 	jeq %d3,2,8000c50a <_svfprintf_r+0x8ee>
8000c460:	82 03       	mov %d3,0
8000c462:	3c 03       	j 8000c468 <_svfprintf_r+0x84c>
8000c464:	82 04       	mov %d4,0
8000c466:	3c 22       	j 8000c4aa <_svfprintf_r+0x88e>
8000c468:	8b 73 02 71 	rsub %d7,%d3,39
8000c46c:	60 72       	mov.a %a2,%d7
8000c46e:	8f 78 00 41 	and %d4,%d8,7
8000c472:	d9 a3 28 10 	lea %a3,[%sp]104
8000c476:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000c47a:	30 23       	add.a %a3,%a2
8000c47c:	1b 04 03 40 	addi %d4,%d4,48
8000c480:	06 d9       	sh %d9,-3
8000c482:	34 34       	st.b [%a3],%d4
8000c484:	0f 89 a0 60 	or %d6,%d9,%d8
8000c488:	c2 13       	add %d3,1
8000c48a:	df 06 ef ff 	jne %d6,0,8000c468 <_svfprintf_r+0x84c>
8000c48e:	80 d2       	mov.d %d2,%a13
8000c490:	80 3d       	mov.d %d13,%a3
8000c492:	6f 02 61 00 	jz.t %d2,0,8000c554 <_svfprintf_r+0x938>
8000c496:	8b 04 03 42 	eq %d4,%d4,48
8000c49a:	df 04 5d 80 	jne %d4,0,8000c554 <_svfprintf_r+0x938>
8000c49e:	3b 00 03 70 	mov %d7,48
8000c4a2:	c2 fd       	add %d13,-1
8000c4a4:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000c4a8:	3c 56       	j 8000c554 <_svfprintf_r+0x938>
8000c4aa:	8b 84 02 71 	rsub %d7,%d4,40
8000c4ae:	8b 09 00 32 	eq %d3,%d9,0
8000c4b2:	60 73       	mov.a %a3,%d7
8000c4b4:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000c4b8:	d9 a7 28 10 	lea %a7,[%sp]104
8000c4bc:	8b 09 00 35 	or.ne %d3,%d9,0
8000c4c0:	30 37       	add.a %a7,%a3
8000c4c2:	1b 14 00 d0 	addi %d13,%d4,1
8000c4c6:	df 03 1b 00 	jeq %d3,0,8000c4fc <_svfprintf_r+0x8e0>
8000c4ca:	8b 74 02 41 	rsub %d4,%d4,39
8000c4ce:	60 42       	mov.a %a2,%d4
8000c4d0:	fb a0 00 60 	mov %e6,10
8000c4d4:	0b 89 10 48 	mov %e4,%d9,%d8
8000c4d8:	d9 af 28 10 	lea %a15,[%sp]104
8000c4dc:	30 2f       	add.a %a15,%a2
8000c4de:	6d 00 b1 12 	call 8000ea40 <__umoddi3>
8000c4e2:	0b 89 10 48 	mov %e4,%d9,%d8
8000c4e6:	1b 02 03 20 	addi %d2,%d2,48
8000c4ea:	fb a0 00 60 	mov %e6,10
8000c4ee:	28 02       	st.b [%a15]0,%d2
8000c4f0:	6d 00 58 12 	call 8000e9a0 <__udivdi3>
8000c4f4:	02 d4       	mov %d4,%d13
8000c4f6:	0b 23 10 88 	mov %e8,%d3,%d2
8000c4fa:	3c d8       	j 8000c4aa <_svfprintf_r+0x88e>
8000c4fc:	80 7d       	mov.d %d13,%a7
8000c4fe:	1b 08 03 80 	addi %d8,%d8,48
8000c502:	c2 fd       	add %d13,-1
8000c504:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000c508:	3c 26       	j 8000c554 <_svfprintf_r+0x938>
8000c50a:	82 03       	mov %d3,0
8000c50c:	d8 0f       	ld.a %a15,[%sp]60
8000c50e:	80 ad       	mov.d %d13,%sp
8000c510:	8f f8 00 f1 	and %d15,%d8,15
8000c514:	8b 73 02 71 	rsub %d7,%d3,39
8000c518:	1b 8d 06 d0 	addi %d13,%d13,104
8000c51c:	10 f7       	addsc.a %a7,%a15,%d15,0
8000c51e:	42 7d       	add %d13,%d7
8000c520:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000c524:	0c 70       	ld.bu %d15,[%a7]0
8000c526:	60 d2       	mov.a %a2,%d13
8000c528:	06 c9       	sh %d9,-4
8000c52a:	2c 20       	st.b [%a2]0,%d15
8000c52c:	0f 89 a0 40 	or %d4,%d9,%d8
8000c530:	c2 13       	add %d3,1
8000c532:	df 04 ed ff 	jne %d4,0,8000c50c <_svfprintf_r+0x8f0>
8000c536:	3c 0f       	j 8000c554 <_svfprintf_r+0x938>
8000c538:	80 a2       	mov.d %d2,%sp
8000c53a:	1b 02 09 d0 	addi %d13,%d2,144
8000c53e:	f6 3b       	jnz %d3,8000c554 <_svfprintf_r+0x938>
8000c540:	80 df       	mov.d %d15,%a13
8000c542:	2e 09       	jz.t %d15,0,8000c554 <_svfprintf_r+0x938>
8000c544:	1b 02 0d d0 	addi %d13,%d2,208
8000c548:	60 d2       	mov.a %a2,%d13
8000c54a:	3b 00 03 70 	mov %d7,48
8000c54e:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000c552:	80 2d       	mov.d %d13,%a2
8000c554:	d9 a3 10 20 	lea %a3,[%sp]144
8000c558:	80 39       	mov.d %d9,%a3
8000c55a:	a2 d9       	sub %d9,%d13
8000c55c:	3c 14       	j 8000c584 <_svfprintf_r+0x968>
8000c55e:	e9 af 01 10 	st.b [%sp]65,%d15
8000c562:	58 04       	ld.w %d15,[%sp]16
8000c564:	df 0f 1f 04 	jeq %d15,0,8000cda2 <_svfprintf_r+0x1186>
8000c568:	82 03       	mov %d3,0
8000c56a:	60 ad       	mov.a %a13,%d10
8000c56c:	e9 af 28 10 	st.b [%sp]104,%d15
8000c570:	e9 a3 01 10 	st.b [%sp]65,%d3
8000c574:	40 fc       	mov.aa %a12,%a15
8000c576:	80 a2       	mov.d %d2,%sp
8000c578:	82 19       	mov %d9,1
8000c57a:	82 0e       	mov %d14,0
8000c57c:	1b 82 06 d0 	addi %d13,%d2,104
8000c580:	3c 02       	j 8000c584 <_svfprintf_r+0x968>
8000c582:	82 0e       	mov %d14,0
8000c584:	79 a7 01 10 	ld.b %d7,[%sp]65
8000c588:	80 df       	mov.d %d15,%a13
8000c58a:	0b e9 a0 a1 	max %d10,%d9,%d14
8000c58e:	80 d2       	mov.d %d2,%a13
8000c590:	16 02       	and %d15,2
8000c592:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000c596:	60 ff       	mov.a %a15,%d15
8000c598:	8a 2a       	cadd %d10,%d15,2
8000c59a:	8f 42 08 f1 	and %d15,%d2,132
8000c59e:	ee 48       	jnz %d15,8000c62e <_svfprintf_r+0xa12>
8000c5a0:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000c5a4:	a2 a8       	sub %d8,%d10
8000c5a6:	bf 18 44 00 	jlt %d8,1,8000c62e <_svfprintf_r+0xa12>
8000c5aa:	91 00 00 28 	movh.a %a2,32768
8000c5ae:	d9 22 f0 f0 	lea %a2,[%a2]4080 <80000ff0 <blanks.4035>>
8000c5b2:	19 a1 24 10 	ld.w %d1,[%sp]100 <80000ff0 <blanks.4035>>
8000c5b6:	19 a4 20 10 	ld.w %d4,[%sp]96 <80000ff0 <blanks.4035>>
8000c5ba:	8b 18 81 72 	ge %d7,%d8,17
8000c5be:	f4 e2       	st.a [%a14],%a2
8000c5c0:	df 07 20 00 	jeq %d7,0,8000c600 <_svfprintf_r+0x9e4>
8000c5c4:	1b 14 00 00 	addi %d0,%d4,1
8000c5c8:	3b 00 01 20 	mov %d2,16
8000c5cc:	1b 01 01 10 	addi %d1,%d1,16
8000c5d0:	59 e2 04 00 	st.w [%a14]4,%d2
8000c5d4:	59 a0 20 10 	st.w [%sp]96,%d0
8000c5d8:	59 a1 24 10 	st.w [%sp]100,%d1
8000c5dc:	8b 80 80 02 	ge %d0,%d0,8
8000c5e0:	d9 ee 08 00 	lea %a14,[%a14]8
8000c5e4:	76 0b       	jz %d0,8000c5fa <_svfprintf_r+0x9de>
8000c5e6:	60 c4       	mov.a %a4,%d12
8000c5e8:	60 b5       	mov.a %a5,%d11
8000c5ea:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c5ee:	6d 00 f4 0d 	call 8000e1d6 <__ssprint_r>
8000c5f2:	df 02 e0 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c5f6:	d9 ae 10 20 	lea %a14,[%sp]144
8000c5fa:	1b 08 ff 8f 	addi %d8,%d8,-16
8000c5fe:	3c d6       	j 8000c5aa <_svfprintf_r+0x98e>
8000c600:	c2 14       	add %d4,1
8000c602:	42 81       	add %d1,%d8
8000c604:	59 e8 04 00 	st.w [%a14]4,%d8
8000c608:	59 a4 20 10 	st.w [%sp]96,%d4
8000c60c:	59 a1 24 10 	st.w [%sp]100,%d1
8000c610:	8b 84 80 42 	ge %d4,%d4,8
8000c614:	d9 ee 08 00 	lea %a14,[%a14]8
8000c618:	76 4b       	jz %d4,8000c62e <_svfprintf_r+0xa12>
8000c61a:	60 c4       	mov.a %a4,%d12
8000c61c:	60 b5       	mov.a %a5,%d11
8000c61e:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c622:	6d 00 da 0d 	call 8000e1d6 <__ssprint_r>
8000c626:	df 02 c6 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c62a:	d9 ae 10 20 	lea %a14,[%sp]144
8000c62e:	79 a4 01 10 	ld.b %d4,[%sp]65
8000c632:	df 04 21 00 	jeq %d4,0,8000c674 <_svfprintf_r+0xa58>
8000c636:	19 a4 24 10 	ld.w %d4,[%sp]100
8000c63a:	d9 a7 01 10 	lea %a7,[%sp]65
8000c63e:	c2 14       	add %d4,1
8000c640:	59 a4 24 10 	st.w [%sp]100,%d4
8000c644:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c648:	82 17       	mov %d7,1
8000c64a:	c2 14       	add %d4,1
8000c64c:	f4 e7       	st.a [%a14],%a7
8000c64e:	59 e7 04 00 	st.w [%a14]4,%d7
8000c652:	59 a4 20 10 	st.w [%sp]96,%d4
8000c656:	8b 84 80 42 	ge %d4,%d4,8
8000c65a:	d9 ee 08 00 	lea %a14,[%a14]8
8000c65e:	76 4b       	jz %d4,8000c674 <_svfprintf_r+0xa58>
8000c660:	60 c4       	mov.a %a4,%d12
8000c662:	60 b5       	mov.a %a5,%d11
8000c664:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c668:	6d 00 b7 0d 	call 8000e1d6 <__ssprint_r>
8000c66c:	df 02 a3 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c670:	d9 ae 10 20 	lea %a14,[%sp]144
8000c674:	bd 0f 21 00 	jz.a %a15,8000c6b6 <_svfprintf_r+0xa9a>
8000c678:	19 a4 24 10 	ld.w %d4,[%sp]100
8000c67c:	d9 a7 02 10 	lea %a7,[%sp]66
8000c680:	c2 24       	add %d4,2
8000c682:	59 a4 24 10 	st.w [%sp]100,%d4
8000c686:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c68a:	82 27       	mov %d7,2
8000c68c:	c2 14       	add %d4,1
8000c68e:	f4 e7       	st.a [%a14],%a7
8000c690:	59 e7 04 00 	st.w [%a14]4,%d7
8000c694:	59 a4 20 10 	st.w [%sp]96,%d4
8000c698:	8b 84 80 42 	ge %d4,%d4,8
8000c69c:	d9 ee 08 00 	lea %a14,[%a14]8
8000c6a0:	76 4b       	jz %d4,8000c6b6 <_svfprintf_r+0xa9a>
8000c6a2:	60 c4       	mov.a %a4,%d12
8000c6a4:	60 b5       	mov.a %a5,%d11
8000c6a6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c6aa:	6d 00 96 0d 	call 8000e1d6 <__ssprint_r>
8000c6ae:	df 02 82 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c6b2:	d9 ae 10 20 	lea %a14,[%sp]144
8000c6b6:	8b 0f 28 42 	ne %d4,%d15,128
8000c6ba:	df 04 48 80 	jne %d4,0,8000c74a <_svfprintf_r+0xb2e>
8000c6be:	58 07       	ld.w %d15,[%sp]28
8000c6c0:	7b 00 00 28 	movh %d2,32768
8000c6c4:	60 23       	mov.a %a3,%d2
8000c6c6:	a2 af       	sub %d15,%d10
8000c6c8:	d9 3f e0 f0 	lea %a15,[%a3]4064
8000c6cc:	bf 1f 3f 00 	jlt %d15,1,8000c74a <_svfprintf_r+0xb2e>
8000c6d0:	19 a7 24 10 	ld.w %d7,[%sp]100
8000c6d4:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c6d8:	8b 1f 81 82 	ge %d8,%d15,17
8000c6dc:	ec e0       	st.a [%a14]0,%a15
8000c6de:	df 08 20 00 	jeq %d8,0,8000c71e <_svfprintf_r+0xb02>
8000c6e2:	1b 14 00 00 	addi %d0,%d4,1
8000c6e6:	3b 00 01 20 	mov %d2,16
8000c6ea:	1b 07 01 10 	addi %d1,%d7,16
8000c6ee:	59 e2 04 00 	st.w [%a14]4,%d2
8000c6f2:	59 a0 20 10 	st.w [%sp]96,%d0
8000c6f6:	59 a1 24 10 	st.w [%sp]100,%d1
8000c6fa:	8b 80 80 02 	ge %d0,%d0,8
8000c6fe:	d9 ee 08 00 	lea %a14,[%a14]8
8000c702:	76 0b       	jz %d0,8000c718 <_svfprintf_r+0xafc>
8000c704:	60 c4       	mov.a %a4,%d12
8000c706:	60 b5       	mov.a %a5,%d11
8000c708:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c70c:	6d 00 65 0d 	call 8000e1d6 <__ssprint_r>
8000c710:	df 02 51 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c714:	d9 ae 10 20 	lea %a14,[%sp]144
8000c718:	1b 0f ff ff 	addi %d15,%d15,-16
8000c71c:	3c da       	j 8000c6d0 <_svfprintf_r+0xab4>
8000c71e:	c2 14       	add %d4,1
8000c720:	42 f7       	add %d7,%d15
8000c722:	6c e1       	st.w [%a14]4,%d15
8000c724:	59 a4 20 10 	st.w [%sp]96,%d4
8000c728:	59 a7 24 10 	st.w [%sp]100,%d7
8000c72c:	8b 84 80 42 	ge %d4,%d4,8
8000c730:	d9 ee 08 00 	lea %a14,[%a14]8
8000c734:	76 4b       	jz %d4,8000c74a <_svfprintf_r+0xb2e>
8000c736:	60 c4       	mov.a %a4,%d12
8000c738:	60 b5       	mov.a %a5,%d11
8000c73a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c73e:	6d 00 4c 0d 	call 8000e1d6 <__ssprint_r>
8000c742:	df 02 38 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c746:	d9 ae 10 20 	lea %a14,[%sp]144
8000c74a:	7b 00 00 88 	movh %d8,32768
8000c74e:	a2 9e       	sub %d14,%d9
8000c750:	1b 08 fe 80 	addi %d8,%d8,4064
8000c754:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000c758:	bf 1e 3c 00 	jlt %d14,1,8000c7d0 <_svfprintf_r+0xbb4>
8000c75c:	19 a6 24 10 	ld.w %d6,[%sp]100
8000c760:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c764:	8b 1e 81 02 	ge %d0,%d14,17
8000c768:	74 e8       	st.w [%a14],%d8
8000c76a:	df 00 1c 00 	jeq %d0,0,8000c7a2 <_svfprintf_r+0xb86>
8000c76e:	c2 14       	add %d4,1
8000c770:	1b 06 01 00 	addi %d0,%d6,16
8000c774:	ec e1       	st.a [%a14]4,%a15
8000c776:	59 a4 20 10 	st.w [%sp]96,%d4
8000c77a:	59 a0 24 10 	st.w [%sp]100,%d0
8000c77e:	8b 84 80 42 	ge %d4,%d4,8
8000c782:	d9 ee 08 00 	lea %a14,[%a14]8
8000c786:	76 4b       	jz %d4,8000c79c <_svfprintf_r+0xb80>
8000c788:	60 c4       	mov.a %a4,%d12
8000c78a:	60 b5       	mov.a %a5,%d11
8000c78c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c790:	6d 00 23 0d 	call 8000e1d6 <__ssprint_r>
8000c794:	df 02 0f 83 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c798:	d9 ae 10 20 	lea %a14,[%sp]144
8000c79c:	1b 0e ff ef 	addi %d14,%d14,-16
8000c7a0:	3c de       	j 8000c75c <_svfprintf_r+0xb40>
8000c7a2:	c2 14       	add %d4,1
8000c7a4:	42 e6       	add %d6,%d14
8000c7a6:	59 ee 04 00 	st.w [%a14]4,%d14
8000c7aa:	59 a4 20 10 	st.w [%sp]96,%d4
8000c7ae:	59 a6 24 10 	st.w [%sp]100,%d6
8000c7b2:	8b 84 80 42 	ge %d4,%d4,8
8000c7b6:	d9 ee 08 00 	lea %a14,[%a14]8
8000c7ba:	76 4b       	jz %d4,8000c7d0 <_svfprintf_r+0xbb4>
8000c7bc:	60 c4       	mov.a %a4,%d12
8000c7be:	60 b5       	mov.a %a5,%d11
8000c7c0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c7c4:	6d 00 09 0d 	call 8000e1d6 <__ssprint_r>
8000c7c8:	df 02 f5 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c7cc:	d9 ae 10 20 	lea %a14,[%sp]144
8000c7d0:	80 df       	mov.d %d15,%a13
8000c7d2:	19 ae 24 10 	ld.w %d14,[%sp]100
8000c7d6:	19 a8 20 10 	ld.w %d8,[%sp]96
8000c7da:	6f 8f 1d 80 	jnz.t %d15,8,8000c814 <_svfprintf_r+0xbf8>
8000c7de:	c2 18       	add %d8,1
8000c7e0:	59 e9 04 00 	st.w [%a14]4,%d9
8000c7e4:	42 e9       	add %d9,%d14
8000c7e6:	59 a8 20 10 	st.w [%sp]96,%d8
8000c7ea:	74 ed       	st.w [%a14],%d13
8000c7ec:	59 a9 24 10 	st.w [%sp]100,%d9
8000c7f0:	8b 88 80 82 	ge %d8,%d8,8
8000c7f4:	d9 ef 08 00 	lea %a15,[%a14]8
8000c7f8:	df 08 79 02 	jeq %d8,0,8000ccea <_svfprintf_r+0x10ce>
8000c7fc:	60 c4       	mov.a %a4,%d12
8000c7fe:	60 b5       	mov.a %a5,%d11
8000c800:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c804:	6d 00 e9 0c 	call 8000e1d6 <__ssprint_r>
8000c808:	df 02 d5 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c80c:	d9 af 10 20 	lea %a15,[%sp]144
8000c810:	1d 00 6d 02 	j 8000ccea <_svfprintf_r+0x10ce>
8000c814:	19 a2 10 00 	ld.w %d2,[%sp]16
8000c818:	8b 62 46 f2 	lt %d15,%d2,102
8000c81c:	df 0f be 81 	jne %d15,0,8000cb98 <_svfprintf_r+0xf7c>
8000c820:	d2 06       	mov %e6,0
8000c822:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000c826:	19 a5 30 00 	ld.w %d5,[%sp]48
8000c82a:	6d 00 db 0f 	call 8000e7e0 <__eqdf2>
8000c82e:	df 02 78 80 	jne %d2,0,8000c91e <_svfprintf_r+0xd02>
8000c832:	7b 00 00 38 	movh %d3,32768
8000c836:	1b e3 fd 30 	addi %d3,%d3,4062
8000c83a:	c2 18       	add %d8,1
8000c83c:	74 e3       	st.w [%a14],%d3
8000c83e:	1b 1e 00 90 	addi %d9,%d14,1
8000c842:	82 13       	mov %d3,1
8000c844:	59 a8 20 10 	st.w [%sp]96,%d8
8000c848:	59 e3 04 00 	st.w [%a14]4,%d3
8000c84c:	59 a9 24 10 	st.w [%sp]100,%d9
8000c850:	8b 88 80 82 	ge %d8,%d8,8
8000c854:	d9 ef 08 00 	lea %a15,[%a14]8
8000c858:	76 8b       	jz %d8,8000c86e <_svfprintf_r+0xc52>
8000c85a:	60 c4       	mov.a %a4,%d12
8000c85c:	60 b5       	mov.a %a5,%d11
8000c85e:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c862:	6d 00 ba 0c 	call 8000e1d6 <__ssprint_r>
8000c866:	df 02 a6 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c86a:	d9 af 10 20 	lea %a15,[%sp]144
8000c86e:	58 11       	ld.w %d15,[%sp]68
8000c870:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c874:	3f 2f 05 00 	jlt %d15,%d2,8000c87e <_svfprintf_r+0xc62>
8000c878:	80 df       	mov.d %d15,%a13
8000c87a:	6f 0f 38 02 	jz.t %d15,0,8000ccea <_svfprintf_r+0x10ce>
8000c87e:	58 08       	ld.w %d15,[%sp]32
8000c880:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c884:	68 1f       	st.w [%a15]4,%d15
8000c886:	58 19       	ld.w %d15,[%sp]100
8000c888:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c88c:	42 2f       	add %d15,%d2
8000c88e:	78 19       	st.w [%sp]100,%d15
8000c890:	58 18       	ld.w %d15,[%sp]96
8000c892:	e8 03       	st.a [%a15]0,%a3
8000c894:	c2 1f       	add %d15,1
8000c896:	78 18       	st.w [%sp]96,%d15
8000c898:	8b 8f 80 f2 	ge %d15,%d15,8
8000c89c:	d9 ff 08 00 	lea %a15,[%a15]8
8000c8a0:	6e 0b       	jz %d15,8000c8b6 <_svfprintf_r+0xc9a>
8000c8a2:	60 c4       	mov.a %a4,%d12
8000c8a4:	60 b5       	mov.a %a5,%d11
8000c8a6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c8aa:	6d 00 96 0c 	call 8000e1d6 <__ssprint_r>
8000c8ae:	df 02 82 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c8b2:	d9 af 10 20 	lea %a15,[%sp]144
8000c8b6:	58 05       	ld.w %d15,[%sp]20
8000c8b8:	7b 00 00 88 	movh %d8,32768
8000c8bc:	c2 ff       	add %d15,-1
8000c8be:	1b 08 fe 80 	addi %d8,%d8,4064
8000c8c2:	3b 00 01 90 	mov %d9,16
8000c8c6:	bf 1f 12 02 	jlt %d15,1,8000ccea <_svfprintf_r+0x10ce>
8000c8ca:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c8ce:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c8d2:	8b 1f 81 42 	ge %d4,%d15,17
8000c8d6:	68 08       	st.w [%a15]0,%d8
8000c8d8:	df 04 1c 00 	jeq %d4,0,8000c910 <_svfprintf_r+0xcf4>
8000c8dc:	c2 13       	add %d3,1
8000c8de:	1b 05 01 40 	addi %d4,%d5,16
8000c8e2:	68 19       	st.w [%a15]4,%d9
8000c8e4:	59 a3 20 10 	st.w [%sp]96,%d3
8000c8e8:	59 a4 24 10 	st.w [%sp]100,%d4
8000c8ec:	8b 83 80 32 	ge %d3,%d3,8
8000c8f0:	d9 ff 08 00 	lea %a15,[%a15]8
8000c8f4:	76 3b       	jz %d3,8000c90a <_svfprintf_r+0xcee>
8000c8f6:	60 c4       	mov.a %a4,%d12
8000c8f8:	60 b5       	mov.a %a5,%d11
8000c8fa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c8fe:	6d 00 6c 0c 	call 8000e1d6 <__ssprint_r>
8000c902:	df 02 58 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c906:	d9 af 10 20 	lea %a15,[%sp]144
8000c90a:	1b 0f ff ff 	addi %d15,%d15,-16
8000c90e:	3c de       	j 8000c8ca <_svfprintf_r+0xcae>
8000c910:	12 54       	add %d4,%d15,%d5
8000c912:	68 1f       	st.w [%a15]4,%d15
8000c914:	59 a4 24 10 	st.w [%sp]100,%d4
8000c918:	9a 13       	add %d15,%d3,1
8000c91a:	1d 00 e1 01 	j 8000ccdc <_svfprintf_r+0x10c0>
8000c91e:	19 a3 04 10 	ld.w %d3,[%sp]68
8000c922:	ff 13 8e 00 	jge %d3,1,8000ca3e <_svfprintf_r+0xe22>
8000c926:	7b 00 00 38 	movh %d3,32768
8000c92a:	1b e3 fd 30 	addi %d3,%d3,4062
8000c92e:	c2 18       	add %d8,1
8000c930:	74 e3       	st.w [%a14],%d3
8000c932:	1b 1e 00 90 	addi %d9,%d14,1
8000c936:	82 13       	mov %d3,1
8000c938:	59 a8 20 10 	st.w [%sp]96,%d8
8000c93c:	59 e3 04 00 	st.w [%a14]4,%d3
8000c940:	59 a9 24 10 	st.w [%sp]100,%d9
8000c944:	8b 88 80 82 	ge %d8,%d8,8
8000c948:	d9 ef 08 00 	lea %a15,[%a14]8
8000c94c:	76 8b       	jz %d8,8000c962 <_svfprintf_r+0xd46>
8000c94e:	60 c4       	mov.a %a4,%d12
8000c950:	60 b5       	mov.a %a5,%d11
8000c952:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c956:	6d 00 40 0c 	call 8000e1d6 <__ssprint_r>
8000c95a:	df 02 2c 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c95e:	d9 af 10 20 	lea %a15,[%sp]144
8000c962:	58 11       	ld.w %d15,[%sp]68
8000c964:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c968:	a6 2f       	or %d15,%d2
8000c96a:	ee 04       	jnz %d15,8000c972 <_svfprintf_r+0xd56>
8000c96c:	80 df       	mov.d %d15,%a13
8000c96e:	6f 0f be 01 	jz.t %d15,0,8000ccea <_svfprintf_r+0x10ce>
8000c972:	58 08       	ld.w %d15,[%sp]32
8000c974:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c978:	68 1f       	st.w [%a15]4,%d15
8000c97a:	58 19       	ld.w %d15,[%sp]100
8000c97c:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c980:	42 2f       	add %d15,%d2
8000c982:	78 19       	st.w [%sp]100,%d15
8000c984:	58 18       	ld.w %d15,[%sp]96
8000c986:	e8 03       	st.a [%a15]0,%a3
8000c988:	c2 1f       	add %d15,1
8000c98a:	78 18       	st.w [%sp]96,%d15
8000c98c:	8b 8f 80 f2 	ge %d15,%d15,8
8000c990:	d9 ff 08 00 	lea %a15,[%a15]8
8000c994:	6e 0b       	jz %d15,8000c9aa <_svfprintf_r+0xd8e>
8000c996:	60 c4       	mov.a %a4,%d12
8000c998:	60 b5       	mov.a %a5,%d11
8000c99a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c99e:	6d 00 1c 0c 	call 8000e1d6 <__ssprint_r>
8000c9a2:	df 02 08 82 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c9a6:	d9 af 10 20 	lea %a15,[%sp]144
8000c9aa:	58 11       	ld.w %d15,[%sp]68
8000c9ac:	7b 00 00 88 	movh %d8,32768
8000c9b0:	32 5f       	rsub %d15
8000c9b2:	1b 08 fe 80 	addi %d8,%d8,4064
8000c9b6:	3b 00 01 90 	mov %d9,16
8000c9ba:	bf 1f 3a 00 	jlt %d15,1,8000ca2e <_svfprintf_r+0xe12>
8000c9be:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c9c2:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c9c6:	8b 1f 81 42 	ge %d4,%d15,17
8000c9ca:	68 08       	st.w [%a15]0,%d8
8000c9cc:	df 04 1c 00 	jeq %d4,0,8000ca04 <_svfprintf_r+0xde8>
8000c9d0:	c2 13       	add %d3,1
8000c9d2:	1b 05 01 40 	addi %d4,%d5,16
8000c9d6:	68 19       	st.w [%a15]4,%d9
8000c9d8:	59 a3 20 10 	st.w [%sp]96,%d3
8000c9dc:	59 a4 24 10 	st.w [%sp]100,%d4
8000c9e0:	8b 83 80 32 	ge %d3,%d3,8
8000c9e4:	d9 ff 08 00 	lea %a15,[%a15]8
8000c9e8:	76 3b       	jz %d3,8000c9fe <_svfprintf_r+0xde2>
8000c9ea:	60 c4       	mov.a %a4,%d12
8000c9ec:	60 b5       	mov.a %a5,%d11
8000c9ee:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c9f2:	6d 00 f2 0b 	call 8000e1d6 <__ssprint_r>
8000c9f6:	df 02 de 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000c9fa:	d9 af 10 20 	lea %a15,[%sp]144
8000c9fe:	1b 0f ff ff 	addi %d15,%d15,-16
8000ca02:	3c de       	j 8000c9be <_svfprintf_r+0xda2>
8000ca04:	68 1f       	st.w [%a15]4,%d15
8000ca06:	12 54       	add %d4,%d15,%d5
8000ca08:	9a 13       	add %d15,%d3,1
8000ca0a:	78 18       	st.w [%sp]96,%d15
8000ca0c:	59 a4 24 10 	st.w [%sp]100,%d4
8000ca10:	8b 8f 80 f2 	ge %d15,%d15,8
8000ca14:	d9 ff 08 00 	lea %a15,[%a15]8
8000ca18:	6e 0b       	jz %d15,8000ca2e <_svfprintf_r+0xe12>
8000ca1a:	60 c4       	mov.a %a4,%d12
8000ca1c:	60 b5       	mov.a %a5,%d11
8000ca1e:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ca22:	6d 00 da 0b 	call 8000e1d6 <__ssprint_r>
8000ca26:	df 02 c6 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000ca2a:	d9 af 10 20 	lea %a15,[%sp]144
8000ca2e:	58 05       	ld.w %d15,[%sp]20
8000ca30:	68 0d       	st.w [%a15]0,%d13
8000ca32:	68 1f       	st.w [%a15]4,%d15
8000ca34:	19 a2 14 00 	ld.w %d2,[%sp]20
8000ca38:	58 19       	ld.w %d15,[%sp]100
8000ca3a:	1d 00 4d 01 	j 8000ccd4 <_svfprintf_r+0x10b8>
8000ca3e:	58 05       	ld.w %d15,[%sp]20
8000ca40:	74 ed       	st.w [%a14],%d13
8000ca42:	3f f3 6a 00 	jlt %d3,%d15,8000cb16 <_svfprintf_r+0xefa>
8000ca46:	02 f9       	mov %d9,%d15
8000ca48:	c2 18       	add %d8,1
8000ca4a:	42 e9       	add %d9,%d14
8000ca4c:	59 a8 20 10 	st.w [%sp]96,%d8
8000ca50:	6c e1       	st.w [%a14]4,%d15
8000ca52:	59 a9 24 10 	st.w [%sp]100,%d9
8000ca56:	8b 88 80 82 	ge %d8,%d8,8
8000ca5a:	d9 ef 08 00 	lea %a15,[%a14]8
8000ca5e:	76 8b       	jz %d8,8000ca74 <_svfprintf_r+0xe58>
8000ca60:	60 c4       	mov.a %a4,%d12
8000ca62:	60 b5       	mov.a %a5,%d11
8000ca64:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ca68:	6d 00 b7 0b 	call 8000e1d6 <__ssprint_r>
8000ca6c:	df 02 a3 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000ca70:	d9 af 10 20 	lea %a15,[%sp]144
8000ca74:	58 11       	ld.w %d15,[%sp]68
8000ca76:	19 a2 14 00 	ld.w %d2,[%sp]20
8000ca7a:	7b 00 00 88 	movh %d8,32768
8000ca7e:	a2 2f       	sub %d15,%d2
8000ca80:	1b 08 fe 80 	addi %d8,%d8,4064
8000ca84:	3b 00 01 90 	mov %d9,16
8000ca88:	bf 1f 3a 00 	jlt %d15,1,8000cafc <_svfprintf_r+0xee0>
8000ca8c:	19 a5 24 10 	ld.w %d5,[%sp]100
8000ca90:	19 a3 20 10 	ld.w %d3,[%sp]96
8000ca94:	8b 1f 81 42 	ge %d4,%d15,17
8000ca98:	68 08       	st.w [%a15]0,%d8
8000ca9a:	df 04 1c 00 	jeq %d4,0,8000cad2 <_svfprintf_r+0xeb6>
8000ca9e:	c2 13       	add %d3,1
8000caa0:	1b 05 01 40 	addi %d4,%d5,16
8000caa4:	68 19       	st.w [%a15]4,%d9
8000caa6:	59 a3 20 10 	st.w [%sp]96,%d3
8000caaa:	59 a4 24 10 	st.w [%sp]100,%d4
8000caae:	8b 83 80 32 	ge %d3,%d3,8
8000cab2:	d9 ff 08 00 	lea %a15,[%a15]8
8000cab6:	76 3b       	jz %d3,8000cacc <_svfprintf_r+0xeb0>
8000cab8:	60 c4       	mov.a %a4,%d12
8000caba:	60 b5       	mov.a %a5,%d11
8000cabc:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cac0:	6d 00 8b 0b 	call 8000e1d6 <__ssprint_r>
8000cac4:	df 02 77 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cac8:	d9 af 10 20 	lea %a15,[%sp]144
8000cacc:	1b 0f ff ff 	addi %d15,%d15,-16
8000cad0:	3c de       	j 8000ca8c <_svfprintf_r+0xe70>
8000cad2:	68 1f       	st.w [%a15]4,%d15
8000cad4:	12 54       	add %d4,%d15,%d5
8000cad6:	9a 13       	add %d15,%d3,1
8000cad8:	78 18       	st.w [%sp]96,%d15
8000cada:	59 a4 24 10 	st.w [%sp]100,%d4
8000cade:	8b 8f 80 f2 	ge %d15,%d15,8
8000cae2:	d9 ff 08 00 	lea %a15,[%a15]8
8000cae6:	6e 0b       	jz %d15,8000cafc <_svfprintf_r+0xee0>
8000cae8:	60 c4       	mov.a %a4,%d12
8000caea:	60 b5       	mov.a %a5,%d11
8000caec:	d9 a6 1c 10 	lea %a6,[%sp]92
8000caf0:	6d 00 73 0b 	call 8000e1d6 <__ssprint_r>
8000caf4:	df 02 5f 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000caf8:	d9 af 10 20 	lea %a15,[%sp]144
8000cafc:	80 df       	mov.d %d15,%a13
8000cafe:	6f 0f f6 00 	jz.t %d15,0,8000ccea <_svfprintf_r+0x10ce>
8000cb02:	99 a3 34 00 	ld.a %a3,[%sp]52
8000cb06:	58 08       	ld.w %d15,[%sp]32
8000cb08:	19 a2 20 00 	ld.w %d2,[%sp]32
8000cb0c:	68 1f       	st.w [%a15]4,%d15
8000cb0e:	e8 03       	st.a [%a15]0,%a3
8000cb10:	58 19       	ld.w %d15,[%sp]100
8000cb12:	1d 00 e1 00 	j 8000ccd4 <_svfprintf_r+0x10b8>
8000cb16:	c2 18       	add %d8,1
8000cb18:	59 e3 04 00 	st.w [%a14]4,%d3
8000cb1c:	42 e3       	add %d3,%d14
8000cb1e:	59 a8 20 10 	st.w [%sp]96,%d8
8000cb22:	59 a3 24 10 	st.w [%sp]100,%d3
8000cb26:	8b 88 80 82 	ge %d8,%d8,8
8000cb2a:	d9 ef 08 00 	lea %a15,[%a14]8
8000cb2e:	76 8b       	jz %d8,8000cb44 <_svfprintf_r+0xf28>
8000cb30:	60 c4       	mov.a %a4,%d12
8000cb32:	60 b5       	mov.a %a5,%d11
8000cb34:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cb38:	6d 00 4f 0b 	call 8000e1d6 <__ssprint_r>
8000cb3c:	df 02 3b 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cb40:	d9 af 10 20 	lea %a15,[%sp]144
8000cb44:	58 08       	ld.w %d15,[%sp]32
8000cb46:	19 a2 20 00 	ld.w %d2,[%sp]32
8000cb4a:	68 1f       	st.w [%a15]4,%d15
8000cb4c:	58 19       	ld.w %d15,[%sp]100
8000cb4e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000cb52:	42 2f       	add %d15,%d2
8000cb54:	78 19       	st.w [%sp]100,%d15
8000cb56:	58 18       	ld.w %d15,[%sp]96
8000cb58:	99 ae 04 10 	ld.a %a14,[%sp]68
8000cb5c:	c2 1f       	add %d15,1
8000cb5e:	60 d2       	mov.a %a2,%d13
8000cb60:	e8 03       	st.a [%a15]0,%a3
8000cb62:	78 18       	st.w [%sp]96,%d15
8000cb64:	8b 8f 80 f2 	ge %d15,%d15,8
8000cb68:	30 2e       	add.a %a14,%a2
8000cb6a:	d9 ff 08 00 	lea %a15,[%a15]8
8000cb6e:	6e 0b       	jz %d15,8000cb84 <_svfprintf_r+0xf68>
8000cb70:	60 c4       	mov.a %a4,%d12
8000cb72:	60 b5       	mov.a %a5,%d11
8000cb74:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cb78:	6d 00 2f 0b 	call 8000e1d6 <__ssprint_r>
8000cb7c:	df 02 1b 81 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cb80:	d9 af 10 20 	lea %a15,[%sp]144
8000cb84:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cb88:	58 11       	ld.w %d15,[%sp]68
8000cb8a:	e8 0e       	st.a [%a15]0,%a14
8000cb8c:	5a f2       	sub %d15,%d2,%d15
8000cb8e:	68 1f       	st.w [%a15]4,%d15
8000cb90:	19 a2 24 10 	ld.w %d2,[%sp]100
8000cb94:	1d 00 a0 00 	j 8000ccd4 <_svfprintf_r+0x10b8>
8000cb98:	c2 18       	add %d8,1
8000cb9a:	82 13       	mov %d3,1
8000cb9c:	1b 1e 00 90 	addi %d9,%d14,1
8000cba0:	58 05       	ld.w %d15,[%sp]20
8000cba2:	59 a8 20 10 	st.w [%sp]96,%d8
8000cba6:	74 ed       	st.w [%a14],%d13
8000cba8:	59 e3 04 00 	st.w [%a14]4,%d3
8000cbac:	59 a9 24 10 	st.w [%sp]100,%d9
8000cbb0:	8b 88 80 82 	ge %d8,%d8,8
8000cbb4:	ff 2f 05 00 	jge %d15,2,8000cbbe <_svfprintf_r+0xfa2>
8000cbb8:	80 d2       	mov.d %d2,%a13
8000cbba:	6f 02 81 00 	jz.t %d2,0,8000ccbc <_svfprintf_r+0x10a0>
8000cbbe:	d9 ef 08 00 	lea %a15,[%a14]8
8000cbc2:	76 8b       	jz %d8,8000cbd8 <_svfprintf_r+0xfbc>
8000cbc4:	60 c4       	mov.a %a4,%d12
8000cbc6:	60 b5       	mov.a %a5,%d11
8000cbc8:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cbcc:	6d 00 05 0b 	call 8000e1d6 <__ssprint_r>
8000cbd0:	df 02 f1 80 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cbd4:	d9 af 10 20 	lea %a15,[%sp]144
8000cbd8:	58 08       	ld.w %d15,[%sp]32
8000cbda:	19 a2 20 00 	ld.w %d2,[%sp]32
8000cbde:	68 1f       	st.w [%a15]4,%d15
8000cbe0:	58 19       	ld.w %d15,[%sp]100
8000cbe2:	99 a3 34 00 	ld.a %a3,[%sp]52
8000cbe6:	42 2f       	add %d15,%d2
8000cbe8:	78 19       	st.w [%sp]100,%d15
8000cbea:	58 18       	ld.w %d15,[%sp]96
8000cbec:	e8 03       	st.a [%a15]0,%a3
8000cbee:	c2 1f       	add %d15,1
8000cbf0:	78 18       	st.w [%sp]96,%d15
8000cbf2:	8b 8f 80 f2 	ge %d15,%d15,8
8000cbf6:	d9 ff 08 00 	lea %a15,[%a15]8
8000cbfa:	6e 0b       	jz %d15,8000cc10 <_svfprintf_r+0xff4>
8000cbfc:	60 c4       	mov.a %a4,%d12
8000cbfe:	60 b5       	mov.a %a5,%d11
8000cc00:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cc04:	6d 00 e9 0a 	call 8000e1d6 <__ssprint_r>
8000cc08:	df 02 d5 80 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cc0c:	d9 af 10 20 	lea %a15,[%sp]144
8000cc10:	d2 06       	mov %e6,0
8000cc12:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000cc16:	19 a5 30 00 	ld.w %d5,[%sp]48
8000cc1a:	6d 00 03 0e 	call 8000e820 <__nedf2>
8000cc1e:	58 05       	ld.w %d15,[%sp]20
8000cc20:	c2 ff       	add %d15,-1
8000cc22:	76 2c       	jz %d2,8000cc3a <_svfprintf_r+0x101e>
8000cc24:	19 a2 24 10 	ld.w %d2,[%sp]100
8000cc28:	60 de       	mov.a %a14,%d13
8000cc2a:	68 1f       	st.w [%a15]4,%d15
8000cc2c:	42 2f       	add %d15,%d2
8000cc2e:	78 19       	st.w [%sp]100,%d15
8000cc30:	58 18       	ld.w %d15,[%sp]96
8000cc32:	b0 1e       	add.a %a14,1
8000cc34:	e8 0e       	st.a [%a15]0,%a14
8000cc36:	c2 1f       	add %d15,1
8000cc38:	3c 31       	j 8000cc9a <_svfprintf_r+0x107e>
8000cc3a:	7b 00 00 88 	movh %d8,32768
8000cc3e:	1b 08 fe 80 	addi %d8,%d8,4064
8000cc42:	3b 00 01 90 	mov %d9,16
8000cc46:	bf 1f 3f 00 	jlt %d15,1,8000ccc4 <_svfprintf_r+0x10a8>
8000cc4a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000cc4e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000cc52:	8b 1f 81 42 	ge %d4,%d15,17
8000cc56:	68 08       	st.w [%a15]0,%d8
8000cc58:	df 04 1c 00 	jeq %d4,0,8000cc90 <_svfprintf_r+0x1074>
8000cc5c:	c2 13       	add %d3,1
8000cc5e:	1b 05 01 40 	addi %d4,%d5,16
8000cc62:	68 19       	st.w [%a15]4,%d9
8000cc64:	59 a3 20 10 	st.w [%sp]96,%d3
8000cc68:	59 a4 24 10 	st.w [%sp]100,%d4
8000cc6c:	8b 83 80 32 	ge %d3,%d3,8
8000cc70:	d9 ff 08 00 	lea %a15,[%a15]8
8000cc74:	76 3b       	jz %d3,8000cc8a <_svfprintf_r+0x106e>
8000cc76:	60 c4       	mov.a %a4,%d12
8000cc78:	60 b5       	mov.a %a5,%d11
8000cc7a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cc7e:	6d 00 ac 0a 	call 8000e1d6 <__ssprint_r>
8000cc82:	df 02 98 80 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cc86:	d9 af 10 20 	lea %a15,[%sp]144
8000cc8a:	1b 0f ff ff 	addi %d15,%d15,-16
8000cc8e:	3c de       	j 8000cc4a <_svfprintf_r+0x102e>
8000cc90:	12 54       	add %d4,%d15,%d5
8000cc92:	68 1f       	st.w [%a15]4,%d15
8000cc94:	59 a4 24 10 	st.w [%sp]100,%d4
8000cc98:	9a 13       	add %d15,%d3,1
8000cc9a:	78 18       	st.w [%sp]96,%d15
8000cc9c:	8b 8f 80 f2 	ge %d15,%d15,8
8000cca0:	d9 ff 08 00 	lea %a15,[%a15]8
8000cca4:	6e 10       	jz %d15,8000ccc4 <_svfprintf_r+0x10a8>
8000cca6:	60 c4       	mov.a %a4,%d12
8000cca8:	60 b5       	mov.a %a5,%d11
8000ccaa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ccae:	6d 00 94 0a 	call 8000e1d6 <__ssprint_r>
8000ccb2:	df 02 80 80 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000ccb6:	d9 af 10 20 	lea %a15,[%sp]144
8000ccba:	3c 05       	j 8000ccc4 <_svfprintf_r+0x10a8>
8000ccbc:	df 08 f5 ff 	jne %d8,0,8000cca6 <_svfprintf_r+0x108a>
8000ccc0:	d9 ef 08 00 	lea %a15,[%a14]8
8000ccc4:	58 0e       	ld.w %d15,[%sp]56
8000ccc6:	d9 a3 0d 10 	lea %a3,[%sp]77
8000ccca:	68 1f       	st.w [%a15]4,%d15
8000cccc:	19 a2 38 00 	ld.w %d2,[%sp]56
8000ccd0:	58 19       	ld.w %d15,[%sp]100
8000ccd2:	e8 03       	st.a [%a15]0,%a3
8000ccd4:	42 2f       	add %d15,%d2
8000ccd6:	78 19       	st.w [%sp]100,%d15
8000ccd8:	58 18       	ld.w %d15,[%sp]96
8000ccda:	c2 1f       	add %d15,1
8000ccdc:	78 18       	st.w [%sp]96,%d15
8000ccde:	8b 8f 80 f2 	ge %d15,%d15,8
8000cce2:	df 0f 8d fd 	jne %d15,0,8000c7fc <_svfprintf_r+0xbe0>
8000cce6:	d9 ff 08 00 	lea %a15,[%a15]8
8000ccea:	80 df       	mov.d %d15,%a13
8000ccec:	ae 2d       	jnz.t %d15,2,8000cd06 <_svfprintf_r+0x10ea>
8000ccee:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000ccf2:	0b 2a a0 f1 	max %d15,%d10,%d2
8000ccf6:	19 a2 28 00 	ld.w %d2,[%sp]40
8000ccfa:	42 f2       	add %d2,%d15
8000ccfc:	58 19       	ld.w %d15,[%sp]100
8000ccfe:	59 a2 28 00 	st.w [%sp]40,%d2
8000cd02:	6e 49       	jz %d15,8000cd94 <_svfprintf_r+0x1178>
8000cd04:	3c 40       	j 8000cd84 <_svfprintf_r+0x1168>
8000cd06:	58 07       	ld.w %d15,[%sp]28
8000cd08:	3b 00 01 80 	mov %d8,16
8000cd0c:	a2 af       	sub %d15,%d10
8000cd0e:	bf 1f f0 7f 	jlt %d15,1,8000ccee <_svfprintf_r+0x10d2>
8000cd12:	91 00 00 28 	movh.a %a2,32768
8000cd16:	d9 22 f0 f0 	lea %a2,[%a2]4080 <80000ff0 <blanks.4035>>
8000cd1a:	19 a5 24 10 	ld.w %d5,[%sp]100 <80000ff0 <blanks.4035>>
8000cd1e:	19 a3 20 10 	ld.w %d3,[%sp]96 <80000ff0 <blanks.4035>>
8000cd22:	8b 1f 81 42 	ge %d4,%d15,17
8000cd26:	e8 02       	st.a [%a15]0,%a2
8000cd28:	df 04 1c 00 	jeq %d4,0,8000cd60 <_svfprintf_r+0x1144>
8000cd2c:	c2 13       	add %d3,1
8000cd2e:	1b 05 01 40 	addi %d4,%d5,16
8000cd32:	68 18       	st.w [%a15]4,%d8
8000cd34:	59 a3 20 10 	st.w [%sp]96,%d3
8000cd38:	59 a4 24 10 	st.w [%sp]100,%d4
8000cd3c:	8b 83 80 32 	ge %d3,%d3,8
8000cd40:	d9 ff 08 00 	lea %a15,[%a15]8
8000cd44:	76 3b       	jz %d3,8000cd5a <_svfprintf_r+0x113e>
8000cd46:	60 c4       	mov.a %a4,%d12
8000cd48:	60 b5       	mov.a %a5,%d11
8000cd4a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cd4e:	6d 00 44 0a 	call 8000e1d6 <__ssprint_r>
8000cd52:	df 02 30 80 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cd56:	d9 af 10 20 	lea %a15,[%sp]144
8000cd5a:	1b 0f ff ff 	addi %d15,%d15,-16
8000cd5e:	3c da       	j 8000cd12 <_svfprintf_r+0x10f6>
8000cd60:	12 54       	add %d4,%d15,%d5
8000cd62:	68 1f       	st.w [%a15]4,%d15
8000cd64:	9a 13       	add %d15,%d3,1
8000cd66:	78 18       	st.w [%sp]96,%d15
8000cd68:	59 a4 24 10 	st.w [%sp]100,%d4
8000cd6c:	8b 8f 40 f2 	lt %d15,%d15,8
8000cd70:	ee bf       	jnz %d15,8000ccee <_svfprintf_r+0x10d2>
8000cd72:	60 c4       	mov.a %a4,%d12
8000cd74:	60 b5       	mov.a %a5,%d11
8000cd76:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cd7a:	6d 00 2e 0a 	call 8000e1d6 <__ssprint_r>
8000cd7e:	df 02 b8 7f 	jeq %d2,0,8000ccee <_svfprintf_r+0x10d2>
8000cd82:	3c 18       	j 8000cdb2 <_svfprintf_r+0x1196>
8000cd84:	60 c4       	mov.a %a4,%d12
8000cd86:	60 b5       	mov.a %a5,%d11
8000cd88:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cd8c:	6d 00 25 0a 	call 8000e1d6 <__ssprint_r>
8000cd90:	df 02 11 80 	jne %d2,0,8000cdb2 <_svfprintf_r+0x1196>
8000cd94:	82 0f       	mov %d15,0
8000cd96:	78 18       	st.w [%sp]96,%d15
8000cd98:	40 cf       	mov.aa %a15,%a12
8000cd9a:	d9 ae 10 20 	lea %a14,[%sp]144
8000cd9e:	1d ff 77 f7 	j 8000bc8c <_svfprintf_r+0x70>
8000cda2:	58 19       	ld.w %d15,[%sp]100
8000cda4:	6e 07       	jz %d15,8000cdb2 <_svfprintf_r+0x1196>
8000cda6:	60 c4       	mov.a %a4,%d12
8000cda8:	60 b5       	mov.a %a5,%d11
8000cdaa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cdae:	6d 00 14 0a 	call 8000e1d6 <__ssprint_r>
8000cdb2:	60 b3       	mov.a %a3,%d11
8000cdb4:	19 a2 28 00 	ld.w %d2,[%sp]40
8000cdb8:	8c 36       	ld.h %d15,[%a3]12
8000cdba:	16 40       	and %d15,64
8000cdbc:	aa f2       	cmov %d2,%d15,-1
8000cdbe:	00 90       	ret 

8000cdc0 <quorem>:
8000cdc0:	19 58 10 00 	ld.w %d8,[%a5]16
8000cdc4:	4c 44       	ld.w %d15,[%a4]16
8000cdc6:	82 02       	mov %d2,0
8000cdc8:	3f 8f 88 00 	jlt %d15,%d8,8000ced8 <quorem+0x118>
8000cdcc:	c2 f8       	add %d8,-1
8000cdce:	80 4f       	mov.d %d15,%a4
8000cdd0:	8f 28 00 20 	sh %d2,%d8,2
8000cdd4:	60 2f       	mov.a %a15,%d2
8000cdd6:	1b 4f 01 90 	addi %d9,%d15,20
8000cdda:	d9 5c 14 00 	lea %a12,[%a5]20
8000cdde:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000cde2:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000cde6:	54 dc       	ld.w %d12,[%a13]
8000cde8:	4c f0       	ld.w %d15,[%a15]0
8000cdea:	c2 1c       	add %d12,1
8000cdec:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000cdf0:	02 ca       	mov %d10,%d12
8000cdf2:	df 0c 3d 00 	jeq %d12,0,8000ce6c <quorem+0xac>
8000cdf6:	60 96       	mov.a %a6,%d9
8000cdf8:	40 c2       	mov.aa %a2,%a12
8000cdfa:	82 05       	mov %d5,0
8000cdfc:	82 06       	mov %d6,0
8000cdfe:	54 22       	ld.w %d2,[%a2]
8000ce00:	40 63       	mov.aa %a3,%a6
8000ce02:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000ce06:	8f 02 1f 20 	sh %d2,%d2,-16
8000ce0a:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000ce0e:	b0 42       	add.a %a2,4
8000ce10:	8f 03 1f 40 	sh %d4,%d3,-16
8000ce14:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000ce18:	44 34       	ld.w %d4,[%a3+]
8000ce1a:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000ce1e:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000ce22:	8f 02 1f 50 	sh %d5,%d2,-16
8000ce26:	42 f6       	add %d6,%d15
8000ce28:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000ce2c:	0b 36 80 30 	sub %d3,%d6,%d3
8000ce30:	8f 04 1f 40 	sh %d4,%d4,-16
8000ce34:	8f 03 3f f0 	sha %d15,%d3,-16
8000ce38:	0b 24 80 20 	sub %d2,%d4,%d2
8000ce3c:	42 f2       	add %d2,%d15
8000ce3e:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000ce42:	8f 02 3f 60 	sha %d6,%d2,-16
8000ce46:	80 2f       	mov.d %d15,%a2
8000ce48:	80 d2       	mov.d %d2,%a13
8000ce4a:	74 63       	st.w [%a6],%d3
8000ce4c:	40 36       	mov.aa %a6,%a3
8000ce4e:	7f f2 d8 ff 	jge.u %d2,%d15,8000cdfe <quorem+0x3e>
8000ce52:	4c f0       	ld.w %d15,[%a15]0
8000ce54:	ee 0c       	jnz %d15,8000ce6c <quorem+0xac>
8000ce56:	b0 cf       	add.a %a15,-4
8000ce58:	80 f2       	mov.d %d2,%a15
8000ce5a:	3f 29 05 80 	jlt.u %d9,%d2,8000ce64 <quorem+0xa4>
8000ce5e:	59 48 10 00 	st.w [%a4]16,%d8
8000ce62:	3c 05       	j 8000ce6c <quorem+0xac>
8000ce64:	4c f0       	ld.w %d15,[%a15]0
8000ce66:	ee fc       	jnz %d15,8000ce5e <quorem+0x9e>
8000ce68:	c2 f8       	add %d8,-1
8000ce6a:	3c f6       	j 8000ce56 <quorem+0x96>
8000ce6c:	40 4e       	mov.aa %a14,%a4
8000ce6e:	6d 00 b9 08 	call 8000dfe0 <__mcmp>
8000ce72:	bf 02 32 00 	jlt %d2,0,8000ced6 <quorem+0x116>
8000ce76:	60 92       	mov.a %a2,%d9
8000ce78:	1b 1c 00 a0 	addi %d10,%d12,1
8000ce7c:	82 04       	mov %d4,0
8000ce7e:	40 2f       	mov.aa %a15,%a2
8000ce80:	44 f3       	ld.w %d3,[%a15+]
8000ce82:	54 c5       	ld.w %d5,[%a12]
8000ce84:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000ce88:	8f 05 1f f0 	sh %d15,%d5,-16
8000ce8c:	42 42       	add %d2,%d4
8000ce8e:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000ce92:	8f 03 1f 30 	sh %d3,%d3,-16
8000ce96:	a2 42       	sub %d2,%d4
8000ce98:	8f 02 3f 40 	sha %d4,%d2,-16
8000ce9c:	a2 f3       	sub %d3,%d15
8000ce9e:	42 43       	add %d3,%d4
8000cea0:	8f 03 3f 40 	sha %d4,%d3,-16
8000cea4:	b0 4c       	add.a %a12,4
8000cea6:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000ceaa:	80 df       	mov.d %d15,%a13
8000ceac:	80 c2       	mov.d %d2,%a12
8000ceae:	74 23       	st.w [%a2],%d3
8000ceb0:	40 f2       	mov.aa %a2,%a15
8000ceb2:	7f 2f e6 ff 	jge.u %d15,%d2,8000ce7e <quorem+0xbe>
8000ceb6:	60 92       	mov.a %a2,%d9
8000ceb8:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000cebc:	4c f0       	ld.w %d15,[%a15]0
8000cebe:	ee 0c       	jnz %d15,8000ced6 <quorem+0x116>
8000cec0:	b0 cf       	add.a %a15,-4
8000cec2:	80 f2       	mov.d %d2,%a15
8000cec4:	3f 29 05 80 	jlt.u %d9,%d2,8000cece <quorem+0x10e>
8000cec8:	59 e8 10 00 	st.w [%a14]16,%d8
8000cecc:	3c 05       	j 8000ced6 <quorem+0x116>
8000cece:	4c f0       	ld.w %d15,[%a15]0
8000ced0:	ee fc       	jnz %d15,8000cec8 <quorem+0x108>
8000ced2:	c2 f8       	add %d8,-1
8000ced4:	3c f6       	j 8000cec0 <quorem+0x100>
8000ced6:	02 a2       	mov %d2,%d10
8000ced8:	00 90       	ret 
	...

8000cedc <_dtoa_r>:
8000cedc:	20 58       	sub.a %sp,88
8000cede:	b5 a5 08 10 	st.a [%sp]72,%a5
8000cee2:	99 45 00 10 	ld.a %a5,[%a4]64
8000cee6:	59 a6 1c 00 	st.w [%sp]28,%d6
8000ceea:	59 a7 28 00 	st.w [%sp]40,%d7
8000ceee:	b5 a7 38 00 	st.a [%sp]56,%a7
8000cef2:	40 4d       	mov.aa %a13,%a4
8000cef4:	0b 45 10 88 	mov %e8,%d5,%d4
8000cef8:	40 6c       	mov.aa %a12,%a6
8000cefa:	0b 45 10 c8 	mov %e12,%d5,%d4
8000cefe:	bc 5e       	jz.a %a5,8000cf1a <_dtoa_r+0x3e>
8000cf00:	19 4f 04 10 	ld.w %d15,[%a4]68
8000cf04:	82 12       	mov %d2,1
8000cf06:	0f f2 00 20 	sh %d2,%d2,%d15
8000cf0a:	6c 51       	st.w [%a5]4,%d15
8000cf0c:	59 52 08 00 	st.w [%a5]8,%d2
8000cf10:	82 0f       	mov %d15,0
8000cf12:	6d 00 99 06 	call 8000dc44 <_Bfree>
8000cf16:	59 df 00 10 	st.w [%a13]64,%d15
8000cf1a:	ce 96       	jgez %d9,8000cf26 <_dtoa_r+0x4a>
8000cf1c:	82 1f       	mov %d15,1
8000cf1e:	6c c0       	st.w [%a12]0,%d15
8000cf20:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000cf24:	3c 03       	j 8000cf2a <_dtoa_r+0x4e>
8000cf26:	82 0f       	mov %d15,0
8000cf28:	6c c0       	st.w [%a12]0,%d15
8000cf2a:	7b 00 ff 27 	movh %d2,32752
8000cf2e:	26 d2       	and %d2,%d13
8000cf30:	7b 00 ff 37 	movh %d3,32752
8000cf34:	5f 32 22 80 	jne %d2,%d3,8000cf78 <_dtoa_r+0x9c>
8000cf38:	99 a3 08 10 	ld.a %a3,[%sp]72
8000cf3c:	3b f0 70 22 	mov %d2,9999
8000cf40:	91 00 00 f8 	movh.a %a15,32768
8000cf44:	74 32       	st.w [%a3],%d2
8000cf46:	d9 ff 09 01 	lea %a15,[%a15]4105 <80001009 <blanks.4035+0x19>>
8000cf4a:	f6 c8       	jnz %d12,8000cf5a <_dtoa_r+0x7e>
8000cf4c:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000cf50:	ee 05       	jnz %d15,8000cf5a <_dtoa_r+0x7e>
8000cf52:	91 00 00 f8 	movh.a %a15,32768
8000cf56:	d9 ff 00 01 	lea %a15,[%a15]4096 <80001000 <blanks.4035+0x10>>
8000cf5a:	99 a3 38 00 	ld.a %a3,[%sp]56 <80001000 <blanks.4035+0x10>>
8000cf5e:	40 f2       	mov.aa %a2,%a15
8000cf60:	bd 03 26 06 	jz.a %a3,8000dbac <_dtoa_r+0xcd0>
8000cf64:	80 ff       	mov.d %d15,%a15
8000cf66:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000cf6a:	1b 8f 00 20 	addi %d2,%d15,8
8000cf6e:	c2 3f       	add %d15,3
8000cf70:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000cf74:	6c 30       	st.w [%a3]0,%d15
8000cf76:	00 90       	ret 
8000cf78:	0b cd 10 48 	mov %e4,%d13,%d12
8000cf7c:	d2 06       	mov %e6,0
8000cf7e:	0b cd 10 88 	mov %e8,%d13,%d12
8000cf82:	6d 00 2f 0c 	call 8000e7e0 <__eqdf2>
8000cf86:	df 02 13 80 	jne %d2,0,8000cfac <_dtoa_r+0xd0>
8000cf8a:	99 a3 08 10 	ld.a %a3,[%sp]72
8000cf8e:	d8 0e       	ld.a %a15,[%sp]56
8000cf90:	82 1f       	mov %d15,1
8000cf92:	91 00 00 28 	movh.a %a2,32768
8000cf96:	6c 30       	st.w [%a3]0,%d15
8000cf98:	d9 22 0d 01 	lea %a2,[%a2]4109 <8000100d <blanks.4035+0x1d>>
8000cf9c:	bd 0f 08 06 	jz.a %a15,8000dbac <_dtoa_r+0xcd0>
8000cfa0:	7b 00 00 f8 	movh %d15,32768
8000cfa4:	1b ef 00 f1 	addi %d15,%d15,4110
8000cfa8:	68 0f       	st.w [%a15]0,%d15
8000cfaa:	00 90       	ret 
8000cfac:	0b cd 10 48 	mov %e4,%d13,%d12
8000cfb0:	40 d4       	mov.aa %a4,%a13
8000cfb2:	d9 a5 14 10 	lea %a5,[%sp]84
8000cfb6:	d9 a6 10 10 	lea %a6,[%sp]80
8000cfba:	6d 00 99 08 	call 8000e0ec <__d2b>
8000cfbe:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000cfc2:	40 2e       	mov.aa %a14,%a2
8000cfc4:	19 aa 10 10 	ld.w %d10,[%sp]80
8000cfc8:	76 bd       	jz %d11,8000cfe2 <_dtoa_r+0x106>
8000cfca:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000cfce:	0b cd 10 48 	mov %e4,%d13,%d12
8000cfd2:	7b 00 ff 23 	movh %d2,16368
8000cfd6:	0f 2f a0 50 	or %d5,%d15,%d2
8000cfda:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000cfde:	82 0f       	mov %d15,0
8000cfe0:	3c 22       	j 8000d024 <_dtoa_r+0x148>
8000cfe2:	19 ab 14 10 	ld.w %d11,[%sp]84
8000cfe6:	3b e0 be 4f 	mov %d4,-1042
8000cfea:	42 ab       	add %d11,%d10
8000cfec:	a2 b4       	sub %d4,%d11
8000cfee:	3b f0 be 2f 	mov %d2,-1041
8000cff2:	0f 4c 00 40 	sh %d4,%d12,%d4
8000cff6:	3f 2b 0f 00 	jlt %d11,%d2,8000d014 <_dtoa_r+0x138>
8000cffa:	1b 2b 41 30 	addi %d3,%d11,1042
8000cffe:	3b e0 c0 4f 	mov %d4,-1010
8000d002:	a2 b4       	sub %d4,%d11
8000d004:	8b 03 00 21 	rsub %d2,%d3,0
8000d008:	0f 2c 00 20 	sh %d2,%d12,%d2
8000d00c:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000d010:	0f f2 a0 40 	or %d4,%d2,%d15
8000d014:	6d 00 ad 0c 	call 8000e96e <__floatunsidf>
8000d018:	0b 23 10 48 	mov %e4,%d3,%d2
8000d01c:	9b 03 e1 5f 	addih %d5,%d3,65040
8000d020:	c2 fb       	add %d11,-1
8000d022:	82 1f       	mov %d15,1
8000d024:	b7 00 ab 69 	imask %e6,0,19,11
8000d028:	78 13       	st.w [%sp]76,%d15
8000d02a:	6d ff ba ee 	call 8000ad9e <__subdf3>
8000d02e:	7b 30 fd 73 	movh %d7,16339
8000d032:	0b 23 10 48 	mov %e4,%d3,%d2
8000d036:	7b f0 36 66 	movh %d6,25455
8000d03a:	1b 77 7a 78 	addi %d7,%d7,-30809
8000d03e:	1b 16 36 64 	addi %d6,%d6,17249
8000d042:	6d ff ce ee 	call 8000adde <__muldf3>
8000d046:	7b 70 fc 73 	movh %d7,16327
8000d04a:	0b 23 10 48 	mov %e4,%d3,%d2
8000d04e:	7b 10 b6 68 	movh %d6,35681
8000d052:	1b 87 a2 78 	addi %d7,%d7,-30168
8000d056:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000d05a:	6d ff 86 ee 	call 8000ad66 <__adddf3>
8000d05e:	02 b4       	mov %d4,%d11
8000d060:	0b 23 10 88 	mov %e8,%d3,%d2
8000d064:	6d ff 1b f0 	call 8000b09a <__floatsidf>
8000d068:	7b 30 fd 73 	movh %d7,16339
8000d06c:	0b 23 10 48 	mov %e4,%d3,%d2
8000d070:	7b f0 09 65 	movh %d6,20639
8000d074:	1b 37 41 74 	addi %d7,%d7,17427
8000d078:	1b b6 9f 67 	addi %d6,%d6,31227
8000d07c:	6d ff b1 ee 	call 8000adde <__muldf3>
8000d080:	0b 89 10 48 	mov %e4,%d9,%d8
8000d084:	0b 23 10 68 	mov %e6,%d3,%d2
8000d088:	6d ff 6f ee 	call 8000ad66 <__adddf3>
8000d08c:	0b 23 10 48 	mov %e4,%d3,%d2
8000d090:	0b 23 10 88 	mov %e8,%d3,%d2
8000d094:	6d 00 46 0c 	call 8000e920 <__fixdfsi>
8000d098:	0b 89 10 48 	mov %e4,%d9,%d8
8000d09c:	d2 06       	mov %e6,0
8000d09e:	59 a2 08 00 	st.w [%sp]8,%d2
8000d0a2:	6d 00 1f 0c 	call 8000e8e0 <__ltdf2>
8000d0a6:	ff 02 12 00 	jge %d2,0,8000d0ca <_dtoa_r+0x1ee>
8000d0aa:	19 a4 08 00 	ld.w %d4,[%sp]8
8000d0ae:	6d ff f6 ef 	call 8000b09a <__floatsidf>
8000d0b2:	0b 89 10 48 	mov %e4,%d9,%d8
8000d0b6:	0b 23 10 68 	mov %e6,%d3,%d2
8000d0ba:	6d 00 b3 0b 	call 8000e820 <__nedf2>
8000d0be:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d0c2:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000d0c6:	59 a3 08 00 	st.w [%sp]8,%d3
8000d0ca:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d0ce:	82 13       	mov %d3,1
8000d0d0:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000d0d4:	59 a3 3c 00 	st.w [%sp]60,%d3
8000d0d8:	ee 18       	jnz %d15,8000d108 <_dtoa_r+0x22c>
8000d0da:	91 00 00 f8 	movh.a %a15,32768
8000d0de:	d9 ff 30 21 	lea %a15,[%a15]4272 <800010b0 <__mprec_tens>>
8000d0e2:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000d0e6:	0b cd 10 68 	mov %e6,%d13,%d12
8000d0ea:	09 f4 40 09 	ld.d %e4,[%a15]
8000d0ee:	6d 00 b9 0b 	call 8000e860 <__gtdf2>
8000d0f2:	8e 28       	jlez %d2,8000d102 <_dtoa_r+0x226>
8000d0f4:	58 02       	ld.w %d15,[%sp]8
8000d0f6:	82 02       	mov %d2,0
8000d0f8:	c2 ff       	add %d15,-1
8000d0fa:	78 02       	st.w [%sp]8,%d15
8000d0fc:	59 a2 3c 00 	st.w [%sp]60,%d2
8000d100:	3c 04       	j 8000d108 <_dtoa_r+0x22c>
8000d102:	82 03       	mov %d3,0
8000d104:	59 a3 3c 00 	st.w [%sp]60,%d3
8000d108:	0b ba 80 b0 	sub %d11,%d10,%d11
8000d10c:	9a fb       	add %d15,%d11,-1
8000d10e:	82 02       	mov %d2,0
8000d110:	78 06       	st.w [%sp]24,%d15
8000d112:	59 a2 14 00 	st.w [%sp]20,%d2
8000d116:	ce f6       	jgez %d15,8000d122 <_dtoa_r+0x246>
8000d118:	32 5f       	rsub %d15
8000d11a:	82 03       	mov %d3,0
8000d11c:	78 05       	st.w [%sp]20,%d15
8000d11e:	59 a3 18 00 	st.w [%sp]24,%d3
8000d122:	58 02       	ld.w %d15,[%sp]8
8000d124:	0e fa       	jltz %d15,8000d138 <_dtoa_r+0x25c>
8000d126:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d12a:	78 0d       	st.w [%sp]52,%d15
8000d12c:	42 f2       	add %d2,%d15
8000d12e:	82 0f       	mov %d15,0
8000d130:	59 a2 18 00 	st.w [%sp]24,%d2
8000d134:	78 08       	st.w [%sp]32,%d15
8000d136:	3c 0d       	j 8000d150 <_dtoa_r+0x274>
8000d138:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d13c:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d140:	82 0f       	mov %d15,0
8000d142:	a2 32       	sub %d2,%d3
8000d144:	32 53       	rsub %d3
8000d146:	59 a2 14 00 	st.w [%sp]20,%d2
8000d14a:	59 a3 20 00 	st.w [%sp]32,%d3
8000d14e:	78 0d       	st.w [%sp]52,%d15
8000d150:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d154:	82 18       	mov %d8,1
8000d156:	ff a2 46 80 	jge.u %d2,10,8000d1e2 <_dtoa_r+0x306>
8000d15a:	bf 62 06 00 	jlt %d2,6,8000d166 <_dtoa_r+0x28a>
8000d15e:	c2 c2       	add %d2,-4
8000d160:	59 a2 1c 00 	st.w [%sp]28,%d2
8000d164:	82 08       	mov %d8,0
8000d166:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000d16a:	c2 e3       	add %d3,-2
8000d16c:	ff 43 4b 80 	jge.u %d3,4,8000d202 <_dtoa_r+0x326>
8000d170:	91 10 00 f8 	movh.a %a15,32769
8000d174:	d9 ff 00 6d 	lea %a15,[%a15]-11904 <8000d180 <_dtoa_r+0x2a4>>
8000d178:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000d17c:	dc 0f       	ji %a15
8000d17e:	00 00       	nop 
8000d180:	1d 00 08 00 	j 8000d190 <_dtoa_r+0x2b4>
8000d184:	1d 00 1c 00 	j 8000d1bc <_dtoa_r+0x2e0>
8000d188:	1d 00 08 00 	j 8000d198 <_dtoa_r+0x2bc>
8000d18c:	1d 00 1c 00 	j 8000d1c4 <_dtoa_r+0x2e8>
8000d190:	82 03       	mov %d3,0
8000d192:	59 a3 24 00 	st.w [%sp]36,%d3
8000d196:	3c 03       	j 8000d19c <_dtoa_r+0x2c0>
8000d198:	82 1f       	mov %d15,1
8000d19a:	78 09       	st.w [%sp]36,%d15
8000d19c:	19 a2 28 00 	ld.w %d2,[%sp]40
8000d1a0:	59 a2 2c 00 	st.w [%sp]44,%d2
8000d1a4:	59 a2 10 00 	st.w [%sp]16,%d2
8000d1a8:	02 23       	mov %d3,%d2
8000d1aa:	ff 12 38 00 	jge %d2,1,8000d21a <_dtoa_r+0x33e>
8000d1ae:	82 13       	mov %d3,1
8000d1b0:	82 1f       	mov %d15,1
8000d1b2:	59 a3 2c 00 	st.w [%sp]44,%d3
8000d1b6:	78 04       	st.w [%sp]16,%d15
8000d1b8:	82 12       	mov %d2,1
8000d1ba:	3c 21       	j 8000d1fc <_dtoa_r+0x320>
8000d1bc:	82 03       	mov %d3,0
8000d1be:	59 a3 24 00 	st.w [%sp]36,%d3
8000d1c2:	3c 03       	j 8000d1c8 <_dtoa_r+0x2ec>
8000d1c4:	82 1f       	mov %d15,1
8000d1c6:	78 09       	st.w [%sp]36,%d15
8000d1c8:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d1cc:	19 a2 28 00 	ld.w %d2,[%sp]40
8000d1d0:	42 32       	add %d2,%d3
8000d1d2:	59 a2 2c 00 	st.w [%sp]44,%d2
8000d1d6:	c2 12       	add %d2,1
8000d1d8:	59 a2 10 00 	st.w [%sp]16,%d2
8000d1dc:	8b 12 40 33 	max %d3,%d2,1
8000d1e0:	3c 1d       	j 8000d21a <_dtoa_r+0x33e>
8000d1e2:	82 0f       	mov %d15,0
8000d1e4:	82 12       	mov %d2,1
8000d1e6:	82 f3       	mov %d3,-1
8000d1e8:	78 07       	st.w [%sp]28,%d15
8000d1ea:	82 ff       	mov %d15,-1
8000d1ec:	59 a2 24 00 	st.w [%sp]36,%d2
8000d1f0:	59 a3 2c 00 	st.w [%sp]44,%d3
8000d1f4:	78 04       	st.w [%sp]16,%d15
8000d1f6:	3b 20 01 30 	mov %d3,18
8000d1fa:	82 02       	mov %d2,0
8000d1fc:	59 a2 28 00 	st.w [%sp]40,%d2
8000d200:	3c 0d       	j 8000d21a <_dtoa_r+0x33e>
8000d202:	82 ff       	mov %d15,-1
8000d204:	82 13       	mov %d3,1
8000d206:	78 0b       	st.w [%sp]44,%d15
8000d208:	82 f2       	mov %d2,-1
8000d20a:	82 0f       	mov %d15,0
8000d20c:	59 a3 24 00 	st.w [%sp]36,%d3
8000d210:	59 a2 10 00 	st.w [%sp]16,%d2
8000d214:	3b 20 01 30 	mov %d3,18
8000d218:	78 0a       	st.w [%sp]40,%d15
8000d21a:	82 05       	mov %d5,0
8000d21c:	59 d5 04 10 	st.w [%a13]68,%d5
8000d220:	82 45       	mov %d5,4
8000d222:	1b 45 01 00 	addi %d0,%d5,20
8000d226:	3f 03 09 80 	jlt.u %d3,%d0,8000d238 <_dtoa_r+0x35c>
8000d22a:	19 d0 04 10 	ld.w %d0,[%a13]68
8000d22e:	06 15       	sh %d5,1
8000d230:	c2 10       	add %d0,1
8000d232:	59 d0 04 10 	st.w [%a13]68,%d0
8000d236:	3c f6       	j 8000d222 <_dtoa_r+0x346>
8000d238:	40 d4       	mov.aa %a4,%a13
8000d23a:	19 d4 04 10 	ld.w %d4,[%a13]68
8000d23e:	6d 00 d8 04 	call 8000dbee <_Balloc>
8000d242:	19 a2 10 00 	ld.w %d2,[%sp]16
8000d246:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000d24a:	8b f2 60 32 	lt.u %d3,%d2,15
8000d24e:	b5 d2 00 10 	st.a [%a13]64,%a2
8000d252:	26 38       	and %d8,%d3
8000d254:	df 08 97 01 	jeq %d8,0,8000d582 <_dtoa_r+0x6a6>
8000d258:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d25c:	89 ac 40 19 	st.d [%sp]64,%e12
8000d260:	bf 13 3f 00 	jlt %d3,1,8000d2de <_dtoa_r+0x402>
8000d264:	91 00 00 f8 	movh.a %a15,32768
8000d268:	8f f3 00 31 	and %d3,%d3,15
8000d26c:	d9 ff 30 21 	lea %a15,[%a15]4272 <800010b0 <__mprec_tens>>
8000d270:	19 ae 08 00 	ld.w %d14,[%sp]8 <800010b0 <__mprec_tens>>
8000d274:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000d278:	86 ce       	sha %d14,-4
8000d27a:	09 f8 40 09 	ld.d %e8,[%a15]
8000d27e:	82 2a       	mov %d10,2
8000d280:	6f 4e 11 00 	jz.t %d14,4,8000d2a2 <_dtoa_r+0x3c6>
8000d284:	91 00 00 f8 	movh.a %a15,32768
8000d288:	0b cd 10 48 	mov %e4,%d13,%d12
8000d28c:	d9 ff 08 21 	lea %a15,[%a15]4232 <80001088 <__mprec_bigtens>>
8000d290:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000d294:	6d ff 77 ee 	call 8000af82 <__divdf3>
8000d298:	0b 23 10 c8 	mov %e12,%d3,%d2
8000d29c:	8f fe 00 e1 	and %d14,%d14,15
8000d2a0:	82 3a       	mov %d10,3
8000d2a2:	7b 00 00 b8 	movh %d11,32768
8000d2a6:	82 0f       	mov %d15,0
8000d2a8:	1b 8b 08 b1 	addi %d11,%d11,4232
8000d2ac:	df 0e 12 00 	jeq %d14,0,8000d2d0 <_dtoa_r+0x3f4>
8000d2b0:	6f 0e 0d 00 	jz.t %d14,0,8000d2ca <_dtoa_r+0x3ee>
8000d2b4:	60 b2       	mov.a %a2,%d11
8000d2b6:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000d2b8:	0b 89 10 48 	mov %e4,%d9,%d8
8000d2bc:	09 f6 40 09 	ld.d %e6,[%a15]
8000d2c0:	6d ff 8f ed 	call 8000adde <__muldf3>
8000d2c4:	0b 23 10 88 	mov %e8,%d3,%d2
8000d2c8:	c2 1a       	add %d10,1
8000d2ca:	86 fe       	sha %d14,-1
8000d2cc:	c2 1f       	add %d15,1
8000d2ce:	3c ef       	j 8000d2ac <_dtoa_r+0x3d0>
8000d2d0:	0b cd 10 48 	mov %e4,%d13,%d12
8000d2d4:	0b 89 10 68 	mov %e6,%d9,%d8
8000d2d8:	6d ff 55 ee 	call 8000af82 <__divdf3>
8000d2dc:	3c 2c       	j 8000d334 <_dtoa_r+0x458>
8000d2de:	19 a8 08 00 	ld.w %d8,[%sp]8
8000d2e2:	82 2a       	mov %d10,2
8000d2e4:	32 58       	rsub %d8
8000d2e6:	df 08 29 00 	jeq %d8,0,8000d338 <_dtoa_r+0x45c>
8000d2ea:	91 00 00 f8 	movh.a %a15,32768
8000d2ee:	8f f8 00 31 	and %d3,%d8,15
8000d2f2:	d9 ff 30 21 	lea %a15,[%a15]4272 <800010b0 <__mprec_tens>>
8000d2f6:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000d2fa:	09 a4 40 19 	ld.d %e4,[%sp]64
8000d2fe:	09 f6 40 09 	ld.d %e6,[%a15]
8000d302:	7b 00 00 c8 	movh %d12,32768
8000d306:	6d ff 6c ed 	call 8000adde <__muldf3>
8000d30a:	82 09       	mov %d9,0
8000d30c:	86 c8       	sha %d8,-4
8000d30e:	1b 8c 08 c1 	addi %d12,%d12,4232
8000d312:	df 08 11 00 	jeq %d8,0,8000d334 <_dtoa_r+0x458>
8000d316:	6f 08 0c 00 	jz.t %d8,0,8000d32e <_dtoa_r+0x452>
8000d31a:	60 c3       	mov.a %a3,%d12
8000d31c:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000d320:	0b 23 10 48 	mov %e4,%d3,%d2
8000d324:	09 f6 40 09 	ld.d %e6,[%a15]
8000d328:	c2 1a       	add %d10,1
8000d32a:	6d ff 5a ed 	call 8000adde <__muldf3>
8000d32e:	86 f8       	sha %d8,-1
8000d330:	c2 19       	add %d9,1
8000d332:	3c f0       	j 8000d312 <_dtoa_r+0x436>
8000d334:	0b 23 10 c8 	mov %e12,%d3,%d2
8000d338:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000d33c:	df 02 23 00 	jeq %d2,0,8000d382 <_dtoa_r+0x4a6>
8000d340:	0b cd 10 48 	mov %e4,%d13,%d12
8000d344:	b7 00 2a 6a 	imask %e6,0,20,10
8000d348:	6d 00 cc 0a 	call 8000e8e0 <__ltdf2>
8000d34c:	ff 02 20 00 	jge %d2,0,8000d38c <_dtoa_r+0x4b0>
8000d350:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d354:	df 03 21 00 	jeq %d3,0,8000d396 <_dtoa_r+0x4ba>
8000d358:	58 0b       	ld.w %d15,[%sp]44
8000d35a:	bf 1f 12 01 	jlt %d15,1,8000d57e <_dtoa_r+0x6a2>
8000d35e:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d362:	0b cd 10 48 	mov %e4,%d13,%d12
8000d366:	c2 f2       	add %d2,-1
8000d368:	82 06       	mov %d6,0
8000d36a:	7b 40 02 74 	movh %d7,16420
8000d36e:	59 a2 30 00 	st.w [%sp]48,%d2
8000d372:	6d ff 36 ed 	call 8000adde <__muldf3>
8000d376:	c2 1a       	add %d10,1
8000d378:	0b 23 10 c8 	mov %e12,%d3,%d2
8000d37c:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000d380:	3c 10       	j 8000d3a0 <_dtoa_r+0x4c4>
8000d382:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d386:	59 a3 30 00 	st.w [%sp]48,%d3
8000d38a:	3c 03       	j 8000d390 <_dtoa_r+0x4b4>
8000d38c:	58 02       	ld.w %d15,[%sp]8
8000d38e:	78 0c       	st.w [%sp]48,%d15
8000d390:	99 ac 10 00 	ld.a %a12,[%sp]16
8000d394:	3c 06       	j 8000d3a0 <_dtoa_r+0x4c4>
8000d396:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d39a:	a0 0c       	mov.a %a12,0
8000d39c:	59 a2 30 00 	st.w [%sp]48,%d2
8000d3a0:	02 a4       	mov %d4,%d10
8000d3a2:	6d ff 7c ee 	call 8000b09a <__floatsidf>
8000d3a6:	0b cd 10 68 	mov %e6,%d13,%d12
8000d3aa:	0b 23 10 48 	mov %e4,%d3,%d2
8000d3ae:	6d ff 18 ed 	call 8000adde <__muldf3>
8000d3b2:	0b 23 10 48 	mov %e4,%d3,%d2
8000d3b6:	82 06       	mov %d6,0
8000d3b8:	7b c0 01 74 	movh %d7,16412
8000d3bc:	6d ff d5 ec 	call 8000ad66 <__adddf3>
8000d3c0:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d3c4:	0b 23 10 e8 	mov %e14,%d3,%d2
8000d3c8:	60 b2       	mov.a %a2,%d11
8000d3ca:	11 02 cc ff 	addih.a %a15,%a2,64704
8000d3ce:	80 ff       	mov.d %d15,%a15
8000d3d0:	bd 0c 1e 80 	jnz.a %a12,8000d40c <_dtoa_r+0x530>
8000d3d4:	0b cd 10 48 	mov %e4,%d13,%d12
8000d3d8:	82 06       	mov %d6,0
8000d3da:	7b 40 01 74 	movh %d7,16404
8000d3de:	6d ff e0 ec 	call 8000ad9e <__subdf3>
8000d3e2:	80 f7       	mov.d %d7,%a15
8000d3e4:	0b 23 10 48 	mov %e4,%d3,%d2
8000d3e8:	02 e6       	mov %d6,%d14
8000d3ea:	0b 23 10 88 	mov %e8,%d3,%d2
8000d3ee:	6d 00 39 0a 	call 8000e860 <__gtdf2>
8000d3f2:	ff 12 8e 02 	jge %d2,1,8000d90e <_dtoa_r+0xa32>
8000d3f6:	0b 89 10 48 	mov %e4,%d9,%d8
8000d3fa:	02 e6       	mov %d6,%d14
8000d3fc:	9b 0b cc 77 	addih %d7,%d11,31936
8000d400:	6d 00 70 0a 	call 8000e8e0 <__ltdf2>
8000d404:	bf 02 7d 02 	jlt %d2,0,8000d8fe <_dtoa_r+0xa22>
8000d408:	1d 00 bb 00 	j 8000d57e <_dtoa_r+0x6a2>
8000d40c:	80 c5       	mov.d %d5,%a12
8000d40e:	91 00 00 f8 	movh.a %a15,32768
8000d412:	19 a2 24 00 	ld.w %d2,[%sp]36
8000d416:	d9 ff 30 21 	lea %a15,[%a15]4272 <800010b0 <__mprec_tens>>
8000d41a:	c2 f5       	add %d5,-1
8000d41c:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000d420:	df 02 57 00 	jeq %d2,0,8000d4ce <_dtoa_r+0x5f2>
8000d424:	b7 00 a9 4a 	imask %e4,0,21,9
8000d428:	09 f6 40 09 	ld.d %e6,[%a15]
8000d42c:	6d ff ab ed 	call 8000af82 <__divdf3>
8000d430:	0b ef 10 68 	mov %e6,%d15,%d14
8000d434:	0b 23 10 48 	mov %e4,%d3,%d2
8000d438:	6d ff b3 ec 	call 8000ad9e <__subdf3>
8000d43c:	d8 03       	ld.a %a15,[%sp]12
8000d43e:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d442:	0b cd 10 48 	mov %e4,%d13,%d12
8000d446:	80 fe       	mov.d %d14,%a15
8000d448:	6d 00 6c 0a 	call 8000e920 <__fixdfsi>
8000d44c:	02 24       	mov %d4,%d2
8000d44e:	02 2f       	mov %d15,%d2
8000d450:	6d ff 25 ee 	call 8000b09a <__floatsidf>
8000d454:	0b cd 10 48 	mov %e4,%d13,%d12
8000d458:	0b 23 10 68 	mov %e6,%d3,%d2
8000d45c:	c2 1e       	add %d14,1
8000d45e:	6d ff a0 ec 	call 8000ad9e <__subdf3>
8000d462:	1b 0f 03 50 	addi %d5,%d15,48
8000d466:	28 05       	st.b [%a15]0,%d5
8000d468:	0b ab 10 68 	mov %e6,%d11,%d10
8000d46c:	0b 23 10 48 	mov %e4,%d3,%d2
8000d470:	0b 23 10 88 	mov %e8,%d3,%d2
8000d474:	6d 00 36 0a 	call 8000e8e0 <__ltdf2>
8000d478:	bf 02 86 03 	jlt %d2,0,8000db84 <_dtoa_r+0xca8>
8000d47c:	b7 00 2a 4a 	imask %e4,0,20,10
8000d480:	0b 89 10 68 	mov %e6,%d9,%d8
8000d484:	6d ff 8d ec 	call 8000ad9e <__subdf3>
8000d488:	0b ab 10 68 	mov %e6,%d11,%d10
8000d48c:	0b 23 10 48 	mov %e4,%d3,%d2
8000d490:	6d 00 28 0a 	call 8000e8e0 <__ltdf2>
8000d494:	bf 02 ea 00 	jlt %d2,0,8000d668 <_dtoa_r+0x78c>
8000d498:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000d49c:	02 e5       	mov %d5,%d14
8000d49e:	80 cf       	mov.d %d15,%a12
8000d4a0:	a2 35       	sub %d5,%d3
8000d4a2:	7f f5 6e 00 	jge %d5,%d15,8000d57e <_dtoa_r+0x6a2>
8000d4a6:	0b ab 10 48 	mov %e4,%d11,%d10
8000d4aa:	82 06       	mov %d6,0
8000d4ac:	7b 40 02 74 	movh %d7,16420
8000d4b0:	6d ff 97 ec 	call 8000adde <__muldf3>
8000d4b4:	0b 89 10 48 	mov %e4,%d9,%d8
8000d4b8:	82 06       	mov %d6,0
8000d4ba:	7b 40 02 74 	movh %d7,16420
8000d4be:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d4c2:	6d ff 8e ec 	call 8000adde <__muldf3>
8000d4c6:	60 ef       	mov.a %a15,%d14
8000d4c8:	0b 23 10 c8 	mov %e12,%d3,%d2
8000d4cc:	3c bb       	j 8000d442 <_dtoa_r+0x566>
8000d4ce:	0b ef 10 68 	mov %e6,%d15,%d14
8000d4d2:	09 f4 40 09 	ld.d %e4,[%a15]
8000d4d6:	6d ff 84 ec 	call 8000adde <__muldf3>
8000d4da:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d4de:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d4e2:	30 c3       	add.a %a3,%a12
8000d4e4:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000d4e8:	80 3e       	mov.d %d14,%a3
8000d4ea:	0b cd 10 48 	mov %e4,%d13,%d12
8000d4ee:	d9 cf 01 00 	lea %a15,[%a12]1
8000d4f2:	6d 00 17 0a 	call 8000e920 <__fixdfsi>
8000d4f6:	02 24       	mov %d4,%d2
8000d4f8:	02 2f       	mov %d15,%d2
8000d4fa:	6d ff d0 ed 	call 8000b09a <__floatsidf>
8000d4fe:	0b cd 10 48 	mov %e4,%d13,%d12
8000d502:	0b 23 10 68 	mov %e6,%d3,%d2
8000d506:	6d ff 4c ec 	call 8000ad9e <__subdf3>
8000d50a:	1b 0f 03 50 	addi %d5,%d15,48
8000d50e:	0b 23 10 88 	mov %e8,%d3,%d2
8000d512:	80 f2       	mov.d %d2,%a15
8000d514:	34 c5       	st.b [%a12],%d5
8000d516:	5f e2 29 80 	jne %d2,%d14,8000d568 <_dtoa_r+0x68c>
8000d51a:	0b ab 10 48 	mov %e4,%d11,%d10
8000d51e:	b7 00 a9 6a 	imask %e6,0,21,9
8000d522:	6d ff 22 ec 	call 8000ad66 <__adddf3>
8000d526:	0b 89 10 48 	mov %e4,%d9,%d8
8000d52a:	0b 23 10 68 	mov %e6,%d3,%d2
8000d52e:	6d 00 99 09 	call 8000e860 <__gtdf2>
8000d532:	ff 12 9b 00 	jge %d2,1,8000d668 <_dtoa_r+0x78c>
8000d536:	b7 00 a9 4a 	imask %e4,0,21,9
8000d53a:	0b ab 10 68 	mov %e6,%d11,%d10
8000d53e:	6d ff 30 ec 	call 8000ad9e <__subdf3>
8000d542:	0b 89 10 48 	mov %e4,%d9,%d8
8000d546:	0b 23 10 68 	mov %e6,%d3,%d2
8000d54a:	6d 00 cb 09 	call 8000e8e0 <__ltdf2>
8000d54e:	ff 02 18 00 	jge %d2,0,8000d57e <_dtoa_r+0x6a2>
8000d552:	60 e2       	mov.a %a2,%d14
8000d554:	60 ef       	mov.a %a15,%d14
8000d556:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000d55a:	b0 ff       	add.a %a15,-1
8000d55c:	8b 0f 03 f2 	eq %d15,%d15,48
8000d560:	df 0f 12 03 	jeq %d15,0,8000db84 <_dtoa_r+0xca8>
8000d564:	80 fe       	mov.d %d14,%a15
8000d566:	3c f6       	j 8000d552 <_dtoa_r+0x676>
8000d568:	0b 89 10 48 	mov %e4,%d9,%d8
8000d56c:	82 06       	mov %d6,0
8000d56e:	7b 40 02 74 	movh %d7,16420
8000d572:	6d ff 36 ec 	call 8000adde <__muldf3>
8000d576:	40 fc       	mov.aa %a12,%a15
8000d578:	0b 23 10 c8 	mov %e12,%d3,%d2
8000d57c:	3c b7       	j 8000d4ea <_dtoa_r+0x60e>
8000d57e:	09 ac 40 19 	ld.d %e12,[%sp]64
8000d582:	19 a3 14 10 	ld.w %d3,[%sp]84
8000d586:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d58a:	8b 03 80 52 	ge %d5,%d3,0
8000d58e:	8b f2 40 54 	and.lt %d5,%d2,15
8000d592:	df 05 9e 00 	jeq %d5,0,8000d6ce <_dtoa_r+0x7f2>
8000d596:	91 00 00 f8 	movh.a %a15,32768
8000d59a:	d9 ff 30 21 	lea %a15,[%a15]4272 <800010b0 <__mprec_tens>>
8000d59e:	19 a3 10 00 	ld.w %d3,[%sp]16 <800010b0 <__mprec_tens>>
8000d5a2:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000d5a6:	19 a2 28 00 	ld.w %d2,[%sp]40
8000d5aa:	fa 13       	lt %d15,%d3,1
8000d5ac:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000d5b0:	09 f8 40 09 	ld.d %e8,[%a15]
8000d5b4:	6e 16       	jz %d15,8000d5e0 <_dtoa_r+0x704>
8000d5b6:	df 03 a4 81 	jne %d3,0,8000d8fe <_dtoa_r+0xa22>
8000d5ba:	0b 89 10 48 	mov %e4,%d9,%d8
8000d5be:	82 06       	mov %d6,0
8000d5c0:	7b 40 01 74 	movh %d7,16404
8000d5c4:	6d ff 0d ec 	call 8000adde <__muldf3>
8000d5c8:	0b cd 10 68 	mov %e6,%d13,%d12
8000d5cc:	0b 23 10 48 	mov %e4,%d3,%d2
8000d5d0:	a0 0c       	mov.a %a12,0
8000d5d2:	6d 00 67 09 	call 8000e8a0 <__gedf2>
8000d5d6:	a0 0f       	mov.a %a15,0
8000d5d8:	ff 02 95 01 	jge %d2,0,8000d902 <_dtoa_r+0xa26>
8000d5dc:	1d 00 9d 01 	j 8000d916 <_dtoa_r+0xa3a>
8000d5e0:	d8 03       	ld.a %a15,[%sp]12
8000d5e2:	0b cd 10 a8 	mov %e10,%d13,%d12
8000d5e6:	0b 89 10 68 	mov %e6,%d9,%d8
8000d5ea:	0b ab 10 48 	mov %e4,%d11,%d10
8000d5ee:	80 fe       	mov.d %d14,%a15
8000d5f0:	6d ff c9 ec 	call 8000af82 <__divdf3>
8000d5f4:	0b 23 10 48 	mov %e4,%d3,%d2
8000d5f8:	c2 1e       	add %d14,1
8000d5fa:	6d 00 93 09 	call 8000e920 <__fixdfsi>
8000d5fe:	02 24       	mov %d4,%d2
8000d600:	02 2f       	mov %d15,%d2
8000d602:	6d ff 4c ed 	call 8000b09a <__floatsidf>
8000d606:	0b 89 10 68 	mov %e6,%d9,%d8
8000d60a:	0b 23 10 48 	mov %e4,%d3,%d2
8000d60e:	6d ff e8 eb 	call 8000adde <__muldf3>
8000d612:	0b ab 10 48 	mov %e4,%d11,%d10
8000d616:	0b 23 10 68 	mov %e6,%d3,%d2
8000d61a:	6d ff c2 eb 	call 8000ad9e <__subdf3>
8000d61e:	0b 23 10 48 	mov %e4,%d3,%d2
8000d622:	1b 0f 03 30 	addi %d3,%d15,48
8000d626:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000d62a:	28 03       	st.b [%a15]0,%d3
8000d62c:	02 e3       	mov %d3,%d14
8000d62e:	a2 23       	sub %d3,%d2
8000d630:	19 a2 10 00 	ld.w %d2,[%sp]16
8000d634:	5f 23 3c 80 	jne %d3,%d2,8000d6ac <_dtoa_r+0x7d0>
8000d638:	0b 45 10 68 	mov %e6,%d5,%d4
8000d63c:	6d ff 95 eb 	call 8000ad66 <__adddf3>
8000d640:	0b 89 10 68 	mov %e6,%d9,%d8
8000d644:	0b 23 10 48 	mov %e4,%d3,%d2
8000d648:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d64c:	6d 00 0a 09 	call 8000e860 <__gtdf2>
8000d650:	4e 2e       	jgtz %d2,8000d66c <_dtoa_r+0x790>
8000d652:	0b ab 10 48 	mov %e4,%d11,%d10
8000d656:	0b 89 10 68 	mov %e6,%d9,%d8
8000d65a:	6d 00 c3 08 	call 8000e7e0 <__eqdf2>
8000d65e:	df 02 95 82 	jne %d2,0,8000db88 <_dtoa_r+0xcac>
8000d662:	ae 05       	jnz.t %d15,0,8000d66c <_dtoa_r+0x790>
8000d664:	1d 00 92 02 	j 8000db88 <_dtoa_r+0xcac>
8000d668:	58 0c       	ld.w %d15,[%sp]48
8000d66a:	78 02       	st.w [%sp]8,%d15
8000d66c:	58 03       	ld.w %d15,[%sp]12
8000d66e:	a2 ef       	sub %d15,%d14
8000d670:	46 0f       	not %d15
8000d672:	60 e2       	mov.a %a2,%d14
8000d674:	60 ef       	mov.a %a15,%d14
8000d676:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000d67a:	b0 ff       	add.a %a15,-1
8000d67c:	8b 93 03 32 	eq %d3,%d3,57
8000d680:	df 03 11 00 	jeq %d3,0,8000d6a2 <_dtoa_r+0x7c6>
8000d684:	9f 0f 0d 80 	jned %d15,0,8000d69e <_dtoa_r+0x7c2>
8000d688:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d68c:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d690:	c2 13       	add %d3,1
8000d692:	da 30       	mov %d15,48
8000d694:	59 a3 08 00 	st.w [%sp]8,%d3
8000d698:	2c 30       	st.b [%a3]0,%d15
8000d69a:	40 3f       	mov.aa %a15,%a3
8000d69c:	3c 03       	j 8000d6a2 <_dtoa_r+0x7c6>
8000d69e:	80 fe       	mov.d %d14,%a15
8000d6a0:	3c e9       	j 8000d672 <_dtoa_r+0x796>
8000d6a2:	0c f0       	ld.bu %d15,[%a15]0
8000d6a4:	c2 1f       	add %d15,1
8000d6a6:	28 0f       	st.b [%a15]0,%d15
8000d6a8:	1d 00 70 02 	j 8000db88 <_dtoa_r+0xcac>
8000d6ac:	82 06       	mov %d6,0
8000d6ae:	7b 40 02 74 	movh %d7,16420
8000d6b2:	6d ff 96 eb 	call 8000adde <__muldf3>
8000d6b6:	d2 06       	mov %e6,0
8000d6b8:	0b 23 10 48 	mov %e4,%d3,%d2
8000d6bc:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d6c0:	60 ef       	mov.a %a15,%d14
8000d6c2:	6d 00 8f 08 	call 8000e7e0 <__eqdf2>
8000d6c6:	df 02 90 ff 	jne %d2,0,8000d5e6 <_dtoa_r+0x70a>
8000d6ca:	1d 00 5f 02 	j 8000db88 <_dtoa_r+0xcac>
8000d6ce:	19 a2 24 00 	ld.w %d2,[%sp]36
8000d6d2:	58 08       	ld.w %d15,[%sp]32
8000d6d4:	19 a8 14 00 	ld.w %d8,[%sp]20
8000d6d8:	a0 0f       	mov.a %a15,0
8000d6da:	df 02 3b 00 	jeq %d2,0,8000d750 <_dtoa_r+0x874>
8000d6de:	58 07       	ld.w %d15,[%sp]28
8000d6e0:	ff 2f 10 00 	jge %d15,2,8000d700 <_dtoa_r+0x824>
8000d6e4:	58 13       	ld.w %d15,[%sp]76
8000d6e6:	6e 05       	jz %d15,8000d6f0 <_dtoa_r+0x814>
8000d6e8:	1b 33 43 30 	addi %d3,%d3,1075
8000d6ec:	58 08       	ld.w %d15,[%sp]32
8000d6ee:	3c 22       	j 8000d732 <_dtoa_r+0x856>
8000d6f0:	19 a3 10 10 	ld.w %d3,[%sp]80
8000d6f4:	58 08       	ld.w %d15,[%sp]32
8000d6f6:	8b 63 03 31 	rsub %d3,%d3,54
8000d6fa:	19 a8 14 00 	ld.w %d8,[%sp]20
8000d6fe:	3c 1a       	j 8000d732 <_dtoa_r+0x856>
8000d700:	58 04       	ld.w %d15,[%sp]16
8000d702:	19 a2 20 00 	ld.w %d2,[%sp]32
8000d706:	c2 ff       	add %d15,-1
8000d708:	3f f2 04 00 	jlt %d2,%d15,8000d710 <_dtoa_r+0x834>
8000d70c:	5a f2       	sub %d15,%d2,%d15
8000d70e:	3c 0b       	j 8000d724 <_dtoa_r+0x848>
8000d710:	19 a3 20 00 	ld.w %d3,[%sp]32
8000d714:	78 08       	st.w [%sp]32,%d15
8000d716:	52 32       	sub %d2,%d15,%d3
8000d718:	19 a3 34 00 	ld.w %d3,[%sp]52
8000d71c:	82 0f       	mov %d15,0
8000d71e:	42 23       	add %d3,%d2
8000d720:	59 a3 34 00 	st.w [%sp]52,%d3
8000d724:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d728:	19 a8 14 00 	ld.w %d8,[%sp]20
8000d72c:	ce 33       	jgez %d3,8000d732 <_dtoa_r+0x856>
8000d72e:	a2 38       	sub %d8,%d3
8000d730:	82 03       	mov %d3,0
8000d732:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d736:	40 d4       	mov.aa %a4,%a13
8000d738:	42 32       	add %d2,%d3
8000d73a:	59 a2 14 00 	st.w [%sp]20,%d2
8000d73e:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d742:	82 14       	mov %d4,1
8000d744:	42 32       	add %d2,%d3
8000d746:	59 a2 18 00 	st.w [%sp]24,%d2
8000d74a:	6d 00 1b 03 	call 8000dd80 <__i2b>
8000d74e:	40 2f       	mov.aa %a15,%a2
8000d750:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d754:	8b 18 80 32 	ge %d3,%d8,1
8000d758:	8b 12 80 34 	and.ge %d3,%d2,1
8000d75c:	76 3e       	jz %d3,8000d778 <_dtoa_r+0x89c>
8000d75e:	0b 82 80 31 	min %d3,%d2,%d8
8000d762:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d766:	a2 38       	sub %d8,%d3
8000d768:	a2 32       	sub %d2,%d3
8000d76a:	59 a2 14 00 	st.w [%sp]20,%d2
8000d76e:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d772:	a2 32       	sub %d2,%d3
8000d774:	59 a2 18 00 	st.w [%sp]24,%d2
8000d778:	19 a3 20 00 	ld.w %d3,[%sp]32
8000d77c:	bf 13 27 00 	jlt %d3,1,8000d7ca <_dtoa_r+0x8ee>
8000d780:	19 a2 24 00 	ld.w %d2,[%sp]36
8000d784:	df 02 1c 00 	jeq %d2,0,8000d7bc <_dtoa_r+0x8e0>
8000d788:	bf 1f 13 00 	jlt %d15,1,8000d7ae <_dtoa_r+0x8d2>
8000d78c:	40 f5       	mov.aa %a5,%a15
8000d78e:	02 f4       	mov %d4,%d15
8000d790:	40 d4       	mov.aa %a4,%a13
8000d792:	6d 00 8c 03 	call 8000deaa <__pow5mult>
8000d796:	40 e6       	mov.aa %a6,%a14
8000d798:	40 d4       	mov.aa %a4,%a13
8000d79a:	40 25       	mov.aa %a5,%a2
8000d79c:	40 2f       	mov.aa %a15,%a2
8000d79e:	6d 00 f9 02 	call 8000dd90 <__multiply>
8000d7a2:	40 e5       	mov.aa %a5,%a14
8000d7a4:	40 2c       	mov.aa %a12,%a2
8000d7a6:	40 d4       	mov.aa %a4,%a13
8000d7a8:	6d 00 4e 02 	call 8000dc44 <_Bfree>
8000d7ac:	40 ce       	mov.aa %a14,%a12
8000d7ae:	19 a4 20 00 	ld.w %d4,[%sp]32
8000d7b2:	40 d4       	mov.aa %a4,%a13
8000d7b4:	a2 f4       	sub %d4,%d15
8000d7b6:	40 e5       	mov.aa %a5,%a14
8000d7b8:	76 49       	jz %d4,8000d7ca <_dtoa_r+0x8ee>
8000d7ba:	3c 05       	j 8000d7c4 <_dtoa_r+0x8e8>
8000d7bc:	19 a4 20 00 	ld.w %d4,[%sp]32
8000d7c0:	40 d4       	mov.aa %a4,%a13
8000d7c2:	40 e5       	mov.aa %a5,%a14
8000d7c4:	6d 00 73 03 	call 8000deaa <__pow5mult>
8000d7c8:	40 2e       	mov.aa %a14,%a2
8000d7ca:	40 d4       	mov.aa %a4,%a13
8000d7cc:	82 14       	mov %d4,1
8000d7ce:	6d 00 d9 02 	call 8000dd80 <__i2b>
8000d7d2:	19 a3 34 00 	ld.w %d3,[%sp]52
8000d7d6:	40 2c       	mov.aa %a12,%a2
8000d7d8:	8e 3c       	jlez %d3,8000d7f0 <_dtoa_r+0x914>
8000d7da:	40 d4       	mov.aa %a4,%a13
8000d7dc:	40 25       	mov.aa %a5,%a2
8000d7de:	02 34       	mov %d4,%d3
8000d7e0:	6d 00 65 03 	call 8000deaa <__pow5mult>
8000d7e4:	58 07       	ld.w %d15,[%sp]28
8000d7e6:	40 2c       	mov.aa %a12,%a2
8000d7e8:	82 09       	mov %d9,0
8000d7ea:	ff 2f 1f 00 	jge %d15,2,8000d828 <_dtoa_r+0x94c>
8000d7ee:	3c 06       	j 8000d7fa <_dtoa_r+0x91e>
8000d7f0:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d7f4:	82 09       	mov %d9,0
8000d7f6:	ff 22 15 00 	jge %d2,2,8000d820 <_dtoa_r+0x944>
8000d7fa:	82 09       	mov %d9,0
8000d7fc:	df 0c 12 80 	jne %d12,0,8000d820 <_dtoa_r+0x944>
8000d800:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000d804:	ee 0e       	jnz %d15,8000d820 <_dtoa_r+0x944>
8000d806:	7b 00 ff f7 	movh %d15,32752
8000d80a:	26 df       	and %d15,%d13
8000d80c:	6e 0a       	jz %d15,8000d820 <_dtoa_r+0x944>
8000d80e:	19 a3 14 00 	ld.w %d3,[%sp]20
8000d812:	58 06       	ld.w %d15,[%sp]24
8000d814:	c2 13       	add %d3,1
8000d816:	c2 1f       	add %d15,1
8000d818:	59 a3 14 00 	st.w [%sp]20,%d3
8000d81c:	78 06       	st.w [%sp]24,%d15
8000d81e:	82 19       	mov %d9,1
8000d820:	19 a3 34 00 	ld.w %d3,[%sp]52
8000d824:	82 12       	mov %d2,1
8000d826:	76 39       	jz %d3,8000d838 <_dtoa_r+0x95c>
8000d828:	4c c4       	ld.w %d15,[%a12]16
8000d82a:	90 c3       	addsc.a %a3,%a12,%d15,2
8000d82c:	19 34 10 00 	ld.w %d4,[%a3]16
8000d830:	6d 00 54 02 	call 8000dcd8 <__hi0bits>
8000d834:	8b 02 02 21 	rsub %d2,%d2,32
8000d838:	58 06       	ld.w %d15,[%sp]24
8000d83a:	42 2f       	add %d15,%d2
8000d83c:	16 1f       	and %d15,31
8000d83e:	6e 0a       	jz %d15,8000d852 <_dtoa_r+0x976>
8000d840:	8b 0f 02 31 	rsub %d3,%d15,32
8000d844:	8b cf 01 f1 	rsub %d15,%d15,28
8000d848:	ff 53 07 00 	jge %d3,5,8000d856 <_dtoa_r+0x97a>
8000d84c:	df 43 10 00 	jeq %d3,4,8000d86c <_dtoa_r+0x990>
8000d850:	02 3f       	mov %d15,%d3
8000d852:	1b cf 01 f0 	addi %d15,%d15,28
8000d856:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d85a:	19 a3 18 00 	ld.w %d3,[%sp]24
8000d85e:	42 f2       	add %d2,%d15
8000d860:	42 f3       	add %d3,%d15
8000d862:	59 a2 14 00 	st.w [%sp]20,%d2
8000d866:	42 f8       	add %d8,%d15
8000d868:	59 a3 18 00 	st.w [%sp]24,%d3
8000d86c:	58 05       	ld.w %d15,[%sp]20
8000d86e:	8e f7       	jlez %d15,8000d87c <_dtoa_r+0x9a0>
8000d870:	40 e5       	mov.aa %a5,%a14
8000d872:	40 d4       	mov.aa %a4,%a13
8000d874:	02 f4       	mov %d4,%d15
8000d876:	6d 00 58 03 	call 8000df26 <__lshift>
8000d87a:	40 2e       	mov.aa %a14,%a2
8000d87c:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d880:	8e 27       	jlez %d2,8000d88e <_dtoa_r+0x9b2>
8000d882:	40 c5       	mov.aa %a5,%a12
8000d884:	40 d4       	mov.aa %a4,%a13
8000d886:	02 24       	mov %d4,%d2
8000d888:	6d 00 4f 03 	call 8000df26 <__lshift>
8000d88c:	40 2c       	mov.aa %a12,%a2
8000d88e:	19 a3 3c 00 	ld.w %d3,[%sp]60
8000d892:	df 03 20 00 	jeq %d3,0,8000d8d2 <_dtoa_r+0x9f6>
8000d896:	40 e4       	mov.aa %a4,%a14
8000d898:	40 c5       	mov.aa %a5,%a12
8000d89a:	6d 00 a3 03 	call 8000dfe0 <__mcmp>
8000d89e:	ff 02 1a 00 	jge %d2,0,8000d8d2 <_dtoa_r+0x9f6>
8000d8a2:	58 02       	ld.w %d15,[%sp]8
8000d8a4:	40 e5       	mov.aa %a5,%a14
8000d8a6:	c2 ff       	add %d15,-1
8000d8a8:	40 d4       	mov.aa %a4,%a13
8000d8aa:	fb a0 00 40 	mov %e4,10
8000d8ae:	78 02       	st.w [%sp]8,%d15
8000d8b0:	6d 00 d3 01 	call 8000dc56 <__multadd>
8000d8b4:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000d8b8:	19 a3 24 00 	ld.w %d3,[%sp]36
8000d8bc:	59 a2 10 00 	st.w [%sp]16,%d2
8000d8c0:	40 2e       	mov.aa %a14,%a2
8000d8c2:	76 38       	jz %d3,8000d8d2 <_dtoa_r+0x9f6>
8000d8c4:	40 f5       	mov.aa %a5,%a15
8000d8c6:	40 d4       	mov.aa %a4,%a13
8000d8c8:	fb a0 00 40 	mov %e4,10
8000d8cc:	6d 00 c5 01 	call 8000dc56 <__multadd>
8000d8d0:	40 2f       	mov.aa %a15,%a2
8000d8d2:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d8d6:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d8da:	8b 32 80 f2 	ge %d15,%d2,3
8000d8de:	8b 13 40 f4 	and.lt %d15,%d3,1
8000d8e2:	6e 2a       	jz %d15,8000d936 <_dtoa_r+0xa5a>
8000d8e4:	f6 3f       	jnz %d3,8000d902 <_dtoa_r+0xa26>
8000d8e6:	40 c5       	mov.aa %a5,%a12
8000d8e8:	40 d4       	mov.aa %a4,%a13
8000d8ea:	d2 54       	mov %e4,5
8000d8ec:	6d 00 b5 01 	call 8000dc56 <__multadd>
8000d8f0:	40 e4       	mov.aa %a4,%a14
8000d8f2:	40 25       	mov.aa %a5,%a2
8000d8f4:	40 2c       	mov.aa %a12,%a2
8000d8f6:	6d 00 75 03 	call 8000dfe0 <__mcmp>
8000d8fa:	4e 2e       	jgtz %d2,8000d916 <_dtoa_r+0xa3a>
8000d8fc:	3c 03       	j 8000d902 <_dtoa_r+0xa26>
8000d8fe:	a0 0c       	mov.a %a12,0
8000d900:	a0 0f       	mov.a %a15,0
8000d902:	58 0a       	ld.w %d15,[%sp]40
8000d904:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000d908:	46 0f       	not %d15
8000d90a:	78 02       	st.w [%sp]8,%d15
8000d90c:	3c 11       	j 8000d92e <_dtoa_r+0xa52>
8000d90e:	58 0c       	ld.w %d15,[%sp]48
8000d910:	a0 0c       	mov.a %a12,0
8000d912:	78 02       	st.w [%sp]8,%d15
8000d914:	a0 0f       	mov.a %a15,0
8000d916:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d91a:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d91e:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000d922:	da 31       	mov %d15,49
8000d924:	c2 12       	add %d2,1
8000d926:	c2 1e       	add %d14,1
8000d928:	2c 30       	st.b [%a3]0,%d15
8000d92a:	59 a2 08 00 	st.w [%sp]8,%d2
8000d92e:	80 f8       	mov.d %d8,%a15
8000d930:	a0 0f       	mov.a %a15,0
8000d932:	1d 00 14 01 	j 8000db5a <_dtoa_r+0xc7e>
8000d936:	19 a3 24 00 	ld.w %d3,[%sp]36
8000d93a:	f6 35       	jnz %d3,8000d944 <_dtoa_r+0xa68>
8000d93c:	19 a8 0c 00 	ld.w %d8,[%sp]12
8000d940:	1d 00 c2 00 	j 8000dac4 <_dtoa_r+0xbe8>
8000d944:	8e 87       	jlez %d8,8000d952 <_dtoa_r+0xa76>
8000d946:	40 f5       	mov.aa %a5,%a15
8000d948:	40 d4       	mov.aa %a4,%a13
8000d94a:	02 84       	mov %d4,%d8
8000d94c:	6d 00 ed 02 	call 8000df26 <__lshift>
8000d950:	40 2f       	mov.aa %a15,%a2
8000d952:	80 f8       	mov.d %d8,%a15
8000d954:	df 09 16 00 	jeq %d9,0,8000d980 <_dtoa_r+0xaa4>
8000d958:	40 d4       	mov.aa %a4,%a13
8000d95a:	48 14       	ld.w %d4,[%a15]4
8000d95c:	6d 00 49 01 	call 8000dbee <_Balloc>
8000d960:	48 44       	ld.w %d4,[%a15]16
8000d962:	d9 24 0c 00 	lea %a4,[%a2]12
8000d966:	c2 24       	add %d4,2
8000d968:	d9 f5 0c 00 	lea %a5,[%a15]12
8000d96c:	06 24       	sh %d4,2
8000d96e:	80 2f       	mov.d %d15,%a2
8000d970:	6d 00 31 01 	call 8000dbd2 <memcpy>
8000d974:	60 f5       	mov.a %a5,%d15
8000d976:	40 d4       	mov.aa %a4,%a13
8000d978:	82 14       	mov %d4,1
8000d97a:	6d 00 d6 02 	call 8000df26 <__lshift>
8000d97e:	80 28       	mov.d %d8,%a2
8000d980:	19 a9 0c 00 	ld.w %d9,[%sp]12
8000d984:	8f 1c 00 a1 	and %d10,%d12,1
8000d988:	40 e4       	mov.aa %a4,%a14
8000d98a:	40 c5       	mov.aa %a5,%a12
8000d98c:	6d ff 1a fa 	call 8000cdc0 <quorem>
8000d990:	40 e4       	mov.aa %a4,%a14
8000d992:	40 f5       	mov.aa %a5,%a15
8000d994:	02 2e       	mov %d14,%d2
8000d996:	1b 02 03 f0 	addi %d15,%d2,48
8000d99a:	6d 00 23 03 	call 8000dfe0 <__mcmp>
8000d99e:	60 86       	mov.a %a6,%d8
8000d9a0:	40 d4       	mov.aa %a4,%a13
8000d9a2:	40 c5       	mov.aa %a5,%a12
8000d9a4:	02 2b       	mov %d11,%d2
8000d9a6:	6d 00 3e 03 	call 8000e022 <__mdiff>
8000d9aa:	19 22 0c 00 	ld.w %d2,[%a2]12
8000d9ae:	80 2d       	mov.d %d13,%a2
8000d9b0:	82 1c       	mov %d12,1
8000d9b2:	f6 26       	jnz %d2,8000d9be <_dtoa_r+0xae2>
8000d9b4:	40 e4       	mov.aa %a4,%a14
8000d9b6:	40 25       	mov.aa %a5,%a2
8000d9b8:	6d 00 14 03 	call 8000dfe0 <__mcmp>
8000d9bc:	02 2c       	mov %d12,%d2
8000d9be:	60 d5       	mov.a %a5,%d13
8000d9c0:	40 d4       	mov.aa %a4,%a13
8000d9c2:	6d 00 41 01 	call 8000dc44 <_Bfree>
8000d9c6:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000d9ca:	1b 19 00 d0 	addi %d13,%d9,1
8000d9ce:	a6 c3       	or %d3,%d12
8000d9d0:	f6 3f       	jnz %d3,8000d9ee <_dtoa_r+0xb12>
8000d9d2:	f6 ae       	jnz %d10,8000d9ee <_dtoa_r+0xb12>
8000d9d4:	8b 9f 03 32 	eq %d3,%d15,57
8000d9d8:	40 e2       	mov.aa %a2,%a14
8000d9da:	df 03 3a 80 	jne %d3,0,8000da4e <_dtoa_r+0xb72>
8000d9de:	1b 1e 03 20 	addi %d2,%d14,49
8000d9e2:	8b 1b 80 b2 	ge %d11,%d11,1
8000d9e6:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
8000d9ea:	02 de       	mov %d14,%d13
8000d9ec:	3c 37       	j 8000da5a <_dtoa_r+0xb7e>
8000d9ee:	ce b5       	jgez %d11,8000d9f8 <_dtoa_r+0xb1c>
8000d9f0:	02 fa       	mov %d10,%d15
8000d9f2:	40 e2       	mov.aa %a2,%a14
8000d9f4:	4e ca       	jgtz %d12,8000da08 <_dtoa_r+0xb2c>
8000d9f6:	3c 1e       	j 8000da32 <_dtoa_r+0xb56>
8000d9f8:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d9fc:	a6 2b       	or %d11,%d2
8000d9fe:	df 0b 20 80 	jne %d11,0,8000da3e <_dtoa_r+0xb62>
8000da02:	df 0a 1e 80 	jne %d10,0,8000da3e <_dtoa_r+0xb62>
8000da06:	3c f5       	j 8000d9f0 <_dtoa_r+0xb14>
8000da08:	40 d4       	mov.aa %a4,%a13
8000da0a:	40 e5       	mov.aa %a5,%a14
8000da0c:	82 14       	mov %d4,1
8000da0e:	6d 00 8c 02 	call 8000df26 <__lshift>
8000da12:	40 c5       	mov.aa %a5,%a12
8000da14:	40 24       	mov.aa %a4,%a2
8000da16:	b5 a2 04 00 	st.a [%sp]4,%a2
8000da1a:	6d 00 e3 02 	call 8000dfe0 <__mcmp>
8000da1e:	99 a2 04 00 	ld.a %a2,[%sp]4
8000da22:	4e 23       	jgtz %d2,8000da28 <_dtoa_r+0xb4c>
8000da24:	f6 27       	jnz %d2,8000da32 <_dtoa_r+0xb56>
8000da26:	2e 06       	jz.t %d15,0,8000da32 <_dtoa_r+0xb56>
8000da28:	8b 9f 03 32 	eq %d3,%d15,57
8000da2c:	df 03 11 80 	jne %d3,0,8000da4e <_dtoa_r+0xb72>
8000da30:	92 1a       	add %d10,%d15,1
8000da32:	60 93       	mov.a %a3,%d9
8000da34:	02 de       	mov %d14,%d13
8000da36:	34 3a       	st.b [%a3],%d10
8000da38:	40 2e       	mov.aa %a14,%a2
8000da3a:	1d 00 90 00 	j 8000db5a <_dtoa_r+0xc7e>
8000da3e:	bf 1c 11 00 	jlt %d12,1,8000da60 <_dtoa_r+0xb84>
8000da42:	8b 9f 23 32 	ne %d3,%d15,57
8000da46:	40 e2       	mov.aa %a2,%a14
8000da48:	02 de       	mov %d14,%d13
8000da4a:	c2 1f       	add %d15,1
8000da4c:	f6 37       	jnz %d3,8000da5a <_dtoa_r+0xb7e>
8000da4e:	60 93       	mov.a %a3,%d9
8000da50:	da 39       	mov %d15,57
8000da52:	02 de       	mov %d14,%d13
8000da54:	2c 30       	st.b [%a3]0,%d15
8000da56:	40 2e       	mov.aa %a14,%a2
8000da58:	3c 5d       	j 8000db12 <_dtoa_r+0xc36>
8000da5a:	60 92       	mov.a %a2,%d9
8000da5c:	2c 20       	st.b [%a2]0,%d15
8000da5e:	3c 7e       	j 8000db5a <_dtoa_r+0xc7e>
8000da60:	60 93       	mov.a %a3,%d9
8000da62:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000da66:	02 d5       	mov %d5,%d13
8000da68:	19 a3 10 00 	ld.w %d3,[%sp]16
8000da6c:	2c 30       	st.b [%a3]0,%d15
8000da6e:	a2 25       	sub %d5,%d2
8000da70:	02 de       	mov %d14,%d13
8000da72:	5f 35 41 00 	jeq %d5,%d3,8000daf4 <_dtoa_r+0xc18>
8000da76:	40 e5       	mov.aa %a5,%a14
8000da78:	40 d4       	mov.aa %a4,%a13
8000da7a:	fb a0 00 40 	mov %e4,10
8000da7e:	6d 00 ec 00 	call 8000dc56 <__multadd>
8000da82:	80 ff       	mov.d %d15,%a15
8000da84:	40 2e       	mov.aa %a14,%a2
8000da86:	40 d4       	mov.aa %a4,%a13
8000da88:	40 f5       	mov.aa %a5,%a15
8000da8a:	fb a0 00 40 	mov %e4,10
8000da8e:	7e 86       	jne %d15,%d8,8000da9a <_dtoa_r+0xbbe>
8000da90:	6d 00 e3 00 	call 8000dc56 <__multadd>
8000da94:	40 2f       	mov.aa %a15,%a2
8000da96:	80 28       	mov.d %d8,%a2
8000da98:	3c 0b       	j 8000daae <_dtoa_r+0xbd2>
8000da9a:	6d 00 de 00 	call 8000dc56 <__multadd>
8000da9e:	60 85       	mov.a %a5,%d8
8000daa0:	40 d4       	mov.aa %a4,%a13
8000daa2:	fb a0 00 40 	mov %e4,10
8000daa6:	40 2f       	mov.aa %a15,%a2
8000daa8:	6d 00 d7 00 	call 8000dc56 <__multadd>
8000daac:	80 28       	mov.d %d8,%a2
8000daae:	02 d9       	mov %d9,%d13
8000dab0:	1d ff 6c ff 	j 8000d988 <_dtoa_r+0xaac>
8000dab4:	40 e5       	mov.aa %a5,%a14
8000dab6:	40 d4       	mov.aa %a4,%a13
8000dab8:	fb a0 00 40 	mov %e4,10
8000dabc:	6d 00 cd 00 	call 8000dc56 <__multadd>
8000dac0:	02 98       	mov %d8,%d9
8000dac2:	40 2e       	mov.aa %a14,%a2
8000dac4:	40 e4       	mov.aa %a4,%a14
8000dac6:	40 c5       	mov.aa %a5,%a12
8000dac8:	6d ff 7c f9 	call 8000cdc0 <quorem>
8000dacc:	1b 18 00 90 	addi %d9,%d8,1
8000dad0:	1b 02 03 f0 	addi %d15,%d2,48
8000dad4:	60 82       	mov.a %a2,%d8
8000dad6:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000dada:	02 95       	mov %d5,%d9
8000dadc:	19 a3 10 00 	ld.w %d3,[%sp]16
8000dae0:	2c 20       	st.b [%a2]0,%d15
8000dae2:	a2 25       	sub %d5,%d2
8000dae4:	3f 35 e8 7f 	jlt %d5,%d3,8000dab4 <_dtoa_r+0xbd8>
8000dae8:	8b 13 40 33 	max %d3,%d3,1
8000daec:	02 2e       	mov %d14,%d2
8000daee:	80 f8       	mov.d %d8,%a15
8000daf0:	42 3e       	add %d14,%d3
8000daf2:	a0 0f       	mov.a %a15,0
8000daf4:	40 e5       	mov.aa %a5,%a14
8000daf6:	40 d4       	mov.aa %a4,%a13
8000daf8:	82 14       	mov %d4,1
8000dafa:	6d 00 16 02 	call 8000df26 <__lshift>
8000dafe:	40 c5       	mov.aa %a5,%a12
8000db00:	40 2e       	mov.aa %a14,%a2
8000db02:	40 24       	mov.aa %a4,%a2
8000db04:	6d 00 6e 02 	call 8000dfe0 <__mcmp>
8000db08:	4e 25       	jgtz %d2,8000db12 <_dtoa_r+0xc36>
8000db0a:	df 02 1e 80 	jne %d2,0,8000db46 <_dtoa_r+0xc6a>
8000db0e:	6f 0f 1c 00 	jz.t %d15,0,8000db46 <_dtoa_r+0xc6a>
8000db12:	58 03       	ld.w %d15,[%sp]12
8000db14:	a2 ef       	sub %d15,%d14
8000db16:	46 0f       	not %d15
8000db18:	60 e2       	mov.a %a2,%d14
8000db1a:	60 e3       	mov.a %a3,%d14
8000db1c:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000db20:	b0 f3       	add.a %a3,-1
8000db22:	8b 93 03 52 	eq %d5,%d3,57
8000db26:	76 5d       	jz %d5,8000db40 <_dtoa_r+0xc64>
8000db28:	9f 0f 0a 80 	jned %d15,0,8000db3c <_dtoa_r+0xc60>
8000db2c:	58 02       	ld.w %d15,[%sp]8
8000db2e:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000db32:	c2 1f       	add %d15,1
8000db34:	78 02       	st.w [%sp]8,%d15
8000db36:	da 31       	mov %d15,49
8000db38:	2c 30       	st.b [%a3]0,%d15
8000db3a:	3c 10       	j 8000db5a <_dtoa_r+0xc7e>
8000db3c:	80 3e       	mov.d %d14,%a3
8000db3e:	3c ed       	j 8000db18 <_dtoa_r+0xc3c>
8000db40:	c2 13       	add %d3,1
8000db42:	34 33       	st.b [%a3],%d3
8000db44:	3c 0b       	j 8000db5a <_dtoa_r+0xc7e>
8000db46:	60 e2       	mov.a %a2,%d14
8000db48:	60 e3       	mov.a %a3,%d14
8000db4a:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000db4e:	b0 f3       	add.a %a3,-1
8000db50:	8b 0f 03 f2 	eq %d15,%d15,48
8000db54:	6e 03       	jz %d15,8000db5a <_dtoa_r+0xc7e>
8000db56:	80 3e       	mov.d %d14,%a3
8000db58:	3c f7       	j 8000db46 <_dtoa_r+0xc6a>
8000db5a:	40 d4       	mov.aa %a4,%a13
8000db5c:	40 c5       	mov.aa %a5,%a12
8000db5e:	6d 00 73 00 	call 8000dc44 <_Bfree>
8000db62:	df 08 13 00 	jeq %d8,0,8000db88 <_dtoa_r+0xcac>
8000db66:	80 f2       	mov.d %d2,%a15
8000db68:	8b 02 20 f2 	ne %d15,%d2,0
8000db6c:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8000db70:	6e 05       	jz %d15,8000db7a <_dtoa_r+0xc9e>
8000db72:	40 d4       	mov.aa %a4,%a13
8000db74:	40 f5       	mov.aa %a5,%a15
8000db76:	6d 00 67 00 	call 8000dc44 <_Bfree>
8000db7a:	60 85       	mov.a %a5,%d8
8000db7c:	40 d4       	mov.aa %a4,%a13
8000db7e:	6d 00 63 00 	call 8000dc44 <_Bfree>
8000db82:	3c 03       	j 8000db88 <_dtoa_r+0xcac>
8000db84:	58 0c       	ld.w %d15,[%sp]48
8000db86:	78 02       	st.w [%sp]8,%d15
8000db88:	40 d4       	mov.aa %a4,%a13
8000db8a:	40 e5       	mov.aa %a5,%a14
8000db8c:	6d 00 5c 00 	call 8000dc44 <_Bfree>
8000db90:	60 e2       	mov.a %a2,%d14
8000db92:	19 a2 08 00 	ld.w %d2,[%sp]8
8000db96:	99 a3 08 10 	ld.a %a3,[%sp]72
8000db9a:	82 0f       	mov %d15,0
8000db9c:	d8 0e       	ld.a %a15,[%sp]56
8000db9e:	2c 20       	st.b [%a2]0,%d15
8000dba0:	c2 12       	add %d2,1
8000dba2:	74 32       	st.w [%a3],%d2
8000dba4:	99 a2 0c 00 	ld.a %a2,[%sp]12
8000dba8:	bc f2       	jz.a %a15,8000dbac <_dtoa_r+0xcd0>
8000dbaa:	68 0e       	st.w [%a15]0,%d14
8000dbac:	00 90       	ret 
	...

8000dbb0 <_localeconv_r>:
8000dbb0:	91 00 00 28 	movh.a %a2,32768
8000dbb4:	d9 22 1c 01 	lea %a2,[%a2]4124 <8000101c <lconv>>
8000dbb8:	00 90       	ret 

8000dbba <memchr>:
8000dbba:	8f f4 0f 41 	and %d4,%d4,255
8000dbbe:	9f 05 04 80 	jned %d5,0,8000dbc6 <memchr+0xc>
8000dbc2:	a0 02       	mov.a %a2,0
8000dbc4:	00 90       	ret 
8000dbc6:	0c 40       	ld.bu %d15,[%a4]0
8000dbc8:	3e 43       	jeq %d15,%d4,8000dbce <memchr+0x14>
8000dbca:	b0 14       	add.a %a4,1
8000dbcc:	3c f9       	j 8000dbbe <memchr+0x4>
8000dbce:	40 42       	mov.aa %a2,%a4
8000dbd0:	00 90       	ret 

8000dbd2 <memcpy>:
8000dbd2:	40 42       	mov.aa %a2,%a4
8000dbd4:	a0 0f       	mov.a %a15,0
8000dbd6:	01 f2 10 40 	add.a %a4,%a2,%a15
8000dbda:	01 f5 10 30 	add.a %a3,%a5,%a15
8000dbde:	9f 04 03 80 	jned %d4,0,8000dbe4 <memcpy+0x12>
8000dbe2:	00 90       	ret 
8000dbe4:	79 3f 00 00 	ld.b %d15,[%a3]0
8000dbe8:	b0 1f       	add.a %a15,1
8000dbea:	2c 40       	st.b [%a4]0,%d15
8000dbec:	3c f5       	j 8000dbd6 <memcpy+0x4>

8000dbee <_Balloc>:
8000dbee:	19 42 0c 10 	ld.w %d2,[%a4]76
8000dbf2:	40 4f       	mov.aa %a15,%a4
8000dbf4:	02 4f       	mov %d15,%d4
8000dbf6:	76 29       	jz %d2,8000dc08 <_Balloc+0x1a>
8000dbf8:	99 f3 0c 10 	ld.a %a3,[%a15]76
8000dbfc:	90 33       	addsc.a %a3,%a3,%d15,2
8000dbfe:	d4 32       	ld.a %a2,[%a3]
8000dc00:	bc 2f       	jz.a %a2,8000dc1e <_Balloc+0x30>
8000dc02:	4c 20       	ld.w %d15,[%a2]0
8000dc04:	6c 30       	st.w [%a3]0,%d15
8000dc06:	3c 1b       	j 8000dc3c <_Balloc+0x4e>
8000dc08:	82 44       	mov %d4,4
8000dc0a:	3b 10 02 50 	mov %d5,33
8000dc0e:	6d 00 5c 03 	call 8000e2c6 <_calloc_r>
8000dc12:	b5 f2 0c 10 	st.a [%a15]76,%a2
8000dc16:	bd 02 f1 ff 	jnz.a %a2,8000dbf8 <_Balloc+0xa>
8000dc1a:	a0 02       	mov.a %a2,0
8000dc1c:	00 90       	ret 
8000dc1e:	82 18       	mov %d8,1
8000dc20:	0f f8 00 80 	sh %d8,%d8,%d15
8000dc24:	1b 58 00 50 	addi %d5,%d8,5
8000dc28:	40 f4       	mov.aa %a4,%a15
8000dc2a:	82 14       	mov %d4,1
8000dc2c:	06 25       	sh %d5,2
8000dc2e:	6d 00 4c 03 	call 8000e2c6 <_calloc_r>
8000dc32:	bd 02 f4 7f 	jz.a %a2,8000dc1a <_Balloc+0x2c>
8000dc36:	6c 21       	st.w [%a2]4,%d15
8000dc38:	59 28 08 00 	st.w [%a2]8,%d8
8000dc3c:	82 0f       	mov %d15,0
8000dc3e:	6c 24       	st.w [%a2]16,%d15
8000dc40:	6c 23       	st.w [%a2]12,%d15
8000dc42:	00 90       	ret 

8000dc44 <_Bfree>:
8000dc44:	bc 58       	jz.a %a5,8000dc54 <_Bfree+0x10>
8000dc46:	99 4f 0c 10 	ld.a %a15,[%a4]76
8000dc4a:	4c 51       	ld.w %d15,[%a5]4
8000dc4c:	90 ff       	addsc.a %a15,%a15,%d15,2
8000dc4e:	4c f0       	ld.w %d15,[%a15]0
8000dc50:	6c 50       	st.w [%a5]0,%d15
8000dc52:	e8 05       	st.a [%a15]0,%a5
8000dc54:	00 90       	ret 

8000dc56 <__multadd>:
8000dc56:	19 59 10 00 	ld.w %d9,[%a5]16
8000dc5a:	40 4c       	mov.aa %a12,%a4
8000dc5c:	9a f9       	add %d15,%d9,-1
8000dc5e:	8b 19 80 22 	ge %d2,%d9,1
8000dc62:	40 5f       	mov.aa %a15,%a5
8000dc64:	02 58       	mov %d8,%d5
8000dc66:	d9 53 14 00 	lea %a3,[%a5]20
8000dc6a:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000dc6e:	40 32       	mov.aa %a2,%a3
8000dc70:	44 25       	ld.w %d5,[%a2+]
8000dc72:	b7 05 10 38 	insert %d3,%d5,0,16,16
8000dc76:	8f 05 1f f0 	sh %d15,%d5,-16
8000dc7a:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
8000dc7e:	8f 03 1f 60 	sh %d6,%d3,-16
8000dc82:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
8000dc86:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000dc8a:	8f 0f 1f 80 	sh %d8,%d15,-16
8000dc8e:	74 33       	st.w [%a3],%d3
8000dc90:	40 23       	mov.aa %a3,%a2
8000dc92:	9f 02 ee ff 	jned %d2,0,8000dc6e <__multadd+0x18>
8000dc96:	df 08 1f 00 	jeq %d8,0,8000dcd4 <__multadd+0x7e>
8000dc9a:	4c f2       	ld.w %d15,[%a15]8
8000dc9c:	3f f9 16 00 	jlt %d9,%d15,8000dcc8 <__multadd+0x72>
8000dca0:	48 14       	ld.w %d4,[%a15]4
8000dca2:	40 c4       	mov.aa %a4,%a12
8000dca4:	c2 14       	add %d4,1
8000dca6:	6d ff a4 ff 	call 8000dbee <_Balloc>
8000dcaa:	48 44       	ld.w %d4,[%a15]16
8000dcac:	d9 f5 0c 00 	lea %a5,[%a15]12
8000dcb0:	c2 24       	add %d4,2
8000dcb2:	d9 24 0c 00 	lea %a4,[%a2]12
8000dcb6:	06 24       	sh %d4,2
8000dcb8:	40 2d       	mov.aa %a13,%a2
8000dcba:	6d ff 8c ff 	call 8000dbd2 <memcpy>
8000dcbe:	40 f5       	mov.aa %a5,%a15
8000dcc0:	40 c4       	mov.aa %a4,%a12
8000dcc2:	6d ff c1 ff 	call 8000dc44 <_Bfree>
8000dcc6:	40 df       	mov.aa %a15,%a13
8000dcc8:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
8000dccc:	c2 19       	add %d9,1
8000dcce:	59 28 14 00 	st.w [%a2]20,%d8
8000dcd2:	68 49       	st.w [%a15]16,%d9
8000dcd4:	40 f2       	mov.aa %a2,%a15
8000dcd6:	00 90       	ret 

8000dcd8 <__hi0bits>:
8000dcd8:	b7 04 10 f0 	insert %d15,%d4,0,0,16
8000dcdc:	82 02       	mov %d2,0
8000dcde:	ee 05       	jnz %d15,8000dce8 <__hi0bits+0x10>
8000dce0:	8f 04 01 40 	sh %d4,%d4,16
8000dce4:	3b 00 01 20 	mov %d2,16
8000dce8:	b7 04 18 f0 	insert %d15,%d4,0,0,24
8000dcec:	ee 05       	jnz %d15,8000dcf6 <__hi0bits+0x1e>
8000dcee:	1b 82 00 20 	addi %d2,%d2,8
8000dcf2:	8f 84 00 40 	sh %d4,%d4,8
8000dcf6:	b7 04 1c f0 	insert %d15,%d4,0,0,28
8000dcfa:	ee 03       	jnz %d15,8000dd00 <__hi0bits+0x28>
8000dcfc:	c2 42       	add %d2,4
8000dcfe:	06 44       	sh %d4,4
8000dd00:	b7 04 1e f0 	insert %d15,%d4,0,0,30
8000dd04:	ee 03       	jnz %d15,8000dd0a <__hi0bits+0x32>
8000dd06:	c2 22       	add %d2,2
8000dd08:	06 24       	sh %d4,2
8000dd0a:	0e 47       	jltz %d4,8000dd18 <__hi0bits+0x40>
8000dd0c:	7b 00 00 f4 	movh %d15,16384
8000dd10:	26 f4       	and %d4,%d15
8000dd12:	c2 12       	add %d2,1
8000dd14:	ab 02 82 24 	sel %d2,%d4,%d2,32
8000dd18:	00 90       	ret 

8000dd1a <__lo0bits>:
8000dd1a:	54 43       	ld.w %d3,[%a4]
8000dd1c:	8f 73 00 f1 	and %d15,%d3,7
8000dd20:	6e 0e       	jz %d15,8000dd3c <__lo0bits+0x22>
8000dd22:	82 02       	mov %d2,0
8000dd24:	6f 03 2d 80 	jnz.t %d3,0,8000dd7e <__lo0bits+0x64>
8000dd28:	6f 13 06 00 	jz.t %d3,1,8000dd34 <__lo0bits+0x1a>
8000dd2c:	06 f3       	sh %d3,-1
8000dd2e:	74 43       	st.w [%a4],%d3
8000dd30:	82 12       	mov %d2,1
8000dd32:	00 90       	ret 
8000dd34:	06 e3       	sh %d3,-2
8000dd36:	74 43       	st.w [%a4],%d3
8000dd38:	82 22       	mov %d2,2
8000dd3a:	00 90       	ret 
8000dd3c:	b7 03 10 f8 	insert %d15,%d3,0,16,16
8000dd40:	82 04       	mov %d4,0
8000dd42:	ee 05       	jnz %d15,8000dd4c <__lo0bits+0x32>
8000dd44:	8f 03 1f 30 	sh %d3,%d3,-16
8000dd48:	3b 00 01 40 	mov %d4,16
8000dd4c:	02 3f       	mov %d15,%d3
8000dd4e:	16 ff       	and %d15,255
8000dd50:	ee 04       	jnz %d15,8000dd58 <__lo0bits+0x3e>
8000dd52:	1b 84 00 40 	addi %d4,%d4,8
8000dd56:	06 83       	sh %d3,-8
8000dd58:	8f f3 00 f1 	and %d15,%d3,15
8000dd5c:	ee 03       	jnz %d15,8000dd62 <__lo0bits+0x48>
8000dd5e:	c2 44       	add %d4,4
8000dd60:	06 c3       	sh %d3,-4
8000dd62:	8f 33 00 f1 	and %d15,%d3,3
8000dd66:	ee 03       	jnz %d15,8000dd6c <__lo0bits+0x52>
8000dd68:	c2 24       	add %d4,2
8000dd6a:	06 e3       	sh %d3,-2
8000dd6c:	6f 03 07 80 	jnz.t %d3,0,8000dd7a <__lo0bits+0x60>
8000dd70:	06 f3       	sh %d3,-1
8000dd72:	3b 00 02 20 	mov %d2,32
8000dd76:	76 34       	jz %d3,8000dd7e <__lo0bits+0x64>
8000dd78:	c2 14       	add %d4,1
8000dd7a:	74 43       	st.w [%a4],%d3
8000dd7c:	02 42       	mov %d2,%d4
8000dd7e:	00 90       	ret 

8000dd80 <__i2b>:
8000dd80:	02 4f       	mov %d15,%d4
8000dd82:	82 14       	mov %d4,1
8000dd84:	6d ff 35 ff 	call 8000dbee <_Balloc>
8000dd88:	6c 25       	st.w [%a2]20,%d15
8000dd8a:	82 1f       	mov %d15,1
8000dd8c:	6c 24       	st.w [%a2]16,%d15
8000dd8e:	00 90       	ret 

8000dd90 <__multiply>:
8000dd90:	19 52 10 00 	ld.w %d2,[%a5]16
8000dd94:	4c 64       	ld.w %d15,[%a6]16
8000dd96:	40 5f       	mov.aa %a15,%a5
8000dd98:	40 6c       	mov.aa %a12,%a6
8000dd9a:	7f f2 04 00 	jge %d2,%d15,8000dda2 <__multiply+0x12>
8000dd9e:	40 6f       	mov.aa %a15,%a6
8000dda0:	40 5c       	mov.aa %a12,%a5
8000dda2:	48 4a       	ld.w %d10,[%a15]16
8000dda4:	19 c9 10 00 	ld.w %d9,[%a12]16
8000dda8:	4c f2       	ld.w %d15,[%a15]8
8000ddaa:	0b 9a 00 80 	add %d8,%d10,%d9
8000ddae:	48 12       	ld.w %d2,[%a15]4
8000ddb0:	0b 8f 20 41 	lt %d4,%d15,%d8
8000ddb4:	42 24       	add %d4,%d2
8000ddb6:	6d ff 1c ff 	call 8000dbee <_Balloc>
8000ddba:	d9 23 14 00 	lea %a3,[%a2]20
8000ddbe:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
8000ddc2:	40 34       	mov.aa %a4,%a3
8000ddc4:	82 0f       	mov %d15,0
8000ddc6:	80 43       	mov.d %d3,%a4
8000ddc8:	80 d2       	mov.d %d2,%a13
8000ddca:	7f 23 04 80 	jge.u %d3,%d2,8000ddd2 <__multiply+0x42>
8000ddce:	64 4f       	st.w [%a4+],%d15
8000ddd0:	3c fb       	j 8000ddc6 <__multiply+0x36>
8000ddd2:	d9 ff 14 00 	lea %a15,[%a15]20
8000ddd6:	d9 cc 14 00 	lea %a12,[%a12]20
8000ddda:	80 f3       	mov.d %d3,%a15
8000dddc:	80 cf       	mov.d %d15,%a12
8000ddde:	13 4a 20 43 	madd %d4,%d3,%d10,4
8000dde2:	13 49 20 0f 	madd %d0,%d15,%d9,4
8000dde6:	80 c2       	mov.d %d2,%a12
8000dde8:	7f 02 54 80 	jge.u %d2,%d0,8000de90 <__multiply+0x100>
8000ddec:	b9 c2 00 00 	ld.hu %d2,[%a12]0
8000ddf0:	40 34       	mov.aa %a4,%a3
8000ddf2:	40 f6       	mov.aa %a6,%a15
8000ddf4:	82 03       	mov %d3,0
8000ddf6:	df 02 21 00 	jeq %d2,0,8000de38 <__multiply+0xa8>
8000ddfa:	40 45       	mov.aa %a5,%a4
8000ddfc:	44 67       	ld.w %d7,[%a6+]
8000ddfe:	44 56       	ld.w %d6,[%a5+]
8000de00:	b7 07 10 18 	insert %d1,%d7,0,16,16
8000de04:	b7 06 10 58 	insert %d5,%d6,0,16,16
8000de08:	8f 07 1f 70 	sh %d7,%d7,-16
8000de0c:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
8000de10:	8f 06 1f 60 	sh %d6,%d6,-16
8000de14:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
8000de18:	42 35       	add %d5,%d3
8000de1a:	8f 05 1f 30 	sh %d3,%d5,-16
8000de1e:	1a 36       	add %d15,%d6,%d3
8000de20:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
8000de24:	8f 0f 1f 30 	sh %d3,%d15,-16
8000de28:	80 6f       	mov.d %d15,%a6
8000de2a:	74 45       	st.w [%a4],%d5
8000de2c:	7f 4f 04 80 	jge.u %d15,%d4,8000de34 <__multiply+0xa4>
8000de30:	40 54       	mov.aa %a4,%a5
8000de32:	3c e4       	j 8000ddfa <__multiply+0x6a>
8000de34:	59 43 04 00 	st.w [%a4]4,%d3
8000de38:	b9 c2 02 00 	ld.hu %d2,[%a12]2
8000de3c:	df 02 27 00 	jeq %d2,0,8000de8a <__multiply+0xfa>
8000de40:	54 33       	ld.w %d3,[%a3]
8000de42:	40 34       	mov.aa %a4,%a3
8000de44:	40 f5       	mov.aa %a5,%a15
8000de46:	82 07       	mov %d7,0
8000de48:	40 56       	mov.aa %a6,%a5
8000de4a:	44 66       	ld.w %d6,[%a6+]
8000de4c:	40 47       	mov.aa %a7,%a4
8000de4e:	44 75       	ld.w %d5,[%a7+]
8000de50:	b7 06 10 68 	insert %d6,%d6,0,16,16
8000de54:	8f 05 1f 50 	sh %d5,%d5,-16
8000de58:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
8000de5c:	42 7f       	add %d15,%d7
8000de5e:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000de62:	8f 0f 1f f0 	sh %d15,%d15,-16
8000de66:	74 43       	st.w [%a4],%d3
8000de68:	b9 55 02 00 	ld.hu %d5,[%a5]2
8000de6c:	b9 43 04 00 	ld.hu %d3,[%a4]4
8000de70:	40 65       	mov.aa %a5,%a6
8000de72:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
8000de76:	42 f3       	add %d3,%d15
8000de78:	80 6f       	mov.d %d15,%a6
8000de7a:	8f 03 1f 70 	sh %d7,%d3,-16
8000de7e:	7f 4f 04 80 	jge.u %d15,%d4,8000de86 <__multiply+0xf6>
8000de82:	40 74       	mov.aa %a4,%a7
8000de84:	3c e2       	j 8000de48 <__multiply+0xb8>
8000de86:	59 43 04 00 	st.w [%a4]4,%d3
8000de8a:	b0 4c       	add.a %a12,4
8000de8c:	b0 43       	add.a %a3,4
8000de8e:	3c ac       	j 8000dde6 <__multiply+0x56>
8000de90:	8b 08 40 f3 	max %d15,%d8,0
8000de94:	9f 0f 05 80 	jned %d15,0,8000de9e <__multiply+0x10e>
8000de98:	59 28 10 00 	st.w [%a2]16,%d8
8000de9c:	00 90       	ret 
8000de9e:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
8000dea2:	df 02 fb ff 	jne %d2,0,8000de98 <__multiply+0x108>
8000dea6:	c2 f8       	add %d8,-1
8000dea8:	3c f6       	j 8000de94 <__multiply+0x104>

8000deaa <__pow5mult>:
8000deaa:	8f 34 00 21 	and %d2,%d4,3
8000deae:	40 4c       	mov.aa %a12,%a4
8000deb0:	40 5d       	mov.aa %a13,%a5
8000deb2:	02 4f       	mov %d15,%d4
8000deb4:	76 2d       	jz %d2,8000dece <__pow5mult+0x24>
8000deb6:	91 00 00 f8 	movh.a %a15,32768
8000deba:	d9 ff 14 11 	lea %a15,[%a15]4180 <80001054 <p05.2553>>
8000debe:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
8000dec2:	82 05       	mov %d5,0
8000dec4:	19 f4 fc ff 	ld.w %d4,[%a15]-4
8000dec8:	6d ff c7 fe 	call 8000dc56 <__multadd>
8000decc:	40 2d       	mov.aa %a13,%a2
8000dece:	86 ef       	sha %d15,-2
8000ded0:	6e 29       	jz %d15,8000df22 <__pow5mult+0x78>
8000ded2:	99 cf 08 10 	ld.a %a15,[%a12]72
8000ded6:	7c fb       	jnz.a %a15,8000deec <__pow5mult+0x42>
8000ded8:	40 c4       	mov.aa %a4,%a12
8000deda:	3b 10 27 40 	mov %d4,625
8000dede:	6d ff 51 ff 	call 8000dd80 <__i2b>
8000dee2:	82 02       	mov %d2,0
8000dee4:	b5 c2 08 10 	st.a [%a12]72,%a2
8000dee8:	40 2f       	mov.aa %a15,%a2
8000deea:	74 22       	st.w [%a2],%d2
8000deec:	82 08       	mov %d8,0
8000deee:	2e 0c       	jz.t %d15,0,8000df06 <__pow5mult+0x5c>
8000def0:	40 d5       	mov.aa %a5,%a13
8000def2:	40 c4       	mov.aa %a4,%a12
8000def4:	40 f6       	mov.aa %a6,%a15
8000def6:	6d ff 4d ff 	call 8000dd90 <__multiply>
8000defa:	40 d5       	mov.aa %a5,%a13
8000defc:	40 2e       	mov.aa %a14,%a2
8000defe:	40 c4       	mov.aa %a4,%a12
8000df00:	6d ff a2 fe 	call 8000dc44 <_Bfree>
8000df04:	40 ed       	mov.aa %a13,%a14
8000df06:	86 ff       	sha %d15,-1
8000df08:	6e 0d       	jz %d15,8000df22 <__pow5mult+0x78>
8000df0a:	c8 02       	ld.a %a2,[%a15]0
8000df0c:	bc 23       	jz.a %a2,8000df12 <__pow5mult+0x68>
8000df0e:	40 2f       	mov.aa %a15,%a2
8000df10:	3c ef       	j 8000deee <__pow5mult+0x44>
8000df12:	40 c4       	mov.aa %a4,%a12
8000df14:	40 f5       	mov.aa %a5,%a15
8000df16:	40 f6       	mov.aa %a6,%a15
8000df18:	6d ff 3c ff 	call 8000dd90 <__multiply>
8000df1c:	e8 02       	st.a [%a15]0,%a2
8000df1e:	74 28       	st.w [%a2],%d8
8000df20:	3c f7       	j 8000df0e <__pow5mult+0x64>
8000df22:	40 d2       	mov.aa %a2,%a13
8000df24:	00 90       	ret 

8000df26 <__lshift>:
8000df26:	19 5b 10 00 	ld.w %d11,[%a5]16
8000df2a:	8f b4 3f 80 	sha %d8,%d4,-5
8000df2e:	02 4a       	mov %d10,%d4
8000df30:	42 8b       	add %d11,%d8
8000df32:	19 54 04 00 	ld.w %d4,[%a5]4
8000df36:	4c 52       	ld.w %d15,[%a5]8
8000df38:	40 4e       	mov.aa %a14,%a4
8000df3a:	40 5c       	mov.aa %a12,%a5
8000df3c:	1b 1b 00 90 	addi %d9,%d11,1
8000df40:	7f 9f 05 00 	jge %d15,%d9,8000df4a <__lshift+0x24>
8000df44:	c2 14       	add %d4,1
8000df46:	06 1f       	sh %d15,1
8000df48:	3c fc       	j 8000df40 <__lshift+0x1a>
8000df4a:	40 e4       	mov.aa %a4,%a14
8000df4c:	6d ff 51 fe 	call 8000dbee <_Balloc>
8000df50:	8b 08 40 f3 	max %d15,%d8,0
8000df54:	40 2d       	mov.aa %a13,%a2
8000df56:	d9 2f 14 00 	lea %a15,[%a2]20
8000df5a:	d2 02       	mov %e2,0
8000df5c:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
8000df60:	9f 0f 03 80 	jned %d15,0,8000df66 <__lshift+0x40>
8000df64:	3c 04       	j 8000df6c <__lshift+0x46>
8000df66:	74 23       	st.w [%a2],%d3
8000df68:	c2 12       	add %d2,1
8000df6a:	3c f9       	j 8000df5c <__lshift+0x36>
8000df6c:	8b 08 40 83 	max %d8,%d8,0
8000df70:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
8000df74:	d9 cf 14 00 	lea %a15,[%a12]20
8000df78:	19 c2 10 00 	ld.w %d2,[%a12]16
8000df7c:	80 f3       	mov.d %d3,%a15
8000df7e:	8f fa 01 41 	and %d4,%d10,31
8000df82:	13 42 20 23 	madd %d2,%d3,%d2,4
8000df86:	8b 04 02 51 	rsub %d5,%d4,32
8000df8a:	82 0f       	mov %d15,0
8000df8c:	df 04 1a 00 	jeq %d4,0,8000dfc0 <__lshift+0x9a>
8000df90:	40 f5       	mov.aa %a5,%a15
8000df92:	44 53       	ld.w %d3,[%a5+]
8000df94:	d9 32 04 00 	lea %a2,[%a3]4
8000df98:	0f 43 00 30 	sh %d3,%d3,%d4
8000df9c:	a6 3f       	or %d15,%d3
8000df9e:	6c 30       	st.w [%a3]0,%d15
8000dfa0:	4c f0       	ld.w %d15,[%a15]0
8000dfa2:	8b 05 00 31 	rsub %d3,%d5,0
8000dfa6:	0f 3f 00 30 	sh %d3,%d15,%d3
8000dfaa:	02 3f       	mov %d15,%d3
8000dfac:	80 53       	mov.d %d3,%a5
8000dfae:	40 5f       	mov.aa %a15,%a5
8000dfb0:	7f 23 04 80 	jge.u %d3,%d2,8000dfb8 <__lshift+0x92>
8000dfb4:	40 23       	mov.aa %a3,%a2
8000dfb6:	3c ed       	j 8000df90 <__lshift+0x6a>
8000dfb8:	c2 2b       	add %d11,2
8000dfba:	6c 31       	st.w [%a3]4,%d15
8000dfbc:	2a b9       	cmov %d9,%d15,%d11
8000dfbe:	3c 08       	j 8000dfce <__lshift+0xa8>
8000dfc0:	4c f0       	ld.w %d15,[%a15]0
8000dfc2:	b0 4f       	add.a %a15,4
8000dfc4:	80 f3       	mov.d %d3,%a15
8000dfc6:	6c 30       	st.w [%a3]0,%d15
8000dfc8:	b0 43       	add.a %a3,4
8000dfca:	3f 23 fb ff 	jlt.u %d3,%d2,8000dfc0 <__lshift+0x9a>
8000dfce:	c2 f9       	add %d9,-1
8000dfd0:	59 d9 10 00 	st.w [%a13]16,%d9
8000dfd4:	40 e4       	mov.aa %a4,%a14
8000dfd6:	40 c5       	mov.aa %a5,%a12
8000dfd8:	6d ff 36 fe 	call 8000dc44 <_Bfree>
8000dfdc:	40 d2       	mov.aa %a2,%a13
8000dfde:	00 90       	ret 

8000dfe0 <__mcmp>:
8000dfe0:	4c 54       	ld.w %d15,[%a5]16
8000dfe2:	19 42 10 00 	ld.w %d2,[%a4]16
8000dfe6:	a2 f2       	sub %d2,%d15
8000dfe8:	df 02 1c 80 	jne %d2,0,8000e020 <__mcmp+0x40>
8000dfec:	80 42       	mov.d %d2,%a4
8000dfee:	06 2f       	sh %d15,2
8000dff0:	60 f2       	mov.a %a2,%d15
8000dff2:	1b 42 01 30 	addi %d3,%d2,20
8000dff6:	d9 55 14 00 	lea %a5,[%a5]20
8000dffa:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
8000dffe:	30 25       	add.a %a5,%a2
8000e000:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
8000e004:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
8000e008:	5f f2 08 00 	jeq %d2,%d15,8000e018 <__mcmp+0x38>
8000e00c:	0b f2 30 21 	lt.u %d2,%d2,%d15
8000e010:	82 f3       	mov %d3,-1
8000e012:	ab 13 80 22 	sel %d2,%d2,%d3,1
8000e016:	00 90       	ret 
8000e018:	80 ff       	mov.d %d15,%a15
8000e01a:	3f f3 f3 ff 	jlt.u %d3,%d15,8000e000 <__mcmp+0x20>
8000e01e:	82 02       	mov %d2,0
8000e020:	00 90       	ret 

8000e022 <__mdiff>:
8000e022:	40 4d       	mov.aa %a13,%a4
8000e024:	40 5f       	mov.aa %a15,%a5
8000e026:	40 54       	mov.aa %a4,%a5
8000e028:	40 65       	mov.aa %a5,%a6
8000e02a:	40 6c       	mov.aa %a12,%a6
8000e02c:	6d ff da ff 	call 8000dfe0 <__mcmp>
8000e030:	02 2f       	mov %d15,%d2
8000e032:	f6 2a       	jnz %d2,8000e046 <__mdiff+0x24>
8000e034:	40 d4       	mov.aa %a4,%a13
8000e036:	82 04       	mov %d4,0
8000e038:	6d ff db fd 	call 8000dbee <_Balloc>
8000e03c:	82 12       	mov %d2,1
8000e03e:	59 22 10 00 	st.w [%a2]16,%d2
8000e042:	6c 25       	st.w [%a2]20,%d15
8000e044:	00 90       	ret 
8000e046:	82 08       	mov %d8,0
8000e048:	ce 25       	jgez %d2,8000e052 <__mdiff+0x30>
8000e04a:	40 f2       	mov.aa %a2,%a15
8000e04c:	82 18       	mov %d8,1
8000e04e:	40 cf       	mov.aa %a15,%a12
8000e050:	40 2c       	mov.aa %a12,%a2
8000e052:	40 d4       	mov.aa %a4,%a13
8000e054:	48 14       	ld.w %d4,[%a15]4
8000e056:	6d ff cc fd 	call 8000dbee <_Balloc>
8000e05a:	48 42       	ld.w %d2,[%a15]16
8000e05c:	d9 ff 14 00 	lea %a15,[%a15]20
8000e060:	80 ff       	mov.d %d15,%a15
8000e062:	d9 c4 14 00 	lea %a4,[%a12]20
8000e066:	13 42 20 7f 	madd %d7,%d15,%d2,4
8000e06a:	19 c0 10 00 	ld.w %d0,[%a12]16
8000e06e:	80 4f       	mov.d %d15,%a4
8000e070:	59 28 0c 00 	st.w [%a2]12,%d8
8000e074:	13 40 20 0f 	madd %d0,%d15,%d0,4
8000e078:	d9 25 14 00 	lea %a5,[%a2]20
8000e07c:	82 03       	mov %d3,0
8000e07e:	44 f6       	ld.w %d6,[%a15+]
8000e080:	44 45       	ld.w %d5,[%a4+]
8000e082:	b7 06 10 48 	insert %d4,%d6,0,16,16
8000e086:	b7 05 10 18 	insert %d1,%d5,0,16,16
8000e08a:	42 34       	add %d4,%d3
8000e08c:	a2 14       	sub %d4,%d1
8000e08e:	8f 06 1f 60 	sh %d6,%d6,-16
8000e092:	8f 05 1f 50 	sh %d5,%d5,-16
8000e096:	8f 04 3f 30 	sha %d3,%d4,-16
8000e09a:	0b 56 80 50 	sub %d5,%d6,%d5
8000e09e:	1a 35       	add %d15,%d5,%d3
8000e0a0:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000e0a4:	8f 0f 3f 30 	sha %d3,%d15,-16
8000e0a8:	80 4f       	mov.d %d15,%a4
8000e0aa:	d9 53 04 00 	lea %a3,[%a5]4
8000e0ae:	74 54       	st.w [%a5],%d4
8000e0b0:	40 35       	mov.aa %a5,%a3
8000e0b2:	3f 0f e6 ff 	jlt.u %d15,%d0,8000e07e <__mdiff+0x5c>
8000e0b6:	80 ff       	mov.d %d15,%a15
8000e0b8:	7f 7f 12 80 	jge.u %d15,%d7,8000e0dc <__mdiff+0xba>
8000e0bc:	44 f5       	ld.w %d5,[%a15+]
8000e0be:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000e0c2:	8f 05 1f 50 	sh %d5,%d5,-16
8000e0c6:	42 34       	add %d4,%d3
8000e0c8:	8f 04 3f f0 	sha %d15,%d4,-16
8000e0cc:	42 5f       	add %d15,%d5
8000e0ce:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000e0d2:	8f 0f 3f 30 	sha %d3,%d15,-16
8000e0d6:	74 34       	st.w [%a3],%d4
8000e0d8:	b0 43       	add.a %a3,4
8000e0da:	3c ee       	j 8000e0b6 <__mdiff+0x94>
8000e0dc:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
8000e0e0:	ee 03       	jnz %d15,8000e0e6 <__mdiff+0xc4>
8000e0e2:	c2 f2       	add %d2,-1
8000e0e4:	3c fc       	j 8000e0dc <__mdiff+0xba>
8000e0e6:	59 22 10 00 	st.w [%a2]16,%d2
8000e0ea:	00 90       	ret 

8000e0ec <__d2b>:
8000e0ec:	20 08       	sub.a %sp,8
8000e0ee:	02 48       	mov %d8,%d4
8000e0f0:	82 14       	mov %d4,1
8000e0f2:	02 59       	mov %d9,%d5
8000e0f4:	40 5d       	mov.aa %a13,%a5
8000e0f6:	40 6c       	mov.aa %a12,%a6
8000e0f8:	6d ff 7b fd 	call 8000dbee <_Balloc>
8000e0fc:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
8000e100:	37 09 6b 9a 	extr.u %d9,%d9,20,11
8000e104:	40 2f       	mov.aa %a15,%a2
8000e106:	76 93       	jz %d9,8000e10c <__d2b+0x20>
8000e108:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
8000e10c:	59 a2 04 00 	st.w [%sp]4,%d2
8000e110:	df 08 20 00 	jeq %d8,0,8000e150 <__d2b+0x64>
8000e114:	d9 a4 08 00 	lea %a4,[%sp]8
8000e118:	89 48 38 f5 	st.w [+%a4]-8,%d8
8000e11c:	40 a4       	mov.aa %a4,%sp
8000e11e:	6d ff fe fd 	call 8000dd1a <__lo0bits>
8000e122:	58 00       	ld.w %d15,[%sp]0
8000e124:	76 2f       	jz %d2,8000e142 <__d2b+0x56>
8000e126:	19 a4 04 00 	ld.w %d4,[%sp]4
8000e12a:	8b 02 02 31 	rsub %d3,%d2,32
8000e12e:	0f 34 00 30 	sh %d3,%d4,%d3
8000e132:	a6 3f       	or %d15,%d3
8000e134:	68 5f       	st.w [%a15]20,%d15
8000e136:	8b 02 00 f1 	rsub %d15,%d2,0
8000e13a:	0f f4 00 f0 	sh %d15,%d4,%d15
8000e13e:	78 01       	st.w [%sp]4,%d15
8000e140:	3c 02       	j 8000e144 <__d2b+0x58>
8000e142:	68 5f       	st.w [%a15]20,%d15
8000e144:	58 01       	ld.w %d15,[%sp]4
8000e146:	82 28       	mov %d8,2
8000e148:	ea 18       	cmovn %d8,%d15,1
8000e14a:	68 6f       	st.w [%a15]24,%d15
8000e14c:	68 48       	st.w [%a15]16,%d8
8000e14e:	3c 0c       	j 8000e166 <__d2b+0x7a>
8000e150:	d9 a4 04 00 	lea %a4,[%sp]4
8000e154:	6d ff e3 fd 	call 8000dd1a <__lo0bits>
8000e158:	58 01       	ld.w %d15,[%sp]4
8000e15a:	1b 02 02 20 	addi %d2,%d2,32
8000e15e:	68 5f       	st.w [%a15]20,%d15
8000e160:	82 1f       	mov %d15,1
8000e162:	68 4f       	st.w [%a15]16,%d15
8000e164:	82 18       	mov %d8,1
8000e166:	76 98       	jz %d9,8000e176 <__d2b+0x8a>
8000e168:	1b d9 bc 9f 	addi %d9,%d9,-1075
8000e16c:	42 29       	add %d9,%d2
8000e16e:	74 d9       	st.w [%a13],%d9
8000e170:	8b 52 03 21 	rsub %d2,%d2,53
8000e174:	3c 0d       	j 8000e18e <__d2b+0xa2>
8000e176:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
8000e17a:	1b e2 bc 2f 	addi %d2,%d2,-1074
8000e17e:	74 d2       	st.w [%a13],%d2
8000e180:	19 24 10 00 	ld.w %d4,[%a2]16
8000e184:	6d ff aa fd 	call 8000dcd8 <__hi0bits>
8000e188:	06 58       	sh %d8,5
8000e18a:	0b 28 80 20 	sub %d2,%d8,%d2
8000e18e:	74 c2       	st.w [%a12],%d2
8000e190:	40 f2       	mov.aa %a2,%a15
8000e192:	00 90       	ret 

8000e194 <__fpclassifyd>:
8000e194:	0f 45 a0 f0 	or %d15,%d5,%d4
8000e198:	82 22       	mov %d2,2
8000e19a:	6e 1d       	jz %d15,8000e1d4 <__fpclassifyd+0x40>
8000e19c:	7b 00 00 38 	movh %d3,32768
8000e1a0:	3a 53       	eq %d15,%d3,%d5
8000e1a2:	8b 04 00 f4 	and.eq %d15,%d4,0
8000e1a6:	8b 04 00 62 	eq %d6,%d4,0
8000e1aa:	ee 15       	jnz %d15,8000e1d4 <__fpclassifyd+0x40>
8000e1ac:	b7 05 81 5f 	insert %d5,%d5,0,31,1
8000e1b0:	7b 00 fe f7 	movh %d15,32736
8000e1b4:	9b 05 ff 3f 	addih %d3,%d5,65520
8000e1b8:	82 42       	mov %d2,4
8000e1ba:	3f f3 0d 80 	jlt.u %d3,%d15,8000e1d4 <__fpclassifyd+0x40>
8000e1be:	7b 00 01 f0 	movh %d15,16
8000e1c2:	82 32       	mov %d2,3
8000e1c4:	3f f5 08 80 	jlt.u %d5,%d15,8000e1d4 <__fpclassifyd+0x40>
8000e1c8:	7b 00 ff 27 	movh %d2,32752
8000e1cc:	0b 25 00 51 	eq %d5,%d5,%d2
8000e1d0:	0f 56 80 20 	and %d2,%d6,%d5
8000e1d4:	00 90       	ret 

8000e1d6 <__ssprint_r>:
8000e1d6:	4c 62       	ld.w %d15,[%a6]8
8000e1d8:	20 08       	sub.a %sp,8
8000e1da:	40 4e       	mov.aa %a14,%a4
8000e1dc:	40 5f       	mov.aa %a15,%a5
8000e1de:	40 6c       	mov.aa %a12,%a6
8000e1e0:	54 6c       	ld.w %d12,[%a6]
8000e1e2:	6e 30       	jz %d15,8000e242 <__ssprint_r+0x6c>
8000e1e4:	a0 02       	mov.a %a2,0
8000e1e6:	b5 a2 04 00 	st.a [%sp]4,%a2
8000e1ea:	82 09       	mov %d9,0
8000e1ec:	3b 00 48 e0 	mov %d14,1152
8000e1f0:	3b f0 b7 df 	mov %d13,-1153
8000e1f4:	3c 0a       	j 8000e208 <__ssprint_r+0x32>
8000e1f6:	60 c2       	mov.a %a2,%d12
8000e1f8:	d4 22       	ld.a %a2,[%a2]
8000e1fa:	b5 a2 04 00 	st.a [%sp]4,%a2
8000e1fe:	60 c2       	mov.a %a2,%d12
8000e200:	1b 8c 00 c0 	addi %d12,%d12,8
8000e204:	19 29 04 00 	ld.w %d9,[%a2]4
8000e208:	df 09 f7 7f 	jeq %d9,0,8000e1f6 <__ssprint_r+0x20>
8000e20c:	48 28       	ld.w %d8,[%a15]8
8000e20e:	3f 89 5a 80 	jlt.u %d9,%d8,8000e2c2 <__ssprint_r+0xec>
8000e212:	88 62       	ld.h %d2,[%a15]12
8000e214:	0f e2 80 f0 	and %d15,%d2,%d14
8000e218:	ee 19       	jnz %d15,8000e24a <__ssprint_r+0x74>
8000e21a:	3f 89 54 80 	jlt.u %d9,%d8,8000e2c2 <__ssprint_r+0xec>
8000e21e:	c8 04       	ld.a %a4,[%a15]0
8000e220:	99 a5 04 00 	ld.a %a5,[%sp]4 <0 <NULL>>
8000e224:	02 84       	mov %d4,%d8
8000e226:	6d 00 81 00 	call 8000e328 <memmove>
8000e22a:	4c f2       	ld.w %d15,[%a15]8
8000e22c:	a2 8f       	sub %d15,%d8
8000e22e:	68 2f       	st.w [%a15]8,%d15
8000e230:	4c f0       	ld.w %d15,[%a15]0
8000e232:	42 f8       	add %d8,%d15
8000e234:	4c c2       	ld.w %d15,[%a12]8
8000e236:	68 08       	st.w [%a15]0,%d8
8000e238:	52 99       	sub %d9,%d15,%d9
8000e23a:	59 c9 08 00 	st.w [%a12]8,%d9
8000e23e:	df 09 dc ff 	jne %d9,0,8000e1f6 <__ssprint_r+0x20>
8000e242:	82 0f       	mov %d15,0
8000e244:	6c c1       	st.w [%a12]4,%d15
8000e246:	82 02       	mov %d2,0
8000e248:	00 90       	ret 
8000e24a:	c8 45       	ld.a %a5,[%a15]16
8000e24c:	48 5a       	ld.w %d10,[%a15]20
8000e24e:	4c f0       	ld.w %d15,[%a15]0
8000e250:	80 53       	mov.d %d3,%a5
8000e252:	53 3a 20 a0 	mul %d10,%d10,3
8000e256:	a2 3f       	sub %d15,%d3
8000e258:	82 23       	mov %d3,2
8000e25a:	4b 3a 01 a2 	div %e10,%d10,%d3
8000e25e:	92 13       	add %d3,%d15,1
8000e260:	42 93       	add %d3,%d9
8000e262:	0b 3a b0 a1 	max.u %d10,%d10,%d3
8000e266:	40 e4       	mov.aa %a4,%a14
8000e268:	02 a4       	mov %d4,%d10
8000e26a:	6f a2 12 00 	jz.t %d2,10,8000e28e <__ssprint_r+0xb8>
8000e26e:	6d ff 0b e9 	call 8000b484 <_malloc_r>
8000e272:	40 2d       	mov.aa %a13,%a2
8000e274:	bd 02 15 00 	jz.a %a2,8000e29e <__ssprint_r+0xc8>
8000e278:	c8 45       	ld.a %a5,[%a15]16
8000e27a:	40 24       	mov.aa %a4,%a2
8000e27c:	02 f4       	mov %d4,%d15
8000e27e:	6d ff aa fc 	call 8000dbd2 <memcpy>
8000e282:	88 62       	ld.h %d2,[%a15]12
8000e284:	26 d2       	and %d2,%d13
8000e286:	8f 02 48 21 	or %d2,%d2,128
8000e28a:	a8 62       	st.h [%a15]12,%d2
8000e28c:	3c 13       	j 8000e2b2 <__ssprint_r+0xdc>
8000e28e:	6d 00 7d 00 	call 8000e388 <_realloc_r>
8000e292:	40 2d       	mov.aa %a13,%a2
8000e294:	7c 2f       	jnz.a %a2,8000e2b2 <__ssprint_r+0xdc>
8000e296:	c8 45       	ld.a %a5,[%a15]16
8000e298:	40 e4       	mov.aa %a4,%a14
8000e29a:	6d ff ea eb 	call 8000ba6e <_free_r>
8000e29e:	da 0c       	mov %d15,12
8000e2a0:	6c e0       	st.w [%a14]0,%d15
8000e2a2:	8c f6       	ld.h %d15,[%a15]12
8000e2a4:	82 f2       	mov %d2,-1
8000e2a6:	96 40       	or %d15,64
8000e2a8:	a8 6f       	st.h [%a15]12,%d15
8000e2aa:	82 0f       	mov %d15,0
8000e2ac:	6c c2       	st.w [%a12]8,%d15
8000e2ae:	6c c1       	st.w [%a12]4,%d15
8000e2b0:	00 90       	ret 
8000e2b2:	e8 4d       	st.a [%a15]16,%a13
8000e2b4:	10 dd       	addsc.a %a13,%a13,%d15,0
8000e2b6:	68 5a       	st.w [%a15]20,%d10
8000e2b8:	a2 fa       	sub %d10,%d15
8000e2ba:	e8 0d       	st.a [%a15]0,%a13
8000e2bc:	02 98       	mov %d8,%d9
8000e2be:	68 2a       	st.w [%a15]8,%d10
8000e2c0:	3c ad       	j 8000e21a <__ssprint_r+0x44>
8000e2c2:	02 98       	mov %d8,%d9
8000e2c4:	3c ad       	j 8000e21e <__ssprint_r+0x48>

8000e2c6 <_calloc_r>:
8000e2c6:	e2 54       	mul %d4,%d5
8000e2c8:	6d ff de e8 	call 8000b484 <_malloc_r>
8000e2cc:	40 2f       	mov.aa %a15,%a2
8000e2ce:	a0 02       	mov.a %a2,0
8000e2d0:	bd 0f 2b 00 	jz.a %a15,8000e326 <_calloc_r+0x60>
8000e2d4:	19 f5 fc ff 	ld.w %d5,[%a15]-4
8000e2d8:	8f 35 c0 51 	andn %d5,%d5,3
8000e2dc:	c2 c5       	add %d5,-4
8000e2de:	8b 55 a2 f2 	ge.u %d15,%d5,37
8000e2e2:	ee 1d       	jnz %d15,8000e31c <_calloc_r+0x56>
8000e2e4:	8b 45 61 f2 	lt.u %d15,%d5,20
8000e2e8:	40 f2       	mov.aa %a2,%a15
8000e2ea:	ee 14       	jnz %d15,8000e312 <_calloc_r+0x4c>
8000e2ec:	82 0f       	mov %d15,0
8000e2ee:	68 0f       	st.w [%a15]0,%d15
8000e2f0:	68 1f       	st.w [%a15]4,%d15
8000e2f2:	8b c5 a1 22 	ge.u %d2,%d5,28
8000e2f6:	d9 f2 08 00 	lea %a2,[%a15]8
8000e2fa:	76 2c       	jz %d2,8000e312 <_calloc_r+0x4c>
8000e2fc:	68 2f       	st.w [%a15]8,%d15
8000e2fe:	68 3f       	st.w [%a15]12,%d15
8000e300:	8b 45 02 52 	eq %d5,%d5,36
8000e304:	d9 f2 10 00 	lea %a2,[%a15]16
8000e308:	76 55       	jz %d5,8000e312 <_calloc_r+0x4c>
8000e30a:	68 4f       	st.w [%a15]16,%d15
8000e30c:	d9 f2 18 00 	lea %a2,[%a15]24
8000e310:	68 5f       	st.w [%a15]20,%d15
8000e312:	82 0f       	mov %d15,0
8000e314:	6c 20       	st.w [%a2]0,%d15
8000e316:	6c 21       	st.w [%a2]4,%d15
8000e318:	6c 22       	st.w [%a2]8,%d15
8000e31a:	3c 05       	j 8000e324 <_calloc_r+0x5e>
8000e31c:	40 f4       	mov.aa %a4,%a15
8000e31e:	82 04       	mov %d4,0
8000e320:	6d 00 2c 00 	call 8000e378 <memset>
8000e324:	40 f2       	mov.aa %a2,%a15
8000e326:	00 90       	ret 

8000e328 <memmove>:
8000e328:	80 46       	mov.d %d6,%a4
8000e32a:	80 52       	mov.d %d2,%a5
8000e32c:	7f 62 16 80 	jge.u %d2,%d6,8000e358 <memmove+0x30>
8000e330:	0b 42 00 50 	add %d5,%d2,%d4
8000e334:	7f 56 12 80 	jge.u %d6,%d5,8000e358 <memmove+0x30>
8000e338:	60 4f       	mov.a %a15,%d4
8000e33a:	02 42       	mov %d2,%d4
8000e33c:	c2 f2       	add %d2,-1
8000e33e:	fd f0 03 00 	loop %a15,8000e344 <memmove+0x1c>
8000e342:	3c 19       	j 8000e374 <memmove+0x4c>
8000e344:	5a 42       	sub %d15,%d2,%d4
8000e346:	60 f2       	mov.a %a2,%d15
8000e348:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
8000e34c:	1a 62       	add %d15,%d2,%d6
8000e34e:	79 23 00 00 	ld.b %d3,[%a2]0
8000e352:	60 f2       	mov.a %a2,%d15
8000e354:	34 23       	st.b [%a2],%d3
8000e356:	3c f3       	j 8000e33c <memmove+0x14>
8000e358:	60 4f       	mov.a %a15,%d4
8000e35a:	a0 02       	mov.a %a2,0
8000e35c:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
8000e360:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
8000e364:	fd f0 03 00 	loop %a15,8000e36a <memmove+0x42>
8000e368:	3c 06       	j 8000e374 <memmove+0x4c>
8000e36a:	79 33 00 00 	ld.b %d3,[%a3]0
8000e36e:	b0 12       	add.a %a2,1
8000e370:	34 43       	st.b [%a4],%d3
8000e372:	3c f5       	j 8000e35c <memmove+0x34>
8000e374:	60 62       	mov.a %a2,%d6
8000e376:	00 90       	ret 

8000e378 <memset>:
8000e378:	40 42       	mov.aa %a2,%a4
8000e37a:	40 4f       	mov.aa %a15,%a4
8000e37c:	9f 05 03 80 	jned %d5,0,8000e382 <memset+0xa>
8000e380:	00 90       	ret 
8000e382:	28 04       	st.b [%a15]0,%d4
8000e384:	b0 1f       	add.a %a15,1
8000e386:	3c fb       	j 8000e37c <memset+0x4>

8000e388 <_realloc_r>:
8000e388:	40 4d       	mov.aa %a13,%a4
8000e38a:	40 5f       	mov.aa %a15,%a5
8000e38c:	02 49       	mov %d9,%d4
8000e38e:	7c 53       	jnz.a %a5,8000e394 <_realloc_r+0xc>
8000e390:	1d ff 7a e8 	j 8000b484 <_malloc_r>
8000e394:	6d ff c5 ea 	call 8000b91e <__malloc_lock>
8000e398:	1b b9 00 20 	addi %d2,%d9,11
8000e39c:	8b 72 61 f2 	lt.u %d15,%d2,23
8000e3a0:	8f 72 c0 21 	andn %d2,%d2,7
8000e3a4:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
8000e3a8:	19 f3 fc ff 	ld.w %d3,[%a15]-4
8000e3ac:	0b 9f 30 21 	lt.u %d2,%d15,%d9
8000e3b0:	8b 0f 20 25 	or.lt %d2,%d15,0
8000e3b4:	d9 fe f8 ff 	lea %a14,[%a15]-8
8000e3b8:	8f 33 c0 81 	andn %d8,%d3,3
8000e3bc:	76 25       	jz %d2,8000e3c6 <_realloc_r+0x3e>
8000e3be:	da 0c       	mov %d15,12
8000e3c0:	6c d0       	st.w [%a13]0,%d15
8000e3c2:	1d 00 56 01 	j 8000e66e <_realloc_r+0x2e6>
8000e3c6:	7f f8 ac 01 	jge %d8,%d15,8000e71e <_realloc_r+0x396>
8000e3ca:	7b 00 00 c7 	movh %d12,28672
8000e3ce:	60 c3       	mov.a %a3,%d12
8000e3d0:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
8000e3d4:	d9 34 10 50 	lea %a4,[%a3]336
8000e3d8:	99 43 08 00 	ld.a %a3,[%a4]8
8000e3dc:	80 4c       	mov.d %d12,%a4
8000e3de:	19 2b 04 00 	ld.w %d11,[%a2]4
8000e3e2:	7d 32 0a 00 	jeq.a %a2,%a3,8000e3f6 <_realloc_r+0x6e>
8000e3e6:	8f 1b c0 21 	andn %d2,%d11,1
8000e3ea:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
8000e3ee:	19 42 04 00 	ld.w %d2,[%a4]4
8000e3f2:	6f 02 2b 80 	jnz.t %d2,0,8000e448 <_realloc_r+0xc0>
8000e3f6:	8f 3b c0 b1 	andn %d11,%d11,3
8000e3fa:	0b 8b 00 20 	add %d2,%d11,%d8
8000e3fe:	7d 32 1b 80 	jne.a %a2,%a3,8000e434 <_realloc_r+0xac>
8000e402:	1b 0f 01 40 	addi %d4,%d15,16
8000e406:	3f 42 23 00 	jlt %d2,%d4,8000e44c <_realloc_r+0xc4>
8000e40a:	10 ee       	addsc.a %a14,%a14,%d15,0
8000e40c:	60 c2       	mov.a %a2,%d12
8000e40e:	a2 f2       	sub %d2,%d15
8000e410:	b5 2e 08 00 	st.a [%a2]8,%a14
8000e414:	8f 12 40 21 	or %d2,%d2,1
8000e418:	59 e2 04 00 	st.w [%a14]4,%d2
8000e41c:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000e420:	40 d4       	mov.aa %a4,%a13
8000e422:	8f 12 00 21 	and %d2,%d2,1
8000e426:	a6 2f       	or %d15,%d2
8000e428:	59 ff fc ff 	st.w [%a15]-4,%d15
8000e42c:	6d ff 7a ea 	call 8000b920 <__malloc_unlock>
8000e430:	40 f2       	mov.aa %a2,%a15
8000e432:	00 90       	ret 
8000e434:	3f f2 0c 00 	jlt %d2,%d15,8000e44c <_realloc_r+0xc4>
8000e438:	cc 23       	ld.a %a15,[%a2]12
8000e43a:	99 22 08 00 	ld.a %a2,[%a2]8
8000e43e:	02 28       	mov %d8,%d2
8000e440:	ec 23       	st.a [%a2]12,%a15
8000e442:	e8 22       	st.a [%a15]8,%a2
8000e444:	1d 00 6d 01 	j 8000e71e <_realloc_r+0x396>
8000e448:	82 0b       	mov %d11,0
8000e44a:	a0 02       	mov.a %a2,0
8000e44c:	6f 03 08 81 	jnz.t %d3,0,8000e65c <_realloc_r+0x2d4>
8000e450:	99 fc f8 ff 	ld.a %a12,[%a15]-8
8000e454:	01 ce 20 c0 	sub.a %a12,%a14,%a12
8000e458:	19 ca 04 00 	ld.w %d10,[%a12]4
8000e45c:	8f 3a c0 a1 	andn %d10,%d10,3
8000e460:	42 8a       	add %d10,%d8
8000e462:	bd 02 b3 00 	jz.a %a2,8000e5c8 <_realloc_r+0x240>
8000e466:	42 ab       	add %d11,%d10
8000e468:	7d 32 5f 80 	jne.a %a2,%a3,8000e526 <_realloc_r+0x19e>
8000e46c:	1b 0f 01 20 	addi %d2,%d15,16
8000e470:	3f 2b ac 00 	jlt %d11,%d2,8000e5c8 <_realloc_r+0x240>
8000e474:	40 ce       	mov.aa %a14,%a12
8000e476:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000e47a:	09 e3 88 05 	ld.a %a3,[+%a14]8
8000e47e:	1b c8 ff 4f 	addi %d4,%d8,-4
8000e482:	8b 54 a2 22 	ge.u %d2,%d4,37
8000e486:	b5 32 0c 00 	st.a [%a3]12,%a2
8000e48a:	b5 23 08 00 	st.a [%a2]8,%a3
8000e48e:	df 02 36 80 	jne %d2,0,8000e4fa <_realloc_r+0x172>
8000e492:	8b 44 61 22 	lt.u %d2,%d4,20
8000e496:	40 e3       	mov.aa %a3,%a14
8000e498:	df 02 28 80 	jne %d2,0,8000e4e8 <_realloc_r+0x160>
8000e49c:	48 02       	ld.w %d2,[%a15]0
8000e49e:	59 c2 08 00 	st.w [%a12]8,%d2
8000e4a2:	48 13       	ld.w %d3,[%a15]4
8000e4a4:	8b c4 a1 22 	ge.u %d2,%d4,28
8000e4a8:	59 c3 0c 00 	st.w [%a12]12,%d3
8000e4ac:	f6 26       	jnz %d2,8000e4b8 <_realloc_r+0x130>
8000e4ae:	d9 c3 10 00 	lea %a3,[%a12]16
8000e4b2:	d9 ff 08 00 	lea %a15,[%a15]8
8000e4b6:	3c 19       	j 8000e4e8 <_realloc_r+0x160>
8000e4b8:	48 22       	ld.w %d2,[%a15]8
8000e4ba:	8b 44 02 82 	eq %d8,%d4,36
8000e4be:	59 c2 10 00 	st.w [%a12]16,%d2
8000e4c2:	48 33       	ld.w %d3,[%a15]12
8000e4c4:	59 c3 14 00 	st.w [%a12]20,%d3
8000e4c8:	f6 86       	jnz %d8,8000e4d4 <_realloc_r+0x14c>
8000e4ca:	d9 c3 18 00 	lea %a3,[%a12]24
8000e4ce:	d9 ff 10 00 	lea %a15,[%a15]16
8000e4d2:	3c 0b       	j 8000e4e8 <_realloc_r+0x160>
8000e4d4:	48 42       	ld.w %d2,[%a15]16
8000e4d6:	d9 c3 20 00 	lea %a3,[%a12]32
8000e4da:	59 c2 18 00 	st.w [%a12]24,%d2
8000e4de:	48 53       	ld.w %d3,[%a15]20
8000e4e0:	d9 ff 18 00 	lea %a15,[%a15]24
8000e4e4:	59 c3 1c 00 	st.w [%a12]28,%d3
8000e4e8:	48 02       	ld.w %d2,[%a15]0
8000e4ea:	74 32       	st.w [%a3],%d2
8000e4ec:	48 13       	ld.w %d3,[%a15]4
8000e4ee:	59 33 04 00 	st.w [%a3]4,%d3
8000e4f2:	48 22       	ld.w %d2,[%a15]8
8000e4f4:	59 32 08 00 	st.w [%a3]8,%d2
8000e4f8:	3c 05       	j 8000e502 <_realloc_r+0x17a>
8000e4fa:	40 e4       	mov.aa %a4,%a14
8000e4fc:	40 f5       	mov.aa %a5,%a15
8000e4fe:	6d ff 15 ff 	call 8000e328 <memmove>
8000e502:	10 cf       	addsc.a %a15,%a12,%d15,0
8000e504:	60 c2       	mov.a %a2,%d12
8000e506:	a2 fb       	sub %d11,%d15
8000e508:	ec 22       	st.a [%a2]8,%a15
8000e50a:	8f 1b 40 b1 	or %d11,%d11,1
8000e50e:	68 1b       	st.w [%a15]4,%d11
8000e510:	19 c2 04 00 	ld.w %d2,[%a12]4
8000e514:	40 d4       	mov.aa %a4,%a13
8000e516:	8f 12 00 21 	and %d2,%d2,1
8000e51a:	a6 2f       	or %d15,%d2
8000e51c:	6c c1       	st.w [%a12]4,%d15
8000e51e:	6d ff 01 ea 	call 8000b920 <__malloc_unlock>
8000e522:	40 e2       	mov.aa %a2,%a14
8000e524:	00 90       	ret 
8000e526:	3f fb 51 00 	jlt %d11,%d15,8000e5c8 <_realloc_r+0x240>
8000e52a:	99 23 0c 00 	ld.a %a3,[%a2]12
8000e52e:	99 22 08 00 	ld.a %a2,[%a2]8
8000e532:	40 c4       	mov.aa %a4,%a12
8000e534:	1b c8 ff 4f 	addi %d4,%d8,-4
8000e538:	b5 23 0c 00 	st.a [%a2]12,%a3
8000e53c:	b5 32 08 00 	st.a [%a3]8,%a2
8000e540:	09 43 88 05 	ld.a %a3,[+%a4]8
8000e544:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000e548:	8b 54 a2 22 	ge.u %d2,%d4,37
8000e54c:	b5 32 0c 00 	st.a [%a3]12,%a2
8000e550:	b5 23 08 00 	st.a [%a2]8,%a3
8000e554:	df 02 35 80 	jne %d2,0,8000e5be <_realloc_r+0x236>
8000e558:	8b 44 61 22 	lt.u %d2,%d4,20
8000e55c:	df 02 28 80 	jne %d2,0,8000e5ac <_realloc_r+0x224>
8000e560:	48 02       	ld.w %d2,[%a15]0
8000e562:	59 c2 08 00 	st.w [%a12]8,%d2
8000e566:	48 13       	ld.w %d3,[%a15]4
8000e568:	8b c4 a1 22 	ge.u %d2,%d4,28
8000e56c:	59 c3 0c 00 	st.w [%a12]12,%d3
8000e570:	f6 26       	jnz %d2,8000e57c <_realloc_r+0x1f4>
8000e572:	d9 c4 10 00 	lea %a4,[%a12]16
8000e576:	d9 ff 08 00 	lea %a15,[%a15]8
8000e57a:	3c 19       	j 8000e5ac <_realloc_r+0x224>
8000e57c:	48 22       	ld.w %d2,[%a15]8
8000e57e:	8b 44 02 82 	eq %d8,%d4,36
8000e582:	59 c2 10 00 	st.w [%a12]16,%d2
8000e586:	48 33       	ld.w %d3,[%a15]12
8000e588:	59 c3 14 00 	st.w [%a12]20,%d3
8000e58c:	f6 86       	jnz %d8,8000e598 <_realloc_r+0x210>
8000e58e:	d9 c4 18 00 	lea %a4,[%a12]24
8000e592:	d9 ff 10 00 	lea %a15,[%a15]16
8000e596:	3c 0b       	j 8000e5ac <_realloc_r+0x224>
8000e598:	48 42       	ld.w %d2,[%a15]16
8000e59a:	d9 c4 20 00 	lea %a4,[%a12]32
8000e59e:	59 c2 18 00 	st.w [%a12]24,%d2
8000e5a2:	48 53       	ld.w %d3,[%a15]20
8000e5a4:	d9 ff 18 00 	lea %a15,[%a15]24
8000e5a8:	59 c3 1c 00 	st.w [%a12]28,%d3
8000e5ac:	48 02       	ld.w %d2,[%a15]0
8000e5ae:	74 42       	st.w [%a4],%d2
8000e5b0:	48 13       	ld.w %d3,[%a15]4
8000e5b2:	59 43 04 00 	st.w [%a4]4,%d3
8000e5b6:	48 22       	ld.w %d2,[%a15]8
8000e5b8:	59 42 08 00 	st.w [%a4]8,%d2
8000e5bc:	3c 04       	j 8000e5c4 <_realloc_r+0x23c>
8000e5be:	40 f5       	mov.aa %a5,%a15
8000e5c0:	6d ff b4 fe 	call 8000e328 <memmove>
8000e5c4:	02 b8       	mov %d8,%d11
8000e5c6:	3c 45       	j 8000e650 <_realloc_r+0x2c8>
8000e5c8:	3f fa 4a 00 	jlt %d10,%d15,8000e65c <_realloc_r+0x2d4>
8000e5cc:	40 c4       	mov.aa %a4,%a12
8000e5ce:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000e5d2:	09 43 88 05 	ld.a %a3,[+%a4]8
8000e5d6:	1b c8 ff 4f 	addi %d4,%d8,-4
8000e5da:	8b 54 a2 22 	ge.u %d2,%d4,37
8000e5de:	b5 32 0c 00 	st.a [%a3]12,%a2
8000e5e2:	b5 23 08 00 	st.a [%a2]8,%a3
8000e5e6:	df 02 37 80 	jne %d2,0,8000e654 <_realloc_r+0x2cc>
8000e5ea:	8b 44 61 22 	lt.u %d2,%d4,20
8000e5ee:	df 02 28 80 	jne %d2,0,8000e63e <_realloc_r+0x2b6>
8000e5f2:	48 03       	ld.w %d3,[%a15]0
8000e5f4:	59 c3 08 00 	st.w [%a12]8,%d3
8000e5f8:	48 12       	ld.w %d2,[%a15]4
8000e5fa:	59 c2 0c 00 	st.w [%a12]12,%d2
8000e5fe:	8b c4 a1 22 	ge.u %d2,%d4,28
8000e602:	f6 26       	jnz %d2,8000e60e <_realloc_r+0x286>
8000e604:	d9 c4 10 00 	lea %a4,[%a12]16
8000e608:	d9 ff 08 00 	lea %a15,[%a15]8
8000e60c:	3c 19       	j 8000e63e <_realloc_r+0x2b6>
8000e60e:	48 23       	ld.w %d3,[%a15]8
8000e610:	8b 44 02 82 	eq %d8,%d4,36
8000e614:	59 c3 10 00 	st.w [%a12]16,%d3
8000e618:	48 32       	ld.w %d2,[%a15]12
8000e61a:	59 c2 14 00 	st.w [%a12]20,%d2
8000e61e:	f6 86       	jnz %d8,8000e62a <_realloc_r+0x2a2>
8000e620:	d9 c4 18 00 	lea %a4,[%a12]24
8000e624:	d9 ff 10 00 	lea %a15,[%a15]16
8000e628:	3c 0b       	j 8000e63e <_realloc_r+0x2b6>
8000e62a:	48 43       	ld.w %d3,[%a15]16
8000e62c:	d9 c4 20 00 	lea %a4,[%a12]32
8000e630:	59 c3 18 00 	st.w [%a12]24,%d3
8000e634:	48 52       	ld.w %d2,[%a15]20
8000e636:	d9 ff 18 00 	lea %a15,[%a15]24
8000e63a:	59 c2 1c 00 	st.w [%a12]28,%d2
8000e63e:	48 03       	ld.w %d3,[%a15]0
8000e640:	74 43       	st.w [%a4],%d3
8000e642:	48 12       	ld.w %d2,[%a15]4
8000e644:	59 42 04 00 	st.w [%a4]4,%d2
8000e648:	48 23       	ld.w %d3,[%a15]8
8000e64a:	59 43 08 00 	st.w [%a4]8,%d3
8000e64e:	02 a8       	mov %d8,%d10
8000e650:	40 ce       	mov.aa %a14,%a12
8000e652:	3c 66       	j 8000e71e <_realloc_r+0x396>
8000e654:	40 f5       	mov.aa %a5,%a15
8000e656:	6d ff 69 fe 	call 8000e328 <memmove>
8000e65a:	3c fa       	j 8000e64e <_realloc_r+0x2c6>
8000e65c:	40 d4       	mov.aa %a4,%a13
8000e65e:	02 94       	mov %d4,%d9
8000e660:	6d ff 12 e7 	call 8000b484 <_malloc_r>
8000e664:	40 2c       	mov.aa %a12,%a2
8000e666:	7c 26       	jnz.a %a2,8000e672 <_realloc_r+0x2ea>
8000e668:	40 d4       	mov.aa %a4,%a13
8000e66a:	6d ff 5b e9 	call 8000b920 <__malloc_unlock>
8000e66e:	a0 02       	mov.a %a2,0
8000e670:	00 90       	ret 
8000e672:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000e676:	d9 23 f8 ff 	lea %a3,[%a2]-8
8000e67a:	8f 12 c0 21 	andn %d2,%d2,1
8000e67e:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
8000e682:	80 32       	mov.d %d2,%a3
8000e684:	80 23       	mov.d %d3,%a2
8000e686:	5f 32 08 80 	jne %d2,%d3,8000e696 <_realloc_r+0x30e>
8000e68a:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8000e68e:	8f 32 c0 21 	andn %d2,%d2,3
8000e692:	42 28       	add %d8,%d2
8000e694:	3c 45       	j 8000e71e <_realloc_r+0x396>
8000e696:	1b c8 ff 4f 	addi %d4,%d8,-4
8000e69a:	8b 54 a2 f2 	ge.u %d15,%d4,37
8000e69e:	ee 33       	jnz %d15,8000e704 <_realloc_r+0x37c>
8000e6a0:	8b 44 61 f2 	lt.u %d15,%d4,20
8000e6a4:	40 c3       	mov.aa %a3,%a12
8000e6a6:	40 f2       	mov.aa %a2,%a15
8000e6a8:	ee 23       	jnz %d15,8000e6ee <_realloc_r+0x366>
8000e6aa:	4c f0       	ld.w %d15,[%a15]0
8000e6ac:	d9 c3 08 00 	lea %a3,[%a12]8
8000e6b0:	6c c0       	st.w [%a12]0,%d15
8000e6b2:	48 12       	ld.w %d2,[%a15]4
8000e6b4:	8b c4 a1 f2 	ge.u %d15,%d4,28
8000e6b8:	59 c2 04 00 	st.w [%a12]4,%d2
8000e6bc:	d9 f2 08 00 	lea %a2,[%a15]8
8000e6c0:	6e 17       	jz %d15,8000e6ee <_realloc_r+0x366>
8000e6c2:	48 23       	ld.w %d3,[%a15]8
8000e6c4:	8b 44 02 82 	eq %d8,%d4,36
8000e6c8:	59 c3 08 00 	st.w [%a12]8,%d3
8000e6cc:	4c f3       	ld.w %d15,[%a15]12
8000e6ce:	d9 c3 10 00 	lea %a3,[%a12]16
8000e6d2:	6c c3       	st.w [%a12]12,%d15
8000e6d4:	d9 f2 10 00 	lea %a2,[%a15]16
8000e6d8:	76 8b       	jz %d8,8000e6ee <_realloc_r+0x366>
8000e6da:	48 42       	ld.w %d2,[%a15]16
8000e6dc:	d9 c3 18 00 	lea %a3,[%a12]24
8000e6e0:	59 c2 10 00 	st.w [%a12]16,%d2
8000e6e4:	48 53       	ld.w %d3,[%a15]20
8000e6e6:	d9 f2 18 00 	lea %a2,[%a15]24
8000e6ea:	59 c3 14 00 	st.w [%a12]20,%d3
8000e6ee:	4c 20       	ld.w %d15,[%a2]0
8000e6f0:	6c 30       	st.w [%a3]0,%d15
8000e6f2:	19 22 04 00 	ld.w %d2,[%a2]4
8000e6f6:	59 32 04 00 	st.w [%a3]4,%d2
8000e6fa:	19 23 08 00 	ld.w %d3,[%a2]8
8000e6fe:	59 33 08 00 	st.w [%a3]8,%d3
8000e702:	3c 05       	j 8000e70c <_realloc_r+0x384>
8000e704:	40 c4       	mov.aa %a4,%a12
8000e706:	40 f5       	mov.aa %a5,%a15
8000e708:	6d ff 10 fe 	call 8000e328 <memmove>
8000e70c:	40 d4       	mov.aa %a4,%a13
8000e70e:	40 f5       	mov.aa %a5,%a15
8000e710:	6d ff af e9 	call 8000ba6e <_free_r>
8000e714:	40 d4       	mov.aa %a4,%a13
8000e716:	6d ff 05 e9 	call 8000b920 <__malloc_unlock>
8000e71a:	40 c2       	mov.aa %a2,%a12
8000e71c:	00 90       	ret 
8000e71e:	0b f8 80 20 	sub %d2,%d8,%d15
8000e722:	8b 02 61 42 	lt.u %d4,%d2,16
8000e726:	19 e3 04 00 	ld.w %d3,[%a14]4
8000e72a:	df 04 16 80 	jne %d4,0,8000e756 <_realloc_r+0x3ce>
8000e72e:	8f 13 00 31 	and %d3,%d3,1
8000e732:	10 e5       	addsc.a %a5,%a14,%d15,0
8000e734:	a6 3f       	or %d15,%d3
8000e736:	6c e1       	st.w [%a14]4,%d15
8000e738:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
8000e73c:	8f 12 40 f1 	or %d15,%d2,1
8000e740:	b7 10 21 20 	imask %e2,1,0,1
8000e744:	6c 51       	st.w [%a5]4,%d15
8000e746:	49 f2 44 08 	ldmst [%a15]4,%e2
8000e74a:	40 d4       	mov.aa %a4,%a13
8000e74c:	d9 55 08 00 	lea %a5,[%a5]8
8000e750:	6d ff 8f e9 	call 8000ba6e <_free_r>
8000e754:	3c 0c       	j 8000e76c <_realloc_r+0x3e4>
8000e756:	8f 13 00 31 	and %d3,%d3,1
8000e75a:	a6 83       	or %d3,%d8
8000e75c:	59 e3 04 00 	st.w [%a14]4,%d3
8000e760:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
8000e764:	b7 10 21 20 	imask %e2,1,0,1
8000e768:	49 f2 44 08 	ldmst [%a15]4,%e2
8000e76c:	40 d4       	mov.aa %a4,%a13
8000e76e:	6d ff d9 e8 	call 8000b920 <__malloc_unlock>
8000e772:	d9 e2 08 00 	lea %a2,[%a14]8
8000e776:	00 90       	ret 

8000e778 <_exit>:
8000e778:	76 43       	jz %d4,8000e77e <_exit+0x6>
8000e77a:	60 4e       	mov.a %a14,%d4
8000e77c:	3c 04       	j 8000e784 <_exit+0xc>
8000e77e:	bb d0 00 f9 	mov.u %d15,36877
8000e782:	60 fe       	mov.a %a14,%d15
8000e784:	00 a0       	debug 
8000e786:	3c 00       	j 8000e786 <_exit+0xe>

8000e788 <sbrk>:
8000e788:	91 00 00 f7 	movh.a %a15,28672
8000e78c:	19 ff 80 60 	ld.w %d15,[%a15]2432 <70000980 <heap_top.2289>>
8000e790:	7b 00 00 27 	movh %d2,28672
8000e794:	42 f4       	add %d4,%d15
8000e796:	1b 82 f5 20 	addi %d2,%d2,3928
8000e79a:	7f 42 09 80 	jge.u %d2,%d4,8000e7ac <sbrk+0x24>
8000e79e:	6d 00 13 00 	call 8000e7c4 <__errno>
8000e7a2:	da 0c       	mov %d15,12
8000e7a4:	6c 20       	st.w [%a2]0,%d15
8000e7a6:	a0 02       	mov.a %a2,0
8000e7a8:	b0 f2       	add.a %a2,-1
8000e7aa:	00 90       	ret 
8000e7ac:	7b 00 00 27 	movh %d2,28672
8000e7b0:	1b 82 f5 20 	addi %d2,%d2,3928
8000e7b4:	7f 24 04 80 	jge.u %d4,%d2,8000e7bc <sbrk+0x34>
8000e7b8:	6d 00 0b 00 	call 8000e7ce <abort>
8000e7bc:	59 f4 80 60 	st.w [%a15]2432,%d4
8000e7c0:	60 f2       	mov.a %a2,%d15
8000e7c2:	00 90       	ret 

8000e7c4 <__errno>:
8000e7c4:	91 00 00 27 	movh.a %a2,28672
8000e7c8:	d9 22 d0 d0 	lea %a2,[%a2]3920 <70000f50 <_my_errno>>
8000e7cc:	00 90       	ret 

8000e7ce <abort>:
8000e7ce:	00 a0       	debug 
8000e7d0:	7b e0 ea fd 	movh %d15,57006
8000e7d4:	1b ff ee fb 	addi %d15,%d15,-16657
8000e7d8:	60 fe       	mov.a %a14,%d15
8000e7da:	1d ff cf ff 	j 8000e778 <_exit>
8000e7de:	3c 00       	j 8000e7de <abort+0x10>

8000e7e0 <__eqdf2>:
8000e7e0:	20 38       	sub.a %sp,56
8000e7e2:	40 a4       	mov.aa %a4,%sp
8000e7e4:	d9 a5 10 00 	lea %a5,[%sp]16
8000e7e8:	89 a4 40 09 	st.d [%sp],%e4
8000e7ec:	89 a6 48 09 	st.d [%sp]8,%e6
8000e7f0:	6d ff 84 e5 	call 8000b2f8 <__unpack_d>
8000e7f4:	d9 a4 08 00 	lea %a4,[%sp]8
8000e7f8:	d9 a5 24 00 	lea %a5,[%sp]36
8000e7fc:	6d ff 7e e5 	call 8000b2f8 <__unpack_d>
8000e800:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e804:	82 12       	mov %d2,1
8000e806:	bf 2f 0c 80 	jlt.u %d15,2,8000e81e <__eqdf2+0x3e>
8000e80a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e80e:	bf 2f 08 80 	jlt.u %d15,2,8000e81e <__eqdf2+0x3e>
8000e812:	d9 a4 10 00 	lea %a4,[%sp]16
8000e816:	d9 a5 24 00 	lea %a5,[%sp]36
8000e81a:	6d 00 26 01 	call 8000ea66 <__fpcmp_parts_d>
8000e81e:	00 90       	ret 

8000e820 <__nedf2>:
8000e820:	20 38       	sub.a %sp,56
8000e822:	40 a4       	mov.aa %a4,%sp
8000e824:	d9 a5 10 00 	lea %a5,[%sp]16
8000e828:	89 a4 40 09 	st.d [%sp],%e4
8000e82c:	89 a6 48 09 	st.d [%sp]8,%e6
8000e830:	6d ff 64 e5 	call 8000b2f8 <__unpack_d>
8000e834:	d9 a4 08 00 	lea %a4,[%sp]8
8000e838:	d9 a5 24 00 	lea %a5,[%sp]36
8000e83c:	6d ff 5e e5 	call 8000b2f8 <__unpack_d>
8000e840:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e844:	82 12       	mov %d2,1
8000e846:	bf 2f 0c 80 	jlt.u %d15,2,8000e85e <__nedf2+0x3e>
8000e84a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e84e:	bf 2f 08 80 	jlt.u %d15,2,8000e85e <__nedf2+0x3e>
8000e852:	d9 a4 10 00 	lea %a4,[%sp]16
8000e856:	d9 a5 24 00 	lea %a5,[%sp]36
8000e85a:	6d 00 06 01 	call 8000ea66 <__fpcmp_parts_d>
8000e85e:	00 90       	ret 

8000e860 <__gtdf2>:
8000e860:	20 38       	sub.a %sp,56
8000e862:	40 a4       	mov.aa %a4,%sp
8000e864:	d9 a5 10 00 	lea %a5,[%sp]16
8000e868:	89 a4 40 09 	st.d [%sp],%e4
8000e86c:	89 a6 48 09 	st.d [%sp]8,%e6
8000e870:	6d ff 44 e5 	call 8000b2f8 <__unpack_d>
8000e874:	d9 a4 08 00 	lea %a4,[%sp]8
8000e878:	d9 a5 24 00 	lea %a5,[%sp]36
8000e87c:	6d ff 3e e5 	call 8000b2f8 <__unpack_d>
8000e880:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e884:	82 f2       	mov %d2,-1
8000e886:	bf 2f 0c 80 	jlt.u %d15,2,8000e89e <__gtdf2+0x3e>
8000e88a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e88e:	bf 2f 08 80 	jlt.u %d15,2,8000e89e <__gtdf2+0x3e>
8000e892:	d9 a4 10 00 	lea %a4,[%sp]16
8000e896:	d9 a5 24 00 	lea %a5,[%sp]36
8000e89a:	6d 00 e6 00 	call 8000ea66 <__fpcmp_parts_d>
8000e89e:	00 90       	ret 

8000e8a0 <__gedf2>:
8000e8a0:	20 38       	sub.a %sp,56
8000e8a2:	40 a4       	mov.aa %a4,%sp
8000e8a4:	d9 a5 10 00 	lea %a5,[%sp]16
8000e8a8:	89 a4 40 09 	st.d [%sp],%e4
8000e8ac:	89 a6 48 09 	st.d [%sp]8,%e6
8000e8b0:	6d ff 24 e5 	call 8000b2f8 <__unpack_d>
8000e8b4:	d9 a4 08 00 	lea %a4,[%sp]8
8000e8b8:	d9 a5 24 00 	lea %a5,[%sp]36
8000e8bc:	6d ff 1e e5 	call 8000b2f8 <__unpack_d>
8000e8c0:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e8c4:	82 f2       	mov %d2,-1
8000e8c6:	bf 2f 0c 80 	jlt.u %d15,2,8000e8de <__gedf2+0x3e>
8000e8ca:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e8ce:	bf 2f 08 80 	jlt.u %d15,2,8000e8de <__gedf2+0x3e>
8000e8d2:	d9 a4 10 00 	lea %a4,[%sp]16
8000e8d6:	d9 a5 24 00 	lea %a5,[%sp]36
8000e8da:	6d 00 c6 00 	call 8000ea66 <__fpcmp_parts_d>
8000e8de:	00 90       	ret 

8000e8e0 <__ltdf2>:
8000e8e0:	20 38       	sub.a %sp,56
8000e8e2:	40 a4       	mov.aa %a4,%sp
8000e8e4:	d9 a5 10 00 	lea %a5,[%sp]16
8000e8e8:	89 a4 40 09 	st.d [%sp],%e4
8000e8ec:	89 a6 48 09 	st.d [%sp]8,%e6
8000e8f0:	6d ff 04 e5 	call 8000b2f8 <__unpack_d>
8000e8f4:	d9 a4 08 00 	lea %a4,[%sp]8
8000e8f8:	d9 a5 24 00 	lea %a5,[%sp]36
8000e8fc:	6d ff fe e4 	call 8000b2f8 <__unpack_d>
8000e900:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e904:	82 12       	mov %d2,1
8000e906:	bf 2f 0c 80 	jlt.u %d15,2,8000e91e <__ltdf2+0x3e>
8000e90a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e90e:	bf 2f 08 80 	jlt.u %d15,2,8000e91e <__ltdf2+0x3e>
8000e912:	d9 a4 10 00 	lea %a4,[%sp]16
8000e916:	d9 a5 24 00 	lea %a5,[%sp]36
8000e91a:	6d 00 a6 00 	call 8000ea66 <__fpcmp_parts_d>
8000e91e:	00 90       	ret 

8000e920 <__fixdfsi>:
8000e920:	20 20       	sub.a %sp,32
8000e922:	d9 a4 20 00 	lea %a4,[%sp]32
8000e926:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000e92a:	d9 a5 0c 00 	lea %a5,[%sp]12
8000e92e:	6d ff e5 e4 	call 8000b2f8 <__unpack_d>
8000e932:	0c ac       	ld.bu %d15,[%sp]12
8000e934:	82 02       	mov %d2,0
8000e936:	bf 3f 1b 80 	jlt.u %d15,3,8000e96c <__fixdfsi+0x4c>
8000e93a:	5e 48       	jne %d15,4,8000e94a <__fixdfsi+0x2a>
8000e93c:	7b 00 00 28 	movh %d2,32768
8000e940:	58 04       	ld.w %d15,[%sp]16
8000e942:	1b f2 ff 3f 	addi %d3,%d2,-1
8000e946:	6a 32       	cmovn %d2,%d15,%d3
8000e948:	00 90       	ret 
8000e94a:	19 a6 14 00 	ld.w %d6,[%sp]20
8000e94e:	82 02       	mov %d2,0
8000e950:	0e 6e       	jltz %d6,8000e96c <__fixdfsi+0x4c>
8000e952:	8b f6 81 f2 	ge %d15,%d6,31
8000e956:	ee f3       	jnz %d15,8000e93c <__fixdfsi+0x1c>
8000e958:	09 a4 58 09 	ld.d %e4,[%sp]24
8000e95c:	8b c6 03 61 	rsub %d6,%d6,60
8000e960:	6d ff 09 e1 	call 8000ab72 <__lshrdi3>
8000e964:	58 04       	ld.w %d15,[%sp]16
8000e966:	8b 02 00 41 	rsub %d4,%d2,0
8000e96a:	2a 42       	cmov %d2,%d15,%d4
8000e96c:	00 90       	ret 

8000e96e <__floatunsidf>:
8000e96e:	20 18       	sub.a %sp,24
8000e970:	82 0f       	mov %d15,0
8000e972:	78 02       	st.w [%sp]8,%d15
8000e974:	f6 44       	jnz %d4,8000e97c <__floatunsidf+0xe>
8000e976:	82 2f       	mov %d15,2
8000e978:	2c a4       	st.b [%sp]4,%d15
8000e97a:	3c 0f       	j 8000e998 <__floatunsidf+0x2a>
8000e97c:	82 3f       	mov %d15,3
8000e97e:	2c a4       	st.b [%sp]4,%d15
8000e980:	0f 04 b0 f1 	clz %d15,%d4
8000e984:	1b df 01 60 	addi %d6,%d15,29
8000e988:	82 05       	mov %d5,0
8000e98a:	6d ff d9 e3 	call 8000b13c <__ashldi3>
8000e98e:	8b ff 01 f1 	rsub %d15,%d15,31
8000e992:	89 a2 50 09 	st.d [%sp]16,%e2
8000e996:	78 03       	st.w [%sp]12,%d15
8000e998:	d9 a4 04 00 	lea %a4,[%sp]4
8000e99c:	1d ff 25 e4 	j 8000b1e6 <__pack_d>

8000e9a0 <__udivdi3>:
8000e9a0:	0f 67 a0 20 	or %d2,%d7,%d6
8000e9a4:	0b 45 10 a8 	mov %e10,%d5,%d4
8000e9a8:	02 6f       	mov %d15,%d6
8000e9aa:	02 7c       	mov %d12,%d7
8000e9ac:	d2 f8       	mov %e8,-1
8000e9ae:	df 02 46 00 	jeq %d2,0,8000ea3a <__udivdi3+0x9a>
8000e9b2:	8f 07 40 21 	or %d2,%d7,0
8000e9b6:	f6 2d       	jnz %d2,8000e9d0 <__udivdi3+0x30>
8000e9b8:	4b 6b 11 82 	div.u %e8,%d11,%d6
8000e9bc:	d2 04       	mov %e4,0
8000e9be:	02 a4       	mov %d4,%d10
8000e9c0:	42 95       	add %d5,%d9
8000e9c2:	6d 00 a5 00 	call 8000eb0c <__udiv6432>
8000e9c6:	82 04       	mov %d4,0
8000e9c8:	02 85       	mov %d5,%d8
8000e9ca:	13 12 40 84 	madd.u %e8,%e4,%d2,1
8000e9ce:	3c 36       	j 8000ea3a <__udivdi3+0x9a>
8000e9d0:	0b 7b 00 21 	eq %d2,%d11,%d7
8000e9d4:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
8000e9d8:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
8000e9dc:	d2 08       	mov %e8,0
8000e9de:	df 02 2e 80 	jne %d2,0,8000ea3a <__udivdi3+0x9a>
8000e9e2:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
8000e9e6:	0f 07 b0 d1 	clz %d13,%d7
8000e9ea:	60 5f       	mov.a %a15,%d5
8000e9ec:	0b 67 10 48 	mov %e4,%d7,%d6
8000e9f0:	02 d6       	mov %d6,%d13
8000e9f2:	6d ff a5 e3 	call 8000b13c <__ashldi3>
8000e9f6:	8f fb 1f e0 	sh %d14,%d11,-1
8000e9fa:	80 f4       	mov.d %d4,%a15
8000e9fc:	02 36       	mov %d6,%d3
8000e9fe:	02 e5       	mov %d5,%d14
8000ea00:	6d 00 86 00 	call 8000eb0c <__udiv6432>
8000ea04:	8b fd 01 d1 	rsub %d13,%d13,31
8000ea08:	8b 0d 00 31 	rsub %d3,%d13,0
8000ea0c:	0f 32 00 30 	sh %d3,%d2,%d3
8000ea10:	02 32       	mov %d2,%d3
8000ea12:	8b f2 9f 80 	addx %d8,%d2,-1
8000ea16:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
8000ea1a:	82 03       	mov %d3,0
8000ea1c:	8b f3 bf 90 	addc %d9,%d3,-1
8000ea20:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
8000ea24:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
8000ea28:	0b cb 00 41 	eq %d4,%d11,%d12
8000ea2c:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
8000ea30:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
8000ea34:	f6 43       	jnz %d4,8000ea3a <__udivdi3+0x9a>
8000ea36:	0b 23 10 88 	mov %e8,%d3,%d2
8000ea3a:	0b 89 10 28 	mov %e2,%d9,%d8
8000ea3e:	00 90       	ret 

8000ea40 <__umoddi3>:
8000ea40:	0f 67 a0 90 	or %d9,%d7,%d6
8000ea44:	02 6f       	mov %d15,%d6
8000ea46:	d2 00       	mov %e0,0
8000ea48:	76 9c       	jz %d9,8000ea60 <__umoddi3+0x20>
8000ea4a:	02 7a       	mov %d10,%d7
8000ea4c:	0b 45 10 88 	mov %e8,%d5,%d4
8000ea50:	6d ff a8 ff 	call 8000e9a0 <__udivdi3>
8000ea54:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
8000ea58:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
8000ea5c:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
8000ea60:	0b 01 10 28 	mov %e2,%d1,%d0
8000ea64:	00 90       	ret 

8000ea66 <__fpcmp_parts_d>:
8000ea66:	14 43       	ld.bu %d3,[%a4]
8000ea68:	82 12       	mov %d2,1
8000ea6a:	bf 23 50 80 	jlt.u %d3,2,8000eb0a <__fpcmp_parts_d+0xa4>
8000ea6e:	0c 50       	ld.bu %d15,[%a5]0
8000ea70:	bf 2f 4d 80 	jlt.u %d15,2,8000eb0a <__fpcmp_parts_d+0xa4>
8000ea74:	8b 43 00 42 	eq %d4,%d3,4
8000ea78:	8b 4f 00 22 	eq %d2,%d15,4
8000ea7c:	0f 24 80 50 	and %d5,%d4,%d2
8000ea80:	76 56       	jz %d5,8000ea8c <__fpcmp_parts_d+0x26>
8000ea82:	19 52 04 00 	ld.w %d2,[%a5]4
8000ea86:	4c 41       	ld.w %d15,[%a4]4
8000ea88:	a2 f2       	sub %d2,%d15
8000ea8a:	00 90       	ret 
8000ea8c:	76 47       	jz %d4,8000ea9a <__fpcmp_parts_d+0x34>
8000ea8e:	19 42 04 00 	ld.w %d2,[%a4]4
8000ea92:	82 1f       	mov %d15,1
8000ea94:	ab ff bf 22 	seln %d2,%d2,%d15,-1
8000ea98:	00 90       	ret 
8000ea9a:	76 27       	jz %d2,8000eaa8 <__fpcmp_parts_d+0x42>
8000ea9c:	19 52 04 00 	ld.w %d2,[%a5]4
8000eaa0:	82 ff       	mov %d15,-1
8000eaa2:	ab 1f a0 22 	seln %d2,%d2,%d15,1
8000eaa6:	00 90       	ret 
8000eaa8:	df 23 06 80 	jne %d3,2,8000eab4 <__fpcmp_parts_d+0x4e>
8000eaac:	82 02       	mov %d2,0
8000eaae:	df 2f f7 ff 	jne %d15,2,8000ea9c <__fpcmp_parts_d+0x36>
8000eab2:	00 90       	ret 
8000eab4:	df 2f ed 7f 	jeq %d15,2,8000ea8e <__fpcmp_parts_d+0x28>
8000eab8:	19 45 04 00 	ld.w %d5,[%a4]4
8000eabc:	4c 51       	ld.w %d15,[%a5]4
8000eabe:	5f f5 19 80 	jne %d5,%d15,8000eaf0 <__fpcmp_parts_d+0x8a>
8000eac2:	19 42 08 00 	ld.w %d2,[%a4]8
8000eac6:	4c 52       	ld.w %d15,[%a5]8
8000eac8:	3f 2f 14 00 	jlt %d15,%d2,8000eaf0 <__fpcmp_parts_d+0x8a>
8000eacc:	3f f2 1c 00 	jlt %d2,%d15,8000eb04 <__fpcmp_parts_d+0x9e>
8000ead0:	19 43 10 00 	ld.w %d3,[%a4]16
8000ead4:	19 54 10 00 	ld.w %d4,[%a5]16
8000ead8:	19 47 0c 00 	ld.w %d7,[%a4]12
8000eadc:	19 56 0c 00 	ld.w %d6,[%a5]12
8000eae0:	0b 43 00 21 	eq %d2,%d3,%d4
8000eae4:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
8000eae8:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
8000eaec:	3a 43       	eq %d15,%d3,%d4
8000eaee:	f6 25       	jnz %d2,8000eaf8 <__fpcmp_parts_d+0x92>
8000eaf0:	82 12       	mov %d2,1
8000eaf2:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
8000eaf6:	00 90       	ret 
8000eaf8:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
8000eafc:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
8000eb00:	82 02       	mov %d2,0
8000eb02:	ee 04       	jnz %d15,8000eb0a <__fpcmp_parts_d+0xa4>
8000eb04:	82 f2       	mov %d2,-1
8000eb06:	ab 12 a0 25 	seln %d2,%d5,%d2,1
8000eb0a:	00 90       	ret 

8000eb0c <__udiv6432>:
8000eb0c:	02 53       	mov %d3,%d5
8000eb0e:	82 f2       	mov %d2,-1
8000eb10:	7f 65 4b 80 	jge.u %d5,%d6,8000eba6 <__udiv6432+0x9a>
8000eb14:	0f 06 b0 21 	clz %d2,%d6
8000eb18:	0f 26 00 60 	sh %d6,%d6,%d2
8000eb1c:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
8000eb20:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
8000eb24:	8f 06 1f 70 	sh %d7,%d6,-16
8000eb28:	4b 73 11 02 	div.u %e0,%d3,%d7
8000eb2c:	b7 06 10 88 	insert %d8,%d6,0,16,16
8000eb30:	0f 24 00 20 	sh %d2,%d4,%d2
8000eb34:	02 05       	mov %d5,%d0
8000eb36:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
8000eb3a:	e2 80       	mul %d0,%d8
8000eb3c:	8f 02 1f b0 	sh %d11,%d2,-16
8000eb40:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000eb44:	82 0c       	mov %d12,0
8000eb46:	7b 10 00 90 	movh %d9,1
8000eb4a:	7f 95 09 80 	jge.u %d5,%d9,8000eb5c <__udiv6432+0x50>
8000eb4e:	8f 01 01 f0 	sh %d15,%d1,16
8000eb52:	0b 0c 00 a0 	add %d10,%d12,%d0
8000eb56:	42 bf       	add %d15,%d11
8000eb58:	7f af 07 80 	jge.u %d15,%d10,8000eb66 <__udiv6432+0x5a>
8000eb5c:	42 71       	add %d1,%d7
8000eb5e:	c2 f5       	add %d5,-1
8000eb60:	a2 8c       	sub %d12,%d8
8000eb62:	3f 91 f4 ff 	jlt.u %d1,%d9,8000eb4a <__udiv6432+0x3e>
8000eb66:	8f 03 01 30 	sh %d3,%d3,16
8000eb6a:	42 3b       	add %d11,%d3
8000eb6c:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
8000eb70:	82 0a       	mov %d10,0
8000eb72:	4b 76 11 02 	div.u %e0,%d6,%d7
8000eb76:	7b 10 00 10 	movh %d1,1
8000eb7a:	02 03       	mov %d3,%d0
8000eb7c:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
8000eb80:	e2 80       	mul %d0,%d8
8000eb82:	7f 13 09 80 	jge.u %d3,%d1,8000eb94 <__udiv6432+0x88>
8000eb86:	8f 06 01 f0 	sh %d15,%d6,16
8000eb8a:	0b 0a 00 90 	add %d9,%d10,%d0
8000eb8e:	42 2f       	add %d15,%d2
8000eb90:	7f 9f 07 80 	jge.u %d15,%d9,8000eb9e <__udiv6432+0x92>
8000eb94:	42 76       	add %d6,%d7
8000eb96:	c2 f3       	add %d3,-1
8000eb98:	a2 8a       	sub %d10,%d8
8000eb9a:	3f 16 f4 ff 	jlt.u %d6,%d1,8000eb82 <__udiv6432+0x76>
8000eb9e:	8f 05 01 50 	sh %d5,%d5,16
8000eba2:	0b 53 00 20 	add %d2,%d3,%d5
8000eba6:	00 90       	ret 
