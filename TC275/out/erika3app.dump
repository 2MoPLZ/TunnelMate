
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x0000e5b8 memsz 0x0000e5b8 flags r-x
    LOAD off    0x00014000 vaddr 0x70000000 paddr 0x8000e5d8 align 2**14
         filesz 0x00000938 memsz 0x00000938 flags rw-
    LOAD off    0x00016600 vaddr 0x5001a600 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x5001b700 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00016600 vaddr 0x6001a600 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x6001b700 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00014938 vaddr 0x70000938 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00000360 flags rw-
    LOAD off    0x00018600 vaddr 0x70018600 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00015700 vaddr 0x70019700 paddr 0x8000ef10 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00017c00 vaddr 0x5001bc00 paddr 0x8000ef40 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00017c00 vaddr 0x6001bc00 paddr 0x8000ef40 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00015c00 vaddr 0x70019c00 paddr 0x8000ef40 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00004020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00001138  80000028  80000028  00004028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .bss          00000360  70000938  8000ef10  00014938  2**3
                  ALLOC
  3 .data         00000938  70000000  8000e5d8  00014000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .traptab      00000100  80001200  80001200  00005200  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ctors        00000008  80001300  80001300  00005300  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .dtors        00000008  80001308  80001308  00005308  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .inttab_cpu0  00002000  80002000  80002000  00006000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text         0000a5d8  80004000  80004000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .CPU2.ustack  00001000  5001a600  8000ef10  00016600  2**3
                  ALLOC, CPU2
 10 .CPU2.istack  00000400  5001b700  8000ef10  00017700  2**3
                  ALLOC, CPU2
 11 .CPU2.csa     00002000  5001bc00  8000ef40  00017c00  2**6
                  ALLOC, CPU2
 12 .CPU1.ustack  00001000  6001a600  8000ef10  00016600  2**3
                  ALLOC, CPU1
 13 .CPU1.istack  00000400  6001b700  8000ef10  00017700  2**3
                  ALLOC, CPU1
 14 .CPU1.csa     00002000  6001bc00  8000ef40  00017c00  2**6
                  ALLOC, CPU1
 15 .CPU0.ustack  00001000  70018600  8000ef10  00018600  2**3
                  ALLOC, CPU0
 16 .CPU0.istack  00000400  70019700  8000ef10  00015700  2**3
                  ALLOC, CPU0
 17 .CPU0.csa     00002000  70019c00  8000ef40  00015c00  2**6
                  ALLOC, CPU0
 18 .comment      00000053  00000000  00000000  00014938  2**0
                  CONTENTS, READONLY
 19 .debug_aranges 00000d28  00000000  00000000  00014990  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_info   000c2efb  00000000  00000000  000156b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_abbrev 0000bfd4  00000000  00000000  000d85b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   0000dfff  00000000  00000000  000e4587  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  000022d8  00000000  00000000  000f2588  2**2
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_str    00002020  00000000  00000000  000f4860  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_loc    00013e71  00000000  00000000  000f6880  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_ranges 00001448  00000000  00000000  0010a6f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .version_info 0004c67a  00000000  00000000  0010bb39  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
70000938 l    d  .bss	00000000 .bss
70000000 l    d  .data	00000000 .data
80001200 l    d  .traptab	00000000 .traptab
80001300 l    d  .ctors	00000000 .ctors
80001308 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 Button_Driver.c
00000000 l    df *ABS*	00000000 asw.c
70000000 l     O .data	00000004 c.15764
00000000 l    df *ABS*	00000000 bsw.c
00000000 l    df *ABS*	00000000 ee_applcfg.c
800000e0 l     O .rodata	0000001c osEE_tdb_ptr_array
800000d4 l     O .rodata	00000004 osEE_res_db_ptr_array
800000fc l     O .rodata	000000e0 osEE_tdb_array
70000030 l     O .data	00000030 osEE_sn_array
800000d8 l     O .rodata	00000008 osEE_res_db_array
70000bf4 l     O .bss	0000000c osEE_res_cb_array
800001dc l     O .rodata	00000008 osEE_sdb_array
70000c00 l     O .bss	00000004 osEE_scb_array
70000060 l     O .data	0000008c osEE_tcb_array
00000000 l    df *ABS*	00000000 IfxVadc.c
800001e4 l     O .rodata	00000006 CSWTCH.25
00000000 l    df *ABS*	00000000 IfxVadc_cfg.c
00000000 l    df *ABS*	00000000 IfxAsclin_PinMap.c
00000000 l    df *ABS*	00000000 IfxAsclin_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
700000f0 l     O .data	00000004 IfxScuCcu_xtalFrequency
80006058 l     F .text	00000034 IfxScuCcu_wait
80000ab8 l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 IfxScu_PinMap.c
00000000 l    df *ABS*	00000000 IfxVadc_Adc.c
80000d54 l     O .rodata	00000040 IfxVadc_Adc_masterIndex
00000000 l    df *ABS*	00000000 infotainment_System.c
70000c08 l     O .bss	00000020 buf
70000c28 l     O .bss	00000004 infoState
70000c2c l     O .bss	0000001c infotainmentArr
80000e34 l     O .rodata	0000001c stateMaxArr
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 impure.c
7000050c l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 vfprintf.c
80000eb0 l     O .rodata	00000010 blanks.4035
80000ea0 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000c81c l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 locale.c
80000edc l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80000f14 l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70000930 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
80009656 l     F .text	0000000e osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 Lcd_Driver.c
8000404e l     F .text	00000060 lcd_write4bits
800040ae l     F .text	00000020 lcd_command
00000000 l    df *ABS*	00000000 IfxAsclin.c
00000000 l    df *ABS*	00000000 IfxAsclin_Asc.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuEru.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 Ifx_CircularBuffer.c
00000000 l    df *ABS*	00000000 Ifx_Fifo.c
00000000 l    df *ABS*	00000000 ultrasonic_Driver.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
80009186 l     F .text	00000054 osEE_tc_stm_us_ticks
70000c48 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
80009664 l     F .text	0000001e osEE_shutdown_os
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
80009f28 l     F .text	00000022 osEE_release_all_m
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
8000a41e l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
8000a5f6 l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 Bsp.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 IfxCpu.c
00000000 l    df *ABS*	00000000 IfxCpu_Irq.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc.c
00000000 l    df *ABS*	00000000 IfxStdIf_DPipe.c
00000000 l    df *ABS*	00000000 IfxStm.c
00000000 l    df *ABS*	00000000 IfxStm_cfg.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc_cfg.c
800003ec g     O .rodata	00000010 IfxAsclin1_TX_P33_12_OUT
80008910 g     F .text	0000001c printStateBlue
800031c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_142
80002d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_105
70000010 g     O .data	00000020 osEE_ccb_var
70000c98 g     O .text	00000001 __HEAP
80003980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_204
8000584c g     F .text	00000062 IfxAsclin_Asc_write
80008c4c g     F .text	00000094 measureEchoTick
800050ea g     F .text	0000000a IfxAsclin_Asc_getWriteEvent
80007174 g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
80002c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_100
800073a8 g     F .text	00000036 IfxScuWdt_setCpuEndinit
80000f20 g     O .rodata	00000028 __mprec_tinytens
80000afc g     O .rodata	00000010 IfxScu_WDT1LCK_P20_7_OUT
80004398 g     F .text	000000e8 mdelay
8000ab9a g     F .text	0000001a .hidden __ashldi3
8000710a g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
800021e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_15
800099d4 g     F .text	0000005a TerminateTask
80005166 g     F .text	00000006 IfxAsclin_Asc_resetSendCount
800001ec g     O .rodata	000000a0 IfxVadc_cfg_srcAddresses
70000bf0 g     O .bss	00000004 osEE_kcb_var
8000039c g     O .rodata	00000010 IfxAsclin2_TX_P14_2_OUT
80002f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_123
80008152 g     F .text	00000020 Ifx_CircularBuffer_addDataIncr
80004c16 g     F .text	00000014 IfxVadc_setScan
8000e23c g     F .text	00000040 .hidden __eqdf2
8000577c g     F .text	00000088 IfxAsclin_Asc_initModuleConfig
8000709e g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
80004888 g     F .text	00000010 IfxVadc_getQueueStatus
00000000 g       *ABS*	00000000 __HEAP_SIZE
80008408 g     F .text	00000176 Ifx_Fifo_read
80004c70 g     F .text	0000001c IfxAsclin_disableModule
8000073c g     O .rodata	00000010 IfxAsclin3_RXC_P20_3_IN
80009ffe g     F .text	00000022 osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80003e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_242
80002300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_24
80003580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_172
80008d1a g     F .text	0000046c osEE_tc_core0_start
800024c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_38
800082ce g     F .text	00000004 Ifx_Fifo_destroy
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
800075e2 g     F .text	00000108 IfxVadc_Adc_getChannelConfig
80004838 g     F .text	00000018 IfxVadc_getAdcAnalogFrequency
70000000 g       *ABS*	00000000 __DSPR0_START
80002be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_95
80002740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_58
8000a47e g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80002c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_97
80006914 g     F .text	00000012 IfxScuCcu_initErayPllConfig
8000a346 g     F .text	00000028 osEE_change_context_from_running
800050dc g     F .text	0000000e IfxAsclin_Asc_getWriteCount
8000075c g     O .rodata	00000010 IfxAsclin3_RXA_P15_7_IN
80007034 g     F .text	00000032 IfxScuEru_setInterruptGatingPattern
80005228 g     F .text	00000014 IfxAsclin_Asc_clearTx
800058ca g     F .text	000000c6 IfxAsclin_Asc_stdIfDPipeInit
80002560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_43
8000b37e g     F .text	00000002 __malloc_unlock
800050c6 g     F .text	0000000a IfxAsclin_Asc_getReadEvent
80004270 g     F .text	00000048 TimerISR
800085b4 g     F .text	000000f0 Ifx_Fifo_canWriteCount
80007f1a g     F .text	000000e8 IfxVadc_Adc_initModule
800032e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_151
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_118
80002c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_99
80004752 g     F .text	0000003c IfxVadc_disablePostCalibration
80002680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_52
80004936 g     F .text	00000028 IfxVadc_getSrcAddress
80004982 g     F .text	00000024 IfxVadc_initialiseAdcConverterClock
80004d9a g     F .text	00000024 IfxAsclin_getOvsFrequency
80009dee g     F .text	00000096 SetEvent
800076ea g     F .text	00000038 IfxVadc_Adc_getChannelConversionTime
80003e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_244
80002380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_28
80006ff6 g     F .text	00000012 IfxScuEru_setEventFlag
80003920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_201
80009f4a g     F .text	0000000a osEE_scheduler_task_wrapper_restore
80000d04 g     O .rodata	00000010 IfxScu_EVRWUPA_P14_1_IN
8000050c g     O .rodata	00000010 IfxAsclin3_SLSO_P12_1_OUT
70019600 g     O .CPU0.ustack	00000000 __USTACK0
80003720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_185
8000dd84 g     F .text	00000050 memmove
8000882c g     F .text	00000002 syncInfoState
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
8000d64a g     F .text	00000056 _Balloc
80000ce4 g     O .rodata	00000010 IfxScu_EXTCLK0_P23_1_OUT
80003b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_216
800007fc g     O .rodata	00000010 IfxAsclin1_RXE_P11_10_IN
800005dc g     O .rodata	00000010 IfxAsclin3_SCLK_P15_8_OUT
8000622e g     F .text	0000004a IfxScuCcu_getModuleFrequency
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_213
800028e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_71
800063a0 g     F .text	000003be IfxScuCcu_init
8000e2bc g     F .text	00000040 .hidden __gtdf2
8000e220  w    F .text	0000000a __errno
800037e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_191
80003380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_156
800096b4 g     F .text	00000042 SuspendAllInterrupts
8000516c g     F .text	00000008 IfxAsclin_Asc_canReadCount
80003180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_140
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_103
00001000 g       *ABS*	00000000 __USTACK0_SIZE
800007dc g     O .rodata	00000010 IfxAsclin1_RXG_P02_3_IN
8000a4ec g     F .text	00000066 osEE_hal_terminate_ctx
8000028c g     O .rodata	00000010 IfxAsclin3_TX_P32_3_OUT
8000a090 g     F .text	00000048 osEE_sn_priority_insert
80003480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_164
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_215
80009cfc g     F .text	00000078 GetTaskState
80008110 g     F .text	00000020 Ifx_CircularBuffer_get32
8000a142 g     F .text	00000022 osEE_task_event_set_mask
8000031c g     O .rodata	00000010 IfxAsclin3_TX_P11_1_OUT
8000074c g     O .rodata	00000010 IfxAsclin3_RXB_P11_0_IN
800073de g     F .text	0000009e IfxScuWdt_initCpuWatchdog
80005b30 g     F .text	00000092 IfxPort_setGroupModeOutput
80002080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_4
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80005f7e g     F .text	00000072 IfxScuCcu_getPllFrequency
80002a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_82
70000c88 g     O .bss	00000004 errno
8000ab0e g     F .text	0000001e .hidden __make_dp
80002e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_114
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
800022a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_21
80001260 g       .traptab	00000000 osEE_tc_trap_context
80007560 g     F .text	00000040 IfxScuWdt_enableWatchdogWithDebugger
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_117
800006ec g     O .rodata	00000010 IfxAsclin3_RXG_P21_3_IN
8000088c g     O .rodata	00000010 IfxAsclin2_RTS_P33_4_OUT
8000054c g     O .rodata	00000010 IfxAsclin2_SLSO_P02_3_OUT
800027e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_63
8000ac2e g     F .text	00000016 .hidden __make_fp
80003560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_171
800044d0 g     F .text	0000007e initVADCChannels
800023c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_30
800002bc g     O .rodata	00000010 IfxAsclin3_TX_P22_0_OUT
800020c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_6
80003780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_188
80000be4 g     O .rodata	00000014 IfxScu_REQ15_P14_1_IN
80000c5c g     O .rodata	00000014 IfxScu_REQ0_P15_4_IN
80002260 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_19
80007066 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
80009eb6 g     F .text	00000058 ClearEvent
800062f2 g     F .text	00000042 IfxScuCcu_getCpuFrequency
80003d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_232
800028a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_69
80009f54 g     F .text	000000aa osEE_scheduler_task_wrapper_run
80003f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_251
800035c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_174
8000062c g     O .rodata	00000010 IfxAsclin3_SCLK_P00_0_OUT
80003700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_184
8000095c g     O .rodata	00000080 IfxPort_cfg_indexMap
800053ce g     F .text	000003ae IfxAsclin_Asc_initModule
8000a2e2 g     F .text	00000026 osEE_scheduler_task_preemption_point
8000422e g     F .text	00000014 FuncTaskUltrasonic
8000d62e g     F .text	0000001c memcpy
800021c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_14
800041ec g     F .text	0000003e FuncTask1
8000b678 g     F .text	000011a4 _svfprintf_r
8000aac6 g     F .text	00000048 .hidden __floatsidf
80007722 g     F .text	0000023e IfxVadc_Adc_getGroupConfig
80006ec8 g     F .text	00000026 IfxScuEru_enablePatternDetectionTrigger
8000a0d8 g     F .text	0000000e osEE_scheduler_rq_insert
80002940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_74
8000e33c g     F .text	00000040 .hidden __ltdf2
8000492c g     F .text	0000000a IfxVadc_getScanStatus
80001310 g       .dtors	00000000 __DTOR_END__
80006926 g     F .text	00000076 IfxScuCcu_setCpuFrequency
80007008 g     F .text	0000002c IfxScuEru_setFlagPatternDetection
8000a38e g     F .text	00000026 osEE_idle_task_terminate
80000c48 g     O .rodata	00000014 IfxScu_REQ10_P14_3_IN
80003c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_228
8000882e g     F .text	00000002 updatePacket
8000087c g     O .rodata	00000010 IfxAsclin3_RTS_P00_9_OUT
800006ac g     O .rodata	00000010 IfxAsclin1_SCLK_P20_10_OUT
8000dbf0 g     F .text	00000042 __fpclassifyd
800023a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_29
800070d6 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
80003a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_211
80002340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_26
80007270 g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
80002540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_42
8000a21c g     F .text	0000003c osEE_scheduler_task_unblocked
80002960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_75
80003820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_193
800033c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_158
8000aec8 g     F .text	0000000c malloc
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_102
80006d38 g     F .text	00000028 IfxScuEru_clearInputChannelConfiguration
00000000 g       *ABS*	00000000 NULL
8000070c g     O .rodata	00000010 IfxAsclin3_RXF_P21_6_IN
80009564 g     F .text	0000001e osEE_tc_stm_set_sr0_next_match
80001240 g       .traptab	00000000 osEE_tc_trap_instruction
80000f70 g     O .rodata	000000c8 __mprec_tens
70000008 g     O .data	00000004 g_vadcChannelIDs
80005210 g     F .text	00000008 IfxAsclin_Asc_canWriteCount
80004242 g     F .text	0000002e ButtonISR
80009aa2 g     F .text	000000b2 GetResource
800003ac g     O .rodata	00000010 IfxAsclin2_TX_P10_5_OUT
8000049c g     O .rodata	00000010 IfxAsclin0_TX_P15_2_OUT
8000b3fc g     F .text	00000016 vsnprintf
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_214
800029a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_77
800008dc g     O .rodata	00000010 IfxAsclin3_CTSA_P00_12_IN
800038a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_197
70000c80 g     O .bss	00000004 __malloc_top_pad
80004570 g     F .text	00000026 readADCValue
800088a0 g     F .text	0000001c printStateOn
8000699c g     F .text	0000008e IfxScuCcu_setGtmFrequency
80005cbc g     F .text	00000064 IfxPort_setPinModeLvdsHigh
8000a4a2 g     F .text	0000002c osEE_hal_ready2stacked
80002660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_51
80000bbc g     O .rodata	00000014 IfxScu_REQ1_P15_8_IN
8000827e g     F .text	00000050 Ifx_CircularBuffer_write32
8000d60c g     F .text	0000000a _localeconv_r
80003460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_163
80004d60 g     F .text	00000022 IfxAsclin_getIndex
8000d7dc g     F .text	00000010 __i2b
80009a2e g     F .text	00000074 Schedule
80004dbe g     F .text	00000016 IfxAsclin_getShiftFrequency
80007960 g     F .text	000001ec IfxVadc_Adc_initChannel
80003f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_250
800002ac g     O .rodata	00000010 IfxAsclin3_TX_P22_1_OUT
80006bfe g     F .text	00000112 IfxScuCcu_switchToBackupClock
80003100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_136
800006cc g     O .rodata	00000010 IfxAsclin0_SCLK_P15_2_OUT
800072cc g     F .text	00000072 IfxScuWdt_enableSafetyWatchdog
80002060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_3
80003e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_240
8000b380 g     F .text	0000001e _sbrk_r
8000045c g     O .rodata	00000010 IfxAsclin1_TX_P11_12_OUT
80000c7c g     O .rodata	0000000c IfxScu_HWCFG5_P10_6_IN
8000046c g     O .rodata	00000010 IfxAsclin1_TX_P02_2_OUT
80003040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_130
800088f4 g     F .text	0000001c printStateGreen
80002b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_89
800025c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_46
70000958 g     O .bss	0000000c g_vadcGroup
80006e7c g     F .text	00000026 IfxScuEru_enableAutoClear
800006bc g     O .rodata	00000010 IfxAsclin1_SCLK_P15_0_OUT
800027a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_61
80002800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_64
8000ad56 g     F .text	000000ac .hidden __unpack_d
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
80005d62 g     F .text	0000003c IfxPort_setPinPadDriver
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_246
80002480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_36
8000041c g     O .rodata	00000010 IfxAsclin1_TX_P15_4_OUT
70000c7c g     O .bss	00000004 __malloc_max_sbrked_mem
80002a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_81
800012a0 g       .traptab	00000000 osEE_tc_trap_assertion
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_93
80008000 g       *ABS*	00000000 __A1_MEM
8000a5c4 g     F .text	00000032 .hidden __extendsfdf2
80002700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_56
80004cd6 g     F .text	00000016 IfxAsclin_getAddress
8000a792 g     F .text	00000038 .hidden __adddf3
800041a8 g     F .text	0000000e lcd_goto
80009860 g     F .text	0000001a GetActiveApplicationMode
80006278 g     F .text	0000007a IfxScuCcu_getSriFrequency
80008c30 g     F .text	0000001c sendTrigger
800030c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_134
800096f6 g     F .text	00000026 ResumeAllInterrupts
800036c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_182
800038e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_199
80006b7e g     F .text	00000080 IfxScuCcu_setSriFrequency
8000e46a g     F .text	00000026 .hidden __umoddi3
80003740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_186
70019c00 g     O .CPU0.csa	00000000 __CSA0
80003840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_194
800033e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_159
80003280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_148
80002180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_12
800008ac g     O .rodata	00000010 IfxAsclin1_RTS_P23_1_OUT
80000e64 g     O .rodata	00000004 _global_impure_ptr
80006d88 g     F .text	00000036 IfxScuEru_connectTrigger
70000938 g     O .bss	00000020 g_vadcChannel
80006334 g     F .text	00000036 IfxScuCcu_getFsi2Frequency
8000dde4 g     F .text	000003f0 _realloc_r
8000068c g     O .rodata	00000010 IfxAsclin1_SCLK_P33_12_OUT
80004e10 g     F .text	00000012 IfxAsclin_read16
80008830 g     F .text	0000001c printStateLv1
80005a64 g     F .text	0000003c IfxPort_enableEmergencyStop
800002dc g     O .rodata	00000010 IfxAsclin3_TX_P20_3_OUT
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_254
8000e3ca g     F .text	000000a0 .hidden __udivdi3
8000085c g     O .rodata	00000010 IfxAsclin0_RXB_P15_3_IN
800002ec g     O .rodata	00000010 IfxAsclin3_TX_P20_0_OUT
70008000 g       *ABS*	00000000 __A0_MEM
8000a020 g     F .text	00000070 osEE_scheduler_core_rq_preempt_stk
800004ac g     O .rodata	00000010 IfxAsclin0_TX_P14_1_OUT
800040ce g     F .text	0000000a lcd_clear
80000f48 g     O .rodata	00000028 __mprec_bigtens
8000e22a g     F .text	00000012 abort
8000ab68 g     F .text	00000032 .hidden __floatunsidf
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_85
8000da3c g     F .text	00000042 __mcmp
800038c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_198
8000523c g     F .text	0000001c IfxAsclin_Asc_read
8000987a g     F .text	00000084 ActivateTask
80000bf8 g     O .rodata	00000014 IfxScu_REQ14_P02_1_IN
80003300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_152
80006de4 g     F .text	00000026 IfxScuEru_disableFallingEdgeDetection
80002040 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_2
80002de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_111
800082d2 g     F .text	0000003a Ifx_Fifo_init
800088d8 g     F .text	0000001c printStateRed
80002420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_33
70000c90  w    O .bss	00000004 _my_errno
800004ec g     O .rodata	00000010 IfxAsclin3_SLSO_P21_2_OUT
80005990 g     F .text	00000030 IfxPort_getAddress
80003760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_187
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
8000090c g     O .rodata	00000010 IfxAsclin1_CTSB_P32_4_IN
80009ca4 g     F .text	00000058 GetTaskID
80006772 g     F .text	000001a2 IfxScuCcu_initErayPll
8000038c g     O .rodata	00000010 IfxAsclin2_TX_P14_3_OUT
80003de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_239
8000032c g     O .rodata	00000010 IfxAsclin3_TX_P11_0_OUT
80000a64 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
80006f3a g     F .text	0000000e IfxScuEru_getAllEventFlagsStatus
80000ca0 g     O .rodata	0000000c IfxScu_HWCFG2EVR13_P14_2_IN
8000971c g     F .text	0000005c SuspendOSInterrupts
80003a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_210
800071a6 g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
8000abb4 g     F .text	0000007a .hidden __unpack_f
800094ac g     F .text	00000034 osEE_tc_stm_set_clockpersec
80003a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_208
8000454e g     F .text	00000022 initADC
800031e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_143
80002d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_106
8000a308 g     F .text	0000003e osEE_scheduler_task_set_running
b0008000 g     O *ABS*	00000000 _SMALL_DATA4_
80009582 g     F .text	0000008e osEE_tc_stm_set_sr1
8000072c g     O .rodata	00000010 IfxAsclin3_RXD_P32_2_IN
80004638 g     F .text	0000000c asclin0TxISR
8000060c g     O .rodata	00000010 IfxAsclin3_SCLK_P11_1_OUT
80007200 g     F .text	00000070 IfxScuWdt_disableSafetyWatchdog
80002c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_96
8000755c g     F .text	00000004 IfxScuWdt_serviceSafetyWatchdog
8000078c g     O .rodata	00000010 IfxAsclin2_RXE_P33_8_IN
8000063c g     O .rodata	00000010 IfxAsclin2_SCLK_P33_9_OUT
8000d734 g     F .text	00000042 __hi0bits
80002760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_59
8000082c g     O .rodata	00000010 IfxAsclin1_RXB_P15_5_IN
80002e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_115
800003fc g     O .rodata	00000010 IfxAsclin1_TX_P20_10_OUT
8000040c g     O .rodata	00000010 IfxAsclin1_TX_P15_5_OUT
8000e37c g     F .text	0000004e .hidden __fixdfsi
80003160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_139
8000a186 g     F .text	00000068 osEE_scheduler_task_activated
8000608c g     F .text	00000078 IfxScuCcu_getBbbFrequency
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
8000033c g     O .rodata	00000010 IfxAsclin3_TX_P00_1_OUT
800004bc g     O .rodata	00000010 IfxAsclin0_TX_P14_0_OUT
80002f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_121
8000636a g     F .text	00000036 IfxScuCcu_getFsiFrequency
80000b0c g     O .rodata	00000010 IfxScu_WDT0LCK_P20_8_OUT
80002100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_8
80002580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_44
80003d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_234
800032a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_149
8000713e g     F .text	00000036 IfxScuWdt_clearCpuEndinit
80008ce0 g     F .text	00000024 getUltrasonic
80002e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_113
80003320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_153
800025e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_47
800022e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_23
8000065c g     O .rodata	00000010 IfxAsclin2_SCLK_P14_2_OUT
80004f06 g     F .text	00000182 IfxAsclin_setBitTiming
80000cc4 g     O .rodata	00000010 IfxScu_EXTCLK1_P32_4_OUT
800004cc g     O .rodata	00000010 IfxAsclin3_SLSO_P33_1_OUT
800002fc g     O .rodata	00000010 IfxAsclin3_TX_P15_7_OUT
8000884c g     F .text	0000001c printStateLv2
8000080c g     O .rodata	00000010 IfxAsclin1_RXD_P14_8_IN
80000c88 g     O .rodata	0000000c IfxScu_HWCFG4_P10_5_IN
800075a0 g     F .text	00000026 IfxVadc_Adc_deInitGroup
8000a552 g     F .text	00000026 .hidden __lshrdi3
8000071c g     O .rodata	00000010 IfxAsclin3_RXE_P00_1_IN
80008a8e g     F .text	00000008 initInfotainment
800039a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_205
8000084c g     O .rodata	00000010 IfxAsclin0_RXD_P34_2_IN
800005ac g     O .rodata	00000010 IfxAsclin3_SCLK_P21_7_OUT
80007b62 g     F .text	0000038a IfxVadc_Adc_initGroup
8000d906 g     F .text	0000007c __pow5mult
80002140 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_10
70000968 g     O .bss	0000000c g_ERUconfig
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_255
80002860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_67
80002e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_112
80006e30 g     F .text	00000026 IfxScuEru_disableRisingEdgeDetection
8000056c g     O .rodata	00000010 IfxAsclin1_SLSO_P20_8_OUT
8000a258 g     F .text	0000008a osEE_scheduler_task_terminated
8000034c g     O .rodata	00000010 IfxAsclin3_TX_P00_0_OUT
80002460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_35
800036a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_181
8000ae02 g     F .text	000000c6 .hidden __pack_f
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_245
80008172 g     F .text	0000005e Ifx_CircularBuffer_read8
8000089c g     O .rodata	00000010 IfxAsclin2_RTS_P10_8_OUT
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
80003b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_219
80002360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_27
800037a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_189
8000738e g     F .text	0000001a IfxScuWdt_initConfig
80001300 g       .ctors	00000000 __CTOR_LIST__
80009408 g     F .text	000000a4 osEE_tc_get_fsource
80004e22 g     F .text	00000012 IfxAsclin_read32
80000c20 g     O .rodata	00000014 IfxScu_REQ12_P11_10_IN
8000747c g     F .text	00000004 IfxScuWdt_serviceCpuWatchdog
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_247
800008cc g     O .rodata	00000010 IfxAsclin0_RTS_P14_7_OUT
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_86
8000079c g     O .rodata	00000010 IfxAsclin2_RXD_P10_6_IN
800094e0 g     F .text	00000084 osEE_tc_stm_set_sr0
80000b1c g     O .rodata	00000014 IfxScu_REQ9_P20_0_IN
8000066c g     O .rodata	00000010 IfxAsclin2_SCLK_P10_6_OUT
80002e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_116
8000a4ce g     F .text	0000001e osEE_tc_change_context_from_isr2_end
80002a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_83
8000d616 g     F .text	00000018 memchr
80003400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_160
8000b4cc g     F .text	000001ac _free_r
80005804 g     F .text	00000048 IfxAsclin_Asc_initiateTransmission
80002220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_17
800023e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_31
80009f0e g     F .text	00000018 GetISRID
80008868 g     F .text	0000001c printStateLv3
8000a440 g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
80001280 g       .traptab	00000000 osEE_tc_trap_bus
80005da0 g     F .text	000000f8 IfxScuCcu_calculateSysPllDividers
800008ec g     O .rodata	00000010 IfxAsclin2_CTSB_P33_5_IN
700000f8 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80003520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_169
80008a96 g     F .text	0000009c updateInfoState
8000830c g     F .text	00000022 Ifx_Fifo_create
80003f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_249
8000735e g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800012e0 g       .traptab	00000000 osEE_tc_trap_nmi
800020a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_5
8000d982 g     F .text	000000ba __lshift
80003600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_176
8000064c g     O .rodata	00000010 IfxAsclin2_SCLK_P33_7_OUT
800075c6 g     F .text	0000001c IfxVadc_Adc_disableModule
00002000 g       *ABS*	00000000 __CSA_SIZE
8000dc32 g     F .text	000000f0 __ssprint_r
80004850 g     F .text	0000001a IfxVadc_getAdcDigitalFrequency
5001bc00 g       .CPU2.csa	00000000 __CSA2
800034a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_165
80003c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_227
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
800046d4 g     F .text	00000038 IfxVadc_enableAccess
800027c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_62
8000d7ec g     F .text	0000011a __multiply
00000001 g       *ABS*	00000000 _.
80006f48 g     F .text	00000012 IfxScuEru_getEventFlagStatus
800041b6 g     F .text	00000036 lcd_print
8000052c g     O .rodata	00000010 IfxAsclin2_SLSO_P33_6_OUT
8000037c g     O .rodata	00000010 IfxAsclin2_TX_P32_5_OUT
80004b9c g     F .text	00000024 IfxVadc_selectPowerSupplyVoltage
80006e0a g     F .text	00000026 IfxScuEru_disablePatternDetectionTrigger
70000c50 g     O .bss	00000028 __malloc_current_mallinfo
8000db48 g     F .text	000000a8 __d2b
80003c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_226
800037c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_190
80003360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_155
800026c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_54
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_125
800088bc g     F .text	0000001c printStateOff
80002b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_91
80000b58 g     O .rodata	00000014 IfxScu_REQ6_P02_0_IN
80008130 g     F .text	00000022 Ifx_CircularBuffer_get16
8000044c g     O .rodata	00000010 IfxAsclin1_TX_P14_10_OUT
80003680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_180
80005f3a g     F .text	00000044 IfxScuCcu_getPllErayVcoFrequency
80001300 g       .ctors	00000000 __EH_FRAME_END__
80006dbe g     F .text	00000026 IfxScuEru_disableAutoClear
80006a2a g     F .text	00000050 IfxScuCcu_setPll2ErayFrequency
6001bb00 g       .CPU1.istack	00000000 __ISTACK1
80003800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_192
800033a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_157
80006194 g     F .text	00000022 IfxScuCcu_getBaud2Frequency
80003240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_146
80002da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_109
800005ec g     O .rodata	00000010 IfxAsclin3_SCLK_P15_6_OUT
8000e490 g     F .text	000000a6 .hidden __fpcmp_parts_d
80004cba g     F .text	0000001c IfxAsclin_enableModule
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
8000a0e6 g     F .text	00000026 osEE_scheduler_core_pop_running
800021a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_13
80003f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_252
8000a3b4 g     F .text	0000006a osEE_cpu_startos
80003b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_218
80006eee g     F .text	00000026 IfxScuEru_enableRisingEdgeDetection
800007cc g     O .rodata	00000010 IfxAsclin2_RXA_P14_3_IN
80003e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_241
800029c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_78
800059c0 g     F .text	00000022 IfxPort_getIndex
800030a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_133
80009e84 g     F .text	00000032 GetEvent
800053b2 g     F .text	0000001c IfxAsclin_Asc_disableModule
8000a578 g     F .text	0000004c .hidden __floatundisf
6001b600 g       .CPU1.ustack	00000000 __USTACK1
80004e34 g     F .text	00000012 IfxAsclin_read8
8000a1ee g     F .text	0000002e osEE_scheduler_task_insert
80003be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_223
80002620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_49
8000a9ae g     F .text	00000118 .hidden __divdf3
80000d24 g     O .rodata	00000010 IfxScu_EMGSTOPA_P33_8_IN
80000cd4 g     O .rodata	00000010 IfxScu_EXTCLK1_P11_12_OUT
800058ae g     F .text	0000001c IfxAsclin_Asc_blockingWrite
80008002 g     F .text	0000003a IfxVadc_Adc_initModuleConfig
70000100 g     O .data	00000408 __malloc_av_
80002f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_120
80009c40 g     F .text	00000064 ShutdownOS
80003060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_131
8000b3b2 g     F .text	0000004a _vsnprintf_r
800035e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_175
70018600 g     O .CPU0.ustack	00000000 __USTACK0_END
80003900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_200
80002120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_9
8000a80a g     F .text	000001a4 .hidden __muldf3
80002500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_40
800006dc g     O .rodata	00000010 IfxAsclin0_SCLK_P14_0_OUT
80002520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_41
80008bc2 g     F .text	0000006e delay_us
80000d14 g     O .rodata	00000010 IfxScu_EMGSTOPB_P21_2_IN
8000b37c g     F .text	00000002 __malloc_lock
8000e1e4 g     F .text	0000003c sbrk
80005e98 g     F .text	0000000e IfxScuCcu_getOsc0Frequency
8000469c g     F .text	00000038 IfxVadc_disableAccess
80000000 g       .startup	00000000 BootModeHeader0
800012c0 g       .traptab	00000000 osEE_tc_trap_system
80000c94 g     O .rodata	0000000c IfxScu_HWCFG3_BMI_P14_3_IN
80004dfc g     F .text	00000014 IfxAsclin_getSrcPointerTx
80004898 g     F .text	00000094 IfxVadc_getResultBasedOnRequestSource
8000dd22 g     F .text	00000062 _calloc_r
00002000 g       *ABS*	00000000 __CSA0_SIZE
800061b6 g     F .text	00000078 IfxScuCcu_getSpbFrequency
80002820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_65
800007bc g     O .rodata	00000010 IfxAsclin2_RXB_P02_1_IN
8000478e g     F .text	000000aa IfxVadc_enableGroupSync
80006fa2 g     F .text	00000012 IfxScuEru_getPatternDetectionResult
800024a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_37
80005258 g     F .text	0000009e IfxAsclin_Asc_isrTransmit
8000036c g     O .rodata	00000010 IfxAsclin2_TX_P33_8_OUT
80003d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_233
80003960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_203
8000ddd4 g     F .text	00000010 memset
800034e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_167
80002640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_50
800040d8 g     F .text	000000d0 lcd_init
80004644 g     F .text	00000058 main
8000733e g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
80008b58 g     F .text	0000006a delay_ms
80006f14 g     F .text	00000026 IfxScuEru_enableTriggerPulse
80002200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_16
70000c78 g     O .bss	00000004 __malloc_max_total_mem
80003540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_170
80004c8c g     F .text	0000002e IfxAsclin_enableAscErrorFlags
8000e536 g     F .text	0000009c .hidden __udiv6432
00000400 g       *ABS*	00000000 __ISTACK_SIZE
80006174 g     F .text	00000020 IfxScuCcu_getBaud1Frequency
800025a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_45
8000807e g     F .text	00000092 IfxVadc_Adc_initExternalMultiplexerMode
80000bd0 g     O .rodata	00000014 IfxScu_REQ16_P15_1_IN
70000974 g     O .bss	0000027c g_AsclinAsc
80002b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_88
80000c70 g     O .rodata	0000000c IfxScu_HWCFG6_P14_4_IN
8000a10c g     F .text	00000018 osEE_task_activated
5001bb00 g       .CPU2.istack	00000000 __ISTACK2
800000b8 g     O .rodata	00000014 osEE_kdb_var
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
8000737a g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
8000ab2c g     F .text	0000003c .hidden __truncdfsf2
80003b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_220
80003020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_129
8000c938 g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000aee2 g     F .text	0000049a _malloc_r
800004dc g     O .rodata	00000010 IfxAsclin3_SLSO_P21_6_OUT
80005d20 g     F .text	00000042 IfxPort_setPinModeLvdsMedium
800007ac g     O .rodata	00000010 IfxAsclin2_RXC_P02_10_IN
800039e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_207
8000538c g     F .text	00000026 IfxAsclin_Asc_blockingRead
80003d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_235
800024e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_39
80002020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_1
8000059c g     O .rodata	00000010 IfxAsclin3_SCLK_P32_3_OUT
800050c0 g     F .text	00000006 IfxAsclin_Asc_getReadCount
80002a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_80
80008000 g       *ABS*	00000000 __A8_MEM
8000058c g     O .rodata	00000010 IfxAsclin3_SCLK_P33_2_OUT
b0008000 g       *ABS*	00000000 __A9_MEM
8000509c g     F .text	00000012 IfxAsclin_write32
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_231
80003340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_154
80002c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_98
8000432a g     F .text	0000006e printfSerial
80000e50 g     O .rodata	00000014 .hidden __thenan_df
8000b412 g     F .text	000000ba _malloc_trim_r
80001308 g       .ctors	00000000 __CTOR_END__
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
800003bc g     O .rodata	00000010 IfxAsclin2_TX_P02_9_OUT
80004aa0 g     F .text	000000aa IfxVadc_getChannelConversionTime
50000000 g       *ABS*	00000000 __DSPR2_START
800028c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_70
8000470c g     F .text	00000046 IfxVadc_configExternalMultiplexerMode
8000422a g     F .text	00000004 FuncTaskLCD
80009b54 g     F .text	000000ec ReleaseResource
8000803c g     F .text	00000042 IfxVadc_Adc_initExternalMultiplexerModeConfig
80004d82 g     F .text	00000018 IfxAsclin_getPdFrequency
8000486e g     F .text	0000001a IfxVadc_getBackgroundScanStatus
80003da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_237
80001308 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
80003c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_224
800026a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_53
00001000 g       *ABS*	00000000 __USTACK1_SIZE
80002b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_90
80004b4a g     F .text	00000052 IfxVadc_resetKernel
800008bc g     O .rodata	00000010 IfxAsclin1_RTS_P20_6_OUT
80000cb8 g     O .rodata	0000000c IfxScu_HWCFG0DCLDO_P14_6_IN
8000e27c g     F .text	00000040 .hidden __nedf2
80004eb4 g     F .text	00000052 IfxAsclin_setBaudrateBitFields
80003a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_209
80003880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_196
80005ff0 g     F .text	00000044 IfxScuCcu_getPllVcoFrequency
80006aca g     F .text	000000b4 IfxScuCcu_setSpbFrequency
80003220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_145
80002d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_108
80006f7e g     F .text	00000024 IfxScuEru_getOutputChannelConfiguration
80000aec g     O .rodata	00000010 IfxScu_WDT2LCK_P20_6_OUT
800009dc g     O .rodata	00000080 IfxPort_cfg_esrMasks
80002a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_84
800006fc g     O .rodata	00000010 IfxAsclin3_RXG_P21_2_IN
80003500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_168
80005218 g     F .text	00000010 IfxAsclin_Asc_clearRx
8000092c g     O .rodata	00000010 IfxAsclin0_CTSA_P14_9_IN
80002400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_32
80003000 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_128
80000d44 g     O .rodata	00000010 IfxScu_DCDCSYNC_P32_2_OUT
80005a3a g     F .text	0000002a IfxPort_setESR
800004fc g     O .rodata	00000010 IfxAsclin3_SLSO_P14_3_OUT
80003620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_177
8000043c g     O .rodata	00000010 IfxAsclin1_TX_P15_0_OUT
80003120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_137
80002900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_72
8000091c g     O .rodata	00000010 IfxAsclin1_CTSA_P20_7_IN
80002600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_48
80000b94 g     O .rodata	00000014 IfxScu_REQ3_P10_3_IN
8000042c g     O .rodata	00000010 IfxAsclin1_TX_P15_1_OUT
70000508 g     O .data	00000004 _impure_ptr
80003660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_179
800059e2 g     F .text	00000028 IfxPort_resetESR
800050f4 g     F .text	00000072 IfxAsclin_Asc_isrError
8000495e g     F .text	00000024 IfxVadc_initialiseAdcArbiterClock
80004de8 g     F .text	00000014 IfxAsclin_getSrcPointerRx
800036e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_183
8000048c g     O .rodata	00000010 IfxAsclin0_TX_P15_3_OUT
80008b34 g     F .text	00000024 initUltrasonic
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_230
80004dd4 g     F .text	00000014 IfxAsclin_getSrcPointerEr
00002000 g       *ABS*	00000000 __CSA1_SIZE
800022c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_22
800003dc g     O .rodata	00000010 IfxAsclin1_TX_P33_13_OUT
8000081c g     O .rodata	00000010 IfxAsclin1_RXC_P20_9_IN
80009682 g     F .text	00000016 DisableAllInterrupts
80008220 g     F .text	0000005e Ifx_CircularBuffer_write8
800052f6 g     F .text	00000096 IfxAsclin_Asc_isrReceive
80005aa0 g     F .text	00000090 IfxPort_setGroupModeInput
8000832e g     F .text	000000da Ifx_Fifo_canReadCount
00001000 g       *ABS*	00000000 __USTACK_SIZE
800098fe g     F .text	000000d6 ChainTask
80006fc2 g     F .text	00000034 IfxScuEru_selectExternalInput
80006ea2 g     F .text	00000026 IfxScuEru_enableFallingEdgeDetection
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_101
800008fc g     O .rodata	00000010 IfxAsclin2_CTSA_P10_7_IN
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
8000077c g     O .rodata	00000010 IfxAsclin2_RXF_P32_6_IN
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_126
800005fc g     O .rodata	00000010 IfxAsclin3_SCLK_P11_4_OUT
8000675e g     F .text	00000014 IfxScuCcu_initConfig
80003b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_217
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_221
800002cc g     O .rodata	00000010 IfxAsclin3_TX_P21_7_OUT
800049d0 g     F .text	00000066 IfxVadc_initializeFAdcI
8000053c g     O .rodata	00000010 IfxAsclin2_SLSO_P10_5_OUT
80000b30 g     O .rodata	00000014 IfxScu_REQ8_P33_7_IN
8000029c g     O .rodata	00000010 IfxAsclin3_TX_P32_2_OUT
80001200 g       .traptab	00000000 osEE_tc_trap_mmu
800081d0 g     F .text	00000050 Ifx_CircularBuffer_read32
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_87
80005174 g     F .text	0000009c IfxAsclin_Asc_flushTx
8000962e g     F .text	00000028 osEE_tc_delay
8000061c g     O .rodata	00000010 IfxAsclin3_SCLK_P00_2_OUT
80001038 g     O .rodata	00000000 __clear_table
80005ed6 g     F .text	00000064 IfxScuCcu_getPllErayFrequency
800007ec g     O .rodata	00000010 IfxAsclin1_RXF_P33_13_IN
8000a124 g     F .text	0000001e osEE_task_end
800005cc g     O .rodata	00000010 IfxAsclin3_SCLK_P20_0_OUT
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_110
80002f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_124
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_222
80002240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_18
80002440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_34
8000083c g     O .rodata	00000010 IfxAsclin1_RXA_P15_1_IN
80001300 g       .ctors	00000000 __EH_FRAME_BEGIN__
8000051c g     O .rodata	00000010 IfxAsclin3_SLSO_P00_3_OUT
80002840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_66
80003140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_138
80003e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_243
80006034 g     F .text	00000024 IfxScuCcu_getSourceFrequency
8000047c g     O .rodata	00000010 IfxAsclin0_TX_P34_1_OUT
80000d34 g     O .rodata	00000010 IfxScu_DCDCSYNC_P33_13_OUT
80000c0c g     O .rodata	00000014 IfxScu_REQ13_P15_5_IN
8000a36e g     F .text	00000020 osEE_change_context_from_task_end
80009d74 g     F .text	0000007a WaitEvent
80005a0a g     F .text	00000030 IfxPort_disableEmergencyStop
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_253
80003c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_225
80008d04 g     F .text	00000016 calculateDistanceCm
8000030c g     O .rodata	00000010 IfxAsclin3_TX_P15_6_OUT
80002880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_68
80007eec g     F .text	0000002e IfxVadc_Adc_initGroupConfig
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
80002980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_76
5001b600 g       .CPU2.ustack	00000000 __USTACK2
80003940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_202
80009610 g     F .text	0000001e osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80003260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_147
80000020 g       .startup	00000000 BootModeIndex
800032c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_150
80003d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_236
700000fc g     O .data	00000004 __malloc_trim_threshold
800031a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_141
80002d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_104
8000486a g     F .text	00000004 IfxVadc_getAdcModuleFrequency
800086a4 g     F .text	00000186 Ifx_Fifo_write
8000da7e g     F .text	000000ca __mdiff
800020e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_7
80002920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_73
8000a164 g     F .text	00000022 osEE_activate_isr2
80007b4c g     F .text	00000016 IfxVadc_Adc_initChannelConfig
80004cec g     F .text	00000074 IfxAsclin_getFaFrequency
80006a7a g     F .text	00000050 IfxScuCcu_setPll2Frequency
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_238
80020000 g       .startup	00000000 BootModeHeader1
800091da g     F .text	0000022e osEE_tc_set_pll_fsource
800049a6 g     F .text	0000002a IfxVadc_initializeFAdcD
800042b8 g     F .text	00000072 UART_init
80005bc2 g     F .text	000000a4 IfxPort_setGroupPadDriver
800026e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_55
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_127
80002b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_92
80000cf4 g     O .rodata	00000010 IfxScu_EVRWUPB_P15_1_IN
8000086c g     O .rodata	00000010 IfxAsclin0_RXA_P14_1_IN
80008884 g     F .text	0000001c printStateLv4
800050ae g     F .text	00000012 IfxAsclin_write8
80006fb4 g     F .text	0000000e IfxScuEru_getWholePatternDetectionResult
80002320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_25
800039c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_206
800029e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_79
800010a0 g     O .rodata	00000000 __copy_table
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
80005088 g     F .text	00000014 IfxAsclin_write16
8000857e g     F .text	00000036 Ifx_Fifo_clear
80000ba8 g     O .rodata	00000014 IfxScu_REQ2_P10_2_IN
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_119
8000e1d4 g     F .text	00000010 _exit
80002280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_20
80001220 g       .traptab	00000000 osEE_tc_trap_protection
80001200 g     F .traptab	00000000 __TRAPTAB
80000c34 g     O .rodata	00000014 IfxScu_REQ11_P20_9_IN
00002000 g       *ABS*	00000000 __CSA2_SIZE
80006d60 g     F .text	00000028 IfxScuEru_clearOutputChannelConfiguration
800035a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_173
80006e56 g     F .text	00000026 IfxScuEru_disableTriggerPulse
800074b2 g     F .text	000000aa IfxScuWdt_initSafetyWatchdog
800050d0 g     F .text	00000006 IfxAsclin_Asc_getSendCount
8000b39e g     F .text	00000014 strlen
80003860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_195
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
80004e92 g     F .text	00000022 IfxAsclin_setClockSource
8000e2fc g     F .text	00000040 .hidden __gedf2
80000a5c g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
80004596 g     F .text	000000a2 initPeripheralsAndERU
8000076c g     O .rodata	00000010 IfxAsclin2_RXG_P02_0_IN
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_94
80002720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_57
80003420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_161
800003cc g     O .rodata	00000010 IfxAsclin2_TX_P02_0_OUT
80002f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_122
80000b6c g     O .rodata	00000014 IfxScu_REQ5_P10_8_IN
80004bc0 g     F .text	00000056 IfxVadc_setArbiterPriority
70000c98 g     O .text	00000001 __HEAP_END
8000055c g     O .rodata	00000010 IfxAsclin1_SLSO_P33_10_OUT
6001bc00 g       .CPU1.csa	00000000 __CSA1
80006104 g     F .text	00000070 IfxScuCcu_getMaxFrequency
80009698 g     F .text	0000001c EnableAllInterrupts
8000057c g     O .rodata	00000010 IfxAsclin1_SLSO_P14_3_OUT
80004c2a g     F .text	00000044 IfxVadc_startupCalibration
70000964 g     O .bss	00000004 g_vadc
80005c66 g     F .text	00000056 IfxPort_setPinMode
80003640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_178
80002780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_60
80000b44 g     O .rodata	00000014 IfxScu_REQ7_P00_4_IN
8000a464 g     F .text	0000001a osEE_hal_restore_ctx
8000449e g     F .text	00000032 initVADCGroup
800005bc g     O .rodata	00000010 IfxAsclin3_SCLK_P21_5_OUT
8000a7ca g     F .text	00000040 .hidden __subdf3
70008000 g     O *ABS*	00000000 _SMALL_DATA_
800050d6 g     F .text	00000006 IfxAsclin_Asc_getTxTimeStamp
80004a36 g     F .text	0000006a IfxVadc_isPostCalibration
80004480 g     F .text	0000001e initVADCModule
80003f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_248
80006d22 g     F .text	00000016 IfxScuEru_clearEventFlag
80007480 g     F .text	00000032 IfxScuWdt_setSafetyEndinit
8000d776 g     F .text	00000066 __lo0bits
800034c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_166
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
8000035c g     O .rodata	00000010 IfxAsclin2_TX_P33_9_OUT
80003080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_132
80005ea6 g     F .text	00000030 IfxScuCcu_getOscFrequency
80009778 g     F .text	0000003c ResumeOSInterrupts
80004000 g     F .text	0000004e readLcdButtons
800030e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_135
80004e46 g     F .text	0000004c IfxAsclin_resetModule
80006f5a g     F .text	00000024 IfxScuEru_getInputChannelConfiguration
8000067c g     O .rodata	00000010 IfxAsclin2_SCLK_P02_4_OUT
80006d10 g     F .text	00000012 IfxScuEru_clearAllEventFlags
80003200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_144
80002d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_107
80002160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_11
800000cc g     O .rodata	00000008 osEE_cdb_var
8000ac44 g     F .text	00000112 .hidden __pack_d
8000093c g     O .rodata	00000020 IfxAsclin_cfg_indexMap
800097b4 g     F .text	000000ac StartOS
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_229
80000cac g     O .rodata	0000000c IfxScu_HWCFG1EVR33_P14_5_IN
80000b80 g     O .rodata	00000014 IfxScu_REQ4_P10_7_IN
80003440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_162
8000aed4 g     F .text	0000000e free
80000adc g     O .rodata	00000010 IfxScu_WDTSLCK_P20_9_OUT
8000d6b2 g     F .text	00000082 __multadd
8000d6a0 g     F .text	00000012 _Bfree
8000069c g     O .rodata	00000010 IfxAsclin1_SCLK_P33_11_OUT
80008000 g     O *ABS*	00000000 _SMALL_DATA3_
8000892c g     F .text	00000162 printInfoDisplay
80003a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_212



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 8d 46 	ja 80008d1a <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80001200 <__TRAPTAB>:
80001200:	00 a0       	debug 
80001202:	1d ff ff ff 	j 80001200 <__TRAPTAB>
	...

80001220 <osEE_tc_trap_protection>:
80001220:	00 a0       	debug 
80001222:	1d ff ff ff 	j 80001220 <osEE_tc_trap_protection>
	...

80001240 <osEE_tc_trap_instruction>:
80001240:	00 a0       	debug 
80001242:	1d ff ff ff 	j 80001240 <osEE_tc_trap_instruction>
	...

80001260 <osEE_tc_trap_context>:
80001260:	00 a0       	debug 
80001262:	1d ff ff ff 	j 80001260 <osEE_tc_trap_context>
	...

80001280 <osEE_tc_trap_bus>:
80001280:	00 a0       	debug 
80001282:	1d ff ff ff 	j 80001280 <osEE_tc_trap_bus>
	...

800012a0 <osEE_tc_trap_assertion>:
800012a0:	00 a0       	debug 
800012a2:	1d ff ff ff 	j 800012a0 <osEE_tc_trap_assertion>
	...

800012c0 <osEE_tc_trap_system>:
800012c0:	00 a0       	debug 
800012c2:	1d ff ff ff 	j 800012c0 <osEE_tc_trap_system>
	...

800012e0 <osEE_tc_trap_nmi>:
800012e0:	00 a0       	debug 
800012e2:	1d ff ff ff 	j 800012e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001300 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001308 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_isr_dummy_entry_1>:
80002020:	3c 00       	j 80002020 <osEE_tc_isr_dummy_entry_1>
	...

80002040 <osEE_tc_isr2_entry_2>:
80002040:	0d 00 00 02 	svlcx 
80002044:	82 24       	mov %d4,2
80002046:	1d 00 08 3b 	j 80009656 <osEE_tc_isr2_wrapper>
	...

80002060 <osEE_tc_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_isr_dummy_entry_3>
	...

80002080 <osEE_tc_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_isr_dummy_entry_7>
	...

80002100 <osEE_tc_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_isr_dummy_entry_8>
	...

80002120 <osEE_tc_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_isr_dummy_entry_9>
	...

80002140 <osEE_tc_isr2_entry_10>:
80002140:	0d 00 00 02 	svlcx 
80002144:	82 14       	mov %d4,1
80002146:	1d 00 88 3a 	j 80009656 <osEE_tc_isr2_wrapper>
	...

80002160 <osEE_tc_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_isr_dummy_entry_11>
	...

80002180 <osEE_tc_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_isr_dummy_entry_15>
	...

80002200 <osEE_tc_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_isr_dummy_entry_16>
	...

80002220 <osEE_tc_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_isr_dummy_entry_17>
	...

80002240 <osEE_tc_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_isr_dummy_entry_18>
	...

80002260 <osEE_tc_isr2_entry_19>:
80002260:	0d 00 00 02 	svlcx 
80002264:	82 04       	mov %d4,0
80002266:	1d 00 f8 39 	j 80009656 <osEE_tc_isr2_wrapper>
	...

80002280 <osEE_tc_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_isr_dummy_entry_23>
	...

80002300 <osEE_tc_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_isr_dummy_entry_24>
	...

80002320 <osEE_tc_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_isr_dummy_entry_25>
	...

80002340 <osEE_tc_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_isr_dummy_entry_26>
	...

80002360 <osEE_tc_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_isr_dummy_entry_27>
	...

80002380 <osEE_tc_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_isr_dummy_entry_31>
	...

80002400 <osEE_tc_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_isr_dummy_entry_32>
	...

80002420 <osEE_tc_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_isr_dummy_entry_33>
	...

80002440 <osEE_tc_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_isr_dummy_entry_34>
	...

80002460 <osEE_tc_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_isr_dummy_entry_35>
	...

80002480 <osEE_tc_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_isr_dummy_entry_39>
	...

80002500 <osEE_tc_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_isr_dummy_entry_40>
	...

80002520 <osEE_tc_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_isr_dummy_entry_41>
	...

80002540 <osEE_tc_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_isr_dummy_entry_42>
	...

80002560 <osEE_tc_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_isr_dummy_entry_43>
	...

80002580 <osEE_tc_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_isr_dummy_entry_47>
	...

80002600 <osEE_tc_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_isr_dummy_entry_48>
	...

80002620 <osEE_tc_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_isr_dummy_entry_49>
	...

80002640 <osEE_tc_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_isr_dummy_entry_50>
	...

80002660 <osEE_tc_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_isr_dummy_entry_51>
	...

80002680 <osEE_tc_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_isr_dummy_entry_55>
	...

80002700 <osEE_tc_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_isr_dummy_entry_56>
	...

80002720 <osEE_tc_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_isr_dummy_entry_57>
	...

80002740 <osEE_tc_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_isr_dummy_entry_58>
	...

80002760 <osEE_tc_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_isr_dummy_entry_59>
	...

80002780 <osEE_tc_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_isr_dummy_entry_63>
	...

80002800 <osEE_tc_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_isr_dummy_entry_64>
	...

80002820 <osEE_tc_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_isr_dummy_entry_65>
	...

80002840 <osEE_tc_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_isr_dummy_entry_66>
	...

80002860 <osEE_tc_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_isr_dummy_entry_67>
	...

80002880 <osEE_tc_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_isr_dummy_entry_71>
	...

80002900 <osEE_tc_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_isr_dummy_entry_72>
	...

80002920 <osEE_tc_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_isr_dummy_entry_73>
	...

80002940 <osEE_tc_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_isr_dummy_entry_74>
	...

80002960 <osEE_tc_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_isr_dummy_entry_75>
	...

80002980 <osEE_tc_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_isr_dummy_entry_127>
	...

80003000 <osEE_tc_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_isr_dummy_entry_128>
	...

80003020 <osEE_tc_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_isr_dummy_entry_129>
	...

80003040 <osEE_tc_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_isr_dummy_entry_130>
	...

80003060 <osEE_tc_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_isr_dummy_entry_131>
	...

80003080 <osEE_tc_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_isr_dummy_entry_135>
	...

80003100 <osEE_tc_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_isr_dummy_entry_136>
	...

80003120 <osEE_tc_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_isr_dummy_entry_137>
	...

80003140 <osEE_tc_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_isr_dummy_entry_138>
	...

80003160 <osEE_tc_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_isr_dummy_entry_139>
	...

80003180 <osEE_tc_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_isr_dummy_entry_143>
	...

80003200 <osEE_tc_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_isr_dummy_entry_144>
	...

80003220 <osEE_tc_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_isr_dummy_entry_145>
	...

80003240 <osEE_tc_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_isr_dummy_entry_146>
	...

80003260 <osEE_tc_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_isr_dummy_entry_147>
	...

80003280 <osEE_tc_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_isr_dummy_entry_151>
	...

80003300 <osEE_tc_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_isr_dummy_entry_152>
	...

80003320 <osEE_tc_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_isr_dummy_entry_153>
	...

80003340 <osEE_tc_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_isr_dummy_entry_154>
	...

80003360 <osEE_tc_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_isr_dummy_entry_155>
	...

80003380 <osEE_tc_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_isr_dummy_entry_159>
	...

80003400 <osEE_tc_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_isr_dummy_entry_160>
	...

80003420 <osEE_tc_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_isr_dummy_entry_161>
	...

80003440 <osEE_tc_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_isr_dummy_entry_162>
	...

80003460 <osEE_tc_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_isr_dummy_entry_163>
	...

80003480 <osEE_tc_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_isr_dummy_entry_167>
	...

80003500 <osEE_tc_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_isr_dummy_entry_168>
	...

80003520 <osEE_tc_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_isr_dummy_entry_169>
	...

80003540 <osEE_tc_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_isr_dummy_entry_170>
	...

80003560 <osEE_tc_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_isr_dummy_entry_171>
	...

80003580 <osEE_tc_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_isr_dummy_entry_175>
	...

80003600 <osEE_tc_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_isr_dummy_entry_176>
	...

80003620 <osEE_tc_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_isr_dummy_entry_177>
	...

80003640 <osEE_tc_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_isr_dummy_entry_178>
	...

80003660 <osEE_tc_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_isr_dummy_entry_179>
	...

80003680 <osEE_tc_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_isr_dummy_entry_183>
	...

80003700 <osEE_tc_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_isr_dummy_entry_184>
	...

80003720 <osEE_tc_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_isr_dummy_entry_185>
	...

80003740 <osEE_tc_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_isr_dummy_entry_186>
	...

80003760 <osEE_tc_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_isr_dummy_entry_187>
	...

80003780 <osEE_tc_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_isr_dummy_entry_191>
	...

80003800 <osEE_tc_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_isr_dummy_entry_192>
	...

80003820 <osEE_tc_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_isr_dummy_entry_193>
	...

80003840 <osEE_tc_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_isr_dummy_entry_194>
	...

80003860 <osEE_tc_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_isr_dummy_entry_195>
	...

80003880 <osEE_tc_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_isr_dummy_entry_199>
	...

80003900 <osEE_tc_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_isr_dummy_entry_200>
	...

80003920 <osEE_tc_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_isr_dummy_entry_201>
	...

80003940 <osEE_tc_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_isr_dummy_entry_202>
	...

80003960 <osEE_tc_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_isr_dummy_entry_203>
	...

80003980 <osEE_tc_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <readLcdButtons>:
#include "bsw.h"



int readLcdButtons(void)
{
80004000:	20 08       	sub.a %sp,8
    unsigned adc_key_in;
    int button_state;
    adc_key_in = readADCValue(BUTTON_CH);
80004002:	82 34       	mov %d4,3
80004004:	6d 00 b6 02 	call 80004570 <readADCValue>
    printfSerial("%d",adc_key_in);
80004008:	91 00 00 48 	movh.a %a4,32768
8000400c:	74 a2       	st.w [%sp],%d2
8000400e:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <_start+0x8>>

int readLcdButtons(void)
{
    unsigned adc_key_in;
    int button_state;
    adc_key_in = readADCValue(BUTTON_CH);
80004012:	02 2f       	mov %d15,%d2
    printfSerial("%d",adc_key_in);
80004014:	6d 00 8b 01 	call 8000432a <printfSerial>

    //adc_key_in = readADCValue(BUTTON_CH);
    if (adc_key_in < 100) {
80004018:	8b 4f 66 32 	lt.u %d3,%d15,100
        button_state = btnUP;
8000401c:	82 02       	mov %d2,0
    int button_state;
    adc_key_in = readADCValue(BUTTON_CH);
    printfSerial("%d",adc_key_in);

    //adc_key_in = readADCValue(BUTTON_CH);
    if (adc_key_in < 100) {
8000401e:	df 03 17 80 	jne %d3,0,8000404c <readLcdButtons+0x4c>
        button_state = btnUP;
     
    } 
    else if (adc_key_in < 1000){
80004022:	3b 80 3e 30 	mov %d3,1000
        button_state = btnRIGHT; 
80004026:	82 32       	mov %d2,3
    //adc_key_in = readADCValue(BUTTON_CH);
    if (adc_key_in < 100) {
        button_state = btnUP;
     
    } 
    else if (adc_key_in < 1000){
80004028:	3f 3f 12 80 	jlt.u %d15,%d3,8000404c <readLcdButtons+0x4c>
        button_state = btnRIGHT; 
    }     
    else if (adc_key_in < 2500){ 
8000402c:	3b 40 9c 30 	mov %d3,2500
        button_state = btnLEFT; 
80004030:	82 22       	mov %d2,2
     
    } 
    else if (adc_key_in < 1000){
        button_state = btnRIGHT; 
    }     
    else if (adc_key_in < 2500){ 
80004032:	3f 3f 0d 80 	jlt.u %d15,%d3,8000404c <readLcdButtons+0x4c>
        button_state = btnLEFT; 
    } 
    else if (adc_key_in < 3500){ 
80004036:	3b c0 da 30 	mov %d3,3500
8000403a:	3f 3f 08 80 	jlt.u %d15,%d3,8000404a <readLcdButtons+0x4a>
        button_state = btnDOWN; 
    }  
    else if (adc_key_in >= 4000){ 
        button_state = btnNONE;  
8000403e:	3b 00 fa 30 	mov %d3,4000
80004042:	0b 3f 30 f1 	lt.u %d15,%d15,%d3
80004046:	ea 42       	cmovn %d2,%d15,4
80004048:	00 90       	ret 
    }     
    else if (adc_key_in < 2500){ 
        button_state = btnLEFT; 
    } 
    else if (adc_key_in < 3500){ 
        button_state = btnDOWN; 
8000404a:	82 12       	mov %d2,1
    }  
    else if (adc_key_in >= 4000){ 
        button_state = btnNONE;  
    } 
    return button_state;
8000404c:	00 90       	ret 

8000404e <lcd_write4bits>:
}


static void lcd_write4bits(uint8 data)
{
    IfxPort_setPinState(LCD_D4, (data & 0x01) ? IfxPort_State_high : IfxPort_State_low);
8000404e:	8f 14 00 21 	and %d2,%d4,1
80004052:	7b 10 00 f0 	movh %d15,1
80004056:	ab 1f a0 f2 	seln %d15,%d2,%d15,1
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000405a:	91 40 00 ff 	movh.a %a15,61444
8000405e:	06 4f       	sh %d15,4
80004060:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80004064:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D5, (data & 0x02) ? IfxPort_State_high : IfxPort_State_low);
80004066:	8f 24 00 21 	and %d2,%d4,2
8000406a:	7b 80 00 f0 	movh %d15,8
8000406e:	91 40 00 ff 	movh.a %a15,61444
80004072:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004076:	ab 8f a0 f2 	seln %d15,%d2,%d15,8
8000407a:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D6, (data & 0x04) ? IfxPort_State_high : IfxPort_State_low);
8000407c:	8f 44 00 21 	and %d2,%d4,4
80004080:	7b 00 01 f0 	movh %d15,16
80004084:	ab 0f a1 f2 	seln %d15,%d2,%d15,16
80004088:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D7, (data & 0x08) ? IfxPort_State_high : IfxPort_State_low);
8000408a:	8f 84 00 41 	and %d4,%d4,8
8000408e:	7b 00 02 f0 	movh %d15,32
80004092:	ab 0f a2 44 	seln %d4,%d4,%d15,32
80004096:	68 14       	st.w [%a15]4,%d4
80004098:	da 80       	mov %d15,128
8000409a:	68 1f       	st.w [%a15]4,%d15


static void lcd_pulse_enable(void)
{
    IfxPort_setPinHigh(LCD_E);
    delay_ms(2);       
8000409c:	82 24       	mov %d4,2
8000409e:	6d 00 5d 25 	call 80008b58 <delay_ms>
800040a2:	7b 00 08 f0 	movh %d15,128
800040a6:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinLow(LCD_E);
    delay_ms(2);       
800040a8:	82 24       	mov %d4,2
800040aa:	1d 00 57 25 	j 80008b58 <delay_ms>

800040ae <lcd_command>:
800040ae:	91 40 00 ff 	movh.a %a15,61444
800040b2:	7b 00 04 20 	movh %d2,64
800040b6:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
    lcd_pulse_enable();
}


static void lcd_command(uint8 cmd)
{
800040ba:	02 4f       	mov %d15,%d4
800040bc:	68 12       	st.w [%a15]4,%d2
    IfxPort_setPinLow(LCD_RS);
    lcd_write4bits(cmd >> 4);
800040be:	06 c4       	sh %d4,-4
800040c0:	5c c7       	call 8000404e <lcd_write4bits>
    lcd_write4bits(cmd & 0x0F);
800040c2:	8f ff 00 41 	and %d4,%d15,15
800040c6:	5c c4       	call 8000404e <lcd_write4bits>
    delay_ms(5);       
800040c8:	82 54       	mov %d4,5
800040ca:	1d 00 47 25 	j 80008b58 <delay_ms>

800040ce <lcd_clear>:
}


void lcd_clear(void)
{
    lcd_command(0x01);
800040ce:	82 14       	mov %d4,1
800040d0:	5c ef       	call 800040ae <lcd_command>
    delay_ms(5);       
800040d2:	82 54       	mov %d4,5
800040d4:	1d 00 42 25 	j 80008b58 <delay_ms>

800040d8 <lcd_init>:
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800040d8:	91 40 00 4f 	movh.a %a4,61444
800040dc:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040e0:	82 64       	mov %d4,6
800040e2:	3b 00 08 50 	mov %d5,128
800040e6:	6d 00 c0 0d 	call 80005c66 <IfxPort_setPinMode>
800040ea:	91 40 00 4f 	movh.a %a4,61444
800040ee:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040f2:	82 74       	mov %d4,7
800040f4:	3b 00 08 50 	mov %d5,128
800040f8:	6d 00 b7 0d 	call 80005c66 <IfxPort_setPinMode>
800040fc:	91 40 00 4f 	movh.a %a4,61444
80004100:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80004104:	82 44       	mov %d4,4
80004106:	3b 00 08 50 	mov %d5,128
8000410a:	6d 00 ae 0d 	call 80005c66 <IfxPort_setPinMode>
8000410e:	91 40 00 4f 	movh.a %a4,61444
80004112:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004116:	82 34       	mov %d4,3
80004118:	3b 00 08 50 	mov %d5,128
8000411c:	6d 00 a5 0d 	call 80005c66 <IfxPort_setPinMode>
80004120:	91 40 00 4f 	movh.a %a4,61444
80004124:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004128:	82 44       	mov %d4,4
8000412a:	3b 00 08 50 	mov %d5,128
8000412e:	6d 00 9c 0d 	call 80005c66 <IfxPort_setPinMode>
80004132:	91 40 00 4f 	movh.a %a4,61444
80004136:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000413a:	3b 00 08 50 	mov %d5,128
8000413e:	82 54       	mov %d4,5
80004140:	6d 00 93 0d 	call 80005c66 <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(LCD_D4, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D5, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D6, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D7, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    delay_ms(100);  
80004144:	3b 40 06 40 	mov %d4,100
80004148:	6d 00 08 25 	call 80008b58 <delay_ms>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000414c:	91 40 00 ff 	movh.a %a15,61444
80004150:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004154:	7b 00 04 f0 	movh %d15,64
80004158:	68 1f       	st.w [%a15]4,%d15
8000415a:	7b 00 08 f0 	movh %d15,128
8000415e:	68 1f       	st.w [%a15]4,%d15

    IfxPort_setPinLow(LCD_RS);
    IfxPort_setPinLow(LCD_E);

    lcd_write4bits(0x03); delay_ms(10);  
80004160:	82 34       	mov %d4,3
80004162:	6d ff 76 ff 	call 8000404e <lcd_write4bits>
80004166:	3b a0 00 40 	mov %d4,10
8000416a:	6d 00 f7 24 	call 80008b58 <delay_ms>
    lcd_write4bits(0x03); delay_ms(10);  
8000416e:	82 34       	mov %d4,3
80004170:	6d ff 6f ff 	call 8000404e <lcd_write4bits>
80004174:	3b a0 00 40 	mov %d4,10
80004178:	6d 00 f0 24 	call 80008b58 <delay_ms>
    lcd_write4bits(0x03); delay_ms(5);   
8000417c:	82 34       	mov %d4,3
8000417e:	6d ff 68 ff 	call 8000404e <lcd_write4bits>
80004182:	82 54       	mov %d4,5
80004184:	6d 00 ea 24 	call 80008b58 <delay_ms>
    lcd_write4bits(0x02); delay_ms(5);   
80004188:	82 24       	mov %d4,2
8000418a:	6d ff 62 ff 	call 8000404e <lcd_write4bits>
8000418e:	82 54       	mov %d4,5
80004190:	6d 00 e4 24 	call 80008b58 <delay_ms>

    lcd_command(0x28);
80004194:	3b 80 02 40 	mov %d4,40
80004198:	5c 8b       	call 800040ae <lcd_command>
    lcd_command(0x0C);
8000419a:	3b c0 00 40 	mov %d4,12
8000419e:	5c 88       	call 800040ae <lcd_command>
    lcd_command(0x06);
800041a0:	82 64       	mov %d4,6
800041a2:	5c 86       	call 800040ae <lcd_command>
    lcd_clear();
800041a4:	1d ff 95 ff 	j 800040ce <lcd_clear>

800041a8 <lcd_goto>:
}


void lcd_goto(uint8 row, uint8 col)
{
    uint8 address = (row == 0) ? 0x00 : 0x40;
800041a8:	ab 04 a4 44 	seln %d4,%d4,%d4,64
    address += col;
800041ac:	42 54       	add %d4,%d5
    lcd_command(0x80 | address);
800041ae:	b7 14 99 43 	insert %d4,%d4,1,7,25
800041b2:	1d ff 7e ff 	j 800040ae <lcd_command>

800041b6 <lcd_print>:
800041b6:	91 40 00 cf 	movh.a %a12,61444
}


void lcd_print(const char *str)
{
800041ba:	40 4f       	mov.aa %a15,%a4
800041bc:	d9 cc 00 8a 	lea %a12,[%a12]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800041c0:	3b 00 04 80 	mov %d8,64
    while (*str)
800041c4:	79 ff 00 00 	ld.b %d15,[%a15]0
800041c8:	6e 11       	jz %d15,800041ea <lcd_print+0x34>
        lcd_data(*str++);
800041ca:	16 ff       	and %d15,255


static void lcd_data(uint8 data)
{
    IfxPort_setPinHigh(LCD_RS);
    lcd_write4bits(data >> 4);
800041cc:	8f cf 1f 40 	sh %d4,%d15,-4
800041d0:	59 c8 04 00 	st.w [%a12]4 <f0040004 <_SMALL_DATA4_+0x40038004>>,%d8
800041d4:	6d ff 3d ff 	call 8000404e <lcd_write4bits>
    lcd_write4bits(data & 0x0F);
800041d8:	8f ff 00 41 	and %d4,%d15,15
800041dc:	6d ff 39 ff 	call 8000404e <lcd_write4bits>
    delay_ms(5);       
800041e0:	82 54       	mov %d4,5


void lcd_print(const char *str)
{
    while (*str)
        lcd_data(*str++);
800041e2:	b0 1f       	add.a %a15,1
static void lcd_data(uint8 data)
{
    IfxPort_setPinHigh(LCD_RS);
    lcd_write4bits(data >> 4);
    lcd_write4bits(data & 0x0F);
    delay_ms(5);       
800041e4:	6d 00 ba 24 	call 80008b58 <delay_ms>
800041e8:	3c ee       	j 800041c4 <lcd_print+0xe>

void lcd_print(const char *str)
{
    while (*str)
        lcd_data(*str++);
}
800041ea:	00 90       	ret 

800041ec <FuncTask1>:
#include "bsw.h"

TASK(Task1)
{
    printfSerial("Task1 Begins...");
800041ec:	91 00 00 48 	movh.a %a4,32768
#include "bsw.h"

TASK(Task1)
{
800041f0:	20 08       	sub.a %sp,8
    printfSerial("Task1 Begins...");
800041f2:	d9 44 2b 00 	lea %a4,[%a4]43
800041f6:	6d 00 9a 00 	call 8000432a <printfSerial>
    int a0 = readADCValue(3);
800041fa:	82 34       	mov %d4,3
800041fc:	6d 00 ba 01 	call 80004570 <readADCValue>
    printfSerial("%d",a0);
80004200:	91 00 00 48 	movh.a %a4,32768
#include "bsw.h"

TASK(Task1)
{
    printfSerial("Task1 Begins...");
    int a0 = readADCValue(3);
80004204:	74 a2       	st.w [%sp],%d2
    printfSerial("%d",a0);
80004206:	d9 44 3b 00 	lea %a4,[%a4]59 <8000003b <_start+0x1b>>
8000420a:	6d 00 90 00 	call 8000432a <printfSerial>
    mdelay(3000);
8000420e:	3b 80 bb 40 	mov %d4,3000
80004212:	6d 00 c3 00 	call 80004398 <mdelay>
    printfSerial("Task1 Finishes...");
80004216:	91 00 00 48 	movh.a %a4,32768
8000421a:	d9 44 3e 00 	lea %a4,[%a4]62 <8000003e <_start+0x1e>>
8000421e:	6d 00 86 00 	call 8000432a <printfSerial>

    TerminateTask();
}
80004222:	d9 aa 08 00 	lea %sp,[%sp]8
    int a0 = readADCValue(3);
    printfSerial("%d",a0);
    mdelay(3000);
    printfSerial("Task1 Finishes...");

    TerminateTask();
80004226:	1d 00 d7 2b 	j 800099d4 <TerminateTask>

8000422a <FuncTaskLCD>:
TASK(TaskLCD)
{   
    // lcd_clear(); // LCD    
    // printInfoDisplay();  

    TerminateTask();
8000422a:	1d 00 d5 2b 	j 800099d4 <TerminateTask>

8000422e <FuncTaskUltrasonic>:
}

TASK(TaskUltrasonic)
{   
8000422e:	20 08       	sub.a %sp,8
    printfSerial("%d",getUltrasonic());
80004230:	6d 00 58 25 	call 80008ce0 <getUltrasonic>
80004234:	91 00 00 48 	movh.a %a4,32768
80004238:	74 a2       	st.w [%sp],%d2
8000423a:	d9 44 3b 00 	lea %a4,[%a4]59 <8000003b <_start+0x1b>>
8000423e:	1d 00 76 00 	j 8000432a <printfSerial>

80004242 <ButtonISR>:
}

ISR2(ButtonISR)
{
    unsigned int buttonState;
    DisableAllInterrupts();
80004242:	6d 00 20 2a 	call 80009682 <DisableAllInterrupts>
    osEE_tc_delay(5000);
80004246:	3b 80 38 41 	mov %d4,5000
8000424a:	6d 00 f2 29 	call 8000962e <osEE_tc_delay>
    printfSerial("interuppt");
8000424e:	91 00 00 48 	movh.a %a4,32768
80004252:	d9 44 10 10 	lea %a4,[%a4]80 <80000050 <_start+0x30>>
80004256:	6d 00 6a 00 	call 8000432a <printfSerial>
    buttonState = readLcdButtons();
8000425a:	6d ff d3 fe 	call 80004000 <readLcdButtons>
    updateInfoState(buttonState);
8000425e:	02 24       	mov %d4,%d2
80004260:	6d 00 1b 24 	call 80008a96 <updateInfoState>

    osEE_tc_delay(3000);
80004264:	3b 80 bb 40 	mov %d4,3000
80004268:	6d 00 e3 29 	call 8000962e <osEE_tc_delay>
    EnableAllInterrupts();
8000426c:	1d 00 16 2a 	j 80009698 <EnableAllInterrupts>

80004270 <TimerISR>:


ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004270:	7b f0 00 40 	movh %d4,15
}



ISR2(TimerISR)
{
80004274:	20 08       	sub.a %sp,8
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004276:	1b 04 24 44 	addi %d4,%d4,16960
    if (c == 0)
8000427a:	91 00 00 f7 	movh.a %a15,28672


ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
8000427e:	6d 00 73 29 	call 80009564 <osEE_tc_stm_set_sr0_next_match>
    if (c == 0)
80004282:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004286:	ee 04       	jnz %d15,8000428e <TimerISR+0x1e>
        ActivateTask(Task1);
80004288:	82 34       	mov %d4,3
8000428a:	6d 00 f8 2a 	call 8000987a <ActivateTask>
    if (c % 2 == 0)
8000428e:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004292:	ae 04       	jnz.t %d15,0,8000429a <TimerISR+0x2a>
    ActivateTask(TaskLCD);
80004294:	82 44       	mov %d4,4
80004296:	6d 00 f2 2a 	call 8000987a <ActivateTask>
    ActivateTask(TaskUltrasonic);
8000429a:	82 54       	mov %d4,5
8000429c:	6d 00 ef 2a 	call 8000987a <ActivateTask>
    printfSerial("\n%4ld: ", c++);
800042a0:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
800042a4:	91 00 00 48 	movh.a %a4,32768
800042a8:	78 00       	st.w [%sp]0,%d15
800042aa:	d9 44 1a 10 	lea %a4,[%a4]90 <8000005a <_start+0x3a>>
800042ae:	c2 1f       	add %d15,1
800042b0:	59 ff 00 00 	st.w [%a15]0 <70000000 <__DSPR0_START>>,%d15
800042b4:	1d 00 3b 00 	j 8000432a <printfSerial>

800042b8 <UART_init>:
                                        IfxVadc_ChannelId_6,  /* AN38: channel 6 of group 4                         */
                                        IfxVadc_ChannelId_7}; /* AN39: channel 7 of group 4                         */


void UART_init(void)
{
800042b8:	20 60       	sub.a %sp,96

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
800042ba:	d9 a4 24 00 	lea %a4,[%sp]36
800042be:	c5 f5 80 40 	lea %a5,f0000900 <_SMALL_DATA4_+0x3fff8900>
    ascConfig.baudrate.prescaler    = 1;
800042c2:	82 1f       	mov %d15,1

void UART_init(void)
{

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
800042c4:	6d 00 5c 0a 	call 8000577c <IfxAsclin_Asc_initModuleConfig>
    ascConfig.baudrate.prescaler    = 1;
800042c8:	f9 af 2c 00 	st.h [%sp]44,%d15
    ascConfig.baudrate.baudrate     = 115200;
800042cc:	7b 10 7e f4 	movh %d15,18401
800042d0:	78 0a       	st.w [%sp]40,%d15
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
800042d2:	82 3f       	mov %d15,3
800042d4:	e9 af 2e 00 	st.b [%sp]46,%d15

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;
800042d8:	da 13       	mov %d15,19
800042da:	f9 af 00 10 	st.h [%sp]64,%d15


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800042de:	4d c0 e1 ff 	mfcr %d15,$core_id
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
800042e2:	7b 00 00 28 	movh %d2,32768
800042e6:	60 23       	mov.a %a3,%d2
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800042e8:	37 0f 63 f0 	extr.u %d15,%d15,0,3
800042ec:	d9 af 04 00 	lea %a15,[%sp]4
800042f0:	40 f4       	mov.aa %a4,%a15
800042f2:	d9 32 24 10 	lea %a2,[%a3]100
    ascConfig.baudrate.baudrate     = 115200;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
800042f6:	e9 af 06 10 	st.b [%sp]70,%d15
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
800042fa:	a0 33       	mov.a %a3,3
800042fc:	09 22 48 01 	ld.d %e2,[%a2+]8
80004300:	89 42 48 01 	st.d [%a4+]8,%e2
80004304:	fc 3c       	loop %a3,800042fc <UART_init+0x44>

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
80004306:	7b 00 00 f7 	movh %d15,28672
8000430a:	1b 4f 97 f0 	addi %d15,%d15,2420
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
8000430e:	91 00 00 47 	movh.a %a4,28672

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
80004312:	78 14       	st.w [%sp]80,%d15
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
80004314:	d9 44 88 f0 	lea %a4,[%a4]3016 <70000bc8 <g_AsclinAsc+0x254>>
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80004318:	3b 20 10 f0 	mov %d15,258
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
8000431c:	d9 a5 24 00 	lea %a5,[%sp]36
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80004320:	f9 af 0e 10 	st.h [%sp]78,%d15
        &IfxAsclin3_RXD_P32_2_IN, IfxPort_InputMode_pullUp,        /* Rx pin */
        NULL_PTR,                     IfxPort_OutputMode_pushPull,     /* RTS pin not used */
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
80004324:	f8 12       	st.a [%sp]72,%a15
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
80004326:	1d 00 54 08 	j 800053ce <IfxAsclin_Asc_initModule>

8000432a <printfSerial>:
    //printf("Asclin Asc is initialised\n");
}


void printfSerial(const char *fmt,...)
{
8000432a:	20 e8       	sub.a %sp,232
8000432c:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
8000432e:	6d 00 b5 29 	call 80009698 <EnableAllInterrupts>
    char buf[LEN_BUF];
    va_list args;
    va_start (args, fmt );
    vsnprintf(buf, LEN_BUF, fmt, args);
80004332:	40 f5       	mov.aa %a5,%a15
80004334:	d9 a4 28 10 	lea %a4,[%sp]104
80004338:	3b 00 08 40 	mov %d4,128
8000433c:	d9 a6 28 30 	lea %a6,[%sp]232
80004340:	6d 00 5e 38 	call 8000b3fc <vsnprintf>
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
80004344:	d9 a4 28 10 	lea %a4,[%sp]104
80004348:	6d 00 2b 38 	call 8000b39e <strlen>
8000434c:	91 00 00 f7 	movh.a %a15,28672
80004350:	d9 ff b4 50 	lea %a15,[%a15]2420 <70000974 <g_AsclinAsc>>
80004354:	f9 f2 3a 90 	st.h [%a15]634 <7000027a <__malloc_av_+0x17a>>,%d2
    unsigned int i =0;
80004358:	82 0f       	mov %d15,0
    for(; i<strlen(buf);i++) {
8000435a:	d9 a4 28 10 	lea %a4,[%sp]104
8000435e:	6d 00 20 38 	call 8000b39e <strlen>
80004362:	7f 2f 0c 80 	jge.u %d15,%d2,8000437a <printfSerial+0x50>
        txData[i] = buf[i];
80004366:	d9 a3 04 00 	lea %a3,[%sp]4
8000436a:	10 32       	addsc.a %a2,%a3,%d15,0
8000436c:	d9 a3 28 10 	lea %a3,[%sp]104
80004370:	10 3f       	addsc.a %a15,%a3,%d15,0
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
    unsigned int i =0;
    for(; i<strlen(buf);i++) {
80004372:	c2 1f       	add %d15,1
        txData[i] = buf[i];
80004374:	08 02       	ld.bu %d2,[%a15]0
80004376:	34 22       	st.b [%a2],%d2
80004378:	3c f1       	j 8000435a <printfSerial+0x30>
    }
    /* Transmit data */
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
8000437a:	91 00 00 47 	movh.a %a4,28672
8000437e:	91 00 00 67 	movh.a %a6,28672
80004382:	82 f4       	mov %d4,-1
80004384:	d9 44 88 f0 	lea %a4,[%a4]3016 <70000bc8 <g_AsclinAsc+0x254>>
80004388:	d9 a5 04 00 	lea %a5,[%sp]4 <70000bc8 <g_AsclinAsc+0x254>>
8000438c:	d9 66 ae f0 	lea %a6,[%a6]3054 <70000bee <g_AsclinAsc+0x27a>>
80004390:	9b 04 00 58 	addih %d5,%d4,32768
80004394:	1d 00 5c 0a 	j 8000584c <IfxAsclin_Asc_write>

80004398 <mdelay>:

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004398:	85 fa 10 00 	ld.w %d10,f0000010 <_SMALL_DATA4_+0x3fff8010>
}

void mdelay(unsigned long delay_ms)
{
8000439c:	02 4b       	mov %d11,%d4
    result |= ((uint64)stm->CAP.U) << 32;
8000439e:	85 fc 2c 00 	ld.w %d12,f000002c <_SMALL_DATA4_+0x3fff802c>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
800043a2:	6d 00 49 0e 	call 80006034 <IfxScuCcu_getSourceFrequency>
800043a6:	91 30 00 ff 	movh.a %a15,61443
800043aa:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800043ae:	4c f0       	ld.w %d15,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800043b0:	53 1a 40 80 	mul.u %e8,%d10,1
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800043b4:	0b ac 10 48 	mov %e4,%d12,%d10
800043b8:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800043bc:	a6 95       	or %d5,%d9
800043be:	02 28       	mov %d8,%d2
800043c0:	6d 00 dc 30 	call 8000a578 <__floatundisf>
800043c4:	4b 0f 41 f1 	itof %d15,%d15
800043c8:	7b a0 47 a4 	movh %d10,17530
800043cc:	4b f8 51 f0 	div.f %d15,%d8,%d15
800043d0:	40 fc       	mov.aa %a12,%a15
800043d2:	40 fd       	mov.aa %a13,%a15
800043d4:	4b af 51 f0 	div.f %d15,%d15,%d10
800043d8:	4b f2 51 20 	div.f %d2,%d2,%d15
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800043dc:	02 ae       	mov %d14,%d10
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800043de:	4b 02 71 f1 	ftouz %d15,%d2
800043e2:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800043e6:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
800043ea:	6d 00 25 0e 	call 80006034 <IfxScuCcu_getSourceFrequency>
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
800043ee:	3b 40 01 40 	mov %d4,20
800043f2:	4b 4b 11 42 	div.u %e4,%d11,%d4
800043f6:	48 02       	ld.w %d2,[%a15]0
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
800043f8:	82 0b       	mov %d11,0
    while (cnt < (delay_ms / period_ms)) {
800043fa:	02 4d       	mov %d13,%d4
800043fc:	5f db 41 00 	jeq %d11,%d13,8000447e <mdelay+0xe6>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004400:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80004404:	85 fe 2c 08 	ld.a %a14,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004408:	53 1c 40 80 	mul.u %e8,%d12,1
8000440c:	6d 00 14 0e 	call 80006034 <IfxScuCcu_getSourceFrequency>
80004410:	54 c3       	ld.w %d3,[%a12]
    result |= ((uint64)stm->CAP.U) << 32;
80004412:	80 e5       	mov.d %d5,%a14
80004414:	37 03 64 34 	extr.u %d3,%d3,8,4
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004418:	02 c4       	mov %d4,%d12
8000441a:	a6 95       	or %d5,%d9
8000441c:	60 3f       	mov.a %a15,%d3
8000441e:	02 28       	mov %d8,%d2
80004420:	6d 00 ac 30 	call 8000a578 <__floatundisf>
80004424:	80 f4       	mov.d %d4,%a15
80004426:	4b 04 41 31 	itof %d3,%d4
8000442a:	4b 38 51 80 	div.f %d8,%d8,%d3
8000442e:	4b a8 51 80 	div.f %d8,%d8,%d10
80004432:	4b 82 51 20 	div.f %d2,%d2,%d8
80004436:	4b 02 71 21 	ftouz %d2,%d2
        if (current_ms - prev_ms >= period_ms) {
8000443a:	a2 f2       	sub %d2,%d15
8000443c:	8b 42 61 22 	lt.u %d2,%d2,20
80004440:	df 02 de ff 	jne %d2,0,800043fc <mdelay+0x64>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004444:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80004448:	85 ff 2c 08 	ld.a %a15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000444c:	6d 00 f4 0d 	call 80006034 <IfxScuCcu_getSourceFrequency>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004450:	53 1c 40 80 	mul.u %e8,%d12,1
80004454:	4c d0       	ld.w %d15,[%a13]0
    result |= ((uint64)stm->CAP.U) << 32;
80004456:	80 f5       	mov.d %d5,%a15
80004458:	37 0f 64 f4 	extr.u %d15,%d15,8,4
            cnt++;
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
8000445c:	02 c4       	mov %d4,%d12
8000445e:	a6 95       	or %d5,%d9
80004460:	02 28       	mov %d8,%d2
80004462:	6d 00 8b 30 	call 8000a578 <__floatundisf>
80004466:	4b 0f 41 f1 	itof %d15,%d15
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
        if (current_ms - prev_ms >= period_ms) {
            cnt++;
8000446a:	c2 1b       	add %d11,1
8000446c:	4b f8 51 f0 	div.f %d15,%d8,%d15
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004470:	4b ef 51 f0 	div.f %d15,%d15,%d14
80004474:	4b f2 51 20 	div.f %d2,%d2,%d15
80004478:	4b 02 71 f1 	ftouz %d15,%d2
8000447c:	3c c0       	j 800043fc <mdelay+0x64>
        }
    }
}
8000447e:	00 90       	ret 

80004480 <initVADCModule>:
    IfxVadc_Adc_startBackgroundScan(&g_vadc);
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
80004480:	20 28       	sub.a %sp,40
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
80004482:	d9 a4 04 00 	lea %a4,[%sp]4
80004486:	91 20 00 5f 	movh.a %a5,61442
8000448a:	6d 00 bc 1d 	call 80008002 <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the configuration                  */
8000448e:	91 00 00 47 	movh.a %a4,28672
80004492:	d9 44 a4 50 	lea %a4,[%a4]2404 <70000964 <g_vadc>>
80004496:	d9 a5 04 00 	lea %a5,[%sp]4 <70000964 <g_vadc>>
8000449a:	1d 00 40 1d 	j 80007f1a <IfxVadc_Adc_initModule>

8000449e <initVADCGroup>:
}

/* Function to initialize the VADC group */
void initVADCGroup(void)
{
8000449e:	20 38       	sub.a %sp,56
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */
800044a0:	91 00 00 57 	movh.a %a5,28672
800044a4:	40 a4       	mov.aa %a4,%sp
800044a6:	d9 55 a4 50 	lea %a5,[%a5]2404 <70000964 <g_vadc>>
800044aa:	6d 00 21 1d 	call 80007eec <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
800044ae:	82 4f       	mov %d15,4
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800044b0:	91 00 00 47 	movh.a %a4,28672
void initVADCGroup(void)
{
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
800044b4:	2c a4       	st.b [%sp]4,%d15
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */
800044b6:	2c a5       	st.b [%sp]5,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800044b8:	d9 44 98 50 	lea %a4,[%a4]2392 <70000958 <g_vadcGroup>>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
800044bc:	82 1f       	mov %d15,1
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800044be:	40 a5       	mov.aa %a5,%sp

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
800044c0:	e9 af 35 00 	st.b [%sp]53,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;
800044c4:	e9 af 28 00 	st.b [%sp]40,%d15

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800044c8:	e9 af 2c 00 	st.b [%sp]44,%d15

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800044cc:	1d 00 4b 1b 	j 80007b62 <IfxVadc_Adc_initGroup>

800044d0 <initVADCChannels>:
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
800044d0:	91 00 00 e7 	movh.a %a14,28672

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044d4:	7b 00 00 b7 	movh %d11,28672
800044d8:	7b 00 00 a7 	movh %d10,28672
}


IFX_INLINE void IfxVadc_Adc_setBackgroundScan(IfxVadc_Adc *vadc, IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setBackgroundScan(vadc->vadc, group->groupId, channels, mask);
800044dc:	91 00 00 d7 	movh.a %a13,28672
    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
}

/* Function to initialize the VADC used channels */
void initVADCChannels(void)
{
800044e0:	20 60       	sub.a %sp,96
800044e2:	82 0f       	mov %d15,0
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
800044e4:	d9 ee 98 50 	lea %a14,[%a14]2392 <70000958 <g_vadcGroup>>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044e8:	1b 8b 00 b0 	addi %d11,%d11,8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
800044ec:	82 19       	mov %d9,1
800044ee:	1b 8a 93 a0 	addi %d10,%d10,2360
800044f2:	d9 dd a4 50 	lea %a13,[%a13]2404
800044f6:	53 8f 21 80 	mul %d8,%d15,24
800044fa:	40 ac       	mov.aa %a12,%sp
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
800044fc:	40 e5       	mov.aa %a5,%a14
800044fe:	60 82       	mov.a %a2,%d8

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004500:	d9 af 20 10 	lea %a15,[%sp]96
80004504:	30 2c       	add.a %a12,%a2
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004506:	40 c4       	mov.aa %a4,%a12
80004508:	6d 00 22 1b 	call 80007b4c <IfxVadc_Adc_initChannelConfig>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
8000450c:	60 83       	mov.a %a3,%d8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
8000450e:	40 c5       	mov.aa %a5,%a12
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004510:	30 3f       	add.a %a15,%a3
80004512:	60 b3       	mov.a %a3,%d11
80004514:	10 32       	addsc.a %a2,%a3,%d15,0
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
80004516:	e9 ff ef ef 	st.b [%a15]-81,%d15
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
8000451a:	14 22       	ld.bu %d2,[%a2]
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
8000451c:	60 a2       	mov.a %a2,%d10
8000451e:	d0 24       	addsc.a %a4,%a2,%d15,3
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004520:	e9 f2 ec ef 	st.b [%a15]-84,%d2
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
80004524:	e9 f9 e2 ef 	st.b [%a15]-94,%d9


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004528:	6d 00 1c 1a 	call 80007960 <IfxVadc_Adc_initChannel>
8000452c:	d4 d2       	ld.a %a2,[%a13]
8000452e:	39 e2 08 00 	ld.bu %d2,[%a14]8 <70000008 <g_vadcChannelIDs>>
80004532:	c2 1f       	add %d15,1
80004534:	01 22 02 26 	addsc.a %a2,%a2,%d2,2

        /* Add the channel to background scan */
        unsigned chnEnableBit = (1 << adcChannelConf[chn].channelId);   /* Set the the corresponding input channel  */
80004538:	79 f2 ec ef 	ld.b %d2,[%a15]-84
}


IFX_INLINE void IfxVadc_setBackgroundScan(Ifx_VADC *vadc, IfxVadc_GroupId groupId, uint32 channels, uint32 mask)
{
    channels                = (vadc->BRSSEL[groupId].U & ~mask) | channels;
8000453c:	19 23 00 60 	ld.w %d3,[%a2]384
80004540:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
    vadc->BRSSEL[groupId].U = channels;
80004544:	59 22 00 60 	st.w [%a2]384,%d2
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
80004548:	df 4f d7 ff 	jne %d15,4,800044f6 <initVADCChannels+0x26>
        unsigned mask = chnEnableBit;                                   /* of the respective group to be added in   */
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup, chnEnableBit, mask); /* the background scan sequence.  */

    }

}
8000454c:	00 90       	ret 

8000454e <initADC>:
}


IFX_INLINE void IfxVadc_Adc_startBackgroundScan(IfxVadc_Adc *vadc)
{
    IfxVadc_startBackgroundScan(vadc->vadc);
8000454e:	91 00 00 f7 	movh.a %a15,28672
}

/* Function to initialize the VADC module */
void initADC(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
80004552:	6d ff 97 ff 	call 80004480 <initVADCModule>
    initVADCGroup();                                                    /* Initialize the VADC group                */
80004556:	6d ff a4 ff 	call 8000449e <initVADCGroup>
    initVADCChannels();                                                 /* Initialize the used channels             */
8000455a:	6d ff bb ff 	call 800044d0 <initVADCChannels>
8000455e:	99 ff a4 50 	ld.a %a15,[%a15]2404 <70000964 <g_vadc>>
}


IFX_INLINE void IfxVadc_startBackgroundScan(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.LDEV = 1;     /* execute Load event to start the conversion */
80004562:	19 ff 04 80 	ld.w %d15,[%a15]516 <70000964 <g_vadc>>
80004566:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000456a:	59 ff 04 80 	st.w [%a15]516,%d15
8000456e:	00 90       	ret 

80004570 <readADCValue>:
}


IFX_INLINE Ifx_VADC_RES IfxVadc_Adc_getResult(IfxVadc_Adc_Channel *channel)
{
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
80004570:	91 00 00 f7 	movh.a %a15,28672
80004574:	d9 ff b8 40 	lea %a15,[%a15]2360 <70000938 <g_vadcChannel>>
80004578:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
8000457c:	c8 12       	ld.a %a2,[%a15]4
8000457e:	0c f1       	ld.bu %d15,[%a15]1
80004580:	99 22 04 00 	ld.a %a2,[%a2]4

IFX_INLINE Ifx_VADC_RES IfxVadc_getResult(Ifx_VADC_G *group, uint32 resultIdx)
{
    Ifx_VADC_RES tmpResult;

    tmpResult.U = group->RES[resultIdx].U;
80004584:	1b 0f 0a f0 	addi %d15,%d15,160
80004588:	90 2f       	addsc.a %a15,%a2,%d15,2
8000458a:	4c f0       	ld.w %d15,[%a15]0
8000458c:	37 0f 70 20 	extr.u %d2,%d15,0,16
{
    Ifx_VADC_RES conversionResult;
    do
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    } while(!conversionResult.B.VF);
80004590:	ff 0f fd 7f 	jge %d15,0,8000458a <readADCValue+0x1a>

    return conversionResult.B.RESULT;
}
80004594:	00 90       	ret 

80004596 <initPeripheralsAndERU>:

void initPeripheralsAndERU(void)
{
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */
80004596:	91 40 00 4f 	movh.a %a4,61444
8000459a:	d9 44 00 0e 	lea %a4,[%a4]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
8000459e:	82 74       	mov %d4,7
800045a0:	3b 00 01 50 	mov %d5,16
800045a4:	6d 00 61 0b 	call 80005c66 <IfxPort_setPinMode>


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
800045a8:	91 00 00 f8 	movh.a %a15,32768
800045ac:	d9 ff 98 d0 	lea %a15,[%a15]2904 <80000b58 <IfxScu_REQ6_P02_0_IN>>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800045b0:	c8 24       	ld.a %a4,[%a15]8
800045b2:	91 00 00 d7 	movh.a %a13,28672
800045b6:	08 c4       	ld.bu %d4,[%a15]12
800045b8:	3b 80 00 50 	mov %d5,8
800045bc:	b5 df a8 50 	st.a [%a13]2408 <70000968 <g_ERUconfig>>,%a15
800045c0:	6d 00 53 0b 	call 80005c66 <IfxPort_setPinMode>
/******************************************************************************/

IFX_INLINE void IfxScuEru_initReqPin(IfxScu_Req_In *req, IfxPort_InputMode inputMode)
{
    IfxPort_setPinModeInput(req->pin.port, req->pin.pinIndex, inputMode);
    IfxScuEru_selectExternalInput((IfxScuEru_InputChannel)req->channelId, (IfxScuEru_ExternalInputSelection)req->select);
800045c4:	39 f5 10 00 	ld.bu %d5,[%a15]16 <80000010 <BootModeHeader0+0x10>>
800045c8:	08 44       	ld.bu %d4,[%a15]4
800045ca:	6d 00 fc 14 	call 80006fc2 <IfxScuEru_selectExternalInput>
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
800045ce:	99 df a8 50 	ld.a %a15,[%a13]2408 <70000968 <g_ERUconfig>>
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
800045d2:	d9 dc a8 50 	lea %a12,[%a13]2408 <70000968 <g_ERUconfig>>
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
800045d6:	82 0f       	mov %d15,0
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
800045d8:	08 44       	ld.bu %d4,[%a15]4
800045da:	e9 c4 04 00 	st.b [%a12]4 <70000004 <__DSPR0_START+0x4>>,%d4

    /* Input channel configuration */
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */
800045de:	6d 00 62 14 	call 80006ea2 <IfxScuEru_enableFallingEdgeDetection>
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
800045e2:	39 c4 04 00 	ld.bu %d4,[%a12]4
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
800045e6:	2c c6       	st.b [%a12]6,%d15
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;
800045e8:	2c c5       	st.b [%a12]5,%d15

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
800045ea:	6d 00 95 14 	call 80006f14 <IfxScuEru_enableTriggerPulse>
    /* Determination of output channel for trigger event (Register INPx) */
    IfxScuEru_connectTrigger(g_ERUconfig.inputChannel, g_ERUconfig.triggerSelect);
800045ee:	39 c4 04 00 	ld.bu %d4,[%a12]4
800045f2:	39 c5 05 00 	ld.bu %d5,[%a12]5
800045f6:	6d 00 c9 13 	call 80006d88 <IfxScuEru_connectTrigger>

    /* Configure Output channels, OutputGating Unit OGU (Register IGPy) */
    IfxScuEru_setInterruptGatingPattern(g_ERUconfig.outputChannel, IfxScuEru_InterruptGatingPattern_alwaysActive);
800045fa:	39 c4 06 00 	ld.bu %d4,[%a12]6
800045fe:	82 15       	mov %d5,1
80004600:	6d 00 1a 15 	call 80007034 <IfxScuEru_setInterruptGatingPattern>

    /* Service request configuration */
    /* Get source pointer depending on outputChannel (SRC_SCUERU0 for outputChannel0) */
    g_ERUconfig.src = &MODULE_SRC.SCU.SCU.ERU[(int) g_ERUconfig.outputChannel % 4];
80004604:	0c c6       	ld.bu %d15,[%a12]6
80004606:	16 03       	and %d15,3
80004608:	06 2f       	sh %d15,2
8000460a:	60 f2       	mov.a %a2,%d15
8000460c:	d9 2f d4 38 	lea %a15,[%a2]-29484
80004610:	11 4f 00 ff 	addih.a %a15,%a15,61444
80004614:	ec c2       	st.a [%a12]8,%a15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80004616:	4c f0       	ld.w %d15,[%a15]0
80004618:	b7 af 08 f0 	insert %d15,%d15,10,0,8
8000461c:	68 0f       	st.w [%a15]0,%d15
    src->B.TOS  = typOfService;
8000461e:	4c f0       	ld.w %d15,[%a15]0
80004620:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
80004624:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80004626:	4c f0       	ld.w %d15,[%a15]0
80004628:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
8000462c:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
8000462e:	4c f0       	ld.w %d15,[%a15]0
80004630:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80004634:	68 0f       	st.w [%a15]0,%d15
80004636:	00 90       	ret 

80004638 <asclin0TxISR>:
    IfxSrc_enable(g_ERUconfig.src);
}

ISR(asclin0TxISR)
{
    IfxAsclin_Asc_isrTransmit(&g_AsclinAsc.drivers.asc);
80004638:	91 00 00 47 	movh.a %a4,28672
8000463c:	d9 44 88 f0 	lea %a4,[%a4]3016 <70000bc8 <g_AsclinAsc+0x254>>
80004640:	1d 00 0c 06 	j 80005258 <IfxAsclin_Asc_isrTransmit>

80004644 <main>:
}

int main(void)
{
    osEE_tc_stm_set_clockpersec();
80004644:	6d 00 34 27 	call 800094ac <osEE_tc_stm_set_clockpersec>
    osEE_tc_stm_set_sr0(1000000U, 1U);
80004648:	7b f0 00 40 	movh %d4,15
8000464c:	82 15       	mov %d5,1
8000464e:	1b 04 24 44 	addi %d4,%d4,16960
80004652:	6d 00 47 27 	call 800094e0 <osEE_tc_stm_set_sr0>

    UART_init();
80004656:	6d ff 31 fe 	call 800042b8 <UART_init>
    initADC();
8000465a:	6d ff 7a ff 	call 8000454e <initADC>
    initPeripheralsAndERU();
8000465e:	6d ff 9c ff 	call 80004596 <initPeripheralsAndERU>
    
    /* custom driver init() added start*/
    lcd_init();
80004662:	6d ff 3b fd 	call 800040d8 <lcd_init>
    initUltrasonic();
80004666:	6d 00 67 22 	call 80008b34 <initUltrasonic>
    initInfotainment();
8000466a:	6d 00 12 22 	call 80008a8e <initInfotainment>
    /* custom driver added end*/
    

    printfSerial("\n...............\n");
8000466e:	91 00 00 48 	movh.a %a4,32768
80004672:	d9 44 04 20 	lea %a4,[%a4]132 <80000084 <_start+0x64>>
80004676:	6d ff 5a fe 	call 8000432a <printfSerial>
    printfSerial("...OS Starts...\n");
8000467a:	91 00 00 48 	movh.a %a4,32768
8000467e:	d9 44 16 20 	lea %a4,[%a4]150 <80000096 <_start+0x76>>
80004682:	6d ff 54 fe 	call 8000432a <printfSerial>
    printfSerial("...............\n");
80004686:	91 00 00 48 	movh.a %a4,32768
8000468a:	d9 44 27 20 	lea %a4,[%a4]167 <800000a7 <_start+0x87>>
8000468e:	6d ff 4e fe 	call 8000432a <printfSerial>

    StartOS(OSDEFAULTAPPMODE);
80004692:	82 04       	mov %d4,0
80004694:	6d 00 90 28 	call 800097b4 <StartOS>
    return 0;
}
80004698:	82 02       	mov %d2,0
8000469a:	00 90       	ret 

8000469c <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
8000469c:	02 4f       	mov %d15,%d4
8000469e:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
800046a0:	6d 00 6d 16 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
800046a4:	02 24       	mov %d4,%d2
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
800046a6:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
800046a8:	6d 00 66 15 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
800046ac:	8b 0f a2 22 	ge.u %d2,%d15,32
800046b0:	f6 28       	jnz %d2,800046c0 <IfxVadc_disableAccess+0x24>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
800046b2:	19 f2 08 20 	ld.w %d2,[%a15]136
800046b6:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
800046ba:	59 ff 08 20 	st.w [%a15]136,%d15
800046be:	3c 08       	j 800046ce <IfxVadc_disableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
800046c0:	19 f2 0c 20 	ld.w %d2,[%a15]140
800046c4:	16 1f       	and %d15,31
800046c6:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
800046ca:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
800046ce:	02 84       	mov %d4,%d8
800046d0:	1d 00 d8 16 	j 80007480 <IfxScuWdt_setSafetyEndinit>

800046d4 <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
800046d4:	02 4f       	mov %d15,%d4
800046d6:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
800046d8:	6d 00 51 16 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
800046dc:	02 24       	mov %d4,%d2
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
800046de:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
800046e0:	6d 00 4a 15 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
800046e4:	8b 0f a2 22 	ge.u %d2,%d15,32
800046e8:	f6 28       	jnz %d2,800046f8 <IfxVadc_enableAccess+0x24>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
800046ea:	19 f2 08 20 	ld.w %d2,[%a15]136
800046ee:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
800046f2:	59 ff 08 20 	st.w [%a15]136,%d15
800046f6:	3c 08       	j 80004706 <IfxVadc_enableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
800046f8:	19 f2 0c 20 	ld.w %d2,[%a15]140
800046fc:	16 1f       	and %d15,31
800046fe:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80004702:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80004706:	02 84       	mov %d4,%d8
80004708:	1d 00 bc 16 	j 80007480 <IfxScuWdt_setSafetyEndinit>

8000470c <IfxVadc_configExternalMultiplexerMode>:

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
8000470c:	82 0f       	mov %d15,0
8000470e:	b7 1f 81 ff 	insert %d15,%d15,1,31,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004712:	39 a3 04 00 	ld.bu %d3,[%sp]4
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
80004716:	37 4f 02 fd 	insert %d15,%d15,%d4,26,2
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
8000471a:	14 a2       	ld.bu %d2,[%sp]
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
8000471c:	67 3f 1e f0 	ins.t %d15,%d15,30,%d3,0
    emuxctr.B.EMUXCH   = channels;
80004720:	37 5f 0a f8 	insert %d15,%d15,%d5,16,10
    emuxctr.B.EMUXSET  = startChannel;
80004724:	37 6f 03 f0 	insert %d15,%d15,%d6,0,3
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
80004728:	3b f0 00 40 	mov %d4,15
    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
8000472c:	67 7f 1c f0 	ins.t %d15,%d15,28,%d7,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004730:	40 5f       	mov.aa %a15,%a5
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
80004732:	67 2f 1d f0 	ins.t %d15,%d15,29,%d2,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004736:	40 4c       	mov.aa %a12,%a4
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
80004738:	6d ff ce ff 	call 800046d4 <IfxVadc_enableAccess>
    vadcG->EMUXCTR.U   = emuxctr.U;
8000473c:	59 ff 30 50 	st.w [%a15]368,%d15
    emuxctr.B.EMXWC    = 0;
80004740:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
    vadcG->EMUXCTR.U   = emuxctr.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
80004744:	40 c4       	mov.aa %a4,%a12
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
    vadcG->EMUXCTR.U   = emuxctr.U;
    emuxctr.B.EMXWC    = 0;
    vadcG->EMUXCTR.U   = emuxctr.U;
80004746:	59 ff 30 50 	st.w [%a15]368,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
8000474a:	3b f0 00 40 	mov %d4,15
8000474e:	1d ff a7 ff 	j 8000469c <IfxVadc_disableAccess>

80004752 <IfxVadc_disablePostCalibration>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_disablePostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group, boolean disable)
{
80004752:	40 4f       	mov.aa %a15,%a4
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
80004754:	ff 84 1c 80 	jge.u %d4,8,8000478c <IfxVadc_disablePostCalibration+0x3a>
80004758:	02 4f       	mov %d15,%d4
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
8000475a:	3b f0 01 40 	mov %d4,31
8000475e:	02 58       	mov %d8,%d5
80004760:	6d ff ba ff 	call 800046d4 <IfxVadc_enableAccess>

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
80004764:	1b 0f 01 40 	addi %d4,%d15,16

        if (disable == TRUE)
        {
            vadc->GLOBCFG.U |= mask;
80004768:	19 f2 00 20 	ld.w %d2,[%a15]128
{
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
8000476c:	82 1f       	mov %d15,1
8000476e:	0f 4f 00 f0 	sh %d15,%d15,%d4

        if (disable == TRUE)
80004772:	df 18 04 80 	jne %d8,1,8000477a <IfxVadc_disablePostCalibration+0x28>
        {
            vadc->GLOBCFG.U |= mask;
80004776:	a6 2f       	or %d15,%d2
80004778:	3c 03       	j 8000477e <IfxVadc_disablePostCalibration+0x2c>
        }
        else
        {
            vadc->GLOBCFG.U &= ~mask;
8000477a:	0f f2 e0 f0 	andn %d15,%d2,%d15
8000477e:	59 ff 00 20 	st.w [%a15]128,%d15
        }

        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004782:	40 f4       	mov.aa %a4,%a15
80004784:	3b f0 01 40 	mov %d4,31
80004788:	1d ff 8a ff 	j 8000469c <IfxVadc_disableAccess>
8000478c:	00 90       	ret 

8000478e <IfxVadc_enableGroupSync>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
8000478e:	40 4f       	mov.aa %a15,%a4
80004790:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004792:	6d 00 d6 15 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004796:	02 24       	mov %d4,%d2
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004798:	02 29       	mov %d9,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
8000479a:	6d 00 d2 14 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
8000479e:	40 f4       	mov.aa %a4,%a15
800047a0:	3b f0 01 40 	mov %d4,31
    IfxScuWdt_clearCpuEndinit(passwd);

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
800047a4:	19 ff 00 20 	ld.w %d15,[%a15]128
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800047a8:	6d ff 96 ff 	call 800046d4 <IfxVadc_enableAccess>

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
800047ac:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
        vadcGlobCfg.B.DCMSB = 1;
800047b0:	b7 1f 81 f3 	insert %d15,%d15,1,7,1

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047b4:	40 f4       	mov.aa %a4,%a15
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
800047b6:	59 ff 00 20 	st.w [%a15]128,%d15
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047ba:	3b f0 01 40 	mov %d4,31
800047be:	6d ff 6f ff 	call 8000469c <IfxVadc_disableAccess>
    }

    if (ccu6Num == 0)
800047c2:	df 08 1a 80 	jne %d8,0,800047f6 <IfxVadc_enableGroupSync+0x68>
    {
        // CCU60 Config
        CCU60_CLC.U = 0;
800047c6:	a5 f8 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d8

        if (CCU60_CLC.U)
800047ca:	85 ff 80 82 	ld.w %d15,f0002a00 <_SMALL_DATA4_+0x3fffaa00>
        {}

        CCU60_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
800047ce:	82 4f       	mov %d15,4
800047d0:	a5 ff 94 92 	st.w f0002a54 <_SMALL_DATA4_+0x3fffaa54>,%d15
        CCU60_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
800047d4:	a5 ff 9c 92 	st.w f0002a5c <_SMALL_DATA4_+0x3fffaa5c>,%d15
        CCU60_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
800047d8:	85 ff 80 a2 	ld.w %d15,f0002a80 <_SMALL_DATA4_+0x3fffaa80>
800047dc:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
800047e0:	a5 ff 80 a2 	st.w f0002a80 <_SMALL_DATA4_+0x3fffaa80>,%d15
        CCU60_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
800047e4:	3b 00 20 f4 	mov %d15,16896
800047e8:	a5 ff b8 92 	st.w f0002a78 <_SMALL_DATA4_+0x3fffaa78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 0;                                                                  // CCU60_COUT63 routed to output signal CCU6061 TRIG1
800047ec:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
800047f0:	8f 8f c3 f1 	andn %d15,%d15,56
800047f4:	3c 1d       	j 8000482e <IfxVadc_enableGroupSync+0xa0>
    }
    else if (ccu6Num == 1)
800047f6:	df 18 1e 80 	jne %d8,1,80004832 <IfxVadc_enableGroupSync+0xa4>
    {
        // CCU60 + CCU61 Config
        CCU60_CLC.U = 0;
800047fa:	82 0f       	mov %d15,0
800047fc:	a5 ff 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d15
        CCU61_CLC.U = 0;
80004800:	a5 ff 80 c2 	st.w f0002b00 <_SMALL_DATA4_+0x3fffab00>,%d15

        if (CCU61_CLC.U)
80004804:	85 ff 80 c2 	ld.w %d15,f0002b00 <_SMALL_DATA4_+0x3fffab00>
        {}

        CCU61_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
80004808:	82 4f       	mov %d15,4
8000480a:	a5 ff 94 d2 	st.w f0002b54 <_SMALL_DATA4_+0x3fffab54>,%d15
        CCU61_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
8000480e:	a5 ff 9c d2 	st.w f0002b5c <_SMALL_DATA4_+0x3fffab5c>,%d15
        CCU61_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
80004812:	85 ff 80 e2 	ld.w %d15,f0002b80 <_SMALL_DATA4_+0x3fffab80>
80004816:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000481a:	a5 ff 80 e2 	st.w f0002b80 <_SMALL_DATA4_+0x3fffab80>,%d15
        CCU61_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
8000481e:	3b 00 20 f4 	mov %d15,16896
80004822:	a5 ff b8 d2 	st.w f0002b78 <_SMALL_DATA4_+0x3fffab78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 1;                                                                  // CCU61_COUT63 routed to output signal CCU6061 TRIG1
80004826:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
8000482a:	b7 1f 83 f1 	insert %d15,%d15,1,3,3
8000482e:	a5 ff 8c 82 	st.w f0002a0c <_SMALL_DATA4_+0x3fffaa0c>,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80004832:	02 94       	mov %d4,%d9
80004834:	1d 00 ba 15 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80004838 <IfxVadc_getAdcAnalogFrequency>:
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
80004838:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
8000483a:	6d 00 be 0c 	call 800061b6 <IfxScuCcu_getSpbFrequency>
8000483e:	19 ff 00 20 	ld.w %d15,[%a15]128
80004842:	16 1f       	and %d15,31
80004844:	c2 1f       	add %d15,1
80004846:	4b 0f 41 f1 	itof %d15,%d15
}
8000484a:	4b f2 51 20 	div.f %d2,%d2,%d15
8000484e:	00 90       	ret 

80004850 <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
80004850:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
80004852:	6d 00 b2 0c 	call 800061b6 <IfxScuCcu_getSpbFrequency>
80004856:	19 ff 00 20 	ld.w %d15,[%a15]128
8000485a:	37 0f 62 f4 	extr.u %d15,%d15,8,2
8000485e:	c2 1f       	add %d15,1
80004860:	4b 0f 41 f1 	itof %d15,%d15
}
80004864:	4b f2 51 20 	div.f %d2,%d2,%d15
80004868:	00 90       	ret 

8000486a <IfxVadc_getAdcModuleFrequency>:


float32 IfxVadc_getAdcModuleFrequency(void)
{
    return IfxScuCcu_getSpbFrequency();
8000486a:	1d 00 a6 0c 	j 800061b6 <IfxScuCcu_getSpbFrequency>

8000486e <IfxVadc_getBackgroundScanStatus>:
}


IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
8000486e:	82 0f       	mov %d15,0
80004870:	a0 7f       	mov.a %a15,7
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
    {
        if (vadc->BRSPND[i].U)
80004872:	1b 0f 07 20 	addi %d2,%d15,112
80004876:	01 42 02 26 	addsc.a %a2,%a4,%d2,2
8000487a:	54 22       	ld.w %d2,[%a2]
8000487c:	f6 24       	jnz %d2,80004884 <IfxVadc_getBackgroundScanStatus+0x16>
8000487e:	c2 1f       	add %d15,1
IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
80004880:	fc f9       	loop %a15,80004872 <IfxVadc_getBackgroundScanStatus+0x4>
80004882:	00 90       	ret 
    {
        if (vadc->BRSPND[i].U)
        {
            return IfxVadc_Status_channelsStillPending;
80004884:	82 62       	mov %d2,6
            continue;
        }
    }

    return status;
}
80004886:	00 90       	ret 

80004888 <IfxVadc_getQueueStatus>:
IfxVadc_Status IfxVadc_getQueueStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    /* just fill level is checked */
    if (0x7 == group->QSR0.B.FILL)
80004888:	19 42 08 20 	ld.w %d2,[%a4]136
8000488c:	8f f2 00 21 	and %d2,%d2,15
    {
        status = IfxVadc_Status_queueFull;
    }
    else
    {
        status = IfxVadc_Status_noError;
80004890:	8b 72 00 22 	eq %d2,%d2,7
    }

    return status;
}
80004894:	06 22       	sh %d2,2
80004896:	00 90       	ret 

80004898 <IfxVadc_getResultBasedOnRequestSource>:
Ifx_VADC_RES IfxVadc_getResultBasedOnRequestSource(Ifx_VADC *vadc, Ifx_VADC_G *group, IfxVadc_ChannelId channel, IfxVadc_RequestSource sourceType)
{
    sint32       sourceResultRegister = -1;
    Ifx_VADC_RES tmpResult;

    switch (sourceType)
80004898:	df 15 09 00 	jeq %d5,1,800048aa <IfxVadc_getResultBasedOnRequestSource+0x12>
8000489c:	76 54       	jz %d5,800048a4 <IfxVadc_getResultBasedOnRequestSource+0xc>
8000489e:	df 25 0b 00 	jeq %d5,2,800048b4 <IfxVadc_getResultBasedOnRequestSource+0x1c>
800048a2:	3c 39       	j 80004914 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    {
    case IfxVadc_RequestSource_queue:
        sourceResultRegister = group->QCTRL0.B.SRCRESREG;
800048a4:	19 5f 00 20 	ld.w %d15,[%a5]128
800048a8:	3c 03       	j 800048ae <IfxVadc_getResultBasedOnRequestSource+0x16>
        break;

    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
800048aa:	19 5f 20 20 	ld.w %d15,[%a5]160
800048ae:	16 0f       	and %d15,15
    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
        break;
    }

    if (sourceResultRegister > 0)
800048b0:	ee 39       	jnz %d15,80004922 <IfxVadc_getResultBasedOnRequestSource+0x8a>
800048b2:	3c 31       	j 80004914 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
        break;

    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
800048b4:	19 4f 00 80 	ld.w %d15,[%a4]512
800048b8:	16 0f       	and %d15,15
        break;
    }

    if (sourceResultRegister > 0)
800048ba:	ee 34       	jnz %d15,80004922 <IfxVadc_getResultBasedOnRequestSource+0x8a>

        return tmpResult;
    }
    else
    {
        if ((sourceType == IfxVadc_RequestSource_background) && (group->CHCTR[channel].B.RESTBS == 1))
800048bc:	1b 04 06 f0 	addi %d15,%d4,96
800048c0:	90 5f       	addsc.a %a15,%a5,%d15,2
800048c2:	4c f0       	ld.w %d15,[%a15]0
800048c4:	ef 4f 28 00 	jz.t %d15,20,80004914 <IfxVadc_getResultBasedOnRequestSource+0x7c>
        {
            tmpResult.B.VF     = vadc->GLOBRES.B.VF;
800048c8:	19 42 00 c0 	ld.w %d2,[%a4]768
800048cc:	82 0f       	mov %d15,0
800048ce:	67 2f 9f ff 	ins.t %d15,%d15,31,%d2,31
            tmpResult.B.FCR    = vadc->GLOBRES.B.FCR;
800048d2:	19 42 00 c0 	ld.w %d2,[%a4]768
800048d6:	67 2f 1e ff 	ins.t %d15,%d15,30,%d2,30
            tmpResult.B.CRS    = vadc->GLOBRES.B.CRS;
800048da:	19 42 00 c0 	ld.w %d2,[%a4]768
800048de:	37 02 62 2e 	extr.u %d2,%d2,28,2
800048e2:	37 2f 02 fe 	insert %d15,%d15,%d2,28,2
            tmpResult.B.EMUX   = vadc->GLOBRES.B.EMUX;
800048e6:	19 42 00 c0 	ld.w %d2,[%a4]768
800048ea:	37 02 e3 2c 	extr.u %d2,%d2,25,3
800048ee:	37 2f 83 fc 	insert %d15,%d15,%d2,25,3
            tmpResult.B.CHNR   = vadc->GLOBRES.B.CHNR;
800048f2:	19 42 00 c0 	ld.w %d2,[%a4]768
800048f6:	37 02 65 2a 	extr.u %d2,%d2,20,5
800048fa:	37 2f 05 fa 	insert %d15,%d15,%d2,20,5
            tmpResult.B.DRC    = vadc->GLOBRES.B.GNR; //The bitfields are the same but interpretation is different. TODO- define a generic result register type.
800048fe:	19 42 00 c0 	ld.w %d2,[%a4]768
80004902:	37 02 64 28 	extr.u %d2,%d2,16,4
80004906:	37 2f 04 f8 	insert %d15,%d15,%d2,16,4
            tmpResult.B.RESULT = vadc->GLOBRES.B.RESULT;
8000490a:	19 42 00 c0 	ld.w %d2,[%a4]768
8000490e:	37 2f 10 20 	insert %d2,%d15,%d2,0,16

            return tmpResult;
80004912:	00 90       	ret 
        }
        else
        {
            tmpResult.U = group->RES[group->CHCTR[channel].B.RESREG].U;
80004914:	1b 04 06 40 	addi %d4,%d4,96
80004918:	01 54 02 f6 	addsc.a %a15,%a5,%d4,2
8000491c:	4c f0       	ld.w %d15,[%a15]0
8000491e:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004922:	1b 0f 0a f0 	addi %d15,%d15,160
80004926:	90 55       	addsc.a %a5,%a5,%d15,2
80004928:	54 52       	ld.w %d2,[%a5]

            return tmpResult;
8000492a:	00 90       	ret 

8000492c <IfxVadc_getScanStatus>:

IfxVadc_Status IfxVadc_getScanStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    if (group->ASPND.U)
8000492c:	19 42 2c 20 	ld.w %d2,[%a4]172
    }
    else
    {
        return status;
    }
}
80004930:	ab 62 a0 22 	seln %d2,%d2,%d2,6
80004934:	00 90       	ret 

80004936 <IfxVadc_getSrcAddress>:

volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
80004936:	bf 45 0a 80 	jlt.u %d5,4,8000494a <IfxVadc_getSrcAddress+0x14>
    {
        index -= 4;
8000493a:	9a c5       	add %d15,%d5,-4
8000493c:	8f ff 0f 51 	and %d5,%d15,255

        if ((group & 0x1) != 0)
80004940:	8f 14 00 41 	and %d4,%d4,1
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
80004944:	da 08       	mov %d15,8
80004946:	ab 9f a0 44 	seln %d4,%d4,%d15,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
8000494a:	13 44 20 45 	madd %d4,%d5,%d4,4
8000494e:	91 00 00 f8 	movh.a %a15,32768
80004952:	d9 ff 2c 70 	lea %a15,[%a15]492 <800001ec <IfxVadc_cfg_srcAddresses>>
80004956:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2

    return &(base[0]);
}
8000495a:	c8 02       	ld.a %a2,[%a15]0
8000495c:	00 90       	ret 

8000495e <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
8000495e:	19 4f 00 20 	ld.w %d15,[%a4]128
    return &(base[0]);
}


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
80004962:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
80004964:	37 4f 02 f4 	insert %d15,%d15,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004968:	3b f0 01 40 	mov %d4,31
8000496c:	6d ff b4 fe 	call 800046d4 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
80004970:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004974:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004976:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000497a:	3b f0 01 40 	mov %d4,31
8000497e:	1d ff 8f fe 	j 8000469c <IfxVadc_disableAccess>

80004982 <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80004982:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
}


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
80004986:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
80004988:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
8000498c:	3b f0 01 40 	mov %d4,31
80004990:	6d ff a2 fe 	call 800046d4 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
80004994:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004998:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
8000499a:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000499e:	3b f0 01 40 	mov %d4,31
800049a2:	1d ff 7d fe 	j 8000469c <IfxVadc_disableAccess>

800049a6 <IfxVadc_initializeFAdcD>:
}


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
800049a6:	02 4f       	mov %d15,%d4
800049a8:	40 4f       	mov.aa %a15,%a4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
800049aa:	6d 00 06 0c 	call 800061b6 <IfxScuCcu_getSpbFrequency>
800049ae:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
800049b2:	4b f2 11 42 	div.u %e4,%d2,%d15
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800049b6:	82 3f       	mov %d15,3
800049b8:	c2 f4       	add %d4,-1
800049ba:	0b f4 90 41 	min.u %d4,%d4,%d15

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
800049be:	1b 14 00 80 	addi %d8,%d4,1
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
800049c2:	40 f4       	mov.aa %a4,%a15

    divD   = (fadc / fAdcD - 1);

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
800049c4:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
800049c8:	6d ff cb ff 	call 8000495e <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
800049cc:	02 82       	mov %d2,%d8
800049ce:	00 90       	ret 

800049d0 <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
800049d0:	02 4f       	mov %d15,%d4
800049d2:	40 4f       	mov.aa %a15,%a4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
800049d4:	6d 00 f1 0b 	call 800061b6 <IfxScuCcu_getSpbFrequency>
800049d8:	4b 02 71 21 	ftouz %d2,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
800049dc:	8f 22 00 40 	sh %d4,%d2,2
800049e0:	4b f4 11 42 	div.u %e4,%d4,%d15
800049e4:	3b f0 01 50 	mov %d5,31

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
800049e8:	c2 24       	add %d4,2
800049ea:	06 e4       	sh %d4,-2
    divA   = __minu(divA - 1, 0x1Fu);
800049ec:	c2 f4       	add %d4,-1
800049ee:	0b 54 90 41 	min.u %d4,%d4,%d5
    result = fadc / (divA + 1);
800049f2:	1b 14 00 30 	addi %d3,%d4,1
800049f6:	4b 32 11 62 	div.u %e6,%d2,%d3
800049fa:	02 6f       	mov %d15,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
800049fc:	7b 10 13 60 	movh %d6,305
80004a00:	1b 16 d0 62 	addi %d6,%d6,11521
80004a04:	3f 6f 08 80 	jlt.u %d15,%d6,80004a14 <IfxVadc_initializeFAdcI+0x44>
80004a08:	0b 53 90 41 	min.u %d4,%d3,%d5
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
80004a0c:	9a 14       	add %d15,%d4,1
80004a0e:	4b f2 11 22 	div.u %e2,%d2,%d15
80004a12:	02 2f       	mov %d15,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80004a14:	1b 0f ee 25 	addi %d2,%d15,24288
80004a18:	7b a0 12 30 	movh %d3,298
80004a1c:	9b 82 ff 2f 	addih %d2,%d2,65528
80004a20:	1b 13 be 38 	addi %d3,%d3,-29727
80004a24:	7f 32 06 80 	jge.u %d2,%d3,80004a30 <IfxVadc_initializeFAdcI+0x60>
    {
        result = 0;             /* Min / Max FAdcI frequency */
    }
    else
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
80004a28:	40 f4       	mov.aa %a4,%a15
80004a2a:	6d ff ac ff 	call 80004982 <IfxVadc_initialiseAdcConverterClock>
80004a2e:	3c 02       	j 80004a32 <IfxVadc_initializeFAdcI+0x62>
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
    {
        result = 0;             /* Min / Max FAdcI frequency */
80004a30:	82 0f       	mov %d15,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
80004a32:	02 f2       	mov %d2,%d15
80004a34:	00 90       	ret 

80004a36 <IfxVadc_isPostCalibration>:
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
        break;
    default: pcEnabled                = FALSE;
80004a36:	82 02       	mov %d2,0

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
80004a38:	ff 84 33 80 	jge.u %d4,8,80004a9e <IfxVadc_isPostCalibration+0x68>
80004a3c:	91 00 00 f8 	movh.a %a15,32768
80004a40:	d9 ff 90 94 	lea %a15,[%a15]19024 <80004a50 <IfxVadc_isPostCalibration+0x1a>>
80004a44:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
        break;
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
80004a48:	19 42 00 20 	ld.w %d2,[%a4]128

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
80004a4c:	dc 0f       	ji %a15
80004a4e:	00 00       	nop 
80004a50:	1d 00 10 00 	j 80004a70 <IfxVadc_isPostCalibration+0x3a>
80004a54:	1d 00 11 00 	j 80004a76 <IfxVadc_isPostCalibration+0x40>
80004a58:	1d 00 12 00 	j 80004a7c <IfxVadc_isPostCalibration+0x46>
80004a5c:	1d 00 13 00 	j 80004a82 <IfxVadc_isPostCalibration+0x4c>
80004a60:	1d 00 14 00 	j 80004a88 <IfxVadc_isPostCalibration+0x52>
80004a64:	1d 00 15 00 	j 80004a8e <IfxVadc_isPostCalibration+0x58>
80004a68:	1d 00 16 00 	j 80004a94 <IfxVadc_isPostCalibration+0x5e>
80004a6c:	1d 00 17 00 	j 80004a9a <IfxVadc_isPostCalibration+0x64>
    {
    case IfxVadc_GroupId_0: pcEnabled = vadc->GLOBCFG.B.DPCAL0 == 0;
80004a70:	07 22 10 28 	nand.t %d2,%d2,16,%d2,16
        break;
80004a74:	00 90       	ret 
    case IfxVadc_GroupId_1: pcEnabled = vadc->GLOBCFG.B.DPCAL1 == 0;
80004a76:	07 22 91 28 	nand.t %d2,%d2,17,%d2,17
        break;
80004a7a:	00 90       	ret 
    case IfxVadc_GroupId_2: pcEnabled = vadc->GLOBCFG.B.DPCAL2 == 0;
80004a7c:	07 22 12 29 	nand.t %d2,%d2,18,%d2,18
        break;
80004a80:	00 90       	ret 
    case IfxVadc_GroupId_3: pcEnabled = vadc->GLOBCFG.B.DPCAL3 == 0;
80004a82:	07 22 93 29 	nand.t %d2,%d2,19,%d2,19
        break;
80004a86:	00 90       	ret 
    case IfxVadc_GroupId_4: pcEnabled = vadc->GLOBCFG.B.DPCAL4 == 0;
80004a88:	07 22 14 2a 	nand.t %d2,%d2,20,%d2,20
        break;
80004a8c:	00 90       	ret 
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
80004a8e:	07 22 95 2a 	nand.t %d2,%d2,21,%d2,21
        break;
80004a92:	00 90       	ret 
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
80004a94:	07 22 16 2b 	nand.t %d2,%d2,22,%d2,22
        break;
80004a98:	00 90       	ret 
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
80004a9a:	07 22 97 2b 	nand.t %d2,%d2,23,%d2,23
    default: pcEnabled                = FALSE;
        break;
    }

    return pcEnabled;
}
80004a9e:	00 90       	ret 

80004aa0 <IfxVadc_getChannelConversionTime>:
    return status;
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
80004aa0:	02 40       	mov %d0,%d4
80004aa2:	02 68       	mov %d8,%d6
80004aa4:	02 7a       	mov %d10,%d7
80004aa6:	14 a4       	ld.bu %d4,[%sp]
    IfxVadc_ChannelResolution resolution;
    uint32                    n;

    uint32                    inputClassNum;

    if (inputClass <= IfxVadc_InputClasses_group1)
80004aa8:	ff 25 08 80 	jge.u %d5,2,80004ab8 <IfxVadc_getChannelConversionTime+0x18>
    {
        inputClassNum = inputClass;
        stcs          = vadcG->ICLASS[inputClassNum].B.STCS;
80004aac:	8f 80 00 f0 	sh %d15,%d0,8
80004ab0:	42 f5       	add %d5,%d15
80004ab2:	1b 85 12 50 	addi %d5,%d5,296
80004ab6:	3c 03       	j 80004abc <IfxVadc_getChannelConversionTime+0x1c>
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004ab8:	1b 65 02 50 	addi %d5,%d5,38
80004abc:	01 45 02 f6 	addsc.a %a15,%a4,%d5,2
80004ac0:	4c f0       	ld.w %d15,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004ac2:	48 03       	ld.w %d3,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004ac4:	16 1f       	and %d15,31
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
    }

    if (stcs > 16)
80004ac6:	8b 1f 61 22 	lt.u %d2,%d15,17
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004aca:	37 03 63 34 	extr.u %d3,%d3,8,3
    }

    if (stcs > 16)
80004ace:	f6 24       	jnz %d2,80004ad6 <IfxVadc_getChannelConversionTime+0x36>
    {
        stcs = (stcs - 15) * 16; // Reference for the logic: Table 28-4 of TC29xB User Manual v1.3
80004ad0:	1b 1f ff ff 	addi %d15,%d15,-15
80004ad4:	06 4f       	sh %d15,4
80004ad6:	ff 63 35 80 	jge.u %d3,6,80004b40 <IfxVadc_getChannelConversionTime+0xa0>
80004ada:	91 00 00 f8 	movh.a %a15,32768
80004ade:	d9 ff 24 70 	lea %a15,[%a15]484 <800001e4 <CSWTCH.25>>
80004ae2:	01 f3 00 f6 	addsc.a %a15,%a15,%d3,0
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004ae6:	82 02       	mov %d2,0
80004ae8:	08 09       	ld.bu %d9,[%a15]0
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004aea:	df 04 2f 80 	jne %d4,0,80004b48 <IfxVadc_getChannelConversionTime+0xa8>
    {
        if (resolution != IfxVadc_ChannelResolution_10bitFast)
80004aee:	df 53 0d 00 	jeq %d3,5,80004b08 <IfxVadc_getChannelConversionTime+0x68>
        {
            /* Standard conversion */
            uint32 pc = IfxVadc_isPostCalibration(vadc, group) ? 2 : 0;
80004af2:	02 04       	mov %d4,%d0
80004af4:	6d ff a1 ff 	call 80004a36 <IfxVadc_isPostCalibration>
80004af8:	92 24       	add %d4,%d15,2
80004afa:	ab 22 a0 22 	seln %d2,%d2,%d2,2
80004afe:	42 94       	add %d4,%d9
            conversionTime = (float32)(2 + stcs + n + pc) / analogFrequency + 2.0 / moduleFrequency;
80004b00:	42 24       	add %d4,%d2
80004b02:	4b 04 41 41 	itof %d4,%d4
80004b06:	3c 04       	j 80004b0e <IfxVadc_getChannelConversionTime+0x6e>
        }
        else
        {
            /* Fast compare mode */
            conversionTime = (float32)(2 + stcs + 2) / analogFrequency + 2.0 / moduleFrequency;
80004b08:	c2 4f       	add %d15,4
80004b0a:	4b 0f 41 41 	itof %d4,%d15
80004b0e:	4b 84 51 40 	div.f %d4,%d4,%d8
80004b12:	6d 00 59 2d 	call 8000a5c4 <__extendsfdf2>
80004b16:	02 a4       	mov %d4,%d10
80004b18:	0b 23 10 88 	mov %e8,%d3,%d2
80004b1c:	6d 00 54 2d 	call 8000a5c4 <__extendsfdf2>
80004b20:	b7 00 21 4f 	imask %e4,0,30,1
80004b24:	0b 23 10 68 	mov %e6,%d3,%d2
80004b28:	6d 00 43 2f 	call 8000a9ae <__divdf3>
80004b2c:	0b 89 10 48 	mov %e4,%d9,%d8
80004b30:	0b 23 10 68 	mov %e6,%d3,%d2
80004b34:	6d 00 2f 2e 	call 8000a792 <__adddf3>
80004b38:	0b 23 10 48 	mov %e4,%d3,%d2
80004b3c:	1d 00 f8 2f 	j 8000ab2c <__truncdfsf2>
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004b40:	82 09       	mov %d9,0
80004b42:	df 04 d8 7f 	jeq %d4,0,80004af2 <IfxVadc_getChannelConversionTime+0x52>
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004b46:	82 02       	mov %d2,0
    {
        // do nothing
    }

    return conversionTime;
}
80004b48:	00 90       	ret 

80004b4a <IfxVadc_resetKernel>:
    return pcEnabled;
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
80004b4a:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004b4c:	6d 00 f9 13 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80004b50:	02 24       	mov %d4,%d2
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004b52:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80004b54:	6d 00 f5 12 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b58:	3b f0 01 40 	mov %d4,31
80004b5c:	40 f4       	mov.aa %a4,%a15
80004b5e:	6d ff bb fd 	call 800046d4 <IfxVadc_enableAccess>
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
80004b62:	48 c2       	ld.w %d2,[%a15]48
    vadc->KRST0.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004b64:	02 f4       	mov %d4,%d15
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
80004b66:	8f 12 40 21 	or %d2,%d2,1
80004b6a:	68 c2       	st.w [%a15]48,%d2
    vadc->KRST0.B.RST = 1;
80004b6c:	48 d2       	ld.w %d2,[%a15]52
80004b6e:	8f 12 40 21 	or %d2,%d2,1
80004b72:	68 d2       	st.w [%a15]52,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004b74:	6d 00 1a 14 	call 800073a8 <IfxScuWdt_setCpuEndinit>

    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */
80004b78:	48 d2       	ld.w %d2,[%a15]52
80004b7a:	6f 12 ff 7f 	jz.t %d2,1,80004b78 <IfxVadc_resetKernel+0x2e>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004b7e:	02 f4       	mov %d4,%d15
80004b80:	6d 00 df 12 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
80004b84:	48 b2       	ld.w %d2,[%a15]44
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b86:	3b f0 01 40 	mov %d4,31
    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
80004b8a:	8f 12 40 21 	or %d2,%d2,1
80004b8e:	68 b2       	st.w [%a15]44,%d2
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b90:	40 f4       	mov.aa %a4,%a15
80004b92:	6d ff 85 fd 	call 8000469c <IfxVadc_disableAccess>
    IfxScuWdt_setCpuEndinit(passwd);
80004b96:	02 f4       	mov %d4,%d15
80004b98:	1d 00 08 14 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80004b9c <IfxVadc_selectPowerSupplyVoltage>:


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80004b9c:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
80004ba0:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80004ba2:	67 4f 0e f0 	ins.t %d15,%d15,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004ba6:	3b f0 01 40 	mov %d4,31
80004baa:	6d ff 95 fd 	call 800046d4 <IfxVadc_enableAccess>
void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
80004bae:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bb2:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004bb4:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bb8:	3b f0 01 40 	mov %d4,31
80004bbc:	1d ff 70 fd 	j 8000469c <IfxVadc_disableAccess>

80004bc0 <IfxVadc_setArbiterPriority>:
}


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80004bc0:	1b 87 01 f0 	addi %d15,%d7,24
    if (slotEnable != FALSE)
80004bc4:	df 04 23 00 	jeq %d4,0,80004c0a <IfxVadc_setArbiterPriority+0x4a>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80004bc8:	19 42 04 00 	ld.w %d2,[%a4]4
80004bcc:	0f f4 00 40 	sh %d4,%d4,%d15
80004bd0:	a6 24       	or %d4,%d2
80004bd2:	59 44 04 00 	st.w [%a4]4,%d4
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80004bd6:	19 42 04 00 	ld.w %d2,[%a4]4
80004bda:	06 27       	sh %d7,2
80004bdc:	82 3f       	mov %d15,3
80004bde:	0f 7f 00 f0 	sh %d15,%d15,%d7
80004be2:	0f f2 e0 f0 	andn %d15,%d2,%d15
80004be6:	6c 41       	st.w [%a4]4,%d15
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80004be8:	4c 41       	ld.w %d15,[%a4]4
80004bea:	0f 75 00 50 	sh %d5,%d5,%d7
80004bee:	a6 f5       	or %d5,%d15
80004bf0:	59 45 04 00 	st.w [%a4]4,%d5

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004bf4:	4c 41       	ld.w %d15,[%a4]4
80004bf6:	c2 37       	add %d7,3
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80004bf8:	76 64       	jz %d6,80004c00 <IfxVadc_setArbiterPriority+0x40>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004bfa:	d7 1f 01 77 	insert %d7,%d15,1,%d7,1
80004bfe:	3c 03       	j 80004c04 <IfxVadc_setArbiterPriority+0x44>
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80004c00:	d7 0f 01 77 	insert %d7,%d15,0,%d7,1
80004c04:	59 47 04 00 	st.w [%a4]4,%d7
80004c08:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80004c0a:	19 44 04 00 	ld.w %d4,[%a4]4
80004c0e:	d7 04 01 ff 	insert %d15,%d4,0,%d15,1
80004c12:	6c 41       	st.w [%a4]4,%d15
80004c14:	00 90       	ret 

80004c16 <IfxVadc_setScan>:

void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80004c16:	19 4f 28 20 	ld.w %d15,[%a4]168
80004c1a:	26 54       	and %d4,%d5
80004c1c:	0f 5f e0 f0 	andn %d15,%d15,%d5
80004c20:	0f 4f a0 50 	or %d5,%d15,%d4
80004c24:	59 45 28 20 	st.w [%a4]168,%d5
80004c28:	00 90       	ret 

80004c2a <IfxVadc_startupCalibration>:
{
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c2a:	3b f0 01 40 	mov %d4,31
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004c2e:	40 4f       	mov.aa %a15,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c30:	6d ff 52 fd 	call 800046d4 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80004c34:	19 ff 00 20 	ld.w %d15,[%a15]128
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004c38:	40 f4       	mov.aa %a4,%a15
80004c3a:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80004c3e:	3b f0 01 40 	mov %d4,31
80004c42:	59 ff 00 20 	st.w [%a15]128,%d15
80004c46:	6d ff 2b fd 	call 8000469c <IfxVadc_disableAccess>
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004c4a:	82 02       	mov %d2,0

    /* Wait for hardware self-test and calibration to complete */
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;
80004c4c:	82 0f       	mov %d15,0
80004c4e:	a0 72       	mov.a %a2,7


IFX_INLINE uint8 IfxVadc_getAdcCalibrationActiveState(Ifx_VADC *vadc, uint8 adcCalGroupNum)
{
    uint8 status;
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80004c50:	8f a2 00 30 	sh %d3,%d2,10
80004c54:	01 f3 00 36 	addsc.a %a3,%a15,%d3,0
80004c58:	c2 12       	add %d2,1
80004c5a:	19 33 40 20 	ld.w %d3,[%a3]1152
80004c5e:	37 03 61 3e 	extr.u %d3,%d3,28,1

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
            {
                calibrationRunning = TRUE;
80004c62:	ab 1f a0 f3 	seln %d15,%d3,%d15,1
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80004c66:	fc 25       	loop %a2,80004c50 <IfxVadc_startupCalibration+0x26>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80004c68:	df 1f f1 7f 	jeq %d15,1,80004c4a <IfxVadc_startupCalibration+0x20>
}
80004c6c:	00 90       	ret 
	...

80004c70 <IfxAsclin_disableModule>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
80004c70:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c72:	6d 00 66 13 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004c76:	02 24       	mov %d4,%d2
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c78:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004c7a:	6d 00 62 12 	call 8000713e <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80004c7e:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclin); /* disables the module*/
    IfxScuWdt_setCpuEndinit(psw);              /* sets the endinit protection back on*/
80004c80:	02 f4       	mov %d4,%d15
80004c82:	8f 12 40 21 	or %d2,%d2,1
80004c86:	68 02       	st.w [%a15]0,%d2
80004c88:	1d 00 90 13 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80004c8c <IfxAsclin_enableAscErrorFlags>:
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80004c8c:	7b 10 00 f0 	movh %d15,1
80004c90:	ab 0f 80 44 	sel %d4,%d4,%d15,0
80004c94:	19 4f 00 10 	ld.w %d15,[%a4]64
80004c98:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80004c9c:	a6 f4       	or %d4,%d15
80004c9e:	59 44 00 10 	st.w [%a4]64,%d4
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80004ca2:	7b 00 40 f0 	movh %d15,1024
80004ca6:	ab 0f 80 55 	sel %d5,%d5,%d15,0
80004caa:	19 4f 00 10 	ld.w %d15,[%a4]64
80004cae:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80004cb2:	a6 f5       	or %d5,%d15
80004cb4:	59 45 00 10 	st.w [%a4]64,%d5
80004cb8:	00 90       	ret 

80004cba <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
80004cba:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004cbc:	6d 00 41 13 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004cc0:	02 24       	mov %d4,%d2
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004cc2:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004cc4:	6d 00 3d 12 	call 8000713e <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
80004cc8:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
80004cca:	02 f4       	mov %d4,%d15
80004ccc:	8f 12 c0 21 	andn %d2,%d2,1
80004cd0:	68 02       	st.w [%a15]0,%d2
80004cd2:	1d 00 6b 13 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80004cd6 <IfxAsclin_getAddress>:
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
    }
    else
    {
        module = NULL_PTR;
80004cd6:	a0 02       	mov.a %a2,0

Ifx_ASCLIN *IfxAsclin_getAddress(IfxAsclin_Index asclin)
{
    Ifx_ASCLIN *module;

    if (asclin < IFXASCLIN_NUM_MODULES)
80004cd8:	ff 44 09 00 	jge %d4,4,80004cea <IfxAsclin_getAddress+0x14>
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
80004cdc:	91 00 00 f8 	movh.a %a15,32768
80004ce0:	d9 ff bc 40 	lea %a15,[%a15]2364 <8000093c <IfxAsclin_cfg_indexMap>>
80004ce4:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80004ce8:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
80004cea:	00 90       	ret 

80004cec <IfxAsclin_getFaFrequency>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004cec:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004cf0:	16 1f       	and %d15,31
float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
80004cf2:	c2 ff       	add %d15,-1
80004cf4:	8b 0f a1 22 	ge.u %d2,%d15,16
80004cf8:	df 02 32 80 	jne %d2,0,80004d5c <IfxAsclin_getFaFrequency+0x70>
80004cfc:	91 00 00 f8 	movh.a %a15,32768
80004d00:	d9 ff c8 44 	lea %a15,[%a15]19720 <80004d08 <IfxAsclin_getFaFrequency+0x1c>>
80004d04:	90 ff       	addsc.a %a15,%a15,%d15,2
80004d06:	dc 0f       	ji %a15
80004d08:	1d 00 20 00 	j 80004d48 <IfxAsclin_getFaFrequency+0x5c>
80004d0c:	1d 00 20 00 	j 80004d4c <IfxAsclin_getFaFrequency+0x60>
80004d10:	1d 00 26 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d14:	1d 00 1e 00 	j 80004d50 <IfxAsclin_getFaFrequency+0x64>
80004d18:	1d 00 22 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d1c:	1d 00 20 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d20:	1d 00 1e 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d24:	1d 00 18 00 	j 80004d54 <IfxAsclin_getFaFrequency+0x68>
80004d28:	1d 00 1a 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d2c:	1d 00 18 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d30:	1d 00 16 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d34:	1d 00 14 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d38:	1d 00 12 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d3c:	1d 00 10 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d40:	1d 00 0e 00 	j 80004d5c <IfxAsclin_getFaFrequency+0x70>
80004d44:	1d 00 0a 00 	j 80004d58 <IfxAsclin_getFaFrequency+0x6c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80004d48:	1d 00 37 0a 	j 800061b6 <IfxScuCcu_getSpbFrequency>
        break;
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
80004d4c:	1d 00 a6 08 	j 80005e98 <IfxScuCcu_getOsc0Frequency>
        break;
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80004d50:	1d 00 c3 08 	j 80005ed6 <IfxScuCcu_getPllErayFrequency>
        break;
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
80004d54:	1d 00 20 0a 	j 80006194 <IfxScuCcu_getBaud2Frequency>
        break;
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80004d58:	1d 00 0e 0a 	j 80006174 <IfxScuCcu_getBaud1Frequency>
        frequency = 0.0;
        break;
    }

    return frequency;
}
80004d5c:	82 02       	mov %d2,0
80004d5e:	00 90       	ret 

80004d60 <IfxAsclin_getIndex>:

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004d60:	91 00 00 38 	movh.a %a3,32768
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004d64:	82 0f       	mov %d15,0
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004d66:	d9 33 bc 40 	lea %a3,[%a3]2364 <8000093c <IfxAsclin_cfg_indexMap>>
80004d6a:	a0 3f       	mov.a %a15,3
80004d6c:	d0 32       	addsc.a %a2,%a3,%d15,3
80004d6e:	d4 25       	ld.a %a5,[%a2]
80004d70:	7d 45 05 80 	jne.a %a5,%a4,80004d7a <IfxAsclin_getIndex+0x1a>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80004d74:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80004d78:	00 90       	ret 
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004d7a:	c2 1f       	add %d15,1
80004d7c:	fc f8       	loop %a15,80004d6c <IfxAsclin_getIndex+0xc>
IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;
80004d7e:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80004d80:	00 90       	ret 

80004d82 <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
80004d82:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
80004d84:	6d ff b4 ff 	call 80004cec <IfxAsclin_getFaFrequency>
80004d88:	4c f5       	ld.w %d15,[%a15]20
80004d8a:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004d8e:	c2 1f       	add %d15,1
80004d90:	4b 0f 41 f1 	itof %d15,%d15
}
80004d94:	4b f2 51 20 	div.f %d2,%d2,%d15
80004d98:	00 90       	ret 

80004d9a <IfxAsclin_getOvsFrequency>:
    return result;
}


float32 IfxAsclin_getOvsFrequency(Ifx_ASCLIN *asclin)
{
80004d9a:	40 4f       	mov.aa %a15,%a4
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
80004d9c:	6d ff f3 ff 	call 80004d82 <IfxAsclin_getPdFrequency>
80004da0:	48 83       	ld.w %d3,[%a15]32
80004da2:	4c f8       	ld.w %d15,[%a15]32
80004da4:	37 03 6c 38 	extr.u %d3,%d3,16,12
80004da8:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004dac:	4b 03 41 31 	itof %d3,%d3
80004db0:	4b 0f 41 f1 	itof %d15,%d15
80004db4:	4b 32 41 20 	mul.f %d2,%d2,%d3
}
80004db8:	4b f2 51 20 	div.f %d2,%d2,%d15
80004dbc:	00 90       	ret 

80004dbe <IfxAsclin_getShiftFrequency>:
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
}


float32 IfxAsclin_getShiftFrequency(Ifx_ASCLIN *asclin)
{
80004dbe:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getOvsFrequency(asclin) / asclin->BITCON.B.OVERSAMPLING;
80004dc0:	6d ff ed ff 	call 80004d9a <IfxAsclin_getOvsFrequency>
80004dc4:	4c f5       	ld.w %d15,[%a15]20
80004dc6:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004dca:	4b 0f 41 f1 	itof %d15,%d15
}
80004dce:	4b f2 51 20 	div.f %d2,%d2,%d15
80004dd2:	00 90       	ret 

80004dd4 <IfxAsclin_getSrcPointerEr>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
80004dd4:	6d ff c6 ff 	call 80004d60 <IfxAsclin_getIndex>
80004dd8:	53 c2 20 f0 	mul %d15,%d2,12
80004ddc:	60 ff       	mov.a %a15,%d15
80004dde:	d9 f2 08 28 	lea %a2,[%a15]-32632
}
80004de2:	11 42 00 2f 	addih.a %a2,%a2,61444
80004de6:	00 90       	ret 

80004de8 <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
80004de8:	6d ff bc ff 	call 80004d60 <IfxAsclin_getIndex>
80004dec:	53 c2 20 f0 	mul %d15,%d2,12
80004df0:	60 ff       	mov.a %a15,%d15
80004df2:	d9 f2 04 28 	lea %a2,[%a15]-32636
}
80004df6:	11 42 00 2f 	addih.a %a2,%a2,61444
80004dfa:	00 90       	ret 

80004dfc <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
80004dfc:	6d ff b2 ff 	call 80004d60 <IfxAsclin_getIndex>
80004e00:	53 c2 20 f0 	mul %d15,%d2,12
80004e04:	60 ff       	mov.a %a15,%d15
80004e06:	d9 f2 00 28 	lea %a2,[%a15]-32640
}
80004e0a:	11 42 00 2f 	addih.a %a2,%a2,61444
80004e0e:	00 90       	ret 

80004e10 <IfxAsclin_read16>:


uint32 IfxAsclin_read16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004e10:	9f 04 04 80 	jned %d4,0,80004e18 <IfxAsclin_read16+0x8>
        *data++ = (uint16)rxData->U;
        count--;
    }

    return count;
}
80004e14:	82 02       	mov %d2,0
80004e16:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint16)rxData->U;
80004e18:	19 4f 08 10 	ld.w %d15,[%a4]72
80004e1c:	ac 50       	st.h [%a5]0,%d15
80004e1e:	b0 25       	add.a %a5,2
80004e20:	3c f8       	j 80004e10 <IfxAsclin_read16>

80004e22 <IfxAsclin_read32>:
    return count;
}


uint32 IfxAsclin_read32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004e22:	9f 04 04 80 	jned %d4,0,80004e2a <IfxAsclin_read32+0x8>
        *data++ = rxData->U;
        count--;
    }

    return count;
}
80004e26:	82 02       	mov %d2,0
80004e28:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = rxData->U;
80004e2a:	19 4f 08 10 	ld.w %d15,[%a4]72
80004e2e:	6c 50       	st.w [%a5]0,%d15
80004e30:	b0 45       	add.a %a5,4
80004e32:	3c f8       	j 80004e22 <IfxAsclin_read32>

80004e34 <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004e34:	9f 04 04 80 	jned %d4,0,80004e3c <IfxAsclin_read8+0x8>
        *data++ = (uint8)rxData->U;
        count--;
    }

    return count;
}
80004e38:	82 02       	mov %d2,0
80004e3a:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint8)rxData->U;
80004e3c:	19 4f 08 10 	ld.w %d15,[%a4]72
80004e40:	2c 50       	st.b [%a5]0,%d15
80004e42:	b0 15       	add.a %a5,1
80004e44:	3c f8       	j 80004e34 <IfxAsclin_read8>

80004e46 <IfxAsclin_resetModule>:
    return count;
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
80004e46:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004e48:	6d 00 7b 12 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004e4c:	02 24       	mov %d4,%d2
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004e4e:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004e50:	6d 00 77 11 	call 8000713e <IfxScuWdt_clearCpuEndinit>

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004e54:	19 f2 34 30 	ld.w %d2,[%a15]244
    asclin->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004e58:	02 f4       	mov %d4,%d15
void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004e5a:	8f 12 40 21 	or %d2,%d2,1
80004e5e:	59 f2 34 30 	st.w [%a15]244,%d2
    asclin->KRST1.B.RST = 1;
80004e62:	19 f2 30 30 	ld.w %d2,[%a15]240
80004e66:	8f 12 40 21 	or %d2,%d2,1
80004e6a:	59 f2 30 30 	st.w [%a15]240,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004e6e:	6d 00 9d 12 	call 800073a8 <IfxScuWdt_setCpuEndinit>

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
80004e72:	19 f2 34 30 	ld.w %d2,[%a15]244
80004e76:	6f 12 fe 7f 	jz.t %d2,1,80004e72 <IfxAsclin_resetModule+0x2c>
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004e7a:	02 f4       	mov %d4,%d15
80004e7c:	6d 00 61 11 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004e80:	19 f2 2c 30 	ld.w %d2,[%a15]236

    IfxScuWdt_setCpuEndinit(passwd);
80004e84:	02 f4       	mov %d4,%d15

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004e86:	8f 12 40 21 	or %d2,%d2,1
80004e8a:	59 f2 2c 30 	st.w [%a15]236,%d2

    IfxScuWdt_setCpuEndinit(passwd);
80004e8e:	1d 00 8d 12 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80004e92 <IfxAsclin_setClockSource>:
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004e92:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004e96:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
80004e9a:	59 4f 0c 10 	st.w [%a4]76,%d15

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80004e9e:	f6 46       	jnz %d4,80004eaa <IfxAsclin_setClockSource+0x18>
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004ea0:	19 4f 0c 10 	ld.w %d15,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004ea4:	bf 0f fe 7f 	jlt %d15,0,80004ea0 <IfxAsclin_setClockSource+0xe>
80004ea8:	00 90       	ret 
80004eaa:	19 4f 0c 10 	ld.w %d15,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80004eae:	ff 0f fe 7f 	jge %d15,0,80004eaa <IfxAsclin_setClockSource+0x18>
80004eb2:	00 90       	ret 

80004eb4 <IfxAsclin_setBaudrateBitFields>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004eb4:	19 4f 0c 10 	ld.w %d15,[%a4]76
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004eb8:	19 42 0c 10 	ld.w %d2,[%a4]76
80004ebc:	16 1f       	and %d15,31
80004ebe:	8f f2 c1 21 	andn %d2,%d2,31
80004ec2:	59 42 0c 10 	st.w [%a4]76,%d2
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004ec6:	19 42 0c 10 	ld.w %d2,[%a4]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004eca:	bf 02 fe 7f 	jlt %d2,0,80004ec6 <IfxAsclin_setBaudrateBitFields+0x12>
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80004ece:	19 42 14 00 	ld.w %d2,[%a4]20
80004ed2:	c2 f4       	add %d4,-1
80004ed4:	37 42 0c 40 	insert %d4,%d2,%d4,0,12
80004ed8:	59 44 14 00 	st.w [%a4]20,%d4
}


IFX_INLINE void IfxAsclin_setNumerator(Ifx_ASCLIN *asclin, uint16 numerator)
{
    asclin->BRG.B.NUMERATOR = numerator;
80004edc:	19 42 20 00 	ld.w %d2,[%a4]32
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);                             /* turns off the clock for settings */
    IfxAsclin_setPrescaler(asclin, prescaler);                                                   /* sets the prescaler*/
    IfxAsclin_setNumerator(asclin, numerator);                                                   /* sets the numerator*/
    IfxAsclin_setDenominator(asclin, denominator);                                               /* sets the denominator*/
    IfxAsclin_setOversampling(asclin, oversampling);                                             /* sets the oversampling*/
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
80004ee0:	02 f4       	mov %d4,%d15
80004ee2:	37 52 0c 58 	insert %d5,%d2,%d5,16,12
80004ee6:	59 45 20 00 	st.w [%a4]32,%d5
}


IFX_INLINE void IfxAsclin_setDenominator(Ifx_ASCLIN *asclin, uint16 denominator)
{
    asclin->BRG.B.DENOMINATOR = denominator;
80004eea:	19 42 20 00 	ld.w %d2,[%a4]32
80004eee:	37 62 0c 60 	insert %d6,%d2,%d6,0,12
80004ef2:	59 46 20 00 	st.w [%a4]32,%d6
}


IFX_INLINE void IfxAsclin_setOversampling(Ifx_ASCLIN *asclin, IfxAsclin_OversamplingFactor ovsFactor)
{
    asclin->BITCON.B.OVERSAMPLING = ovsFactor;
80004ef6:	19 42 14 00 	ld.w %d2,[%a4]20
80004efa:	37 72 04 78 	insert %d7,%d2,%d7,16,4
80004efe:	59 47 14 00 	st.w [%a4]20,%d7
80004f02:	1d ff c8 ff 	j 80004e92 <IfxAsclin_setClockSource>

80004f06 <IfxAsclin_setBitTiming>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004f06:	19 42 0c 10 	ld.w %d2,[%a4]76
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
80004f0a:	20 08       	sub.a %sp,8
80004f0c:	8f f2 01 21 	and %d2,%d2,31
80004f10:	02 5f       	mov %d15,%d5
80004f12:	40 4f       	mov.aa %a15,%a4
80004f14:	02 48       	mov %d8,%d4
80004f16:	02 6a       	mov %d10,%d6
80004f18:	60 7d       	mov.a %a13,%d7
80004f1a:	60 2c       	mov.a %a12,%d2
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004f1c:	6d ff 33 ff 	call 80004d82 <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004f20:	92 15       	add %d5,%d15,1
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004f22:	02 29       	mov %d9,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004f24:	82 4f       	mov %d15,4
80004f26:	0b f5 b0 f1 	max.u %d15,%d5,%d15
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004f2a:	8f ff 0f 21 	and %d2,%d15,255
80004f2e:	59 a2 04 00 	st.w [%sp]4,%d2
80004f32:	82 16       	mov %d6,1
80004f34:	0b 6a b0 61 	max.u %d6,%d10,%d6
80004f38:	16 ff       	and %d15,255
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
80004f3a:	4b 0f 41 31 	itof %d3,%d15
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004f3e:	8f f6 0f 61 	and %d6,%d6,255
    fOvs         = baudrate * oversampling;
80004f42:	4b 38 41 f0 	mul.f %d15,%d8,%d3
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004f46:	60 6e       	mov.a %a14,%d6
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004f48:	02 f4       	mov %d4,%d15
80004f4a:	6d 00 3d 2b 	call 8000a5c4 <__extendsfdf2>
80004f4e:	7b 00 f5 73 	movh %d7,16208
80004f52:	0b 23 10 48 	mov %e4,%d3,%d2
80004f56:	7b 20 2f 6d 	movh %d6,54002
80004f5a:	1b d7 24 76 	addi %d7,%d7,25165
80004f5e:	1b c6 9f 6a 	addi %d6,%d6,-22020
80004f62:	6d 00 54 2c 	call 8000a80a <__muldf3>
80004f66:	0b 23 10 48 	mov %e4,%d3,%d2
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
    nBest          = n;
80004f6a:	82 1c       	mov %d12,1
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004f6c:	6d 00 e0 2d 	call 8000ab2c <__truncdfsf2>

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004f70:	4b f9 51 50 	div.f %d5,%d9,%d15
80004f74:	91 00 00 20 	movh.a %a2,0

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);
80004f78:	82 01       	mov %d1,0

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004f7a:	4b 05 71 51 	ftouz %d5,%d5
    }

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
80004f7e:	4b 05 61 31 	utof %d3,%d5
80004f82:	4b 39 51 30 	div.f %d3,%d9,%d3
    relError       = __absf(fOvs - f);
80004f86:	6b 03 31 3f 	sub.f %d3,%d15,%d3
80004f8a:	4b 13 01 00 	cmp.f %d0,%d3,%d1
80004f8e:	37 00 61 00 	extr.u %d0,%d0,0,1
80004f92:	9b 03 00 48 	addih %d4,%d3,32768
80004f96:	2b 34 40 30 	sel %d3,%d0,%d4,%d3
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004f9a:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004f9e:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004fa2:	df 00 45 80 	jne %d0,0,8000502c <IfxAsclin_setBitTiming+0x126>
80004fa6:	8f 15 00 60 	sh %d6,%d5,1
            /* Increase the value of the oversampling to generate the required baudrate */
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
80004faa:	02 51       	mov %d1,%d5
    nBest          = n;
    adder_facL_min = 0;
80004fac:	82 0e       	mov %d14,0
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004fae:	82 28       	mov %d8,2
80004fb0:	3b 00 00 71 	mov %d7,4096
80004fb4:	7f 76 3b 80 	jge.u %d6,%d7,8000502a <IfxAsclin_setBitTiming+0x124>
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
80004fb8:	a0 13       	mov.a %a3,1

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
80004fba:	82 1b       	mov %d11,1
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
80004fbc:	df 28 09 00 	jeq %d8,2,80004fce <IfxAsclin_setBitTiming+0xc8>
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004fc0:	73 8e 0a a0 	mul %d10,%d14,%d8
80004fc4:	4b ca 11 a2 	div.u %e10,%d10,%d12
            adder_facH = adder_facL + 1;
80004fc8:	60 a3       	mov.a %a3,%d10
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004fca:	02 ab       	mov %d11,%d10
            adder_facH = adder_facL + 1;
80004fcc:	b0 13       	add.a %a3,1
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004fce:	80 34       	mov.d %d4,%a3
80004fd0:	3f b4 25 80 	jlt.u %d4,%d11,8000501a <IfxAsclin_setBitTiming+0x114>
        {
            f           = (fpd * n) / (n * d + count);
80004fd4:	4b 08 61 01 	utof %d0,%d8
80004fd8:	0b 6b 00 40 	add %d4,%d11,%d6
80004fdc:	4b 04 61 d1 	utof %d13,%d4
80004fe0:	4b 09 41 00 	mul.f %d0,%d9,%d0
            newRelError = __absf(fOvs - f);
80004fe4:	80 2a       	mov.d %d10,%a2
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
        {
            f           = (fpd * n) / (n * d + count);
80004fe6:	4b d0 51 00 	div.f %d0,%d0,%d13
            newRelError = __absf(fOvs - f);
80004fea:	6b 00 31 0f 	sub.f %d0,%d15,%d0
80004fee:	4b a0 01 d0 	cmp.f %d13,%d0,%d10
80004ff2:	37 0d 61 d0 	extr.u %d13,%d13,0,1
80004ff6:	9b 00 00 a8 	addih %d10,%d0,32768
80004ffa:	2b 0a 40 0d 	sel %d0,%d13,%d10,%d0

            if (relError > (newRelError))
80004ffe:	4b 03 01 d0 	cmp.f %d13,%d3,%d0
80005002:	37 0d 61 d1 	extr.u %d13,%d13,2,1
80005006:	2b be 50 ed 	seln %d14,%d13,%d14,%d11
8000500a:	2b 03 50 3d 	seln %d3,%d13,%d3,%d0
8000500e:	2b 8c 50 cd 	seln %d12,%d13,%d12,%d8
80005012:	2b 41 50 1d 	seln %d1,%d13,%d1,%d4
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
80005016:	c2 1b       	add %d11,1
80005018:	3c db       	j 80004fce <IfxAsclin_setBitTiming+0xc8>
                dBest          = (n * d + count);
                adder_facL_min = count;
            }
        }

        if (relError <= limit)
8000501a:	4b 23 01 00 	cmp.f %d0,%d3,%d2
8000501e:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80005022:	f6 04       	jnz %d0,8000502a <IfxAsclin_setBitTiming+0x124>
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80005024:	c2 18       	add %d8,1
80005026:	42 56       	add %d6,%d5
80005028:	3c c6       	j 80004fb4 <IfxAsclin_setBitTiming+0xae>
8000502a:	02 15       	mov %d5,%d1
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
8000502c:	19 f3 0c 10 	ld.w %d3,[%a15]76
80005030:	8f f3 c1 31 	andn %d3,%d3,31
80005034:	59 f3 0c 10 	st.w [%a15]76,%d3
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80005038:	19 ff 0c 10 	ld.w %d15,[%a15]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
8000503c:	bf 0f fe 7f 	jlt %d15,0,80005038 <IfxAsclin_setBitTiming+0x132>
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80005040:	4c f8       	ld.w %d15,[%a15]32
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80005042:	19 a2 04 00 	ld.w %d2,[%sp]4
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80005046:	37 5f 0c 50 	insert %d5,%d15,%d5,0,12
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
8000504a:	c2 f2       	add %d2,-1
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
8000504c:	68 85       	st.w [%a15]32,%d5
    asclin->BRG.B.NUMERATOR   = nBest;
8000504e:	4c f8       	ld.w %d15,[%a15]32

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005050:	80 ea       	mov.d %d10,%a14
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80005052:	37 cf 0c c8 	insert %d12,%d15,%d12,16,12
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80005056:	80 c4       	mov.d %d4,%a12
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80005058:	68 8c       	st.w [%a15]32,%d12

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
8000505a:	4c f5       	ld.w %d15,[%a15]20
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
8000505c:	40 f4       	mov.aa %a4,%a15
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
8000505e:	37 2f 04 28 	insert %d2,%d15,%d2,16,4
80005062:	68 52       	st.w [%a15]20,%d2

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005064:	4c f5       	ld.w %d15,[%a15]20

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80005066:	80 d2       	mov.d %d2,%a13

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005068:	37 af 04 6c 	insert %d6,%d15,%d10,24,4

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
8000506c:	7b 00 00 f8 	movh %d15,32768

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005070:	68 56       	st.w [%a15]20,%d6

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80005072:	ab 0f 80 72 	sel %d7,%d2,%d15,0
80005076:	4c f5       	ld.w %d15,[%a15]20
80005078:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
8000507c:	a6 7f       	or %d15,%d7
8000507e:	68 5f       	st.w [%a15]20,%d15

    IfxAsclin_setClockSource(asclin, source);
80005080:	6d ff 09 ff 	call 80004e92 <IfxAsclin_setClockSource>

    return TRUE;
}
80005084:	82 12       	mov %d2,1
80005086:	00 90       	ret 

80005088 <IfxAsclin_write16>:
    }
}


uint32 IfxAsclin_write16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80005088:	9f 04 04 80 	jned %d4,0,80005090 <IfxAsclin_write16+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
8000508c:	82 02       	mov %d2,0
8000508e:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
80005090:	b9 5f 00 00 	ld.hu %d15,[%a5]0
80005094:	b0 25       	add.a %a5,2
80005096:	59 4f 04 10 	st.w [%a4]68,%d15
8000509a:	3c f7       	j 80005088 <IfxAsclin_write16>

8000509c <IfxAsclin_write32>:
    return count;
}


uint32 IfxAsclin_write32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
8000509c:	9f 04 04 80 	jned %d4,0,800050a4 <IfxAsclin_write32+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
800050a0:	82 02       	mov %d2,0
800050a2:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
800050a4:	4c 50       	ld.w %d15,[%a5]0
800050a6:	b0 45       	add.a %a5,4
800050a8:	59 4f 04 10 	st.w [%a4]68,%d15
800050ac:	3c f8       	j 8000509c <IfxAsclin_write32>

800050ae <IfxAsclin_write8>:
    return count;
}

#include <stdio.h>
uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
800050ae:	9f 04 04 80 	jned %d4,0,800050b6 <IfxAsclin_write8+0x8>
        count--;

    }

    return count;
}
800050b2:	82 02       	mov %d2,0
800050b4:	00 90       	ret 
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {

        txData->U = *data++;
800050b6:	0c 50       	ld.bu %d15,[%a5]0
800050b8:	b0 15       	add.a %a5,1
800050ba:	59 4f 04 10 	st.w [%a4]68,%d15
800050be:	3c f8       	j 800050ae <IfxAsclin_write8>

800050c0 <IfxAsclin_Asc_getReadCount>:
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
800050c0:	cc 42       	ld.a %a15,[%a4]8


sint32 IfxAsclin_Asc_getReadCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_readCount(asclin->rx);
}
800050c2:	88 22       	ld.h %d2,[%a15]4
800050c4:	00 90       	ret 

800050c6 <IfxAsclin_Asc_getReadEvent>:


IfxStdIf_DPipe_ReadEvent IfxAsclin_Asc_getReadEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->rx->eventWriter;
800050c6:	99 42 08 00 	ld.a %a2,[%a4]8
}
800050ca:	d9 22 1d 00 	lea %a2,[%a2]29
800050ce:	00 90       	ret 

800050d0 <IfxAsclin_Asc_getSendCount>:


uint32 IfxAsclin_Asc_getSendCount(IfxAsclin_Asc *asclin)
{
    return asclin->sendCount;
800050d0:	19 42 10 00 	ld.w %d2,[%a4]16
}
800050d4:	00 90       	ret 

800050d6 <IfxAsclin_Asc_getTxTimeStamp>:


Ifx_TickTime IfxAsclin_Asc_getTxTimeStamp(IfxAsclin_Asc *asclin)
{
    return asclin->txTimestamp;
800050d6:	09 42 54 09 	ld.d %e2,[%a4]20
}
800050da:	00 90       	ret 

800050dc <IfxAsclin_Asc_getWriteCount>:


sint32 IfxAsclin_Asc_getWriteCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_writeCount(asclin->tx);
800050dc:	cc 41       	ld.a %a15,[%a4]4
 *
 * \return Returns the free size in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_writeCount(Ifx_Fifo *fifo)
{
    return (Ifx_SizeT)(fifo->size - Ifx_Fifo_readCount(fifo));
800050de:	88 c2       	ld.h %d2,[%a15]24
800050e0:	8c f2       	ld.h %d15,[%a15]4
800050e2:	a2 f2       	sub %d2,%d15
}
800050e4:	37 02 50 20 	extr %d2,%d2,0,16
800050e8:	00 90       	ret 

800050ea <IfxAsclin_Asc_getWriteEvent>:


IfxStdIf_DPipe_WriteEvent IfxAsclin_Asc_getWriteEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->tx->eventWriter;
800050ea:	99 42 04 00 	ld.a %a2,[%a4]4
}
800050ee:	d9 22 1d 00 	lea %a2,[%a2]29
800050f2:	00 90       	ret 

800050f4 <IfxAsclin_Asc_isrError>:
}


void IfxAsclin_Asc_isrError(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin; /* getting the pointer to ASCLIN registers from module handler*/
800050f4:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE boolean IfxAsclin_getParityErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.PE;
800050f6:	4c fd       	ld.w %d15,[%a15]52

    /* store all the flags in the variable */
    if (IfxAsclin_getParityErrorFlagStatus(asclinSFR))
800050f8:	ef 0f 0a 00 	jz.t %d15,16,8000510c <IfxAsclin_Asc_isrError+0x18>
}


IFX_INLINE void IfxAsclin_clearParityErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.PEC = 1;
800050fc:	4c ff       	ld.w %d15,[%a15]60
800050fe:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80005102:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearParityErrorFlag(asclinSFR);
        asclin->errorFlags.flags.parityError = 1;
80005104:	0c 4e       	ld.bu %d15,[%a4]14
80005106:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
8000510a:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getFrameErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.FE;
8000510c:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR))
8000510e:	ef 2f 0a 00 	jz.t %d15,18,80005122 <IfxAsclin_Asc_isrError+0x2e>
}


IFX_INLINE void IfxAsclin_clearFrameErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.FEC = 1;
80005112:	4c ff       	ld.w %d15,[%a15]60
80005114:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80005118:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlags.flags.frameError = 1;
8000511a:	0c 4e       	ld.bu %d15,[%a4]14
8000511c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
80005120:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFO;
80005122:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR))
80005124:	ef af 0a 00 	jz.t %d15,26,80005138 <IfxAsclin_Asc_isrError+0x44>
}


IFX_INLINE void IfxAsclin_clearRxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFOC = 1;
80005128:	4c ff       	ld.w %d15,[%a15]60
8000512a:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
8000512e:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoOverflow = 1;
80005130:	0c 4e       	ld.bu %d15,[%a4]14
80005132:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
80005136:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoUnderflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFU;
80005138:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoUnderflowFlagStatus(asclinSFR))
8000513a:	ef bf 0a 00 	jz.t %d15,27,8000514e <IfxAsclin_Asc_isrError+0x5a>
}


IFX_INLINE void IfxAsclin_clearRxFifoUnderflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFUC = 1;
8000513e:	4c ff       	ld.w %d15,[%a15]60
80005140:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80005144:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoUnderflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoUnderflow = 1;
80005146:	0c 4e       	ld.bu %d15,[%a4]14
80005148:	b7 1f 81 f1 	insert %d15,%d15,1,3,1
8000514c:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getTxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.TFO;
8000514e:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR))
80005150:	ef ef 0a 00 	jz.t %d15,30,80005164 <IfxAsclin_Asc_isrError+0x70>
}


IFX_INLINE void IfxAsclin_clearTxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.TFOC = 1;
80005154:	4c ff       	ld.w %d15,[%a15]60
80005156:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000515a:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.txFifoOverflow = 1;
8000515c:	0c 4e       	ld.bu %d15,[%a4]14
8000515e:	b7 1f 01 f2 	insert %d15,%d15,1,4,1
80005162:	2c 4e       	st.b [%a4]14,%d15
80005164:	00 90       	ret 

80005166 <IfxAsclin_Asc_resetSendCount>:
}


void IfxAsclin_Asc_resetSendCount(IfxAsclin_Asc *asclin)
{
    asclin->sendCount = 0;
80005166:	82 0f       	mov %d15,0
80005168:	6c 44       	st.w [%a4]16,%d15
8000516a:	00 90       	ret 

8000516c <IfxAsclin_Asc_canReadCount>:
}


boolean IfxAsclin_Asc_canReadCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canReadCount(asclin->rx, count, timeout);
8000516c:	99 44 08 00 	ld.a %a4,[%a4]8
80005170:	1d 00 df 18 	j 8000832e <Ifx_Fifo_canReadCount>

80005174 <IfxAsclin_Asc_flushTx>:

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80005174:	82 f2       	mov %d2,-1
80005176:	06 f2       	sh %d2,-1
80005178:	ba f4       	eq %d15,%d4,-1
8000517a:	0b 52 00 f2 	and.eq %d15,%d2,%d5
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
}


boolean IfxAsclin_Asc_flushTx(IfxAsclin_Asc *asclin, Ifx_TickTime timeout)
{
8000517e:	40 4f       	mov.aa %a15,%a4
80005180:	02 46       	mov %d6,%d4
    {
        deadLine = TIME_INFINITE;
80005182:	82 f9       	mov %d9,-1
80005184:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80005186:	ee 16       	jnz %d15,800051b2 <IfxAsclin_Asc_flushTx+0x3e>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005188:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000518c:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005190:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80005194:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005196:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000519a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000519e:	02 39       	mov %d9,%d3
800051a0:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800051a4:	76 23       	jz %d2,800051aa <IfxAsclin_Asc_flushTx+0x36>
    {
        __enable();
800051a6:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800051aa:	0b 69 40 90 	addx %d9,%d9,%d6
800051ae:	0b 58 50 80 	addc %d8,%d8,%d5
 *
 * \return TRUE if the buffer is emptied.
 */
IFX_INLINE boolean Ifx_Fifo_flush(Ifx_Fifo *fifo, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(fifo, fifo->size, timeout);
800051b2:	c8 14       	ld.a %a4,[%a15]4
800051b4:	02 57       	mov %d7,%d5
800051b6:	c9 44 18 00 	ld.h %d4,[%a4]24
800051ba:	6d 00 fd 19 	call 800085b4 <Ifx_Fifo_canWriteCount>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800051be:	82 f4       	mov %d4,-1
800051c0:	06 f4       	sh %d4,-1
    boolean      result;

    /* Flush the software FIFO */
    result = Ifx_Fifo_flush(asclin->tx, timeout);

    if (result)
800051c2:	f6 23       	jnz %d2,800051c8 <IfxAsclin_Asc_flushTx+0x54>
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
    {
        deadLine = TIME_INFINITE;
800051c4:	82 02       	mov %d2,0
800051c6:	00 90       	ret 
    {
        /* Flush the hardware FIFO (wait until all bytes have been transmitted) */
        do
        {
            result = IfxAsclin_getTxFifoFillLevel(asclin->asclin) == 0;
800051c8:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
800051ca:	4c 23       	ld.w %d15,[%a2]12
800051cc:	37 0f 65 f8 	extr.u %d15,%d15,16,5
        } while (!result && !IfxStm_isDeadLine(deadline));
800051d0:	6e 1e       	jz %d15,8000520c <IfxAsclin_Asc_flushTx+0x98>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800051d2:	ba f9       	eq %d15,%d9,-1
800051d4:	0b 84 00 f2 	and.eq %d15,%d4,%d8
800051d8:	ee f9       	jnz %d15,800051ca <IfxAsclin_Asc_flushTx+0x56>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800051da:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800051de:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800051e2:	0d 00 40 03 	disable 
800051e6:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800051e8:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800051ec:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800051f0:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800051f4:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800051f8:	76 23       	jz %d2,800051fe <IfxAsclin_Asc_flushTx+0x8a>
    {
        __enable();
800051fa:	0d 00 00 03 	enable 
800051fe:	0b 8f 00 21 	eq %d2,%d15,%d8
80005202:	0b 93 30 22 	and.lt.u %d2,%d3,%d9
80005206:	0b 8f 90 22 	or.lt %d2,%d15,%d8
8000520a:	3c dc       	j 800051c2 <IfxAsclin_Asc_flushTx+0x4e>
8000520c:	82 12       	mov %d2,1
    }

    return result;
}
8000520e:	00 90       	ret 

80005210 <IfxAsclin_Asc_canWriteCount>:
}


boolean IfxAsclin_Asc_canWriteCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(asclin->tx, count, timeout);
80005210:	99 44 04 00 	ld.a %a4,[%a4]4
80005214:	1d 00 d0 19 	j 800085b4 <Ifx_Fifo_canWriteCount>

80005218 <IfxAsclin_Asc_clearRx>:
}


void IfxAsclin_Asc_clearRx(IfxAsclin_Asc *asclin)
{
    IfxAsclin_flushRxFifo(asclin->asclin);
80005218:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
8000521a:	4c f4       	ld.w %d15,[%a15]16
8000521c:	96 01       	or %d15,1
8000521e:	68 4f       	st.w [%a15]16,%d15
    Ifx_Fifo_clear(asclin->rx);
80005220:	99 44 08 00 	ld.a %a4,[%a4]8
80005224:	1d 00 ad 19 	j 8000857e <Ifx_Fifo_clear>

80005228 <IfxAsclin_Asc_clearTx>:
}


void IfxAsclin_Asc_clearTx(IfxAsclin_Asc *asclin)
{
80005228:	40 4f       	mov.aa %a15,%a4
    Ifx_Fifo_clear(asclin->tx);
8000522a:	99 44 04 00 	ld.a %a4,[%a4]4
8000522e:	6d 00 a8 19 	call 8000857e <Ifx_Fifo_clear>
    IfxAsclin_flushTxFifo(asclin->asclin);
80005232:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
80005234:	4c f3       	ld.w %d15,[%a15]12
80005236:	96 01       	or %d15,1
80005238:	68 3f       	st.w [%a15]12,%d15
8000523a:	00 90       	ret 

8000523c <IfxAsclin_Asc_read>:
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
8000523c:	99 44 08 00 	ld.a %a4,[%a4]8
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80005240:	0b 45 10 68 	mov %e6,%d5,%d4
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
80005244:	94 64       	ld.h %d4,[%a6]
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80005246:	40 6f       	mov.aa %a15,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
80005248:	6d 00 e0 18 	call 80008408 <Ifx_Fifo_read>

    *count -= left;
8000524c:	8c f0       	ld.h %d15,[%a15]0
8000524e:	a2 2f       	sub %d15,%d2
80005250:	a8 0f       	st.h [%a15]0,%d15

    return left == 0;
}
80005252:	8b 02 00 22 	eq %d2,%d2,0
80005256:	00 90       	ret 

80005258 <IfxAsclin_Asc_isrTransmit>:
    }
}

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
80005258:	20 18       	sub.a %sp,24
8000525a:	40 4f       	mov.aa %a15,%a4
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000525c:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80005260:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005264:	0d 00 40 03 	disable 
80005268:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000526a:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000526e:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005272:	02 52       	mov %d2,%d5
80005274:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005278:	76 43       	jz %d4,8000527e <IfxAsclin_Asc_isrTransmit+0x26>
    {
        __enable();
8000527a:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
8000527e:	89 f2 54 09 	st.d [%a15]20,%e2
    asclin->sendCount++;

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
80005282:	c8 14       	ld.a %a4,[%a15]4

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
    asclin->txTimestamp = IfxStm_now();
    asclin->sendCount++;
80005284:	4c f4       	ld.w %d15,[%a15]16
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80005286:	c9 44 04 00 	ld.h %d4,[%a4]4
8000528a:	c2 1f       	add %d15,1
8000528c:	68 4f       	st.w [%a15]16,%d15

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000528e:	df 04 32 00 	jeq %d4,0,800052f2 <IfxAsclin_Asc_isrTransmit+0x9a>
    {

        switch (asclin->dataBufferMode)
80005292:	0c ff       	ld.bu %d15,[%a15]15
80005294:	6e 03       	jz %d15,8000529a <IfxAsclin_Asc_isrTransmit+0x42>
80005296:	9e 1d       	jeq %d15,1,800052d0 <IfxAsclin_Asc_isrTransmit+0x78>
80005298:	00 90       	ret 
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
8000529a:	c8 02       	ld.a %a2,[%a15]0
        case Ifx_DataBufferMode_normal:
        {

            uint8          ascData[16];
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;
8000529c:	2c a7       	st.b [%sp]7,%d15

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
8000529e:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
800052a2:	4c 23       	ld.w %d15,[%a2]12
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
800052a4:	d2 06       	mov %e6,0
800052a6:	37 0f 65 f8 	extr.u %d15,%d15,16,5
800052aa:	d9 a5 08 00 	lea %a5,[%sp]8
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
800052ae:	2c a7       	st.b [%sp]7,%d15

            i_count          = (16 - hw_tx_fill_level);
800052b0:	0c a7       	ld.bu %d15,[%sp]7
800052b2:	8b 0f 01 f1 	rsub %d15,%d15,16
800052b6:	37 0f 70 f0 	extr.u %d15,%d15,0,16
800052ba:	0b 4f 90 f1 	min.u %d15,%d15,%d4
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
800052be:	37 0f 50 40 	extr %d4,%d15,0,16
800052c2:	6d 00 a3 18 	call 80008408 <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
800052c6:	c8 04       	ld.a %a4,[%a15]0
800052c8:	d9 a5 08 00 	lea %a5,[%sp]8
800052cc:	02 f4       	mov %d4,%d15
800052ce:	3c 10       	j 800052ee <IfxAsclin_Asc_isrTransmit+0x96>
        {

            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
800052d0:	d2 06       	mov %e6,0
800052d2:	d9 a5 08 00 	lea %a5,[%sp]8
800052d6:	3b c0 00 40 	mov %d4,12
800052da:	6d 00 97 18 	call 80008408 <Ifx_Fifo_read>

            ascData = packedData.data;
800052de:	39 af 10 00 	ld.bu %d15,[%sp]16
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
800052e2:	c8 04       	ld.a %a4,[%a15]0
            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);

            ascData = packedData.data;
800052e4:	d9 a5 18 00 	lea %a5,[%sp]24
800052e8:	89 5f 2f f4 	st.b [+%a5]-17,%d15
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
800052ec:	82 14       	mov %d4,1
        }
        break;
800052ee:	1d ff e0 fe 	j 800050ae <IfxAsclin_write8>
    }
    else
    {

        /* Transmit buffer is empty */
        asclin->txInProgress = FALSE;
800052f2:	28 c4       	st.b [%a15]12,%d4
800052f4:	00 90       	ret 

800052f6 <IfxAsclin_Asc_isrReceive>:

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
800052f6:	0c 4f       	ld.bu %d15,[%a4]15
    }
}


void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
800052f8:	20 20       	sub.a %sp,32
800052fa:	40 4f       	mov.aa %a15,%a4
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
800052fc:	6e 34       	jz %d15,80005364 <IfxAsclin_Asc_isrReceive+0x6e>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
800052fe:	82 18       	mov %d8,1

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005300:	df 1f 45 80 	jne %d15,1,8000538a <IfxAsclin_Asc_isrReceive+0x94>
    }
    case Ifx_DataBufferMode_timeStampSingle:
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
80005304:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getRxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->RXFIFOCON.B.FILL;
80005306:	4c 24       	ld.w %d15,[%a2]16
80005308:	37 0f 65 f8 	extr.u %d15,%d15,16,5
8000530c:	6e 2b       	jz %d15,80005362 <IfxAsclin_Asc_isrReceive+0x6c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000530e:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
80005312:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005316:	0d 00 40 03 	disable 
8000531a:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000531c:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005320:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80005324:	8f 02 40 21 	or %d2,%d2,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005328:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000532c:	76 33       	jz %d3,80005332 <IfxAsclin_Asc_isrReceive+0x3c>
    {
        __enable();
8000532e:	0d 00 00 03 	enable 
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
80005332:	c8 04       	ld.a %a4,[%a15]0
80005334:	d9 a5 10 00 	lea %a5,[%sp]16
80005338:	82 14       	mov %d4,1
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
8000533a:	78 02       	st.w [%sp]8,%d15
8000533c:	59 a2 04 00 	st.w [%sp]4,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
80005340:	6d ff 7a fd 	call 80004e34 <IfxAsclin_read8>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
80005344:	c8 24       	ld.a %a4,[%a15]8

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
80005346:	39 af 10 00 	ld.bu %d15,[%sp]16

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
8000534a:	d2 06       	mov %e6,0
8000534c:	d9 a5 04 00 	lea %a5,[%sp]4
80005350:	3b c0 00 40 	mov %d4,12

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
80005354:	2c ac       	st.b [%sp]12,%d15

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
80005356:	6d 00 a7 19 	call 800086a4 <Ifx_Fifo_write>
8000535a:	df 02 d5 7f 	jeq %d2,0,80005304 <IfxAsclin_Asc_isrReceive+0xe>
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
8000535e:	28 d8       	st.b [%a15]13,%d8
80005360:	3c d2       	j 80005304 <IfxAsclin_Asc_isrReceive+0xe>
80005362:	00 90       	ret 
    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
    {
        uint8 count;
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
80005364:	d4 44       	ld.a %a4,[%a4]
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
80005366:	d9 a5 10 00 	lea %a5,[%sp]16
8000536a:	4c 44       	ld.w %d15,[%a4]16
8000536c:	37 0f 65 f8 	extr.u %d15,%d15,16,5
80005370:	02 f4       	mov %d4,%d15
80005372:	6d ff 61 fd 	call 80004e34 <IfxAsclin_read8>

        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
80005376:	c8 24       	ld.a %a4,[%a15]8
80005378:	d2 06       	mov %e6,0
8000537a:	d9 a5 10 00 	lea %a5,[%sp]16
8000537e:	02 f4       	mov %d4,%d15
80005380:	6d 00 92 19 	call 800086a4 <Ifx_Fifo_write>
80005384:	76 23       	jz %d2,8000538a <IfxAsclin_Asc_isrReceive+0x94>
        {
            /* Receive buffer is full, data is discard */
            asclin->rxSwFifoOverflow = TRUE;
80005386:	82 1f       	mov %d15,1
80005388:	28 df       	st.b [%a15]13,%d15
8000538a:	00 90       	ret 

8000538c <IfxAsclin_Asc_blockingRead>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
8000538c:	20 08       	sub.a %sp,8
    Ifx_SizeT count = 1;
8000538e:	82 1f       	mov %d15,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
80005390:	40 4f       	mov.aa %a15,%a4
    Ifx_SizeT count = 1;
80005392:	ac a3       	st.h [%sp]6,%d15
    uint8     data;

    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
80005394:	82 f4       	mov %d4,-1
80005396:	40 f4       	mov.aa %a4,%a15
80005398:	d9 a5 05 00 	lea %a5,[%sp]5
8000539c:	d9 a6 06 00 	lea %a6,[%sp]6
800053a0:	9b 04 00 58 	addih %d5,%d4,32768
800053a4:	6d ff 4c ff 	call 8000523c <IfxAsclin_Asc_read>
800053a8:	df 12 f6 ff 	jne %d2,1,80005394 <IfxAsclin_Asc_blockingRead+0x8>
    {}

    return data;
}
800053ac:	39 a2 05 00 	ld.bu %d2,[%sp]5
800053b0:	00 90       	ret 

800053b2 <IfxAsclin_Asc_disableModule>:
}


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
800053b2:	cc 40       	ld.a %a15,[%a4]0
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
800053b4:	6d 00 c5 0f 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
800053b8:	02 24       	mov %d4,%d2


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
800053ba:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
800053bc:	6d 00 c1 0e 	call 8000713e <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
800053c0:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclinSFR); /* disabling the module */
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
800053c2:	02 f4       	mov %d4,%d15
800053c4:	8f 12 40 21 	or %d2,%d2,1
800053c8:	68 02       	st.w [%a15]0,%d2
800053ca:	1d 00 ef 0f 	j 800073a8 <IfxScuWdt_setCpuEndinit>

800053ce <IfxAsclin_Asc_initModule>:
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
800053ce:	cc 50       	ld.a %a15,[%a5]0
    return &asclin->tx->eventWriter;
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
800053d0:	40 4e       	mov.aa %a14,%a4
800053d2:	40 5c       	mov.aa %a12,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
    IfxAsclin_Status status    = IfxAsclin_Status_noError;

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
800053d4:	ec 40       	st.a [%a4]0,%a15

    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
800053d6:	40 f4       	mov.aa %a4,%a15
800053d8:	6d ff 71 fc 	call 80004cba <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
800053dc:	40 f4       	mov.aa %a4,%a15
800053de:	82 04       	mov %d4,0
800053e0:	6d ff 59 fd 	call 80004e92 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
800053e4:	4c f6       	ld.w %d15,[%a15]24
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
800053e6:	40 f4       	mov.aa %a4,%a15
800053e8:	b7 0f 02 f8 	insert %d15,%d15,0,16,2
800053ec:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
800053ee:	8c c4       	ld.h %d15,[%a12]8
800053f0:	48 52       	ld.w %d2,[%a15]20
800053f2:	c2 ff       	add %d15,-1
800053f4:	37 f2 0c f0 	insert %d15,%d2,%d15,0,12
800053f8:	68 5f       	st.w [%a15]20,%d15
800053fa:	39 c4 28 00 	ld.bu %d4,[%a12]40
800053fe:	6d ff 4a fd 	call 80004e92 <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80005402:	40 f4       	mov.aa %a4,%a15
80005404:	19 c4 04 00 	ld.w %d4,[%a12]4
80005408:	39 c5 0a 00 	ld.bu %d5,[%a12]10
8000540c:	39 c6 0d 00 	ld.bu %d6,[%a12]13
80005410:	39 c7 0c 00 	ld.bu %d7,[%a12]12
80005414:	6d ff 79 fd 	call 80004f06 <IfxAsclin_setBitTiming>
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80005418:	40 f4       	mov.aa %a4,%a15
8000541a:	82 04       	mov %d4,0
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
8000541c:	02 29       	mov %d9,%d2
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
8000541e:	6d ff 3a fd 	call 80004e92 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_enableLoopBackMode(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.LB = enable ? 1 : 0;
80005422:	39 c2 38 00 	ld.bu %d2,[%a12]56
80005426:	7b 00 00 f1 	movh %d15,4096
8000542a:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000542e:	4c f1       	ld.w %d15,[%a15]4
80005430:	b7 0f 01 fe 	insert %d15,%d15,0,28,1
80005434:	a6 2f       	or %d15,%d2
80005436:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxAsclin_enableParity(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
80005438:	39 c2 14 00 	ld.bu %d2,[%a12]20
8000543c:	7b 00 00 f4 	movh %d15,16384
80005440:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80005444:	4c f6       	ld.w %d15,[%a15]24
80005446:	b7 0f 01 ff 	insert %d15,%d15,0,30,1
8000544a:	a6 2f       	or %d15,%d2
8000544c:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setParityType(Ifx_ASCLIN *asclin, IfxAsclin_ParityType type)
{
    asclin->FRAMECON.B.ODD = type;
8000544e:	48 62       	ld.w %d2,[%a15]24
80005450:	39 cf 12 00 	ld.bu %d15,[%a12]18
80005454:	37 f2 81 ff 	insert %d15,%d2,%d15,31,1
80005458:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
8000545a:	48 62       	ld.w %d2,[%a15]24
8000545c:	0c cf       	ld.bu %d15,[%a12]15
8000545e:	37 f2 83 f4 	insert %d15,%d2,%d15,9,3
80005462:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setShiftDirection(Ifx_ASCLIN *asclin, IfxAsclin_ShiftDirection dir)
{
    asclin->FRAMECON.B.MSB = dir;
80005464:	48 62       	ld.w %d2,[%a15]24
80005466:	39 cf 11 00 	ld.bu %d15,[%a12]17
8000546a:	67 f2 1c f0 	ins.t %d15,%d2,28,%d15,0
8000546e:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setDataLength(Ifx_ASCLIN *asclin, IfxAsclin_DataLength length)
{
    asclin->DATCON.B.DATLEN = length;
80005470:	48 72       	ld.w %d2,[%a15]28
80005472:	39 cf 13 00 	ld.bu %d15,[%a12]19
80005476:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
8000547a:	68 7f       	st.w [%a15]28,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
8000547c:	48 32       	ld.w %d2,[%a15]12
8000547e:	39 cf 16 00 	ld.bu %d15,[%a12]22
80005482:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80005486:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_setRxFifoOutletWidth(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoOutletWidth width)
{
    asclin->RXFIFOCON.B.OUTW = width;
80005488:	48 42       	ld.w %d2,[%a15]16
8000548a:	39 cf 17 00 	ld.bu %d15,[%a12]23
8000548e:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80005492:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setIdleDelay(Ifx_ASCLIN *asclin, IfxAsclin_IdleDelay delay)
{
    asclin->FRAMECON.B.IDLE = delay;
80005494:	48 62       	ld.w %d2,[%a15]24
80005496:	0c ce       	ld.bu %d15,[%a12]14
80005498:	37 f2 03 f3 	insert %d15,%d2,%d15,6,3
8000549c:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000549e:	39 c2 18 00 	ld.bu %d2,[%a12]24
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800054a2:	da 0f       	mov %d15,15
800054a4:	0b f2 90 21 	min.u %d2,%d2,%d15
800054a8:	48 33       	ld.w %d3,[%a15]12
800054aa:	37 23 04 24 	insert %d2,%d3,%d2,8,4
800054ae:	68 32       	st.w [%a15]12,%d2
}


IFX_INLINE void IfxAsclin_setRxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoInterruptLevel level)
{
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
800054b0:	39 c2 19 00 	ld.bu %d2,[%a12]25
800054b4:	0b f2 90 f1 	min.u %d15,%d2,%d15
800054b8:	48 42       	ld.w %d2,[%a15]16
800054ba:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
800054be:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
800054c0:	39 cf 10 00 	ld.bu %d15,[%a12]16
800054c4:	48 62       	ld.w %d2,[%a15]24
800054c6:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
800054ca:	68 6f       	st.w [%a15]24,%d15
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/

    /* Pin mapping */
    const IfxAsclin_Asc_Pins *pins = config->pins;
800054cc:	99 cd 24 00 	ld.a %a13,[%a12]36

    if (pins != NULL_PTR)
800054d0:	bd 0d 81 00 	jz.a %a13,800055d2 <IfxAsclin_Asc_initModule+0x204>
    {
        IfxAsclin_Cts_In *cts = pins->cts;
800054d4:	4c d0       	ld.w %d15,[%a13]0

        if (cts != NULL_PTR)
800054d6:	6e 27       	jz %d15,80005524 <IfxAsclin_Asc_initModule+0x156>
}


IFX_INLINE void IfxAsclin_initCtsPin(const IfxAsclin_Cts_In *cts, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (cts->pin.port != NULL_PTR)
800054d8:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
800054da:	79 d5 04 00 	ld.b %d5,[%a13]4
800054de:	99 24 04 00 	ld.a %a4,[%a2]4
800054e2:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800054e6:	bd 04 1f 00 	jz.a %a4,80005524 <IfxAsclin_Asc_initModule+0x156>
800054ea:	39 24 08 00 	ld.bu %d4,[%a2]8
800054ee:	8f f5 0f 51 	and %d5,%d5,255
800054f2:	6d 00 ba 03 	call 80005c66 <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
800054f6:	60 f3       	mov.a %a3,%d15
800054f8:	02 85       	mov %d5,%d8
800054fa:	99 34 04 00 	ld.a %a4,[%a3]4
800054fe:	39 34 08 00 	ld.bu %d4,[%a3]8
80005502:	6d 00 30 04 	call 80005d62 <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
80005506:	60 f3       	mov.a %a3,%d15
80005508:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_enableCts(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
8000550a:	19 22 04 00 	ld.w %d2,[%a2]4
8000550e:	b7 f2 81 2e 	insert %d2,%d2,15,29,1
80005512:	59 22 04 00 	st.w [%a2]4,%d2
    if (cts->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
        IfxAsclin_enableCts(cts->module, TRUE);
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
80005516:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setCtsInput(Ifx_ASCLIN *asclin, IfxAsclin_CtsInputSelect ctsi)
{
    asclin->IOCR.B.CTS = ctsi;
80005518:	0c 3c       	ld.bu %d15,[%a3]12
8000551a:	19 22 04 00 	ld.w %d2,[%a2]4
8000551e:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
80005522:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rx_In *rx = pins->rx;
80005524:	4c d2       	ld.w %d15,[%a13]8

        if (rx != NULL_PTR)
80005526:	6e 20       	jz %d15,80005566 <IfxAsclin_Asc_initModule+0x198>
}


IFX_INLINE void IfxAsclin_initRxPin(const IfxAsclin_Rx_In *rx, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (rx->pin.port != NULL_PTR)
80005528:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
8000552a:	79 d5 0c 00 	ld.b %d5,[%a13]12
8000552e:	99 24 04 00 	ld.a %a4,[%a2]4
80005532:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005536:	bd 04 18 00 	jz.a %a4,80005566 <IfxAsclin_Asc_initModule+0x198>
8000553a:	39 24 08 00 	ld.bu %d4,[%a2]8
8000553e:	8f f5 0f 51 	and %d5,%d5,255
80005542:	6d 00 92 03 	call 80005c66 <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(rx->pin.port, rx->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
80005546:	60 f3       	mov.a %a3,%d15
80005548:	02 85       	mov %d5,%d8
8000554a:	99 34 04 00 	ld.a %a4,[%a3]4
8000554e:	39 34 08 00 	ld.bu %d4,[%a3]8
80005552:	6d 00 08 04 	call 80005d62 <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
80005556:	60 f3       	mov.a %a3,%d15
80005558:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setRxInput(Ifx_ASCLIN *asclin, IfxAsclin_RxInputSelect alti)
{
    asclin->IOCR.B.ALTI = alti;
8000555a:	0c 3c       	ld.bu %d15,[%a3]12
8000555c:	19 22 04 00 	ld.w %d2,[%a2]4
80005560:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3
80005564:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rts_Out *rts = pins->rts;
80005566:	4c d4       	ld.w %d15,[%a13]16

        if (rts != NULL_PTR)
80005568:	6e 1a       	jz %d15,8000559c <IfxAsclin_Asc_initModule+0x1ce>
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000556a:	60 f2       	mov.a %a2,%d15
8000556c:	39 d2 14 00 	ld.bu %d2,[%a13]20
80005570:	39 23 0c 00 	ld.bu %d3,[%a2]12
80005574:	99 24 04 00 	ld.a %a4,[%a2]4
80005578:	0f 23 a0 50 	or %d5,%d3,%d2
8000557c:	39 24 08 00 	ld.bu %d4,[%a2]8
80005580:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
80005584:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005588:	6d 00 6f 03 	call 80005c66 <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initRtsPin(const IfxAsclin_Rts_Out *rts, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
8000558c:	60 f3       	mov.a %a3,%d15
8000558e:	02 85       	mov %d5,%d8
80005590:	99 34 04 00 	ld.a %a4,[%a3]4
80005594:	39 34 08 00 	ld.bu %d4,[%a3]8
80005598:	6d 00 e5 03 	call 80005d62 <IfxPort_setPinPadDriver>
        }

        IfxAsclin_Tx_Out *tx = pins->tx;
8000559c:	4c d6       	ld.w %d15,[%a13]24

        if (tx != NULL_PTR)
8000559e:	6e 1a       	jz %d15,800055d2 <IfxAsclin_Asc_initModule+0x204>
800055a0:	60 f2       	mov.a %a2,%d15
800055a2:	39 d2 1c 00 	ld.bu %d2,[%a13]28
800055a6:	39 23 0c 00 	ld.bu %d3,[%a2]12
800055aa:	99 24 04 00 	ld.a %a4,[%a2]4
800055ae:	0f 23 a0 50 	or %d5,%d3,%d2
800055b2:	39 24 08 00 	ld.bu %d4,[%a2]8
800055b6:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
800055ba:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800055be:	6d 00 54 03 	call 80005c66 <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initTxPin(const IfxAsclin_Tx_Out *tx, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
800055c2:	60 f3       	mov.a %a3,%d15
800055c4:	02 85       	mov %d5,%d8
800055c6:	99 34 04 00 	ld.a %a4,[%a3]4
800055ca:	39 34 08 00 	ld.bu %d4,[%a3]8
800055ce:	6d 00 ca 03 	call 80005d62 <IfxPort_setPinPadDriver>
        }
    }

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
800055d2:	40 f4       	mov.aa %a4,%a15
800055d4:	39 c4 28 00 	ld.bu %d4,[%a12]40
800055d8:	6d ff 5d fc 	call 80004e92 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_disableAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSENABLE.U = 0x00000000;
800055dc:	82 0f       	mov %d15,0
800055de:	59 ff 00 10 	st.w [%a15]64,%d15
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAsclin_clearAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
800055e2:	82 f2       	mov %d2,-1
800055e4:	68 f2       	st.w [%a15]60,%d2

    IfxAsclin_disableAllFlags(asclinSFR);                     /* disable all flags */
    IfxAsclin_clearAllFlags(asclinSFR);                       /* clear all flags */

    /* HW error flags */
    asclin->errorFlags.ALL = 0;
800055e6:	2c ee       	st.b [%a14]14,%d15

    if (config->errorFlags.flags.parityError)
800055e8:	4c ca       	ld.w %d15,[%a12]40
800055ea:	2e 87       	jz.t %d15,8,800055f8 <IfxAsclin_Asc_initModule+0x22a>
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
800055ec:	19 ff 00 10 	ld.w %d15,[%a15]64
800055f0:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800055f4:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableParityErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.frameError)
800055f8:	4c ca       	ld.w %d15,[%a12]40
800055fa:	2e 97       	jz.t %d15,9,80005608 <IfxAsclin_Asc_initModule+0x23a>
}


IFX_INLINE void IfxAsclin_enableFrameErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
800055fc:	19 ff 00 10 	ld.w %d15,[%a15]64
80005600:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80005604:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableFrameErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoOverflow)
80005608:	4c ca       	ld.w %d15,[%a12]40
8000560a:	2e a7       	jz.t %d15,10,80005618 <IfxAsclin_Asc_initModule+0x24a>
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
8000560c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005610:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80005614:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoOverflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoUnderflow)
80005618:	4c ca       	ld.w %d15,[%a12]40
8000561a:	2e b7       	jz.t %d15,11,80005628 <IfxAsclin_Asc_initModule+0x25a>
}


IFX_INLINE void IfxAsclin_enableRxFifoUnderflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
8000561c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005620:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80005624:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoUnderflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.txFifoOverflow)
80005628:	4c ca       	ld.w %d15,[%a12]40
8000562a:	2e c7       	jz.t %d15,12,80005638 <IfxAsclin_Asc_initModule+0x26a>
}


IFX_INLINE void IfxAsclin_enableTxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
8000562c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005630:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80005634:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableTxFifoOverflowFlag(asclinSFR, TRUE);
    }

    /* transmission flags */
    asclin->rxSwFifoOverflow = FALSE;
80005638:	82 0f       	mov %d15,0
8000563a:	2c ed       	st.b [%a14]13,%d15
    asclin->txInProgress     = FALSE;
8000563c:	2c ec       	st.b [%a14]12,%d15

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
8000563e:	d2 04       	mov %e4,0
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
80005640:	39 c3 39 00 	ld.bu %d3,[%a12]57
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;
80005644:	82 0f       	mov %d15,0
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
80005646:	89 e4 54 09 	st.d [%a14]20,%e4
    asclin->sendCount      = 0;
8000564a:	6c e4       	st.w [%a14]16,%d15
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
8000564c:	e9 e3 0f 00 	st.b [%a14]15,%d3
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
        elementSize = 1;
80005650:	82 1f       	mov %d15,1
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
80005652:	76 34       	jz %d3,8000565a <IfxAsclin_Asc_initModule+0x28c>
        break;
    case Ifx_DataBufferMode_timeStampSingle:
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
        break;
    default:
        elementSize = 0;
80005654:	ba 13       	eq %d15,%d3,1
80005656:	ab cf a0 ff 	seln %d15,%d15,%d15,12
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
8000565a:	99 c4 2c 00 	ld.a %a4,[%a12]44
8000565e:	c9 c4 2a 00 	ld.h %d4,[%a12]42
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
80005662:	02 f5       	mov %d5,%d15
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
80005664:	bc 44       	jz.a %a4,8000566c <IfxAsclin_Asc_initModule+0x29e>
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
80005666:	6d 00 36 16 	call 800082d2 <Ifx_Fifo_init>
8000566a:	3c 03       	j 80005670 <IfxAsclin_Asc_initModule+0x2a2>
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
8000566c:	6d 00 50 16 	call 8000830c <Ifx_Fifo_create>
    }

    if (config->rxBuffer != NULL_PTR)
80005670:	99 c4 34 00 	ld.a %a4,[%a12]52
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
80005674:	b5 e2 04 00 	st.a [%a14]4,%a2
80005678:	c9 c4 30 00 	ld.h %d4,[%a12]48
    }

    if (config->rxBuffer != NULL_PTR)
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
8000567c:	02 f5       	mov %d5,%d15
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
    }

    if (config->rxBuffer != NULL_PTR)
8000567e:	bc 44       	jz.a %a4,80005686 <IfxAsclin_Asc_initModule+0x2b8>
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
80005680:	6d 00 29 16 	call 800082d2 <Ifx_Fifo_init>
80005684:	3c 03       	j 8000568a <IfxAsclin_Asc_initModule+0x2bc>
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80005686:	6d 00 43 16 	call 8000830c <Ifx_Fifo_create>
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;
8000568a:	39 cf 22 00 	ld.bu %d15,[%a12]34

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
8000568e:	b9 c2 1e 00 	ld.hu %d2,[%a12]30
80005692:	8b 3f 00 82 	eq %d8,%d15,3
80005696:	02 83       	mov %d3,%d8
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80005698:	b5 e2 08 00 	st.a [%a14]8,%a2
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
8000569c:	8b 02 00 35 	or.ne %d3,%d2,0
800056a0:	df 03 1e 00 	jeq %d3,0,800056dc <IfxAsclin_Asc_initModule+0x30e>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
800056a4:	40 f4       	mov.aa %a4,%a15
800056a6:	6d ff a1 fb 	call 80004de8 <IfxAsclin_getSrcPointerRx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800056aa:	54 22       	ld.w %d2,[%a2]
800056ac:	39 c3 1e 00 	ld.bu %d3,[%a12]30
800056b0:	8f f2 cf 21 	andn %d2,%d2,255
800056b4:	a6 32       	or %d2,%d3
800056b6:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800056b8:	54 22       	ld.w %d2,[%a2]
800056ba:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
800056be:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800056c0:	54 22       	ld.w %d2,[%a2]
800056c2:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
800056c6:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableRxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
800056c8:	19 f2 00 10 	ld.w %d2,[%a15]64
800056cc:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
800056d0:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800056d4:	54 22       	ld.w %d2,[%a2]
800056d6:	b7 f2 01 25 	insert %d2,%d2,15,10,1
800056da:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.rxPriority);
        IfxAsclin_enableRxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
800056dc:	b9 c2 1c 00 	ld.hu %d2,[%a12]28
800056e0:	8b 02 00 85 	or.ne %d8,%d2,0
800056e4:	df 08 1e 00 	jeq %d8,0,80005720 <IfxAsclin_Asc_initModule+0x352>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
800056e8:	40 f4       	mov.aa %a4,%a15
800056ea:	6d ff 89 fb 	call 80004dfc <IfxAsclin_getSrcPointerTx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800056ee:	54 22       	ld.w %d2,[%a2]
800056f0:	39 c3 1c 00 	ld.bu %d3,[%a12]28
800056f4:	8f f2 cf 21 	andn %d2,%d2,255
800056f8:	a6 32       	or %d2,%d3
800056fa:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800056fc:	54 22       	ld.w %d2,[%a2]
800056fe:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
80005702:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005704:	54 22       	ld.w %d2,[%a2]
80005706:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
8000570a:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableTxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
8000570c:	19 f2 00 10 	ld.w %d2,[%a15]64
80005710:	b7 f2 81 2f 	insert %d2,%d2,15,31,1
80005714:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005718:	54 22       	ld.w %d2,[%a2]
8000571a:	b7 f2 01 25 	insert %d2,%d2,15,10,1
8000571e:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.txPriority);
        IfxAsclin_enableTxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
80005720:	b9 c2 20 00 	ld.hu %d2,[%a12]32
80005724:	df 02 1e 00 	jeq %d2,0,80005760 <IfxAsclin_Asc_initModule+0x392>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
80005728:	40 f4       	mov.aa %a4,%a15
8000572a:	6d ff 55 fb 	call 80004dd4 <IfxAsclin_getSrcPointerEr>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000572e:	54 22       	ld.w %d2,[%a2]
80005730:	39 c3 20 00 	ld.bu %d3,[%a12]32
80005734:	8f f2 cf 21 	andn %d2,%d2,255
80005738:	a6 32       	or %d2,%d3
8000573a:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000573c:	54 22       	ld.w %d2,[%a2]
8000573e:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80005742:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005744:	4c 20       	ld.w %d15,[%a2]0
80005746:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
8000574a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
8000574c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005750:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80005754:	59 ff 00 10 	st.w [%a15]64,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005758:	4c 20       	ld.w %d15,[%a2]0
8000575a:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000575e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableRxFifoInlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
80005760:	4c f4       	ld.w %d15,[%a15]16

    IfxAsclin_flushRxFifo(asclinSFR);              // flushing Rx FIFO
    IfxAsclin_flushTxFifo(asclinSFR);              // flushing Tx FIFO

    return status;
}
80005762:	02 92       	mov %d2,%d9
80005764:	96 02       	or %d15,2
80005766:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_enableTxFifoOutlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
80005768:	4c f3       	ld.w %d15,[%a15]12
8000576a:	96 02       	or %d15,2
8000576c:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
8000576e:	4c f4       	ld.w %d15,[%a15]16
80005770:	96 01       	or %d15,1
80005772:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
80005774:	4c f3       	ld.w %d15,[%a15]12
80005776:	96 01       	or %d15,1
80005778:	68 3f       	st.w [%a15]12,%d15
8000577a:	00 90       	ret 

8000577c <IfxAsclin_Asc_initModuleConfig>:

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
8000577c:	82 12       	mov %d2,1
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
8000577e:	7b 10 7e 34 	movh %d3,18401

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
80005782:	e9 42 28 00 	st.b [%a4]40,%d2
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
80005786:	82 12       	mov %d2,1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
80005788:	82 0f       	mov %d15,0

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
8000578a:	f9 42 08 00 	st.h [%a4]8,%d2
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
8000578e:	59 43 04 00 	st.w [%a4]4,%d3
    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
80005792:	e9 42 0f 00 	st.b [%a4]15,%d2

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80005796:	82 33       	mov %d3,3
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
80005798:	e9 42 10 00 	st.b [%a4]16,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
8000579c:	e9 42 16 00 	st.b [%a4]22,%d2
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
800057a0:	e9 42 17 00 	st.b [%a4]23,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
800057a4:	82 f2       	mov %d2,-1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
800057a6:	e9 4f 38 00 	st.b [%a4]56,%d15

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
800057aa:	e9 43 0a 00 	st.b [%a4]10,%d3

    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
800057ae:	2c 4c       	st.b [%a4]12,%d15
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
800057b0:	e9 43 0d 00 	st.b [%a4]13,%d3
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
800057b4:	2c 4e       	st.b [%a4]14,%d15
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
800057b6:	e9 4f 11 00 	st.b [%a4]17,%d15
    config->frame.parityBit               = FALSE;                             /* disable parity*/
800057ba:	e9 4f 14 00 	st.b [%a4]20,%d15
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
800057be:	e9 4f 12 00 	st.b [%a4]18,%d15
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
800057c2:	82 73       	mov %d3,7

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
800057c4:	e9 4f 18 00 	st.b [%a4]24,%d15
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
800057c8:	e9 4f 19 00 	st.b [%a4]25,%d15
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
800057cc:	e9 4f 1a 00 	st.b [%a4]26,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
800057d0:	e9 42 29 00 	st.b [%a4]41,%d2
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
800057d4:	82 0f       	mov %d15,0

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
800057d6:	82 02       	mov %d2,0
}


void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;
800057d8:	f4 45       	st.a [%a4],%a5
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
800057da:	e9 43 13 00 	st.b [%a4]19,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
800057de:	ac 4f       	st.h [%a4]30,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
800057e0:	ac 4e       	st.h [%a4]28,%d15
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
800057e2:	f9 4f 20 00 	st.h [%a4]32,%d15
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
800057e6:	e9 4f 22 00 	st.b [%a4]34,%d15

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
800057ea:	59 42 24 00 	st.w [%a4]36,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
800057ee:	59 42 34 00 	st.w [%a4]52,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
800057f2:	59 42 2c 00 	st.w [%a4]44,%d2

    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
800057f6:	f9 42 2a 00 	st.h [%a4]42,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
800057fa:	f9 42 30 00 	st.h [%a4]48,%d2

    config->dataBufferMode = Ifx_DataBufferMode_normal;
800057fe:	e9 4f 39 00 	st.b [%a4]57,%d15
80005802:	00 90       	ret 

80005804 <IfxAsclin_Asc_initiateTransmission>:
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
80005804:	0c 4c       	ld.bu %d15,[%a4]12
    config->dataBufferMode = Ifx_DataBufferMode_normal;
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
80005806:	20 10       	sub.a %sp,16
80005808:	40 4f       	mov.aa %a15,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
8000580a:	ee 20       	jnz %d15,8000584a <IfxAsclin_Asc_initiateTransmission+0x46>
    {

        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000580c:	99 44 04 00 	ld.a %a4,[%a4]4
80005810:	8c 42       	ld.h %d15,[%a4]4
80005812:	6e 1c       	jz %d15,8000584a <IfxAsclin_Asc_initiateTransmission+0x46>
        {
            uint8 data;

            asclin->txInProgress = TRUE;
80005814:	82 1f       	mov %d15,1
80005816:	28 cf       	st.b [%a15]12,%d15

            switch (asclin->dataBufferMode)
80005818:	0c ff       	ld.bu %d15,[%a15]15
8000581a:	6e 0c       	jz %d15,80005832 <IfxAsclin_Asc_initiateTransmission+0x2e>
8000581c:	de 11       	jne %d15,1,8000583e <IfxAsclin_Asc_initiateTransmission+0x3a>
            break;
            case Ifx_DataBufferMode_timeStampSingle:
            {

                Ifx_DataBufferMode_TimeStampSingle packedData;
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
8000581e:	d2 06       	mov %e6,0
80005820:	d9 a5 04 00 	lea %a5,[%sp]4
80005824:	3b c0 00 40 	mov %d4,12
80005828:	6d 00 f0 15 	call 80008408 <Ifx_Fifo_read>
                data = packedData.data;
8000582c:	0c ac       	ld.bu %d15,[%sp]12
8000582e:	2c a3       	st.b [%sp]3,%d15
80005830:	3c 07       	j 8000583e <IfxAsclin_Asc_initiateTransmission+0x3a>
            switch (asclin->dataBufferMode)
            {
            case Ifx_DataBufferMode_normal: // here
            {

                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
80005832:	d2 06       	mov %e6,0
80005834:	d9 a5 03 00 	lea %a5,[%sp]3
80005838:	82 14       	mov %d4,1
8000583a:	6d 00 e7 15 	call 80008408 <Ifx_Fifo_read>
                data = packedData.data;
            }
            break;
            }

            IfxAsclin_write8(asclin->asclin, &data, 1);
8000583e:	c8 04       	ld.a %a4,[%a15]0
80005840:	d9 a5 03 00 	lea %a5,[%sp]3
80005844:	82 14       	mov %d4,1
80005846:	6d ff 34 fc 	call 800050ae <IfxAsclin_write8>
8000584a:	00 90       	ret 

8000584c <IfxAsclin_Asc_write>:
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
8000584c:	40 4f       	mov.aa %a15,%a4

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
8000584e:	0c 4c       	ld.bu %d15,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
80005850:	99 44 04 00 	ld.a %a4,[%a4]4

    if (*count != 0)
80005854:	94 63       	ld.h %d3,[%a6]
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80005856:	0b 45 10 88 	mov %e8,%d5,%d4
8000585a:	40 5d       	mov.aa %a13,%a5

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
8000585c:	c9 44 18 00 	ld.h %d4,[%a4]24
#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
80005860:	82 12       	mov %d2,1
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;

    if (*count != 0)
80005862:	df 03 25 00 	jeq %d3,0,800058ac <IfxAsclin_Asc_write+0x60>
80005866:	40 6c       	mov.aa %a12,%a6
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
80005868:	ee 13       	jnz %d15,8000588e <IfxAsclin_Asc_write+0x42>
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
8000586a:	37 04 70 f0 	extr.u %d15,%d4,0,16

    if (*count != 0)
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
8000586e:	7f 3f 10 00 	jge %d15,%d3,8000588e <IfxAsclin_Asc_write+0x42>
        {


            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
80005872:	0b 89 10 68 	mov %e6,%d9,%d8
80005876:	6d 00 17 17 	call 800086a4 <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
8000587a:	40 f4       	mov.aa %a4,%a15
8000587c:	6d ff c4 ff 	call 80005804 <IfxAsclin_Asc_initiateTransmission>

            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
80005880:	94 c4       	ld.h %d4,[%a12]
80005882:	c8 14       	ld.a %a4,[%a15]4
80005884:	a2 f4       	sub %d4,%d15
80005886:	10 d5       	addsc.a %a5,%a13,%d15,0
80005888:	37 04 50 40 	extr %d4,%d4,0,16
8000588c:	3c 03       	j 80005892 <IfxAsclin_Asc_write+0x46>

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
8000588e:	40 d5       	mov.aa %a5,%a13
80005890:	02 34       	mov %d4,%d3
80005892:	0b 89 10 68 	mov %e6,%d9,%d8
80005896:	6d 00 07 17 	call 800086a4 <Ifx_Fifo_write>

            IfxAsclin_Asc_initiateTransmission(asclin);
8000589a:	40 f4       	mov.aa %a4,%a15

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
8000589c:	02 2f       	mov %d15,%d2

            IfxAsclin_Asc_initiateTransmission(asclin);
8000589e:	6d ff b3 ff 	call 80005804 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
800058a2:	94 c2       	ld.h %d2,[%a12]
800058a4:	a2 f2       	sub %d2,%d15
800058a6:	b4 c2       	st.h [%a12],%d2
        result  = left == 0;
800058a8:	8b 0f 00 22 	eq %d2,%d15,0

    }

    return result;
}
800058ac:	00 90       	ret 

800058ae <IfxAsclin_Asc_blockingWrite>:
    return data;
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
800058ae:	20 10       	sub.a %sp,16
800058b0:	e9 a4 07 00 	st.b [%sp]7,%d4
    Ifx_SizeT count = 1;

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
800058b4:	82 f4       	mov %d4,-1
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
800058b6:	82 1f       	mov %d15,1

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
800058b8:	d9 a5 07 00 	lea %a5,[%sp]7
800058bc:	d9 a6 0e 00 	lea %a6,[%sp]14
800058c0:	9b 04 00 58 	addih %d5,%d4,32768
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
800058c4:	ac a7       	st.h [%sp]14,%d15

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
}
800058c6:	1d ff c3 ff 	j 8000584c <IfxAsclin_Asc_write>

800058ca <IfxAsclin_Asc_stdIfDPipeInit>:


boolean IfxAsclin_Asc_stdIfDPipeInit(IfxStdIf_DPipe *stdif, IfxAsclin_Asc *asclin)
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));
800058ca:	40 42       	mov.aa %a2,%a4
800058cc:	82 0f       	mov %d15,0
800058ce:	c5 0f 0b 10 	lea %a15,4b <_.+0x4a>
800058d2:	24 2f       	st.b [%a2+],%d15
800058d4:	fc ff       	loop %a15,800058d2 <IfxAsclin_Asc_stdIfDPipeInit+0x8>

    /* Set the API link */
    stdif->driver         = asclin;
    stdif->write          = (IfxStdIf_DPipe_Write) & IfxAsclin_Asc_write;
800058d6:	7b 00 00 f8 	movh %d15,32768
800058da:	1b cf 84 f5 	addi %d15,%d15,22604
800058de:	6c 42       	st.w [%a4]8,%d15
    stdif->read           = (IfxStdIf_DPipe_Read) & IfxAsclin_Asc_read;
800058e0:	7b 00 00 f8 	movh %d15,32768
800058e4:	1b cf 23 f5 	addi %d15,%d15,21052
800058e8:	6c 43       	st.w [%a4]12,%d15
    stdif->getReadCount   = (IfxStdIf_DPipe_GetReadCount) & IfxAsclin_Asc_getReadCount;
800058ea:	7b 00 00 f8 	movh %d15,32768
800058ee:	1b 0f 0c f5 	addi %d15,%d15,20672
800058f2:	6c 44       	st.w [%a4]16,%d15
    stdif->getReadEvent   = (IfxStdIf_DPipe_GetReadEvent) & IfxAsclin_Asc_getReadEvent;
800058f4:	7b 00 00 f8 	movh %d15,32768
800058f8:	1b 6f 0c f5 	addi %d15,%d15,20678
800058fc:	6c 45       	st.w [%a4]20,%d15
    stdif->getWriteCount  = (IfxStdIf_DPipe_GetWriteCount) & IfxAsclin_Asc_getWriteCount;
800058fe:	7b 00 00 f8 	movh %d15,32768
80005902:	1b cf 0d f5 	addi %d15,%d15,20700
80005906:	6c 46       	st.w [%a4]24,%d15
    stdif->getWriteEvent  = (IfxStdIf_DPipe_GetWriteEvent) & IfxAsclin_Asc_getWriteEvent;
80005908:	7b 00 00 f8 	movh %d15,32768
8000590c:	1b af 0e f5 	addi %d15,%d15,20714
80005910:	6c 47       	st.w [%a4]28,%d15
    stdif->canReadCount   = (IfxStdIf_DPipe_CanReadCount) & IfxAsclin_Asc_canReadCount;
80005912:	7b 00 00 f8 	movh %d15,32768
80005916:	1b cf 16 f5 	addi %d15,%d15,20844
8000591a:	6c 48       	st.w [%a4]32,%d15
    stdif->canWriteCount  = (IfxStdIf_DPipe_CanWriteCount) & IfxAsclin_Asc_canWriteCount;
8000591c:	7b 00 00 f8 	movh %d15,32768
80005920:	1b 0f 21 f5 	addi %d15,%d15,21008
80005924:	6c 49       	st.w [%a4]36,%d15
    stdif->flushTx        = (IfxStdIf_DPipe_FlushTx) & IfxAsclin_Asc_flushTx;
80005926:	7b 00 00 f8 	movh %d15,32768
8000592a:	1b 4f 17 f5 	addi %d15,%d15,20852
8000592e:	6c 4a       	st.w [%a4]40,%d15
    stdif->clearTx        = (IfxStdIf_DPipe_ClearTx) & IfxAsclin_Asc_clearTx;
80005930:	7b 00 00 f8 	movh %d15,32768
80005934:	1b 8f 22 f5 	addi %d15,%d15,21032
80005938:	6c 4b       	st.w [%a4]44,%d15
    stdif->clearRx        = (IfxStdIf_DPipe_ClearRx) & IfxAsclin_Asc_clearRx;
8000593a:	7b 00 00 f8 	movh %d15,32768
8000593e:	1b 8f 21 f5 	addi %d15,%d15,21016
80005942:	6c 4c       	st.w [%a4]48,%d15
    stdif->onReceive      = (IfxStdIf_DPipe_OnReceive) & IfxAsclin_Asc_isrReceive;
80005944:	7b 00 00 f8 	movh %d15,32768
80005948:	1b 6f 2f f5 	addi %d15,%d15,21238
8000594c:	6c 4d       	st.w [%a4]52,%d15
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
8000594e:	7b 00 00 f8 	movh %d15,32768
80005952:	1b 8f 25 f5 	addi %d15,%d15,21080
80005956:	6c 4e       	st.w [%a4]56,%d15
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
80005958:	7b 00 00 f8 	movh %d15,32768
8000595c:	1b 4f 0f f5 	addi %d15,%d15,20724
80005960:	6c 4f       	st.w [%a4]60,%d15
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
80005962:	7b 00 00 f8 	movh %d15,32768
80005966:	1b 0f 0d f5 	addi %d15,%d15,20688
8000596a:	59 4f 00 10 	st.w [%a4]64,%d15
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
8000596e:	7b 00 00 f8 	movh %d15,32768
80005972:	1b 6f 0d f5 	addi %d15,%d15,20694
80005976:	59 4f 04 10 	st.w [%a4]68,%d15
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
8000597a:	7b 00 00 f8 	movh %d15,32768
8000597e:	1b 6f 16 f5 	addi %d15,%d15,20838
80005982:	59 4f 08 10 	st.w [%a4]72,%d15
    stdif->txDisabled     = FALSE;
80005986:	82 0f       	mov %d15,0
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));

    /* Set the API link */
    stdif->driver         = asclin;
80005988:	f4 45       	st.a [%a4],%a5
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
    stdif->txDisabled     = FALSE;
8000598a:	2c 44       	st.b [%a4]4,%d15
    return TRUE;
}
8000598c:	82 12       	mov %d2,1
8000598e:	00 90       	ret 

80005990 <IfxPort_getAddress>:
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005990:	91 00 00 28 	movh.a %a2,32768
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80005994:	82 05       	mov %d5,0
}


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
80005996:	82 02       	mov %d2,0
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005998:	d9 22 9c 50 	lea %a2,[%a2]2396 <8000095c <IfxPort_cfg_indexMap>>
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
8000599c:	8f f5 0f f1 	and %d15,%d5,255
800059a0:	8b 02 00 32 	eq %d3,%d2,0
800059a4:	8b 0f 61 34 	and.lt.u %d3,%d15,16
800059a8:	76 3a       	jz %d3,800059bc <IfxPort_getAddress+0x2c>
800059aa:	02 5f       	mov %d15,%d5
800059ac:	16 ff       	and %d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
800059ae:	d0 2f       	addsc.a %a15,%a2,%d15,3
800059b0:	82 02       	mov %d2,0
800059b2:	4c f1       	ld.w %d15,[%a15]4
800059b4:	7e 42       	jne %d15,%d4,800059b8 <IfxPort_getAddress+0x28>
        {
            module = IfxPort_cfg_indexMap[i].module;
800059b6:	48 02       	ld.w %d2,[%a15]0
800059b8:	c2 15       	add %d5,1
800059ba:	3c f1       	j 8000599c <IfxPort_getAddress+0xc>

        i++;
    }

    return module;
}
800059bc:	60 22       	mov.a %a2,%d2
800059be:	00 90       	ret 

800059c0 <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
800059c0:	91 00 00 38 	movh.a %a3,32768
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
800059c4:	82 0f       	mov %d15,0
    {
        if (IfxPort_cfg_indexMap[index].module == port)
800059c6:	d9 33 9c 50 	lea %a3,[%a3]2396 <8000095c <IfxPort_cfg_indexMap>>
800059ca:	a0 ff       	mov.a %a15,15
800059cc:	d0 32       	addsc.a %a2,%a3,%d15,3
800059ce:	d4 25       	ld.a %a5,[%a2]
800059d0:	7d 45 05 80 	jne.a %a5,%a4,800059da <IfxPort_getIndex+0x1a>
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
800059d4:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
800059d8:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
800059da:	c2 1f       	add %d15,1
800059dc:	fc f8       	loop %a15,800059cc <IfxPort_getIndex+0xc>
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
800059de:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
800059e0:	00 90       	ret 

800059e2 <IfxPort_resetESR>:


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
800059e2:	40 4f       	mov.aa %a15,%a4
800059e4:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800059e6:	6d 00 ac 0c 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800059ea:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800059ec:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800059ee:	6d 00 a8 0b 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
800059f2:	82 12       	mov %d2,1
800059f4:	d9 f4 10 10 	lea %a4,[%a15]80
800059f8:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
800059fc:	d2 06       	mov %e6,0
800059fe:	02 27       	mov %d7,%d2
80005a00:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005a04:	02 f4       	mov %d4,%d15
80005a06:	1d 00 d1 0c 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80005a0a <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a0a:	91 00 00 38 	movh.a %a3,32768
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a0e:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a10:	d9 33 9c 70 	lea %a3,[%a3]2524 <800009dc <IfxPort_cfg_esrMasks>>
80005a14:	a0 ff       	mov.a %a15,15
80005a16:	d0 32       	addsc.a %a2,%a3,%d15,3
80005a18:	d4 25       	ld.a %a5,[%a2]
80005a1a:	7d 54 0c 80 	jne.a %a4,%a5,80005a32 <IfxPort_disableEmergencyStop+0x28>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005a1e:	b9 2f 04 00 	ld.hu %d15,[%a2]4
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
80005a22:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005a24:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
80005a28:	6e 08       	jz %d15,80005a38 <IfxPort_disableEmergencyStop+0x2e>
            {
                IfxPort_resetESR(port, pinIndex);
80005a2a:	6d ff dc ff 	call 800059e2 <IfxPort_resetESR>
                result = TRUE;
80005a2e:	82 12       	mov %d2,1
80005a30:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a32:	c2 1f       	add %d15,1
80005a34:	fc f1       	loop %a15,80005a16 <IfxPort_disableEmergencyStop+0xc>
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
80005a36:	82 02       	mov %d2,0
            break;
        }
    }

    return result;
}
80005a38:	00 90       	ret 

80005a3a <IfxPort_setESR>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
80005a3a:	40 4f       	mov.aa %a15,%a4
80005a3c:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a3e:	6d 00 80 0c 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005a42:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a44:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005a46:	6d 00 7c 0b 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
80005a4a:	82 12       	mov %d2,1
80005a4c:	0f 82 00 20 	sh %d2,%d2,%d8
80005a50:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005a54:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005a58:	02 27       	mov %d7,%d2
80005a5a:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005a5e:	02 f4       	mov %d4,%d15
80005a60:	1d 00 a4 0c 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80005a64 <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80005a64:	82 19       	mov %d9,1
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a66:	91 00 00 d8 	movh.a %a13,32768
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80005a6a:	40 4c       	mov.aa %a12,%a4
80005a6c:	02 48       	mov %d8,%d4
80005a6e:	0f 49 00 90 	sh %d9,%d9,%d4
    sint32  portIndex;
    boolean result = FALSE;
80005a72:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a74:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a76:	d9 dd 9c 70 	lea %a13,[%a13]2524 <800009dc <IfxPort_cfg_esrMasks>>
80005a7a:	d0 df       	addsc.a %a15,%a13,%d15,3
80005a7c:	c8 02       	ld.a %a2,[%a15]0
80005a7e:	7d 2c 0b 80 	jne.a %a12,%a2,80005a94 <IfxPort_enableEmergencyStop+0x30>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005a82:	b9 f3 04 00 	ld.hu %d3,[%a15]4
80005a86:	26 93       	and %d3,%d9
80005a88:	76 36       	jz %d3,80005a94 <IfxPort_enableEmergencyStop+0x30>
            {
                IfxPort_setESR(port, pinIndex);
80005a8a:	40 c4       	mov.aa %a4,%a12
80005a8c:	02 84       	mov %d4,%d8
80005a8e:	6d ff d6 ff 	call 80005a3a <IfxPort_setESR>
                result = TRUE;
80005a92:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a94:	c2 1f       	add %d15,1
80005a96:	8b 0f 21 32 	ne %d3,%d15,16
80005a9a:	df 03 f0 ff 	jne %d3,0,80005a7a <IfxPort_enableEmergencyStop+0x16>
            }
        }
    }

    return result;
}
80005a9e:	00 90       	ret 

80005aa0 <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005aa0:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
80005aa2:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005aa4:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005aa6:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005aa8:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80005aaa:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005aac:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005aae:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ab0:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005ab2:	78 07       	st.w [%sp]28,%d15
80005ab4:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005ab8:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005abc:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005ac0:	3b 80 0f 70 	mov %d7,248
80005ac4:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005ac8:	9f 0f 07 80 	jned %d15,0,80005ad6 <IfxPort_setGroupModeInput+0x36>
80005acc:	d9 44 10 00 	lea %a4,[%a4]16
80005ad0:	82 0f       	mov %d15,0
80005ad2:	a0 3f       	mov.a %a15,3
80005ad4:	3c 1e       	j 80005b10 <IfxPort_setGroupModeInput+0x70>
    {
        if ((imask & (1U << i)) != 0)
80005ad6:	57 05 61 24 	extr.u %d2,%d5,%d4,1
80005ada:	df 02 19 00 	jeq %d2,0,80005b0c <IfxPort_setGroupModeInput+0x6c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005ade:	8f 34 c0 31 	andn %d3,%d4,3
80005ae2:	60 32       	mov.a %a2,%d3
80005ae4:	d9 af 20 00 	lea %a15,[%sp]32
80005ae8:	30 2f       	add.a %a15,%a2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80005aea:	8f 34 00 21 	and %d2,%d4,3
80005aee:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80005af0:	19 f0 f0 ff 	ld.w %d0,[%a15]-16
80005af4:	0f 27 00 30 	sh %d3,%d7,%d2
80005af8:	a6 03       	or %d3,%d0
80005afa:	59 f3 f0 ff 	st.w [%a15]-16,%d3
            iocrVal[index]  |= (mode) << shift;
80005afe:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
80005b02:	0f 26 00 20 	sh %d2,%d6,%d2
80005b06:	a6 32       	or %d2,%d3
80005b08:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b0c:	c2 14       	add %d4,1
80005b0e:	3c dd       	j 80005ac8 <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005b10:	d9 a3 20 00 	lea %a3,[%sp]32
80005b14:	90 32       	addsc.a %a2,%a3,%d15,2
80005b16:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005b1a:	76 47       	jz %d4,80005b28 <IfxPort_setGroupModeInput+0x88>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005b1c:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005b20:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005b22:	02 43       	mov %d3,%d4
80005b24:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005b28:	c2 1f       	add %d15,1
80005b2a:	b0 44       	add.a %a4,4
80005b2c:	fc f2       	loop %a15,80005b10 <IfxPort_setGroupModeInput+0x70>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005b2e:	00 90       	ret 

80005b30 <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b30:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
80005b32:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b34:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005b36:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b38:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80005b3a:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b3c:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005b3e:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005b40:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005b42:	78 07       	st.w [%sp]28,%d15
80005b44:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b48:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005b4c:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b50:	3b 80 0f 00 	mov %d0,248
80005b54:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b58:	9f 0f 07 80 	jned %d15,0,80005b66 <IfxPort_setGroupModeOutput+0x36>
80005b5c:	d9 44 10 00 	lea %a4,[%a4]16
80005b60:	82 0f       	mov %d15,0
80005b62:	a0 3f       	mov.a %a15,3
80005b64:	3c 1f       	j 80005ba2 <IfxPort_setGroupModeOutput+0x72>
    {
        if ((imask & (1U << i)) != 0)
80005b66:	57 05 61 24 	extr.u %d2,%d5,%d4,1
80005b6a:	df 02 1a 00 	jeq %d2,0,80005b9e <IfxPort_setGroupModeOutput+0x6e>
        {
            uint32 index = i / 4;
80005b6e:	8f e4 1f 30 	sh %d3,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b72:	d9 a2 20 00 	lea %a2,[%sp]32
80005b76:	01 23 02 f6 	addsc.a %a15,%a2,%d3,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80005b7a:	8f 34 00 21 	and %d2,%d4,3
80005b7e:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
80005b80:	a6 63       	or %d3,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b82:	0f 20 00 70 	sh %d7,%d0,%d2
80005b86:	19 f1 f0 ff 	ld.w %d1,[%a15]-16
            iocrVal[index]  |= (mode | index) << shift;
80005b8a:	0f 23 00 20 	sh %d2,%d3,%d2
80005b8e:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b92:	a6 17       	or %d7,%d1
            iocrVal[index]  |= (mode | index) << shift;
80005b94:	a6 32       	or %d2,%d3
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b96:	59 f7 f0 ff 	st.w [%a15]-16,%d7
            iocrVal[index]  |= (mode | index) << shift;
80005b9a:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b9e:	c2 14       	add %d4,1
80005ba0:	3c dc       	j 80005b58 <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005ba2:	d9 a3 20 00 	lea %a3,[%sp]32
80005ba6:	90 32       	addsc.a %a2,%a3,%d15,2
80005ba8:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005bac:	76 47       	jz %d4,80005bba <IfxPort_setGroupModeOutput+0x8a>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005bae:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005bb2:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005bb4:	02 43       	mov %d3,%d4
80005bb6:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode | index) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005bba:	c2 1f       	add %d15,1
80005bbc:	b0 44       	add.a %a4,4
80005bbe:	fc f2       	loop %a15,80005ba2 <IfxPort_setGroupModeOutput+0x72>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005bc0:	00 90       	ret 

80005bc2 <IfxPort_setGroupPadDriver>:


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80005bc2:	20 10       	sub.a %sp,16
80005bc4:	02 4f       	mov %d15,%d4
80005bc6:	02 5a       	mov %d10,%d5
80005bc8:	40 4c       	mov.aa %a12,%a4
80005bca:	02 69       	mov %d9,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005bcc:	6d 00 b9 0b 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005bd0:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005bd2:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005bd4:	6d 00 b5 0a 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005bd8:	82 03       	mov %d3,0
80005bda:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80005bdc:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005be0:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80005be4:	59 a3 0c 00 	st.w [%sp]12,%d3
80005be8:	8b 1f a1 22 	ge.u %d2,%d15,17
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005bec:	8b 0f 01 31 	rsub %d3,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80005bf0:	0f fa 00 50 	sh %d5,%d10,%d15
80005bf4:	ab 03 a0 32 	seln %d3,%d2,%d3,0

        for (i = pinIndex; i < 16; i++)
80005bf8:	9f 03 03 80 	jned %d3,0,80005bfe <IfxPort_setGroupPadDriver+0x3c>
80005bfc:	3c 1d       	j 80005c36 <IfxPort_setGroupPadDriver+0x74>
        {
            if ((imask & (1U << i)) != 0)
80005bfe:	57 05 61 2f 	extr.u %d2,%d5,%d15,1
80005c02:	df 02 18 00 	jeq %d2,0,80005c32 <IfxPort_setGroupPadDriver+0x70>
            {
                uint32 index = i / 8;
80005c06:	8f df 1f 40 	sh %d4,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005c0a:	d9 a2 10 00 	lea %a2,[%sp]16
80005c0e:	01 24 02 f6 	addsc.a %a15,%a2,%d4,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005c12:	8f 7f 00 21 	and %d2,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80005c16:	19 f4 f8 ff 	ld.w %d4,[%a15]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005c1a:	06 22       	sh %d2,2
                pdrMask[index] |= (0xFUL << shift);
80005c1c:	d7 f4 04 42 	insert %d4,%d4,15,%d2,4
                pdrVal[index]  |= (padDriver << shift);
80005c20:	0f 29 00 20 	sh %d2,%d9,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005c24:	59 f4 f8 ff 	st.w [%a15]-8,%d4
                pdrVal[index]  |= (padDriver << shift);
80005c28:	19 f4 f0 ff 	ld.w %d4,[%a15]-16
80005c2c:	a6 42       	or %d2,%d4
80005c2e:	59 f2 f0 ff 	st.w [%a15]-16,%d2
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80005c32:	c2 1f       	add %d15,1
80005c34:	3c e2       	j 80005bf8 <IfxPort_setGroupPadDriver+0x36>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005c36:	58 02       	ld.w %d15,[%sp]8
80005c38:	6e 08       	jz %d15,80005c48 <IfxPort_setGroupPadDriver+0x86>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005c3a:	d9 cf 00 10 	lea %a15,[%a12]64
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005c3e:	54 a6       	ld.w %d6,[%sp]
80005c40:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005c42:	02 f7       	mov %d7,%d15
80005c44:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005c48:	58 03       	ld.w %d15,[%sp]12
80005c4a:	6e 09       	jz %d15,80005c5c <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005c4c:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005c50:	19 a6 04 00 	ld.w %d6,[%sp]4
80005c54:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005c56:	02 f7       	mov %d7,%d15
80005c58:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005c5c:	02 84       	mov %d4,%d8
}
80005c5e:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005c62:	1d 00 a3 0b 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80005c66 <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80005c66:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005c6a:	8f 34 00 91 	and %d9,%d4,3

    if (port == &MODULE_P40)
80005c6e:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80005c72:	40 4f       	mov.aa %a15,%a4
80005c74:	02 4f       	mov %d15,%d4
80005c76:	02 5a       	mov %d10,%d5
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80005c78:	d9 4c 10 00 	lea %a12,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80005c7c:	8f e4 1f b0 	sh %d11,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005c80:	06 39       	sh %d9,3

    if (port == &MODULE_P40)
80005c82:	7d 24 11 80 	jne.a %a4,%a2,80005ca4 <IfxPort_setPinMode+0x3e>
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c86:	6d 00 5c 0b 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80005c8a:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c8c:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80005c8e:	6d 00 58 0a 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80005c92:	19 f2 20 10 	ld.w %d2,[%a15]96
        IfxScuWdt_setCpuEndinit(passwd);
80005c96:	02 84       	mov %d4,%d8

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80005c98:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80005c9c:	59 ff 20 10 	st.w [%a15]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80005ca0:	6d 00 84 0b 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80005ca4:	da ff       	mov %d15,255
80005ca6:	01 cb 02 f6 	addsc.a %a15,%a12,%d11,2
80005caa:	0f 9f 00 f0 	sh %d15,%d15,%d9
80005cae:	0f 9a 00 20 	sh %d2,%d10,%d9
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005cb2:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005cb4:	02 f3       	mov %d3,%d15
80005cb6:	49 f2 40 08 	ldmst [%a15]0,%e2
80005cba:	00 90       	ret 

80005cbc <IfxPort_setPinModeLvdsHigh>:
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80005cbc:	02 5a       	mov %d10,%d5
80005cbe:	40 4f       	mov.aa %a15,%a4
80005cc0:	02 49       	mov %d9,%d4
80005cc2:	02 6f       	mov %d15,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005cc4:	6d 00 3d 0b 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005cc8:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005cca:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005ccc:	6d 00 39 0a 	call 8000713e <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80005cd0:	37 0a 48 50 	extr %d5,%d10,0,8
80005cd4:	bf 05 11 00 	jlt %d5,0,80005cf6 <IfxPort_setPinModeLvdsHigh+0x3a>
    {
        if (pinIndex < 2)
80005cd8:	bf 29 21 80 	jlt.u %d9,2,80005d1a <IfxPort_setPinModeLvdsHigh+0x5e>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80005cdc:	19 f2 24 20 	ld.w %d2,[%a15]164
80005ce0:	37 f2 01 f0 	insert %d15,%d2,%d15,0,1
80005ce4:	59 ff 24 20 	st.w [%a15]164,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
80005ce8:	19 ff 24 20 	ld.w %d15,[%a15]164
80005cec:	8f 2f c0 f1 	andn %d15,%d15,2
80005cf0:	59 ff 24 20 	st.w [%a15]164,%d15
80005cf4:	3c 13       	j 80005d1a <IfxPort_setPinModeLvdsHigh+0x5e>
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80005cf6:	19 f2 28 20 	ld.w %d2,[%a15]168
80005cfa:	67 f2 0c f0 	ins.t %d15,%d2,12,%d15,0
80005cfe:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_DIS    = 0;
80005d02:	19 ff 28 20 	ld.w %d15,[%a15]168
80005d06:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80005d0a:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_PD     = 0;
80005d0e:	19 ff 28 20 	ld.w %d15,[%a15]168
80005d12:	b7 0f 01 f7 	insert %d15,%d15,0,14,1
80005d16:	59 ff 28 20 	st.w [%a15]168,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80005d1a:	02 84       	mov %d4,%d8
80005d1c:	1d 00 46 0b 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80005d20 <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005d20:	0b 65 10 a8 	mov %e10,%d5,%d6
80005d24:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005d26:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005d2a:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005d2c:	6d 00 09 0b 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005d30:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005d32:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005d34:	6d 00 05 0a 	call 8000713e <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80005d38:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80005d3a:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005d3e:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005d42:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80005d46:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005d4a:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005d4e:	0f 2b 00 50 	sh %d5,%d11,%d2
80005d52:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005d54:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005d56:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005d58:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80005d5c:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005d5e:	1d 00 25 0b 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80005d62 <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80005d62:	0b 45 10 88 	mov %e8,%d5,%d4
80005d66:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005d68:	6d 00 eb 0a 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005d6c:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005d6e:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005d70:	6d 00 e7 09 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80005d74:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005d78:	06 22       	sh %d2,2
80005d7a:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80005d7c:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005d80:	3b f0 00 30 	mov %d3,15
80005d84:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80005d88:	0f 23 00 30 	sh %d3,%d3,%d2
80005d8c:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005d90:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005d92:	02 37       	mov %d7,%d3
80005d94:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005d98:	02 f4       	mov %d4,%d15
80005d9a:	1d 00 07 0b 	j 800073a8 <IfxScuWdt_setCpuEndinit>
	...

80005da0 <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80005da0:	7b e0 e4 30 	movh %d3,3662
80005da4:	1b 13 c0 31 	addi %d3,%d3,7169
80005da8:	0b 34 30 c1 	lt.u %d12,%d4,%d3
80005dac:	82 2f       	mov %d15,2
80005dae:	ab 1f 80 cc 	sel %d12,%d12,%d15,1
80005db2:	8f 4c 00 80 	sh %d8,%d12,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005db6:	7b c0 be 00 	movh %d0,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005dba:	91 40 0f 50 	movh.a %a5,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005dbe:	7b 80 82 6e 	movh %d6,59432
80005dc2:	91 80 7d 61 	movh.a %a6,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
80005dc6:	19 4e 10 10 	ld.w %d14,[%a4]80
80005dca:	60 83       	mov.a %a3,%d8
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005dcc:	1b 00 20 0c 	addi %d0,%d0,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80005dd0:	d2 0a       	mov %e10,0
80005dd2:	82 09       	mov %d9,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005dd4:	3b 00 01 50 	mov %d5,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005dd8:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005ddc:	82 f7       	mov %d7,-1
80005dde:	1b 06 c0 67 	addi %d6,%d6,31744
80005de2:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
80005de6:	a0 ff       	mov.a %a15,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005de8:	4b 5e 11 22 	div.u %e2,%d14,%d5

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005dec:	7b 60 f8 1f 	movh %d1,65414
80005df0:	1b 01 e0 1e 	addi %d1,%d1,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005df4:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005df6:	0b 12 40 10 	addx %d1,%d2,%d1
80005dfa:	8b f3 bf 20 	addc %d2,%d3,-1
80005dfe:	80 53       	mov.d %d3,%a5
80005e00:	ba 02       	eq %d15,%d2,0
80005e02:	0b 31 50 f2 	and.ge.u %d15,%d1,%d3
80005e06:	8b 02 00 f5 	or.ne %d15,%d2,0
80005e0a:	ee 24       	jnz %d15,80005e52 <IfxScuCcu_calculateSysPllDividers+0xb2>
80005e0c:	02 5d       	mov %d13,%d5
80005e0e:	82 11       	mov %d1,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005e10:	03 41 68 26 	madd.u %e2,%e6,%d1,%d4
80005e14:	80 68       	mov.d %d8,%a6
80005e16:	ba 03       	eq %d15,%d3,0
80005e18:	0b 82 50 f2 	and.ge.u %d15,%d2,%d8
80005e1c:	8b 03 00 f5 	or.ne %d15,%d3,0
80005e20:	ee 13       	jnz %d15,80005e46 <IfxScuCcu_calculateSysPllDividers+0xa6>
80005e22:	82 18       	mov %d8,1
80005e24:	c5 02 3f 10 	lea %a2,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
80005e28:	4b d8 11 22 	div.u %e2,%d8,%d13
80005e2c:	e2 e2       	mul %d2,%d14
80005e2e:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
80005e30:	df 02 18 00 	jeq %d2,0,80005e60 <IfxScuCcu_calculateSysPllDividers+0xc0>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
80005e34:	82 1f       	mov %d15,1
80005e36:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80005e3a:	6a 8b       	cmovn %d11,%d15,%d8
80005e3c:	6a 20       	cmovn %d0,%d15,%d2
80005e3e:	6a 5a       	cmovn %d10,%d15,%d5
80005e40:	6a 19       	cmovn %d9,%d15,%d1
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
80005e42:	c2 18       	add %d8,1
80005e44:	fc 22       	loop %a2,80005e28 <IfxScuCcu_calculateSysPllDividers+0x88>
80005e46:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80005e48:	42 c1       	add %d1,%d12
80005e4a:	42 fd       	add %d13,%d15
80005e4c:	8b 11 68 f2 	lt.u %d15,%d1,129
80005e50:	ee e0       	jnz %d15,80005e10 <IfxScuCcu_calculateSysPllDividers+0x70>
80005e52:	60 c2       	mov.a %a2,%d12
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005e54:	c2 f5       	add %d5,-1
80005e56:	01 23 20 30 	sub.a %a3,%a3,%a2
80005e5a:	fd f0 c7 7f 	loop %a15,80005de8 <IfxScuCcu_calculateSysPllDividers+0x48>
80005e5e:	3c 05       	j 80005e68 <IfxScuCcu_calculateSysPllDividers+0xc8>

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
                                bestN          = n;
80005e60:	0b 58 10 a8 	mov %e10,%d8,%d5
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
80005e64:	02 19       	mov %d9,%d1
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
80005e66:	82 00       	mov %d0,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005e68:	da 64       	mov %d15,100
80005e6a:	06 14       	sh %d4,1
80005e6c:	4b f4 11 42 	div.u %e4,%d4,%d15
80005e70:	82 1f       	mov %d15,1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80005e72:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005e74:	0b 40 50 f2 	and.ge.u %d15,%d0,%d4
80005e78:	ee 0f       	jnz %d15,80005e96 <IfxScuCcu_calculateSysPllDividers+0xf6>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005e7a:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005e7c:	c2 fb       	add %d11,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005e7e:	c2 fa       	add %d10,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005e80:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005e82:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005e86:	e9 4b 09 00 	st.b [%a4]9,%d11
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005e8a:	e9 4a 08 00 	st.b [%a4]8,%d10
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005e8e:	e9 49 0a 00 	st.b [%a4]10,%d9
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80005e92:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80005e94:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80005e96:	00 90       	ret 

80005e98 <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80005e98:	91 00 00 f7 	movh.a %a15,28672
80005e9c:	19 f2 30 30 	ld.w %d2,[%a15]240 <700000f0 <IfxScuCcu_xtalFrequency>>
}
80005ea0:	4b 02 61 21 	utof %d2,%d2
80005ea4:	00 90       	ret 

80005ea6 <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005ea6:	91 30 00 ff 	movh.a %a15,61443
80005eaa:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005eae:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005eb0:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005eb4:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005eb8:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005ebc:	6e 0c       	jz %d15,80005ed4 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005ebe:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
80005ec0:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005ec2:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005ec6:	5e 17       	jne %d15,1,80005ed4 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80005ec8:	91 00 00 f7 	movh.a %a15,28672
80005ecc:	19 f2 30 30 	ld.w %d2,[%a15]240 <700000f0 <IfxScuCcu_xtalFrequency>>
80005ed0:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}
80005ed4:	00 90       	ret 

80005ed6 <IfxScuCcu_getPllErayFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005ed6:	91 30 00 ff 	movh.a %a15,61443
80005eda:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005ede:	6d ff e4 ff 	call 80005ea6 <IfxScuCcu_getOscFrequency>

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005ee2:	4c f9       	ld.w %d15,[%a15]36
80005ee4:	2e 05       	jz.t %d15,0,80005eee <IfxScuCcu_getPllErayFrequency+0x18>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80005ee6:	4c fb       	ld.w %d15,[%a15]44
80005ee8:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005eec:	3c 21       	j 80005f2e <IfxScuCcu_getPllErayFrequency+0x58>
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80005eee:	4c f9       	ld.w %d15,[%a15]36
80005ef0:	6f 3f 15 00 	jz.t %d15,3,80005f1a <IfxScuCcu_getPllErayFrequency+0x44>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80005ef4:	48 b4       	ld.w %d4,[%a15]44
80005ef6:	8f f4 07 41 	and %d4,%d4,127
80005efa:	c2 14       	add %d4,1
80005efc:	6d 00 e5 25 	call 8000aac6 <__floatsidf>
80005f00:	7b 80 19 54 	movh %d5,16792
80005f04:	0b 23 10 68 	mov %e6,%d3,%d2
80005f08:	82 04       	mov %d4,0
80005f0a:	1b 45 78 5d 	addi %d5,%d5,-10364
80005f0e:	6d 00 50 25 	call 8000a9ae <__divdf3>
80005f12:	0b 23 10 48 	mov %e4,%d3,%d2
80005f16:	1d 00 0b 26 	j 8000ab2c <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80005f1a:	48 a3       	ld.w %d3,[%a15]40
80005f1c:	4c fb       	ld.w %d15,[%a15]44
80005f1e:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005f22:	16 7f       	and %d15,127
80005f24:	c2 13       	add %d3,1
80005f26:	4b 03 41 31 	itof %d3,%d3
80005f2a:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005f2e:	c2 1f       	add %d15,1
80005f30:	4b 0f 41 f1 	itof %d15,%d15
80005f34:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005f38:	00 90       	ret 

80005f3a <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005f3a:	91 30 00 ff 	movh.a %a15,61443
80005f3e:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80005f42:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005f44:	7b f0 cb 24 	movh %d2,19647
80005f48:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005f4c:	6f 3f 18 80 	jnz.t %d15,3,80005f7c <IfxScuCcu_getPllErayVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80005f50:	6d ff ab ff 	call 80005ea6 <IfxScuCcu_getOscFrequency>
80005f54:	91 30 00 ff 	movh.a %a15,61443
80005f58:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80005f5c:	48 03       	ld.w %d3,[%a15]0
80005f5e:	4c f0       	ld.w %d15,[%a15]0
80005f60:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005f64:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005f68:	c2 13       	add %d3,1
80005f6a:	4b 03 41 31 	itof %d3,%d3
80005f6e:	c2 1f       	add %d15,1
80005f70:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005f74:	4b 0f 41 f1 	itof %d15,%d15
80005f78:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005f7c:	00 90       	ret 

80005f7e <IfxScuCcu_getPllFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005f7e:	91 30 00 ff 	movh.a %a15,61443
80005f82:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005f86:	6d ff 90 ff 	call 80005ea6 <IfxScuCcu_getOscFrequency>

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005f8a:	4c f5       	ld.w %d15,[%a15]20
80005f8c:	2e 06       	jz.t %d15,0,80005f98 <IfxScuCcu_getPllFrequency+0x1a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80005f8e:	4c f7       	ld.w %d15,[%a15]28
80005f90:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005f94:	c2 1f       	add %d15,1
80005f96:	3c 28       	j 80005fe6 <IfxScuCcu_getPllFrequency+0x68>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80005f98:	4c f5       	ld.w %d15,[%a15]20
80005f9a:	6f 3f 15 00 	jz.t %d15,3,80005fc4 <IfxScuCcu_getPllFrequency+0x46>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80005f9e:	48 74       	ld.w %d4,[%a15]28
80005fa0:	8f f4 07 41 	and %d4,%d4,127
80005fa4:	c2 14       	add %d4,1
80005fa6:	6d 00 90 25 	call 8000aac6 <__floatsidf>
80005faa:	7b 80 19 54 	movh %d5,16792
80005fae:	0b 23 10 68 	mov %e6,%d3,%d2
80005fb2:	82 04       	mov %d4,0
80005fb4:	1b 45 78 5d 	addi %d5,%d5,-10364
80005fb8:	6d 00 fb 24 	call 8000a9ae <__divdf3>
80005fbc:	0b 23 10 48 	mov %e4,%d3,%d2
80005fc0:	1d 00 b6 25 	j 8000ab2c <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80005fc4:	48 64       	ld.w %d4,[%a15]24
80005fc6:	4c f7       	ld.w %d15,[%a15]28
80005fc8:	37 04 e7 44 	extr.u %d4,%d4,9,7
80005fcc:	8f ff 07 31 	and %d3,%d15,127
80005fd0:	4c f6       	ld.w %d15,[%a15]24
80005fd2:	c2 14       	add %d4,1
80005fd4:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005fd8:	4b 04 41 41 	itof %d4,%d4
80005fdc:	c2 1f       	add %d15,1
80005fde:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80005fe2:	4b 42 41 20 	mul.f %d2,%d2,%d4
80005fe6:	4b 0f 41 f1 	itof %d15,%d15
80005fea:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005fee:	00 90       	ret 

80005ff0 <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005ff0:	91 30 00 ff 	movh.a %a15,61443
80005ff4:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005ff8:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005ffa:	7b f0 cb 24 	movh %d2,19647
80005ffe:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80006002:	6f 3f 18 80 	jnz.t %d15,3,80006032 <IfxScuCcu_getPllVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80006006:	6d ff 50 ff 	call 80005ea6 <IfxScuCcu_getOscFrequency>
8000600a:	91 30 00 ff 	movh.a %a15,61443
8000600e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006012:	48 03       	ld.w %d3,[%a15]0
80006014:	4c f0       	ld.w %d15,[%a15]0
80006016:	37 03 e7 34 	extr.u %d3,%d3,9,7
8000601a:	37 0f 64 fc 	extr.u %d15,%d15,24,4
8000601e:	c2 13       	add %d3,1
80006020:	4b 03 41 31 	itof %d3,%d3
80006024:	c2 1f       	add %d15,1
80006026:	4b 32 41 20 	mul.f %d2,%d2,%d3
8000602a:	4b 0f 41 f1 	itof %d15,%d15
8000602e:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80006032:	00 90       	ret 

80006034 <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80006034:	91 30 00 ff 	movh.a %a15,61443
80006038:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000603c:	4c f0       	ld.w %d15,[%a15]0
8000603e:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80006042:	6e 06       	jz %d15,8000604e <IfxScuCcu_getSourceFrequency+0x1a>
80006044:	1e 13       	jeq %d15,1,8000604a <IfxScuCcu_getSourceFrequency+0x16>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80006046:	82 02       	mov %d2,0
80006048:	00 90       	ret 
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
8000604a:	1d ff 9a ff 	j 80005f7e <IfxScuCcu_getPllFrequency>
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000604e:	7b f0 cb 24 	movh %d2,19647
80006052:	1b 02 c2 2b 	addi %d2,%d2,-17376
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
80006056:	00 90       	ret 

80006058 <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
80006058:	02 4f       	mov %d15,%d4
8000605a:	6d ff ed ff 	call 80006034 <IfxScuCcu_getSourceFrequency>
8000605e:	91 30 00 ff 	movh.a %a15,61443
80006062:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006066:	48 03       	ld.w %d3,[%a15]0
80006068:	37 03 64 34 	extr.u %d3,%d3,8,4
8000606c:	4b 03 41 31 	itof %d3,%d3
80006070:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80006074:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80006078:	4b f2 41 20 	mul.f %d2,%d2,%d15
8000607c:	4b 02 71 21 	ftouz %d2,%d2
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80006080:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80006084:	a2 3f       	sub %d15,%d3
80006086:	3f 2f fd ff 	jlt.u %d15,%d2,80006080 <IfxScuCcu_wait+0x28>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
8000608a:	00 90       	ret 

8000608c <IfxScuCcu_getBbbFrequency>:
float32 IfxScuCcu_getBbbFrequency(void)
{
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
8000608c:	6d ff d4 ff 	call 80006034 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80006090:	91 30 00 ff 	movh.a %a15,61443
80006094:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006098:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0;
8000609a:	82 0f       	mov %d15,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000609c:	37 03 64 36 	extr.u %d3,%d3,12,4
800060a0:	ff 53 30 80 	jge.u %d3,5,80006100 <IfxScuCcu_getBbbFrequency+0x74>
800060a4:	91 00 00 f8 	movh.a %a15,32768
800060a8:	d9 ff 34 26 	lea %a15,[%a15]24756 <800060b4 <IfxScuCcu_getBbbFrequency+0x28>>
800060ac:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800060b0:	dc 0f       	ji %a15
800060b2:	00 00       	nop 
800060b4:	1d 00 0a 00 	j 800060c8 <IfxScuCcu_getBbbFrequency+0x3c>
800060b8:	1d 00 17 00 	j 800060e6 <IfxScuCcu_getBbbFrequency+0x5a>
800060bc:	1d 00 18 00 	j 800060ec <IfxScuCcu_getBbbFrequency+0x60>
800060c0:	1d 00 19 00 	j 800060f2 <IfxScuCcu_getBbbFrequency+0x66>
800060c4:	1d 00 1a 00 	j 800060f8 <IfxScuCcu_getBbbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
800060c8:	91 30 00 ff 	movh.a %a15,61443
800060cc:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
800060d0:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0;
800060d2:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
800060d4:	8f f3 00 31 	and %d3,%d3,15
800060d8:	df 03 14 00 	jeq %d3,0,80006100 <IfxScuCcu_getBbbFrequency+0x74>
        {
            bbbFrequency = 0.0;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
800060dc:	4c f0       	ld.w %d15,[%a15]0
800060de:	16 0f       	and %d15,15
800060e0:	4b 0f 41 f1 	itof %d15,%d15
800060e4:	3c 0c       	j 800060fc <IfxScuCcu_getBbbFrequency+0x70>
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
800060e6:	7b 00 1f f4 	movh %d15,16880
800060ea:	3c 09       	j 800060fc <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
800060ec:	7b 00 27 f4 	movh %d15,17008
800060f0:	3c 06       	j 800060fc <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
800060f2:	7b 00 2f f4 	movh %d15,17136
800060f6:	3c 03       	j 800060fc <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
800060f8:	7b 00 37 f4 	movh %d15,17264
800060fc:	4b f2 51 f0 	div.f %d15,%d2,%d15
        bbbFrequency = 0.0;
        break;
    }

    return bbbFrequency;
}
80006100:	02 f2       	mov %d2,%d15
80006102:	00 90       	ret 

80006104 <IfxScuCcu_getMaxFrequency>:
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006104:	91 30 00 ff 	movh.a %a15,61443
80006108:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>

float32 IfxScuCcu_getMaxFrequency(void)
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();
8000610c:	6d ff 94 ff 	call 80006034 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80006110:	4c f0       	ld.w %d15,[%a15]0
80006112:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80006116:	ff 5f 2d 80 	jge.u %d15,5,80006170 <IfxScuCcu_getMaxFrequency+0x6c>
8000611a:	91 00 00 f8 	movh.a %a15,32768
8000611e:	d9 ff 28 46 	lea %a15,[%a15]24872 <80006128 <IfxScuCcu_getMaxFrequency+0x24>>
80006122:	90 ff       	addsc.a %a15,%a15,%d15,2
80006124:	dc 0f       	ji %a15
80006126:	00 00       	nop 
80006128:	1d 00 0a 00 	j 8000613c <IfxScuCcu_getMaxFrequency+0x38>
8000612c:	1d 00 14 00 	j 80006154 <IfxScuCcu_getMaxFrequency+0x50>
80006130:	1d 00 15 00 	j 8000615a <IfxScuCcu_getMaxFrequency+0x56>
80006134:	1d 00 16 00 	j 80006160 <IfxScuCcu_getMaxFrequency+0x5c>
80006138:	1d 00 17 00 	j 80006166 <IfxScuCcu_getMaxFrequency+0x62>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
8000613c:	91 30 00 ff 	movh.a %a15,61443
80006140:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80006144:	4c f0       	ld.w %d15,[%a15]0
80006146:	16 0f       	and %d15,15
80006148:	6e 15       	jz %d15,80006172 <IfxScuCcu_getMaxFrequency+0x6e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
8000614a:	4c f0       	ld.w %d15,[%a15]0
8000614c:	16 0f       	and %d15,15
8000614e:	4b 0f 41 f1 	itof %d15,%d15
80006152:	3c 0c       	j 8000616a <IfxScuCcu_getMaxFrequency+0x66>
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80006154:	7b 00 17 f4 	movh %d15,16752
80006158:	3c 09       	j 8000616a <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
8000615a:	7b 00 1f f4 	movh %d15,16880
8000615e:	3c 06       	j 8000616a <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80006160:	7b 00 27 f4 	movh %d15,17008
80006164:	3c 03       	j 8000616a <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
80006166:	7b 00 2f f4 	movh %d15,17136
8000616a:	4b f2 51 20 	div.f %d2,%d2,%d15
        break;
8000616e:	00 90       	ret 
    default:
        maxFrequency = 0.0;
80006170:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
80006172:	00 90       	ret 

80006174 <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006174:	91 30 00 ff 	movh.a %a15,61443
80006178:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000617c:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
8000617e:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006180:	8f ff 00 81 	and %d8,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
80006184:	76 87       	jz %d8,80006192 <IfxScuCcu_getBaud1Frequency+0x1e>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
80006186:	6d ff bf ff 	call 80006104 <IfxScuCcu_getMaxFrequency>
8000618a:	4b 08 41 f1 	itof %d15,%d8
8000618e:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
80006192:	00 90       	ret 

80006194 <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006194:	91 30 00 ff 	movh.a %a15,61443
80006198:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000619c:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
8000619e:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061a0:	37 0f 64 82 	extr.u %d8,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
800061a4:	16 f0       	and %d15,240
800061a6:	6e 07       	jz %d15,800061b4 <IfxScuCcu_getBaud2Frequency+0x20>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
800061a8:	6d ff ae ff 	call 80006104 <IfxScuCcu_getMaxFrequency>
800061ac:	4b 08 41 f1 	itof %d15,%d8
800061b0:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
800061b4:	00 90       	ret 

800061b6 <IfxScuCcu_getSpbFrequency>:
float32 IfxScuCcu_getSpbFrequency(void)
{
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800061b6:	6d ff 3f ff 	call 80006034 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
800061ba:	91 30 00 ff 	movh.a %a15,61443
800061be:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061c2:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0;
800061c4:	82 0f       	mov %d15,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800061c6:	37 03 64 36 	extr.u %d3,%d3,12,4
800061ca:	ff 53 30 80 	jge.u %d3,5,8000622a <IfxScuCcu_getSpbFrequency+0x74>
800061ce:	91 00 00 f8 	movh.a %a15,32768
800061d2:	d9 ff 1c 76 	lea %a15,[%a15]25052 <800061dc <IfxScuCcu_getSpbFrequency+0x26>>
800061d6:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800061da:	dc 0f       	ji %a15
800061dc:	1d 00 0a 00 	j 800061f0 <IfxScuCcu_getSpbFrequency+0x3a>
800061e0:	1d 00 18 00 	j 80006210 <IfxScuCcu_getSpbFrequency+0x5a>
800061e4:	1d 00 19 00 	j 80006216 <IfxScuCcu_getSpbFrequency+0x60>
800061e8:	1d 00 1a 00 	j 8000621c <IfxScuCcu_getSpbFrequency+0x66>
800061ec:	1d 00 1b 00 	j 80006222 <IfxScuCcu_getSpbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800061f0:	91 30 00 ff 	movh.a %a15,61443
800061f4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061f8:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0;
800061fa:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800061fc:	37 03 64 38 	extr.u %d3,%d3,16,4
80006200:	df 03 15 00 	jeq %d3,0,8000622a <IfxScuCcu_getSpbFrequency+0x74>
        {
            spbFrequency = 0.0;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80006204:	4c f0       	ld.w %d15,[%a15]0
80006206:	37 0f 64 f8 	extr.u %d15,%d15,16,4
8000620a:	4b 0f 41 f1 	itof %d15,%d15
8000620e:	3c 0c       	j 80006226 <IfxScuCcu_getSpbFrequency+0x70>
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80006210:	7b 00 1f f4 	movh %d15,16880
80006214:	3c 09       	j 80006226 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
80006216:	7b 00 27 f4 	movh %d15,17008
8000621a:	3c 06       	j 80006226 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
8000621c:	7b 00 2f f4 	movh %d15,17136
80006220:	3c 03       	j 80006226 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
80006222:	7b 00 37 f4 	movh %d15,17264
80006226:	4b f2 51 f0 	div.f %d15,%d2,%d15
        spbFrequency = 0.0;
        break;
    }

    return spbFrequency;
}
8000622a:	02 f2       	mov %d2,%d15
8000622c:	00 90       	ret 

8000622e <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
8000622e:	91 30 00 ff 	movh.a %a15,61443
80006232:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
80006236:	48 09       	ld.w %d9,[%a15]0
    spbFreq = IfxScuCcu_getSpbFrequency();
80006238:	6d ff bf ff 	call 800061b6 <IfxScuCcu_getSpbFrequency>

    if (scuFdr.B.DM == 1)
8000623c:	bb 00 00 fc 	mov.u %d15,49152
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();
80006240:	02 23       	mov %d3,%d2

    if (scuFdr.B.DM == 1)
80006242:	26 9f       	and %d15,%d9
80006244:	3b 00 00 24 	mov %d2,16384
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
80006248:	b7 09 16 85 	insert %d8,%d9,0,10,22
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
8000624c:	7e 29       	jne %d15,%d2,8000625e <IfxScuCcu_getModuleFrequency+0x30>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
8000624e:	3b 00 40 20 	mov %d2,1024
80006252:	a2 82       	sub %d2,%d8
80006254:	4b 02 41 21 	itof %d2,%d2
80006258:	4b 23 51 20 	div.f %d2,%d3,%d2
8000625c:	00 90       	ret 
    }
    else if (scuFdr.B.DM == 2)
8000625e:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
80006262:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
80006264:	7e 49       	jne %d15,%d4,80006276 <IfxScuCcu_getModuleFrequency+0x48>
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
80006266:	4b 08 41 21 	itof %d2,%d8
8000626a:	7b 00 a8 f3 	movh %d15,14976
8000626e:	4b 23 41 20 	mul.f %d2,%d3,%d2
80006272:	4b f2 41 20 	mul.f %d2,%d2,%d15
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
80006276:	00 90       	ret 

80006278 <IfxScuCcu_getSriFrequency>:
float32 IfxScuCcu_getSriFrequency(void)
{
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006278:	6d ff de fe 	call 80006034 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
8000627c:	91 30 00 ff 	movh.a %a15,61443
80006280:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006284:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0;
80006286:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006288:	37 03 64 36 	extr.u %d3,%d3,12,4
8000628c:	ff 53 31 80 	jge.u %d3,5,800062ee <IfxScuCcu_getSriFrequency+0x76>
80006290:	91 00 00 f8 	movh.a %a15,32768
80006294:	d9 ff 20 a6 	lea %a15,[%a15]25248 <800062a0 <IfxScuCcu_getSriFrequency+0x28>>
80006298:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000629c:	dc 0f       	ji %a15
8000629e:	00 00       	nop 
800062a0:	1d 00 0a 00 	j 800062b4 <IfxScuCcu_getSriFrequency+0x3c>
800062a4:	1d 00 18 00 	j 800062d4 <IfxScuCcu_getSriFrequency+0x5c>
800062a8:	1d 00 19 00 	j 800062da <IfxScuCcu_getSriFrequency+0x62>
800062ac:	1d 00 1a 00 	j 800062e0 <IfxScuCcu_getSriFrequency+0x68>
800062b0:	1d 00 1b 00 	j 800062e6 <IfxScuCcu_getSriFrequency+0x6e>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800062b4:	91 30 00 ff 	movh.a %a15,61443
800062b8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800062bc:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0;
800062be:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800062c0:	37 03 64 34 	extr.u %d3,%d3,8,4
800062c4:	df 03 15 00 	jeq %d3,0,800062ee <IfxScuCcu_getSriFrequency+0x76>
        {
            sriFrequency = 0.0;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
800062c8:	4c f0       	ld.w %d15,[%a15]0
800062ca:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800062ce:	4b 0f 41 f1 	itof %d15,%d15
800062d2:	3c 0c       	j 800062ea <IfxScuCcu_getSriFrequency+0x72>
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
800062d4:	7b 00 1f f4 	movh %d15,16880
800062d8:	3c 09       	j 800062ea <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
800062da:	7b 00 27 f4 	movh %d15,17008
800062de:	3c 06       	j 800062ea <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
800062e0:	7b 00 2f f4 	movh %d15,17136
800062e4:	3c 03       	j 800062ea <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
800062e6:	7b 00 37 f4 	movh %d15,17264
800062ea:	4b f2 51 f0 	div.f %d15,%d2,%d15
        sriFrequency = 0.0;
        break;
    }

    return sriFrequency;
}
800062ee:	02 f2       	mov %d2,%d15
800062f0:	00 90       	ret 

800062f2 <IfxScuCcu_getCpuFrequency>:
    return bbbFrequency;
}


float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
800062f2:	02 4f       	mov %d15,%d4
    float32 frequency = IfxScuCcu_getSriFrequency();
800062f4:	6d ff c2 ff 	call 80006278 <IfxScuCcu_getSriFrequency>
    uint32  cpuDiv    = 0;

    switch (cpu)
800062f8:	1e 1d       	jeq %d15,1,80006312 <IfxScuCcu_getCpuFrequency+0x20>
800062fa:	6e 07       	jz %d15,80006308 <IfxScuCcu_getCpuFrequency+0x16>
800062fc:	de 2a       	jne %d15,2,80006330 <IfxScuCcu_getCpuFrequency+0x3e>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
800062fe:	91 30 00 ff 	movh.a %a15,61443
80006302:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80006306:	3c 0a       	j 8000631a <IfxScuCcu_getCpuFrequency+0x28>
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
80006308:	91 30 00 ff 	movh.a %a15,61443
8000630c:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006310:	3c 05       	j 8000631a <IfxScuCcu_getCpuFrequency+0x28>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
80006312:	91 30 00 ff 	movh.a %a15,61443
80006316:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
8000631a:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0;
        break;
    }

    if (cpuDiv != 0)
8000631c:	6e 0b       	jz %d15,80006332 <IfxScuCcu_getCpuFrequency+0x40>
    {
        frequency = frequency * (cpuDiv / 64.0f);
8000631e:	4b 0f 61 f1 	utof %d15,%d15
80006322:	7b 00 c8 33 	movh %d3,15488
80006326:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
8000632a:	4b f2 41 20 	mul.f %d2,%d2,%d15
8000632e:	00 90       	ret 
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0;
80006330:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
80006332:	00 90       	ret 

80006334 <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006334:	91 30 00 ff 	movh.a %a15,61443
80006338:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000633c:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
8000633e:	7b 00 03 30 	movh %d3,48
80006342:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006344:	37 0f 62 8a 	extr.u %d8,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
80006348:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
8000634a:	76 3f       	jz %d3,80006368 <IfxScuCcu_getFsi2Frequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
8000634c:	6d ff 96 ff 	call 80006278 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
80006350:	3b 00 f0 30 	mov %d3,3840
80006354:	26 3f       	and %d15,%d3
80006356:	1b 0f f0 ff 	addi %d15,%d15,-256
8000635a:	8f 0f d0 f1 	andn %d15,%d15,256
8000635e:	ee 05       	jnz %d15,80006368 <IfxScuCcu_getFsi2Frequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
80006360:	4b 08 41 f1 	itof %d15,%d8
80006364:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
80006368:	00 90       	ret 

8000636a <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000636a:	91 30 00 ff 	movh.a %a15,61443
8000636e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006372:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
80006374:	7b 00 30 30 	movh %d3,768
80006378:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000637a:	37 0f 62 8c 	extr.u %d8,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
8000637e:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
80006380:	76 3f       	jz %d3,8000639e <IfxScuCcu_getFsiFrequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
80006382:	6d ff 7b ff 	call 80006278 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
80006386:	3b 00 f0 30 	mov %d3,3840
8000638a:	26 3f       	and %d15,%d3
8000638c:	1b 0f f0 ff 	addi %d15,%d15,-256
80006390:	8f 0f d0 f1 	andn %d15,%d15,256
80006394:	ee 05       	jnz %d15,8000639e <IfxScuCcu_getFsiFrequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
80006396:	4b 08 41 f1 	itof %d15,%d8
8000639a:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
8000639e:	00 90       	ret 

800063a0 <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800063a0:	19 4f 10 10 	ld.w %d15,[%a4]80
800063a4:	91 00 00 c7 	movh.a %a12,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
800063a8:	40 4f       	mov.aa %a15,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800063aa:	59 cf 30 30 	st.w [%a12]240 <700000f0 <IfxScuCcu_xtalFrequency>>,%d15

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
800063ae:	6d 00 c8 07 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
800063b2:	02 29       	mov %d9,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
800063b4:	6d 00 e3 07 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800063b8:	02 94       	mov %d4,%d9
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
800063ba:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800063bc:	6d 00 c1 06 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800063c0:	91 30 00 2f 	movh.a %a2,61443
800063c4:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800063c8:	54 2c       	ld.w %d12,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;
800063ca:	4c 20       	ld.w %d15,[%a2]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800063cc:	02 94       	mov %d4,%d9

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800063ce:	96 08       	or %d15,8
800063d0:	6c 20       	st.w [%a2]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
800063d2:	6d 00 eb 07 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800063d6:	02 84       	mov %d4,%d8
800063d8:	6d 00 ce 06 	call 80007174 <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800063dc:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
800063e0:	91 30 00 3f 	movh.a %a3,61443
800063e4:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063e8:	4c 30       	ld.w %d15,[%a3]0
800063ea:	91 30 00 2f 	movh.a %a2,61443
800063ee:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063f2:	bf 0f fb 7f 	jlt %d15,0,800063e8 <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800063f6:	4c 20       	ld.w %d15,[%a2]0
800063f8:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
800063fc:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
800063fe:	4c 20       	ld.w %d15,[%a2]0
80006400:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006404:	6c 20       	st.w [%a2]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006406:	91 30 00 2f 	movh.a %a2,61443
8000640a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000640e:	4c 20       	ld.w %d15,[%a2]0
80006410:	96 10       	or %d15,16
80006412:	6c 20       	st.w [%a2]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON0.B.LCK != 0U)
80006414:	91 30 00 2f 	movh.a %a2,61443
80006418:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000641c:	4c 20       	ld.w %d15,[%a2]0
8000641e:	bf 0f ff 7f 	jlt %d15,0,8000641c <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80006422:	91 30 00 2f 	movh.a %a2,61443
80006426:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000642a:	4c 20       	ld.w %d15,[%a2]0
8000642c:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
80006430:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
80006432:	4c 20       	ld.w %d15,[%a2]0
80006434:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006438:	6c 20       	st.w [%a2]0,%d15
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
8000643a:	6d 00 82 07 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
8000643e:	91 30 00 2f 	movh.a %a2,61443
80006442:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
80006446:	02 2f       	mov %d15,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80006448:	54 22       	ld.w %d2,[%a2]

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
8000644a:	40 23       	mov.aa %a3,%a2
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
8000644c:	8f 02 c6 21 	andn %d2,%d2,96
80006450:	74 22       	st.w [%a2],%d2

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80006452:	19 c6 30 30 	ld.w %d6,[%a12]240 <700000f0 <IfxScuCcu_xtalFrequency>>
80006456:	7b 60 02 20 	movh %d2,38
8000645a:	1b 02 5a 22 	addi %d2,%d2,9632
8000645e:	4b 26 11 62 	div.u %e6,%d6,%d2
80006462:	54 22       	ld.w %d2,[%a2]
80006464:	c2 f6       	add %d6,-1
80006466:	37 62 05 68 	insert %d6,%d2,%d6,16,5
8000646a:	74 26       	st.w [%a2],%d6

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
8000646c:	54 22       	ld.w %d2,[%a2]
8000646e:	8f 42 40 21 	or %d2,%d2,4
80006472:	74 22       	st.w [%a2],%d2

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80006474:	c5 02 3f 90 	lea %a2,27f <_.+0x27e>
80006478:	54 32       	ld.w %d2,[%a3]
8000647a:	6f 12 05 80 	jnz.t %d2,1,80006484 <IfxScuCcu_init+0xe4>
8000647e:	fc 2d       	loop %a2,80006478 <IfxScuCcu_init+0xd8>
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
80006480:	82 1b       	mov %d11,1
80006482:	3c 05       	j 8000648c <IfxScuCcu_init+0xec>

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80006484:	54 32       	ld.w %d2,[%a3]
80006486:	6f 82 fc 7f 	jz.t %d2,8,8000647e <IfxScuCcu_init+0xde>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
8000648a:	82 0b       	mov %d11,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
8000648c:	02 f4       	mov %d4,%d15
8000648e:	6d 00 58 06 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80006492:	91 30 00 2f 	movh.a %a2,61443
80006496:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
8000649a:	54 22       	ld.w %d2,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
8000649c:	02 f4       	mov %d4,%d15
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000649e:	8f 82 40 21 	or %d2,%d2,8
800064a2:	74 22       	st.w [%a2],%d2
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800064a4:	91 30 00 2f 	movh.a %a2,61443
800064a8:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800064ac:	54 22       	ld.w %d2,[%a2]
800064ae:	8f 82 40 21 	or %d2,%d2,8
800064b2:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinitPw);
800064b4:	6d 00 7a 07 	call 800073a8 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800064b8:	02 84       	mov %d4,%d8
800064ba:	6d 00 e3 07 	call 80007480 <IfxScuWdt_setSafetyEndinit>
    }

    if (status == 0)
800064be:	df 0b 29 81 	jne %d11,0,80006710 <IfxScuCcu_init+0x370>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800064c2:	02 84       	mov %d4,%d8
800064c4:	6d 00 58 06 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
800064c8:	91 30 00 2f 	movh.a %a2,61443
800064cc:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800064d0:	4c 20       	ld.w %d15,[%a2]0
800064d2:	6f 5f ff 7f 	jz.t %d15,5,800064d0 <IfxScuCcu_init+0x130>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800064d6:	91 30 00 2f 	movh.a %a2,61443
800064da:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
800064de:	54 22       	ld.w %d2,[%a2]
800064e0:	0c fa       	ld.bu %d15,[%a15]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800064e2:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800064e6:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800064ea:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800064ee:	6c 20       	st.w [%a2]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
800064f0:	91 30 00 2f 	movh.a %a2,61443
800064f4:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800064f8:	54 22       	ld.w %d2,[%a2]
800064fa:	0c f8       	ld.bu %d15,[%a15]8
800064fc:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80006500:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80006502:	54 22       	ld.w %d2,[%a2]
80006504:	0c f9       	ld.bu %d15,[%a15]9
80006506:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
8000650a:	6c 20       	st.w [%a2]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
8000650c:	4c 20       	ld.w %d15,[%a2]0
8000650e:	96 40       	or %d15,64
80006510:	6c 20       	st.w [%a2]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
80006512:	4c 20       	ld.w %d15,[%a2]0
80006514:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80006518:	6c 20       	st.w [%a2]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
8000651a:	4c 20       	ld.w %d15,[%a2]0
8000651c:	96 20       	or %d15,32
8000651e:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
80006520:	4c 20       	ld.w %d15,[%a2]0
80006522:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80006526:	6c 20       	st.w [%a2]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
80006528:	4c 20       	ld.w %d15,[%a2]0
8000652a:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
8000652e:	6c 20       	st.w [%a2]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006530:	6d ff 94 fd 	call 80006058 <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
80006534:	91 30 00 2f 	movh.a %a2,61443
80006538:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000653c:	4c 20       	ld.w %d15,[%a2]0
8000653e:	6f 2f ff 7f 	jz.t %d15,2,8000653c <IfxScuCcu_init+0x19c>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
80006542:	91 30 00 2f 	movh.a %a2,61443
80006546:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000654a:	4c 20       	ld.w %d15,[%a2]0

                    while (SCU_CCUCON0.B.LCK != 0U)
8000654c:	91 30 00 3f 	movh.a %a3,61443
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
80006550:	8f 1f c0 f1 	andn %d15,%d15,1
80006554:	6c 20       	st.w [%a2]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
80006556:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000655a:	4c 30       	ld.w %d15,[%a3]0
8000655c:	91 30 00 2f 	movh.a %a2,61443
80006560:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006564:	bf 0f fb 7f 	jlt %d15,0,8000655a <IfxScuCcu_init+0x1ba>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
80006568:	4c 20       	ld.w %d15,[%a2]0
8000656a:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
8000656e:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
80006570:	4c 20       	ld.w %d15,[%a2]0
80006572:	91 30 00 cf 	movh.a %a12,61443
80006576:	d9 cc 30 06 	lea %a12,[%a12]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000657a:	bf 0f fb 7f 	jlt %d15,0,80006570 <IfxScuCcu_init+0x1d0>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
8000657e:	48 34       	ld.w %d4,[%a15]12
80006580:	6d ff 6c fd 	call 80006058 <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80006584:	4c f5       	ld.w %d15,[%a15]20
80006586:	54 c3       	ld.w %d3,[%a12]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80006588:	48 42       	ld.w %d2,[%a15]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
8000658a:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
8000658e:	26 f2       	and %d2,%d15
80006590:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
80006594:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
80006598:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
8000659c:	91 30 00 3f 	movh.a %a3,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
800065a0:	6c c0       	st.w [%a12]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800065a2:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800065a6:	4c 30       	ld.w %d15,[%a3]0
800065a8:	91 30 00 2f 	movh.a %a2,61443
800065ac:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800065b0:	bf 0f fb 7f 	jlt %d15,0,800065a6 <IfxScuCcu_init+0x206>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
800065b4:	4c f7       	ld.w %d15,[%a15]28
800065b6:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
800065b8:	48 62       	ld.w %d2,[%a15]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
800065ba:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
800065be:	26 f2       	and %d2,%d15
800065c0:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon1.B.INSEL = 1;
800065c4:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
800065c8:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
800065cc:	91 30 00 3f 	movh.a %a3,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
800065d0:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
800065d2:	d9 33 00 16 	lea %a3,[%a3]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
800065d6:	4c 30       	ld.w %d15,[%a3]0
800065d8:	91 30 00 2f 	movh.a %a2,61443
800065dc:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
800065e0:	bf 0f fb 7f 	jlt %d15,0,800065d6 <IfxScuCcu_init+0x236>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
800065e4:	4c f9       	ld.w %d15,[%a15]36
800065e6:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
800065e8:	48 82       	ld.w %d2,[%a15]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
800065ea:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
800065ee:	26 f2       	and %d2,%d15
800065f0:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon2.B.UP = 1;
800065f4:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
800065f8:	91 30 00 3f 	movh.a %a3,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
800065fc:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
800065fe:	d9 33 0c 16 	lea %a3,[%a3]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80006602:	4c 30       	ld.w %d15,[%a3]0
80006604:	91 30 00 2f 	movh.a %a2,61443
80006608:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
8000660c:	bf 0f fb 7f 	jlt %d15,0,80006602 <IfxScuCcu_init+0x262>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80006610:	54 23       	ld.w %d3,[%a2]
80006612:	4c fb       	ld.w %d15,[%a15]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80006614:	48 a2       	ld.w %d2,[%a15]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80006616:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000661a:	26 f2       	and %d2,%d15
8000661c:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon5.B.UP = 1;
80006620:	b7 1f 01 ff 	insert %d15,%d15,1,30,1

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80006624:	48 c2       	ld.w %d2,[%a15]48
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
80006626:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80006628:	91 30 00 2f 	movh.a %a2,61443
8000662c:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006630:	54 23       	ld.w %d3,[%a2]
80006632:	4c fd       	ld.w %d15,[%a15]52
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
                        SCU_CCUCON8 = ccucon8;
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006634:	02 84       	mov %d4,%d8
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80006636:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
8000663a:	26 f2       	and %d2,%d15
8000663c:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON6 = ccucon6;
80006640:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80006642:	91 30 00 2f 	movh.a %a2,61443
80006646:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
8000664a:	54 23       	ld.w %d3,[%a2]
8000664c:	4c ff       	ld.w %d15,[%a15]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
8000664e:	48 e2       	ld.w %d2,[%a15]56
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80006650:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
80006654:	26 f2       	and %d2,%d15
80006656:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON7 = ccucon7;
8000665a:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
8000665c:	91 30 00 2f 	movh.a %a2,61443
80006660:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80006664:	54 23       	ld.w %d3,[%a2]
80006666:	19 ff 04 10 	ld.w %d15,[%a15]68 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
8000666a:	19 f2 00 10 	ld.w %d2,[%a15]64 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
8000666e:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
80006672:	26 f2       	and %d2,%d15
80006674:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON8 = ccucon8;
80006678:	6c 20       	st.w [%a2]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000667a:	6d 00 03 07 	call 80007480 <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
8000667e:	91 00 80 cf 	movh.a %a12,63488
80006682:	d9 cc 14 02 	lea %a12,[%a12]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
80006686:	19 ff 0c 10 	ld.w %d15,[%a15]76 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
8000668a:	54 c3       	ld.w %d3,[%a12]

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
8000668c:	19 f2 08 10 	ld.w %d2,[%a15]72 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
80006690:	0f f3 e0 30 	andn %d3,%d3,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006694:	26 f2       	and %d2,%d15
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80006696:	02 94       	mov %d4,%d9
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006698:	0f 23 a0 f0 	or %d15,%d3,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
8000669c:	6d 00 51 05 	call 8000713e <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
800066a0:	6c c0       	st.w [%a12]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
800066a2:	02 94       	mov %d4,%d9
800066a4:	6d 00 82 06 	call 800073a8 <IfxScuWdt_setCpuEndinit>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800066a8:	91 30 00 df 	movh.a %a13,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800066ac:	91 30 00 cf 	movh.a %a12,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800066b0:	82 0d       	mov %d13,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800066b2:	d9 dd 14 06 	lea %a13,[%a13]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800066b6:	d9 cc 1c 06 	lea %a12,[%a12]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800066ba:	0c f0       	ld.bu %d15,[%a15]0
800066bc:	8f fd 0f 21 	and %d2,%d13,255
800066c0:	7f f2 28 80 	jge.u %d2,%d15,80006710 <IfxScuCcu_init+0x370>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800066c4:	02 84       	mov %d4,%d8
800066c6:	6d 00 57 05 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800066ca:	4c d0       	ld.w %d15,[%a13]0
800066cc:	6f 5f ff 7f 	jz.t %d15,5,800066ca <IfxScuCcu_init+0x32a>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800066d0:	02 df       	mov %d15,%d13
800066d2:	16 ff       	and %d15,255
800066d4:	53 cf 20 a0 	mul %d10,%d15,12
800066d8:	c8 12       	ld.a %a2,[%a15]4
800066da:	4c c0       	ld.w %d15,[%a12]0
800066dc:	60 a3       	mov.a %a3,%d10
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066de:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800066e0:	30 32       	add.a %a2,%a3
800066e2:	14 22       	ld.bu %d2,[%a2]
800066e4:	37 2f 07 20 	insert %d2,%d15,%d2,0,7
800066e8:	74 c2       	st.w [%a12],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066ea:	6d 00 cb 06 	call 80007480 <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
800066ee:	c8 12       	ld.a %a2,[%a15]4
800066f0:	60 a3       	mov.a %a3,%d10
800066f2:	30 32       	add.a %a2,%a3
800066f4:	99 22 08 00 	ld.a %a2,[%a2]8
800066f8:	bc 23       	jz.a %a2,800066fe <IfxScuCcu_init+0x35e>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
800066fa:	2d 02 00 00 	calli %a2
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
800066fe:	c8 12       	ld.a %a2,[%a15]4
80006700:	60 a3       	mov.a %a3,%d10
80006702:	c2 1d       	add %d13,1
80006704:	30 32       	add.a %a2,%a3
80006706:	19 24 04 00 	ld.w %d4,[%a2]4
8000670a:	6d ff a7 fc 	call 80006058 <IfxScuCcu_wait>
8000670e:	3c d6       	j 800066ba <IfxScuCcu_init+0x31a>
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006710:	02 84       	mov %d4,%d8
80006712:	6d 00 31 05 	call 80007174 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006716:	91 30 00 ff 	movh.a %a15,61443
8000671a:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000671e:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006720:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006722:	8f 0f c4 f1 	andn %d15,%d15,64
80006726:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006728:	6d 00 ac 06 	call 80007480 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000672c:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006730:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;
80006732:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006736:	6d 00 04 05 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
8000673a:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000673c:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000673e:	96 08       	or %d15,8
80006740:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006742:	91 30 00 ff 	movh.a %a15,61443
80006746:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000674a:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000674c:	02 94       	mov %d4,%d9
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000674e:	8f 8f c0 f1 	andn %d15,%d15,8
80006752:	a6 fc       	or %d12,%d15
80006754:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006756:	6d 00 29 06 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
8000675a:	02 b2       	mov %d2,%d11
8000675c:	00 90       	ret 

8000675e <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
8000675e:	91 00 00 f8 	movh.a %a15,32768
80006762:	d9 ff a4 90 	lea %a15,[%a15]2660 <80000a64 <IfxScuCcu_defaultClockConfig>>
80006766:	c5 02 14 00 	lea %a2,14 <_.+0x13>
8000676a:	44 ff       	ld.w %d15,[%a15+]
8000676c:	64 4f       	st.w [%a4+],%d15
8000676e:	fc 2e       	loop %a2,8000676a <IfxScuCcu_initConfig+0xc>
80006770:	00 90       	ret 

80006772 <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
80006772:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006774:	6d 00 e5 05 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
80006778:	02 2f       	mov %d15,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000677a:	6d 00 00 06 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000677e:	02 f4       	mov %d4,%d15
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006780:	02 28       	mov %d8,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006782:	6d 00 de 04 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006786:	91 30 00 ff 	movh.a %a15,61443
8000678a:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000678e:	48 03       	ld.w %d3,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006790:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006792:	02 f4       	mov %d4,%d15
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006794:	8f 82 40 21 	or %d2,%d2,8
80006798:	68 02       	st.w [%a15]0,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
8000679a:	37 03 e1 a1 	extr.u %d10,%d3,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000679e:	6d 00 05 06 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800067a2:	02 84       	mov %d4,%d8
800067a4:	6d 00 e8 04 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800067a8:	91 30 00 ff 	movh.a %a15,61443
800067ac:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800067b0:	48 02       	ld.w %d2,[%a15]0
800067b2:	ef 02 0c 00 	jz.t %d2,16,800067ca <IfxScuCcu_initErayPll+0x58>
800067b6:	48 02       	ld.w %d2,[%a15]0
800067b8:	6f 12 09 80 	jnz.t %d2,1,800067ca <IfxScuCcu_initErayPll+0x58>
800067bc:	91 30 00 ff 	movh.a %a15,61443
800067c0:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800067c4:	48 02       	ld.w %d2,[%a15]0
800067c6:	6f 12 19 00 	jz.t %d2,1,800067f8 <IfxScuCcu_initErayPll+0x86>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
800067ca:	91 30 00 ff 	movh.a %a15,61443
800067ce:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800067d2:	48 02       	ld.w %d2,[%a15]0
800067d4:	b7 f2 01 28 	insert %d2,%d2,15,16,1
800067d8:	68 02       	st.w [%a15]0,%d2
        SCU_PLLERAYCON0.B.VCOPWD = 0;
800067da:	48 02       	ld.w %d2,[%a15]0
800067dc:	8f 22 c0 21 	andn %d2,%d2,2
800067e0:	68 02       	st.w [%a15]0,%d2

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
800067e2:	91 30 00 ff 	movh.a %a15,61443
800067e6:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800067ea:	48 02       	ld.w %d2,[%a15]0
800067ec:	6f 12 ff ff 	jnz.t %d2,1,800067ea <IfxScuCcu_initErayPll+0x78>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
800067f0:	19 c4 04 00 	ld.w %d4,[%a12]4
800067f4:	6d ff 32 fc 	call 80006058 <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
800067f8:	91 30 00 ff 	movh.a %a15,61443
800067fc:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006800:	48 02       	ld.w %d2,[%a15]0
80006802:	6f 02 15 80 	jnz.t %d2,0,8000682c <IfxScuCcu_initErayPll+0xba>
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
80006806:	48 02       	ld.w %d2,[%a15]0
80006808:	6f 42 ff 7f 	jz.t %d2,4,80006806 <IfxScuCcu_initErayPll+0x94>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
8000680c:	91 30 00 ff 	movh.a %a15,61443
80006810:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006814:	48 02       	ld.w %d2,[%a15]0
80006816:	b7 32 07 28 	insert %d2,%d2,3,16,7
8000681a:	68 02       	st.w [%a15]0,%d2

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
8000681c:	91 30 00 ff 	movh.a %a15,61443
80006820:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006824:	48 02       	ld.w %d2,[%a15]0
80006826:	8f 12 40 21 	or %d2,%d2,1
8000682a:	68 02       	st.w [%a15]0,%d2
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
8000682c:	91 30 00 ff 	movh.a %a15,61443
80006830:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006834:	48 02       	ld.w %d2,[%a15]0
80006836:	6f 52 ff 7f 	jz.t %d2,5,80006834 <IfxScuCcu_initErayPll+0xc2>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
8000683a:	91 30 00 ff 	movh.a %a15,61443
8000683e:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006842:	48 03       	ld.w %d3,[%a15]0
80006844:	39 c2 02 00 	ld.bu %d2,[%a12]2 <f0030000 <_SMALL_DATA4_+0x40028000>>
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006848:	02 84       	mov %d4,%d8
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
8000684a:	37 23 07 20 	insert %d2,%d3,%d2,0,7
8000684e:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
80006850:	91 30 00 ff 	movh.a %a15,61443
80006854:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006858:	48 03       	ld.w %d3,[%a15]0
8000685a:	14 c2       	ld.bu %d2,[%a12]
8000685c:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
80006860:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
80006862:	48 03       	ld.w %d3,[%a15]0
80006864:	39 c2 01 00 	ld.bu %d2,[%a12]1
80006868:	37 23 85 24 	insert %d2,%d3,%d2,9,5
8000686c:	68 02       	st.w [%a15]0,%d2
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
8000686e:	48 02       	ld.w %d2,[%a15]0
80006870:	b7 f2 01 29 	insert %d2,%d2,15,18,1
80006874:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
80006876:	48 02       	ld.w %d2,[%a15]0
80006878:	8f 02 42 21 	or %d2,%d2,32
8000687c:	68 02       	st.w [%a15]0,%d2

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000687e:	6d 00 01 06 	call 80007480 <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
80006882:	91 10 00 f0 	movh.a %a15,1
80006886:	91 30 00 2f 	movh.a %a2,61443
8000688a:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000688e:	d9 ff 0f dc 	lea %a15,[%a15]-15537 <c34f <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4f>>
80006892:	fd f0 04 00 	loop %a15,8000689a <IfxScuCcu_initErayPll+0x128>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
80006896:	82 19       	mov %d9,1
80006898:	3c 05       	j 800068a2 <IfxScuCcu_initErayPll+0x130>
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
8000689a:	54 22       	ld.w %d2,[%a2]
8000689c:	6f 22 fb 7f 	jz.t %d2,2,80006892 <IfxScuCcu_initErayPll+0x120>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
800068a0:	82 09       	mov %d9,0
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800068a2:	02 84       	mov %d4,%d8
800068a4:	6d 00 68 04 	call 80007174 <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
800068a8:	91 30 00 ff 	movh.a %a15,61443
800068ac:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800068b0:	48 02       	ld.w %d2,[%a15]0
800068b2:	8f 12 c0 21 	andn %d2,%d2,1
800068b6:	68 02       	st.w [%a15]0,%d2

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
800068b8:	91 30 00 ff 	movh.a %a15,61443
800068bc:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800068c0:	48 02       	ld.w %d2,[%a15]0
800068c2:	6f 02 ff ff 	jnz.t %d2,0,800068c0 <IfxScuCcu_initErayPll+0x14e>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
800068c6:	91 30 00 ff 	movh.a %a15,61443
800068ca:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800068ce:	48 02       	ld.w %d2,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800068d0:	02 84       	mov %d4,%d8

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
800068d2:	37 02 61 21 	extr.u %d2,%d2,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800068d6:	91 30 00 ff 	movh.a %a15,61443
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
800068da:	ab 19 80 92 	sel %d9,%d2,%d9,1
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800068de:	6d 00 d1 05 	call 80007480 <IfxScuWdt_setSafetyEndinit>

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800068e2:	02 f4       	mov %d4,%d15
800068e4:	6d 00 2d 04 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
800068e8:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
800068ec:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800068ee:	8f 3a 00 30 	sh %d3,%d10,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800068f2:	8f 82 40 21 	or %d2,%d2,8
800068f6:	68 02       	st.w [%a15]0,%d2
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800068f8:	91 30 00 ff 	movh.a %a15,61443
800068fc:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006900:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006902:	02 f4       	mov %d4,%d15
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006904:	8f 82 c0 21 	andn %d2,%d2,8
80006908:	a6 32       	or %d2,%d3
8000690a:	68 02       	st.w [%a15]0,%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000690c:	6d 00 4e 05 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80006910:	02 92       	mov %d2,%d9
80006912:	00 90       	ret 

80006914 <IfxScuCcu_initErayPllConfig>:


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
80006914:	91 00 00 f8 	movh.a %a15,32768
80006918:	d9 ff 9c 90 	lea %a15,[%a15]2652 <80000a5c <IfxScuCcu_defaultErayPllConfig>>
8000691c:	09 f2 40 09 	ld.d %e2,[%a15]
80006920:	89 42 40 09 	st.d [%a4],%e2
80006924:	00 90       	ret 

80006926 <IfxScuCcu_setCpuFrequency>:
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
80006926:	02 5a       	mov %d10,%d5
80006928:	02 49       	mov %d9,%d4
    uint16  endinitSfty_pw;
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();
8000692a:	6d ff a7 fc 	call 80006278 <IfxScuCcu_getSriFrequency>
8000692e:	02 2f       	mov %d15,%d2

    if (cpuFreq >= sriFreq)
80006930:	4b 2a 01 20 	cmp.f %d2,%d10,%d2
80006934:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
    {
        cpuDiv = 0;
80006938:	82 08       	mov %d8,0
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
8000693a:	f6 29       	jnz %d2,8000694c <IfxScuCcu_setCpuFrequency+0x26>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
8000693c:	7b 00 28 84 	movh %d8,17024
80006940:	4b 8a 41 80 	mul.f %d8,%d10,%d8
80006944:	4b f8 51 80 	div.f %d8,%d8,%d15
80006948:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000694c:	6d 00 17 05 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006950:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006952:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006954:	6d 00 10 04 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
80006958:	df 19 0f 00 	jeq %d9,1,80006976 <IfxScuCcu_setCpuFrequency+0x50>
8000695c:	76 98       	jz %d9,8000696c <IfxScuCcu_setCpuFrequency+0x46>
8000695e:	df 29 11 80 	jne %d9,2,80006980 <IfxScuCcu_setCpuFrequency+0x5a>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
80006962:	91 30 00 ff 	movh.a %a15,61443
80006966:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
8000696a:	3c 0a       	j 8000697e <IfxScuCcu_setCpuFrequency+0x58>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
8000696c:	91 30 00 ff 	movh.a %a15,61443
80006970:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006974:	3c 05       	j 8000697e <IfxScuCcu_setCpuFrequency+0x58>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
80006976:	91 30 00 ff 	movh.a %a15,61443
8000697a:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
8000697e:	68 08       	st.w [%a15]0,%d8

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006980:	02 a4       	mov %d4,%d10
80006982:	6d 00 7f 05 	call 80007480 <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
80006986:	76 89       	jz %d8,80006998 <IfxScuCcu_setCpuFrequency+0x72>
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
80006988:	4b 08 61 81 	utof %d8,%d8
8000698c:	7b 00 c8 23 	movh %d2,15488
80006990:	4b 28 41 80 	mul.f %d8,%d8,%d2
80006994:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
80006998:	02 f2       	mov %d2,%d15
8000699a:	00 90       	ret 

8000699c <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
8000699c:	91 30 00 ff 	movh.a %a15,61443
800069a0:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
    return sriFreq;
}


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
800069a4:	02 48       	mov %d8,%d4
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
800069a6:	4c f0       	ld.w %d15,[%a15]0

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
800069a8:	6d ff 46 fb 	call 80006034 <IfxScuCcu_getSourceFrequency>
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
800069ac:	4b 82 51 20 	div.f %d2,%d2,%d8
800069b0:	4b 02 31 31 	ftoiz %d3,%d2
800069b4:	4b 03 41 41 	itof %d4,%d3
800069b8:	6b 04 31 22 	sub.f %d2,%d2,%d4
800069bc:	7b 00 f0 43 	movh %d4,16128
800069c0:	4b 42 01 20 	cmp.f %d2,%d2,%d4
800069c4:	37 02 61 21 	extr.u %d2,%d2,2,1
800069c8:	42 32       	add %d2,%d3
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800069ca:	82 13       	mov %d3,1
800069cc:	0b 32 b0 21 	max.u %d2,%d2,%d3
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
800069d0:	8b e2 00 52 	eq %d5,%d2,14
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
800069d4:	1b 92 ff 4f 	addi %d4,%d2,-7
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
    {
        gtmDiv = 12;
800069d8:	ab c2 a0 95 	seln %d9,%d5,%d2,12
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
800069dc:	8f 12 c0 31 	andn %d3,%d2,1
800069e0:	02 92       	mov %d2,%d9
800069e2:	8b 74 a0 92 	ge.u %d9,%d4,7
800069e6:	2b 32 40 99 	sel %d9,%d9,%d2,%d3
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
800069ea:	6d 00 c8 04 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
800069ee:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
800069f0:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
800069f2:	6d 00 c1 03 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
800069f6:	40 f2       	mov.aa %a2,%a15
800069f8:	54 22       	ld.w %d2,[%a2]
800069fa:	91 30 00 ff 	movh.a %a15,61443
800069fe:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006a02:	bf 02 fb 7f 	jlt %d2,0,800069f8 <IfxScuCcu_setGtmFrequency+0x5c>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
80006a06:	37 9f 04 f6 	insert %d15,%d15,%d9,12,4
    ccucon1.B.UP     = 1U;
80006a0a:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a0e:	02 84       	mov %d4,%d8
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
80006a10:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a12:	6d 00 37 05 	call 80007480 <IfxScuWdt_setSafetyEndinit>
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
80006a16:	6d ff 0f fb 	call 80006034 <IfxScuCcu_getSourceFrequency>
80006a1a:	4c f0       	ld.w %d15,[%a15]0
80006a1c:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80006a20:	4b 0f 41 f1 	itof %d15,%d15

    return IfxScuCcu_getGtmFrequency();
}
80006a24:	4b f2 51 20 	div.f %d2,%d2,%d15
80006a28:	00 90       	ret 

80006a2a <IfxScuCcu_setPll2ErayFrequency>:


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
80006a2a:	02 48       	mov %d8,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80006a2c:	6d 00 a7 04 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
80006a30:	02 2f       	mov %d15,%d2
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006a32:	6d ff 84 fa 	call 80005f3a <IfxScuCcu_getPllErayVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(password);
80006a36:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006a38:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(password);
80006a3a:	6d 00 9d 03 	call 80007174 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006a3e:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80006a42:	91 30 00 ff 	movh.a %a15,61443
80006a46:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006a4a:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006a4c:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
80006a50:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006a52:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006a56:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80006a5a:	37 82 04 84 	insert %d8,%d2,%d8,8,4
80006a5e:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(password);
80006a60:	6d 00 10 05 	call 80007480 <IfxScuWdt_setSafetyEndinit>

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
80006a64:	6d ff 6b fa 	call 80005f3a <IfxScuCcu_getPllErayVcoFrequency>
80006a68:	4c f0       	ld.w %d15,[%a15]0
80006a6a:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80006a6e:	c2 1f       	add %d15,1
80006a70:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
80006a74:	4b f2 51 20 	div.f %d2,%d2,%d15
80006a78:	00 90       	ret 

80006a7a <IfxScuCcu_setPll2Frequency>:


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
80006a7a:	02 48       	mov %d8,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006a7c:	6d 00 7f 04 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
80006a80:	02 2f       	mov %d15,%d2
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a82:	6d ff b7 fa 	call 80005ff0 <IfxScuCcu_getPllVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006a86:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a88:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006a8a:	6d 00 75 03 	call 80007174 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a8e:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006a92:	91 30 00 ff 	movh.a %a15,61443
80006a96:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80006a9a:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a9c:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006aa0:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006aa2:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006aa6:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006aaa:	37 82 07 84 	insert %d8,%d2,%d8,8,7
80006aae:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006ab0:	6d 00 e8 04 	call 80007480 <IfxScuWdt_setSafetyEndinit>


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80006ab4:	6d ff 9e fa 	call 80005ff0 <IfxScuCcu_getPllVcoFrequency>
80006ab8:	4c f0       	ld.w %d15,[%a15]0
80006aba:	37 0f 67 f4 	extr.u %d15,%d15,8,7
80006abe:	c2 1f       	add %d15,1
80006ac0:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2Frequency();
}
80006ac4:	4b f2 51 20 	div.f %d2,%d2,%d15
80006ac8:	00 90       	ret 

80006aca <IfxScuCcu_setSpbFrequency>:


float32 IfxScuCcu_setSpbFrequency(float32 spbFreq)
{
80006aca:	02 4f       	mov %d15,%d4
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006acc:	6d ff b4 fa 	call 80006034 <IfxScuCcu_getSourceFrequency>
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80006ad0:	4b f2 51 20 	div.f %d2,%d2,%d15
80006ad4:	82 24       	mov %d4,2
80006ad6:	4b 02 71 21 	ftouz %d2,%d2
80006ada:	0b 42 b0 41 	max.u %d4,%d2,%d4
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
80006ade:	8b e4 00 32 	eq %d3,%d4,14
    {
        spbDiv = 12;
80006ae2:	ab c4 a0 a3 	seln %d10,%d3,%d4,12
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
80006ae6:	1b 94 ff 2f 	addi %d2,%d4,-7
    {
        spbDiv = spbDiv - 1;
80006aea:	8f 14 c0 f1 	andn %d15,%d4,1
80006aee:	02 a4       	mov %d4,%d10
80006af0:	8b 72 a0 a2 	ge.u %d10,%d2,7
80006af4:	2b f4 40 aa 	sel %d10,%d10,%d4,%d15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
80006af8:	6d 00 23 04 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
80006afc:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006afe:	6d 00 3e 04 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006b02:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006b04:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006b06:	6d 00 1c 03 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006b0a:	91 30 00 ff 	movh.a %a15,61443
80006b0e:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006b12:	48 02       	ld.w %d2,[%a15]0
80006b14:	3b 00 3e f0 	mov %d15,992
80006b18:	a6 2f       	or %d15,%d2
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b1a:	02 84       	mov %d4,%d8

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006b1c:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b1e:	6d 00 45 04 	call 800073a8 <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006b22:	02 94       	mov %d4,%d9
80006b24:	6d 00 28 03 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006b28:	91 30 00 2f 	movh.a %a2,61443
80006b2c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b30:	4c 20       	ld.w %d15,[%a2]0
80006b32:	91 30 00 ff 	movh.a %a15,61443
80006b36:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b3a:	bf 0f fb 7f 	jlt %d15,0,80006b30 <IfxScuCcu_setSpbFrequency+0x66>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006b3e:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006b40:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
80006b42:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
80006b46:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006b4a:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006b4c:	6d 00 9a 04 	call 80007480 <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006b50:	02 84       	mov %d4,%d8
80006b52:	6d 00 f6 02 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80006b56:	91 30 00 ff 	movh.a %a15,61443
80006b5a:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006b5e:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b60:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80006b62:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
80006b66:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b68:	6d 00 20 04 	call 800073a8 <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006b6c:	91 30 00 ff 	movh.a %a15,61443
80006b70:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b74:	4c f0       	ld.w %d15,[%a15]0
80006b76:	bf 0f ff 7f 	jlt %d15,0,80006b74 <IfxScuCcu_setSpbFrequency+0xaa>
    {}

    return IfxScuCcu_getSpbFrequency();
80006b7a:	1d ff 1e fb 	j 800061b6 <IfxScuCcu_getSpbFrequency>

80006b7e <IfxScuCcu_setSriFrequency>:
}


float32 IfxScuCcu_setSriFrequency(float32 sriFreq)
{
80006b7e:	02 4f       	mov %d15,%d4
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
80006b80:	6d ff 5a fa 	call 80006034 <IfxScuCcu_getSourceFrequency>
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
80006b84:	4b f2 51 20 	div.f %d2,%d2,%d15
80006b88:	4b 02 31 31 	ftoiz %d3,%d2
80006b8c:	4b 03 41 f1 	itof %d15,%d3
80006b90:	6b 0f 31 22 	sub.f %d2,%d2,%d15
80006b94:	7b 00 f0 f3 	movh %d15,16128
80006b98:	4b f2 01 f0 	cmp.f %d15,%d2,%d15
80006b9c:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80006ba0:	82 12       	mov %d2,1
80006ba2:	42 3f       	add %d15,%d3
80006ba4:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
80006ba8:	8b ef 00 42 	eq %d4,%d15,14
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
80006bac:	92 93       	add %d3,%d15,-7
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
    {
        sriDiv = 12;
80006bae:	ab cf a0 94 	seln %d9,%d4,%d15,12
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
80006bb2:	8f 1f c0 21 	andn %d2,%d15,1
80006bb6:	02 9f       	mov %d15,%d9
80006bb8:	8b 73 a0 92 	ge.u %d9,%d3,7
80006bbc:	2b 2f 40 99 	sel %d9,%d9,%d15,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006bc0:	6d 00 dd 03 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006bc4:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006bc6:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006bc8:	6d 00 d6 02 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006bcc:	91 30 00 2f 	movh.a %a2,61443
80006bd0:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006bd4:	4c 20       	ld.w %d15,[%a2]0
80006bd6:	91 30 00 ff 	movh.a %a15,61443
80006bda:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006bde:	bf 0f fb 7f 	jlt %d15,0,80006bd4 <IfxScuCcu_setSriFrequency+0x56>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006be2:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006be4:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
80006be6:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
80006bea:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006bee:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006bf0:	6d 00 48 04 	call 80007480 <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006bf4:	4c f0       	ld.w %d15,[%a15]0
80006bf6:	bf 0f ff 7f 	jlt %d15,0,80006bf4 <IfxScuCcu_setSriFrequency+0x76>
    {}

    freq = IfxScuCcu_getSriFrequency();
80006bfa:	1d ff 3f fb 	j 80006278 <IfxScuCcu_getSriFrequency>

80006bfe <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80006bfe:	91 30 00 ff 	movh.a %a15,61443
80006c02:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c06:	4c f0       	ld.w %d15,[%a15]0
80006c08:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80006c0c:	df 0f 81 00 	jeq %d15,0,80006d0e <IfxScuCcu_switchToBackupClock+0x110>
80006c10:	40 4f       	mov.aa %a15,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006c12:	6d 00 b4 03 	call 8000737a <IfxScuWdt_getSafetyWatchdogPassword>
80006c16:	02 29       	mov %d9,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006c18:	6d 00 93 03 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006c1c:	0c f0       	ld.bu %d15,[%a15]0
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006c1e:	02 28       	mov %d8,%d2
80006c20:	53 cf 20 20 	mul %d2,%d15,12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006c24:	91 30 00 ef 	movh.a %a14,61443
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c28:	91 30 00 df 	movh.a %a13,61443
80006c2c:	60 22       	mov.a %a2,%d2
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006c2e:	d9 ee 14 06 	lea %a14,[%a14]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006c32:	d9 2c f4 ff 	lea %a12,[%a2]-12 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c36:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006c3a:	6e 1b       	jz %d15,80006c70 <IfxScuCcu_switchToBackupClock+0x72>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006c3c:	02 94       	mov %d4,%d9
80006c3e:	6d 00 9b 02 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006c42:	54 e2       	ld.w %d2,[%a14]
80006c44:	6f 52 ff 7f 	jz.t %d2,5,80006c42 <IfxScuCcu_switchToBackupClock+0x44>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c48:	c8 12       	ld.a %a2,[%a15]4
80006c4a:	54 d3       	ld.w %d3,[%a13]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006c4c:	02 94       	mov %d4,%d9
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c4e:	30 c2       	add.a %a2,%a12
80006c50:	14 22       	ld.bu %d2,[%a2]

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006c52:	c2 ff       	add %d15,-1
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c54:	37 23 07 20 	insert %d2,%d3,%d2,0,7
80006c58:	74 d2       	st.w [%a13],%d2

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006c5a:	6d 00 13 04 	call 80007480 <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80006c5e:	c8 12       	ld.a %a2,[%a15]4
80006c60:	30 c2       	add.a %a2,%a12
80006c62:	19 24 04 00 	ld.w %d4,[%a2]4
80006c66:	6d ff f9 f9 	call 80006058 <IfxScuCcu_wait>
80006c6a:	d9 cc f4 ff 	lea %a12,[%a12]-12
80006c6e:	3c e6       	j 80006c3a <IfxScuCcu_switchToBackupClock+0x3c>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006c70:	02 84       	mov %d4,%d8
80006c72:	6d 00 66 02 	call 8000713e <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006c76:	91 30 00 ff 	movh.a %a15,61443
80006c7a:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006c7e:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006c80:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006c82:	02 84       	mov %d4,%d8
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006c84:	96 08       	or %d15,8
80006c86:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006c88:	37 02 e1 a1 	extr.u %d10,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006c8c:	6d 00 8e 03 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006c90:	02 94       	mov %d4,%d9
80006c92:	6d 00 71 02 	call 80007174 <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
80006c96:	91 30 00 2f 	movh.a %a2,61443
80006c9a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c9e:	4c 20       	ld.w %d15,[%a2]0
80006ca0:	91 30 00 ff 	movh.a %a15,61443
80006ca4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006ca8:	bf 0f fb 7f 	jlt %d15,0,80006c9e <IfxScuCcu_switchToBackupClock+0xa0>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80006cac:	4c f0       	ld.w %d15,[%a15]0
80006cae:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006cb2:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006cb4:	4c f0       	ld.w %d15,[%a15]0
80006cb6:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006cba:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
80006cbc:	4c f0       	ld.w %d15,[%a15]0
80006cbe:	bf 0f ff 7f 	jlt %d15,0,80006cbc <IfxScuCcu_switchToBackupClock+0xbe>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006cc2:	91 30 00 ff 	movh.a %a15,61443
80006cc6:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006cca:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006ccc:	02 94       	mov %d4,%d9
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006cce:	96 10       	or %d15,16
80006cd0:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006cd2:	4c f0       	ld.w %d15,[%a15]0
80006cd4:	8f 0f c4 f1 	andn %d15,%d15,64
80006cd8:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006cda:	6d 00 d3 03 	call 80007480 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006cde:	91 30 00 ff 	movh.a %a15,61443
80006ce2:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006ce6:	02 84       	mov %d4,%d8
80006ce8:	6d 00 2b 02 	call 8000713e <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006cec:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006cee:	8f 3a 00 20 	sh %d2,%d10,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006cf2:	96 08       	or %d15,8
80006cf4:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006cf6:	91 30 00 ff 	movh.a %a15,61443
80006cfa:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006cfe:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006d00:	02 84       	mov %d4,%d8
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006d02:	8f 8f c0 f1 	andn %d15,%d15,8
80006d06:	a6 2f       	or %d15,%d2
80006d08:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006d0a:	1d 00 4f 03 	j 800073a8 <IfxScuWdt_setCpuEndinit>
80006d0e:	00 90       	ret 

80006d10 <IfxScuEru_clearAllEventFlags>:
/******************************************************************************/

void IfxScuEru_clearAllEventFlags(void)
{
    uint32 mask = (0xFF << 16);
    MODULE_SCU.FMR.U = mask;
80006d10:	91 30 00 ff 	movh.a %a15,61443
80006d14:	7b f0 0f f0 	movh %d15,255
80006d18:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d1c:	59 ff 24 80 	st.w [%a15]548 <f0030224 <_SMALL_DATA4_+0x40028224>>,%d15
80006d20:	00 90       	ret 

80006d22 <IfxScuEru_clearEventFlag>:
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006d22:	1b 04 01 40 	addi %d4,%d4,16
80006d26:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006d28:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006d2c:	0f 4f 00 f0 	sh %d15,%d15,%d4
    SCU_FMR.U = mask;
80006d30:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006d34:	68 0f       	st.w [%a15]0,%d15
80006d36:	00 90       	ret 

80006d38 <IfxScuEru_clearInputChannelConfiguration>:


void IfxScuEru_clearInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d38:	8f f4 1f f0 	sh %d15,%d4,-1
80006d3c:	06 2f       	sh %d15,2
80006d3e:	60 ff       	mov.a %a15,%d15
80006d40:	d9 ff 00 06 	lea %a15,[%a15]24576
80006d44:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006d48:	19 ff 10 80 	ld.w %d15,[%a15]528
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006d4c:	6f 04 05 00 	jz.t %d4,0,80006d56 <IfxScuEru_clearInputChannelConfiguration+0x1e>
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006d50:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006d54:	3c 03       	j 80006d5a <IfxScuEru_clearInputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006d56:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006d5a:	59 ff 10 80 	st.w [%a15]528,%d15
80006d5e:	00 90       	ret 

80006d60 <IfxScuEru_clearOutputChannelConfiguration>:


void IfxScuEru_clearOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d60:	8f f4 1f f0 	sh %d15,%d4,-1
80006d64:	06 2f       	sh %d15,2
80006d66:	60 ff       	mov.a %a15,%d15
80006d68:	d9 ff 00 06 	lea %a15,[%a15]24576
80006d6c:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006d70:	19 ff 2c 80 	ld.w %d15,[%a15]556
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006d74:	6f 04 05 00 	jz.t %d4,0,80006d7e <IfxScuEru_clearOutputChannelConfiguration+0x1e>
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006d78:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006d7c:	3c 03       	j 80006d82 <IfxScuEru_clearOutputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006d7e:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006d82:	59 ff 2c 80 	st.w [%a15]556,%d15
80006d86:	00 90       	ret 

80006d88 <IfxScuEru_connectTrigger>:


void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d88:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006d8c:	91 30 00 ff 	movh.a %a15,61443
80006d90:	1b 4f 08 f0 	addi %d15,%d15,132
80006d94:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d98:	8f 75 00 51 	and %d5,%d5,7
80006d9c:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d9e:	6f 04 08 00 	jz.t %d4,0,80006dae <IfxScuEru_connectTrigger+0x26>
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006da2:	4c f0       	ld.w %d15,[%a15]0
80006da4:	8f c5 01 50 	sh %d5,%d5,28
80006da8:	b7 0f 03 fe 	insert %d15,%d15,0,28,3
80006dac:	3c 06       	j 80006db8 <IfxScuEru_connectTrigger+0x30>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.INP0 = triggerSelect;
80006dae:	4c f0       	ld.w %d15,[%a15]0
80006db0:	8f c5 00 50 	sh %d5,%d5,12
80006db4:	b7 0f 03 f6 	insert %d15,%d15,0,12,3
80006db8:	a6 f5       	or %d5,%d15
80006dba:	68 05       	st.w [%a15]0,%d5
80006dbc:	00 90       	ret 

80006dbe <IfxScuEru_disableAutoClear>:


void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006dbe:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006dc2:	91 30 00 ff 	movh.a %a15,61443
80006dc6:	1b 4f 08 f0 	addi %d15,%d15,132
80006dca:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dce:	90 ff       	addsc.a %a15,%a15,%d15,2
80006dd0:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006dd2:	6f 04 05 00 	jz.t %d4,0,80006ddc <IfxScuEru_disableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006dd6:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80006dda:	3c 03       	j 80006de0 <IfxScuEru_disableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = FALSE;
80006ddc:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80006de0:	68 0f       	st.w [%a15]0,%d15
80006de2:	00 90       	ret 

80006de4 <IfxScuEru_disableFallingEdgeDetection>:


void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006de4:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006de8:	91 30 00 ff 	movh.a %a15,61443
80006dec:	1b 4f 08 f0 	addi %d15,%d15,132
80006df0:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006df4:	90 ff       	addsc.a %a15,%a15,%d15,2
80006df6:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006df8:	6f 04 05 00 	jz.t %d4,0,80006e02 <IfxScuEru_disableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006dfc:	b7 0f 01 fc 	insert %d15,%d15,0,24,1
80006e00:	3c 03       	j 80006e06 <IfxScuEru_disableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = FALSE;
80006e02:	8f 0f d0 f1 	andn %d15,%d15,256
80006e06:	68 0f       	st.w [%a15]0,%d15
80006e08:	00 90       	ret 

80006e0a <IfxScuEru_disablePatternDetectionTrigger>:


void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e0a:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006e0e:	91 30 00 ff 	movh.a %a15,61443
80006e12:	1b bf 08 f0 	addi %d15,%d15,139
80006e16:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e1a:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e1c:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e1e:	6f 04 05 00 	jz.t %d4,0,80006e28 <IfxScuEru_disablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006e22:	b7 0f 81 fe 	insert %d15,%d15,0,29,1
80006e26:	3c 03       	j 80006e2c <IfxScuEru_disablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = FALSE;
80006e28:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80006e2c:	68 0f       	st.w [%a15]0,%d15
80006e2e:	00 90       	ret 

80006e30 <IfxScuEru_disableRisingEdgeDetection>:


void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e30:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006e34:	91 30 00 ff 	movh.a %a15,61443
80006e38:	1b 4f 08 f0 	addi %d15,%d15,132
80006e3c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e40:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e42:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e44:	6f 04 05 00 	jz.t %d4,0,80006e4e <IfxScuEru_disableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006e48:	b7 0f 81 fc 	insert %d15,%d15,0,25,1
80006e4c:	3c 03       	j 80006e52 <IfxScuEru_disableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = FALSE;
80006e4e:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80006e52:	68 0f       	st.w [%a15]0,%d15
80006e54:	00 90       	ret 

80006e56 <IfxScuEru_disableTriggerPulse>:


void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e56:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006e5a:	91 30 00 ff 	movh.a %a15,61443
80006e5e:	1b 4f 08 f0 	addi %d15,%d15,132
80006e62:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e66:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e68:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e6a:	6f 04 05 00 	jz.t %d4,0,80006e74 <IfxScuEru_disableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006e6e:	b7 0f 81 fd 	insert %d15,%d15,0,27,1
80006e72:	3c 03       	j 80006e78 <IfxScuEru_disableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = FALSE;
80006e74:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80006e78:	68 0f       	st.w [%a15]0,%d15
80006e7a:	00 90       	ret 

80006e7c <IfxScuEru_enableAutoClear>:


void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e7c:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006e80:	91 30 00 ff 	movh.a %a15,61443
80006e84:	1b 4f 08 f0 	addi %d15,%d15,132
80006e88:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e8c:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e8e:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e90:	6f 04 05 00 	jz.t %d4,0,80006e9a <IfxScuEru_enableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006e94:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80006e98:	3c 03       	j 80006e9e <IfxScuEru_enableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = TRUE;
80006e9a:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80006e9e:	68 0f       	st.w [%a15]0,%d15
80006ea0:	00 90       	ret 

80006ea2 <IfxScuEru_enableFallingEdgeDetection>:


void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ea2:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006ea6:	91 30 00 ff 	movh.a %a15,61443
80006eaa:	1b 4f 08 f0 	addi %d15,%d15,132
80006eae:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006eb2:	90 ff       	addsc.a %a15,%a15,%d15,2
80006eb4:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006eb6:	6f 04 05 00 	jz.t %d4,0,80006ec0 <IfxScuEru_enableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006eba:	b7 ff 01 fc 	insert %d15,%d15,15,24,1
80006ebe:	3c 03       	j 80006ec4 <IfxScuEru_enableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = TRUE;
80006ec0:	8f 0f 50 f1 	or %d15,%d15,256
80006ec4:	68 0f       	st.w [%a15]0,%d15
80006ec6:	00 90       	ret 

80006ec8 <IfxScuEru_enablePatternDetectionTrigger>:


void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ec8:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006ecc:	91 30 00 ff 	movh.a %a15,61443
80006ed0:	1b bf 08 f0 	addi %d15,%d15,139
80006ed4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ed8:	90 ff       	addsc.a %a15,%a15,%d15,2
80006eda:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006edc:	6f 04 05 00 	jz.t %d4,0,80006ee6 <IfxScuEru_enablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006ee0:	b7 ff 81 fe 	insert %d15,%d15,15,29,1
80006ee4:	3c 03       	j 80006eea <IfxScuEru_enablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = TRUE;
80006ee6:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80006eea:	68 0f       	st.w [%a15]0,%d15
80006eec:	00 90       	ret 

80006eee <IfxScuEru_enableRisingEdgeDetection>:


void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006eee:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006ef2:	91 30 00 ff 	movh.a %a15,61443
80006ef6:	1b 4f 08 f0 	addi %d15,%d15,132
80006efa:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006efe:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f00:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006f02:	6f 04 05 00 	jz.t %d4,0,80006f0c <IfxScuEru_enableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006f06:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80006f0a:	3c 03       	j 80006f10 <IfxScuEru_enableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = TRUE;
80006f0c:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80006f10:	68 0f       	st.w [%a15]0,%d15
80006f12:	00 90       	ret 

80006f14 <IfxScuEru_enableTriggerPulse>:


void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f14:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006f18:	91 30 00 ff 	movh.a %a15,61443
80006f1c:	1b 4f 08 f0 	addi %d15,%d15,132
80006f20:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f24:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f26:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006f28:	6f 04 05 00 	jz.t %d4,0,80006f32 <IfxScuEru_enableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006f2c:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80006f30:	3c 03       	j 80006f36 <IfxScuEru_enableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = TRUE;
80006f32:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80006f36:	68 0f       	st.w [%a15]0,%d15
80006f38:	00 90       	ret 

80006f3a <IfxScuEru_getAllEventFlagsStatus>:
}


uint32 IfxScuEru_getAllEventFlagsStatus(void)
{
    return MODULE_SCU.EIFR.U;
80006f3a:	91 30 00 ff 	movh.a %a15,61443
80006f3e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f42:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006f46:	00 90       	ret 

80006f48 <IfxScuEru_getEventFlagStatus>:


boolean IfxScuEru_getEventFlagStatus(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = (1U << inputChannel);
    return (MODULE_SCU.EIFR.U & mask) ? TRUE : FALSE;
80006f48:	91 30 00 ff 	movh.a %a15,61443
80006f4c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f50:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006f54:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006f58:	00 90       	ret 

80006f5a <IfxScuEru_getInputChannelConfiguration>:


uint32 IfxScuEru_getInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f5a:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006f5e:	91 30 00 ff 	movh.a %a15,61443
80006f62:	1b 4f 08 f0 	addi %d15,%d15,132
80006f66:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f6a:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f6c:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006f6e:	6f 04 05 00 	jz.t %d4,0,80006f78 <IfxScuEru_getInputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006f72:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006f76:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.EICR[index].U & mask);
80006f78:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006f7c:	00 90       	ret 

80006f7e <IfxScuEru_getOutputChannelConfiguration>:


uint32 IfxScuEru_getOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f7e:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006f82:	91 30 00 ff 	movh.a %a15,61443
80006f86:	1b bf 08 f0 	addi %d15,%d15,139
80006f8a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f8e:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f90:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006f92:	6f 04 05 00 	jz.t %d4,0,80006f9c <IfxScuEru_getOutputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006f96:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006f9a:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.IGCR[index].U & mask);
80006f9c:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006fa0:	00 90       	ret 

80006fa2 <IfxScuEru_getPatternDetectionResult>:


boolean IfxScuEru_getPatternDetectionResult(IfxScuEru_OutputChannel outputChannel)
{
    uint32 mask = (1U << outputChannel);
    return (MODULE_SCU.PDRR.U & mask) ? TRUE : FALSE;
80006fa2:	91 30 00 ff 	movh.a %a15,61443
80006fa6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006faa:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006fae:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006fb2:	00 90       	ret 

80006fb4 <IfxScuEru_getWholePatternDetectionResult>:


uint32 IfxScuEru_getWholePatternDetectionResult(void)
{
    return MODULE_SCU.PDRR.U;
80006fb4:	91 30 00 ff 	movh.a %a15,61443
80006fb8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006fbc:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006fc0:	00 90       	ret 

80006fc2 <IfxScuEru_selectExternalInput>:


void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006fc2:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006fc6:	91 30 00 ff 	movh.a %a15,61443
80006fca:	1b 4f 08 f0 	addi %d15,%d15,132
80006fce:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006fd2:	8f 75 00 51 	and %d5,%d5,7
80006fd6:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006fd8:	6f 04 08 00 	jz.t %d4,0,80006fe8 <IfxScuEru_selectExternalInput+0x26>
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006fdc:	4c f0       	ld.w %d15,[%a15]0
80006fde:	8f 45 01 50 	sh %d5,%d5,20
80006fe2:	b7 0f 03 fa 	insert %d15,%d15,0,20,3
80006fe6:	3c 05       	j 80006ff0 <IfxScuEru_selectExternalInput+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EXIS0 = inputSignal;
80006fe8:	4c f0       	ld.w %d15,[%a15]0
80006fea:	06 45       	sh %d5,4
80006fec:	8f 0f c7 f1 	andn %d15,%d15,112
80006ff0:	a6 f5       	or %d5,%d15
80006ff2:	68 05       	st.w [%a15]0,%d5
80006ff4:	00 90       	ret 

80006ff6 <IfxScuEru_setEventFlag>:
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006ff6:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006ff8:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006ffc:	0f 4f 00 40 	sh %d4,%d15,%d4
    SCU_FMR.U = mask;
80007000:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80007004:	68 04       	st.w [%a15]0,%d4
80007006:	00 90       	ret 

80007008 <IfxScuEru_setFlagPatternDetection>:
}


void IfxScuEru_setFlagPatternDetection(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InputChannel inputChannel, boolean state)
{
80007008:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 shift, mask;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD) // for channels 1, 3 ,5 and 7
8000700c:	6f 04 04 00 	jz.t %d4,0,80007014 <IfxScuEru_setFlagPatternDetection+0xc>
    {
        shift = (inputChannel + 16);                  // offset at location IPEN10
80007010:	1b 05 01 50 	addi %d5,%d5,16
80007014:	06 2f       	sh %d15,2
80007016:	60 f2       	mov.a %a2,%d15
80007018:	d9 2f 00 06 	lea %a15,[%a2]24576
8000701c:	11 3f 00 ff 	addih.a %a15,%a15,61443
    {
        shift = inputChannel;
        mask  = (1 << shift);
        // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
        uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & ~mask) | ((uint32)state << shift);
80007020:	19 ff 2c 80 	ld.w %d15,[%a15]556
80007024:	d7 0f 01 f5 	insert %d15,%d15,0,%d5,1
80007028:	0f 56 00 50 	sh %d5,%d6,%d5
8000702c:	a6 f5       	or %d5,%d15
8000702e:	59 f5 2c 80 	st.w [%a15]556,%d5
80007032:	00 90       	ret 

80007034 <IfxScuEru_setInterruptGatingPattern>:


void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80007034:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80007038:	91 30 00 ff 	movh.a %a15,61443
8000703c:	1b bf 08 f0 	addi %d15,%d15,139
80007040:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007044:	8f 35 00 51 	and %d5,%d5,3
80007048:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
8000704a:	6f 04 06 00 	jz.t %d4,0,80007056 <IfxScuEru_setInterruptGatingPattern+0x22>
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
8000704e:	4c f0       	ld.w %d15,[%a15]0
80007050:	37 5f 02 5f 	insert %d5,%d15,%d5,30,2
80007054:	3c 07       	j 80007062 <IfxScuEru_setInterruptGatingPattern+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.IGP0 = gatingPattern;
80007056:	4c f0       	ld.w %d15,[%a15]0
80007058:	8f e5 00 50 	sh %d5,%d5,14
8000705c:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
80007060:	a6 f5       	or %d5,%d15
80007062:	68 05       	st.w [%a15]0,%d5
80007064:	00 90       	ret 

80007066 <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007066:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000706a:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
8000706c:	53 cf 20 f0 	mul %d15,%d15,12
80007070:	60 f2       	mov.a %a2,%d15
80007072:	d9 2f 00 46 	lea %a15,[%a2]24832
80007076:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
8000707a:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000707c:	2e 16       	jz.t %d15,1,80007088 <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000707e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80007082:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80007086:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007088:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000708c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
80007090:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80007094:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007096:	4c f0       	ld.w %d15,[%a15]0
80007098:	6f 0f ff 7f 	jz.t %d15,0,80007096 <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
8000709c:	00 90       	ret 

8000709e <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000709e:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800070a2:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
800070a4:	53 cf 20 f0 	mul %d15,%d15,12
800070a8:	60 f2       	mov.a %a2,%d15
800070aa:	d9 2f 00 46 	lea %a15,[%a2]24832
800070ae:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
800070b2:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
800070b4:	2e 16       	jz.t %d15,1,800070c0 <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800070b6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
800070ba:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800070be:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
800070c0:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
800070c4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
800070c8:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
800070cc:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
800070ce:	4c f0       	ld.w %d15,[%a15]0
800070d0:	6f 0f ff 7f 	jz.t %d15,0,800070ce <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
800070d4:	00 90       	ret 

800070d6 <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
800070d6:	91 30 00 ff 	movh.a %a15,61443
800070da:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070de:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
800070e0:	2e 16       	jz.t %d15,1,800070ec <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800070e2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
800070e6:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
800070ea:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
800070ec:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
800070f0:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
800070f4:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
800070f8:	91 30 00 ff 	movh.a %a15,61443
800070fc:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007100:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007102:	4c f0       	ld.w %d15,[%a15]0
80007104:	6f 0f ff 7f 	jz.t %d15,0,80007102 <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
80007108:	00 90       	ret 

8000710a <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
8000710a:	91 30 00 ff 	movh.a %a15,61443
8000710e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007112:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80007114:	2e 16       	jz.t %d15,1,80007120 <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80007116:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000711a:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000711e:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007120:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80007124:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80007128:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
8000712c:	91 30 00 ff 	movh.a %a15,61443
80007130:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007134:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80007136:	4c f0       	ld.w %d15,[%a15]0
80007138:	6f 0f ff 7f 	jz.t %d15,0,80007136 <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
8000713c:	00 90       	ret 

8000713e <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000713e:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007142:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80007144:	53 cf 20 f0 	mul %d15,%d15,12
80007148:	06 24       	sh %d4,2
8000714a:	60 f2       	mov.a %a2,%d15
8000714c:	d9 2f 00 46 	lea %a15,[%a2]24832
80007150:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007154:	4c f0       	ld.w %d15,[%a15]0
80007156:	2e 16       	jz.t %d15,1,80007162 <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007158:	4c f0       	ld.w %d15,[%a15]0
8000715a:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000715e:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007160:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007162:	4c f0       	ld.w %d15,[%a15]0
80007164:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007168:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000716a:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000716c:	4c f0       	ld.w %d15,[%a15]0
8000716e:	6f 0f ff ff 	jnz.t %d15,0,8000716c <IfxScuWdt_clearCpuEndinit+0x2e>
}
80007172:	00 90       	ret 

80007174 <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007174:	91 30 00 ff 	movh.a %a15,61443
80007178:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000717c:	4c f0       	ld.w %d15,[%a15]0
8000717e:	06 24       	sh %d4,2
80007180:	2e 16       	jz.t %d15,1,8000718c <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007182:	4c f0       	ld.w %d15,[%a15]0
80007184:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007188:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000718a:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000718c:	91 30 00 ff 	movh.a %a15,61443
80007190:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007194:	4c f0       	ld.w %d15,[%a15]0
80007196:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000719a:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000719c:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000719e:	4c f0       	ld.w %d15,[%a15]0
800071a0:	6f 0f ff ff 	jnz.t %d15,0,8000719e <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
800071a4:	00 90       	ret 

800071a6 <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800071a6:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800071aa:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800071ac:	53 cf 20 f0 	mul %d15,%d15,12
800071b0:	06 24       	sh %d4,2
800071b2:	60 f2       	mov.a %a2,%d15
800071b4:	d9 2f 00 46 	lea %a15,[%a2]24832
800071b8:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800071bc:	4c f0       	ld.w %d15,[%a15]0
800071be:	2e 16       	jz.t %d15,1,800071ca <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800071c0:	4c f0       	ld.w %d15,[%a15]0
800071c2:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071c6:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071c8:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800071ca:	4c f0       	ld.w %d15,[%a15]0
800071cc:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071d0:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071d2:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
800071d4:	4c f0       	ld.w %d15,[%a15]0
800071d6:	6f 0f ff ff 	jnz.t %d15,0,800071d4 <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
800071da:	4c f1       	ld.w %d15,[%a15]4
800071dc:	96 08       	or %d15,8
800071de:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800071e0:	4c f0       	ld.w %d15,[%a15]0
800071e2:	2e 16       	jz.t %d15,1,800071ee <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800071e4:	4c f0       	ld.w %d15,[%a15]0
800071e6:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071ea:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071ec:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800071ee:	4c f0       	ld.w %d15,[%a15]0
800071f0:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071f4:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071f6:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800071f8:	4c f0       	ld.w %d15,[%a15]0
800071fa:	6f 0f ff 7f 	jz.t %d15,0,800071f8 <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
800071fe:	00 90       	ret 

80007200 <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007200:	91 30 00 ff 	movh.a %a15,61443
80007204:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007208:	4c f0       	ld.w %d15,[%a15]0
8000720a:	06 24       	sh %d4,2
8000720c:	2e 16       	jz.t %d15,1,80007218 <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000720e:	4c f0       	ld.w %d15,[%a15]0
80007210:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007214:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007216:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007218:	91 30 00 ff 	movh.a %a15,61443
8000721c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007220:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007222:	40 f2       	mov.aa %a2,%a15
80007224:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007228:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000722a:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000722c:	4c 20       	ld.w %d15,[%a2]0
8000722e:	91 30 00 ff 	movh.a %a15,61443
80007232:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007236:	6f 0f fb ff 	jnz.t %d15,0,8000722c <IfxScuWdt_disableSafetyWatchdog+0x2c>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
8000723a:	91 30 00 2f 	movh.a %a2,61443
8000723e:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
80007242:	4c 20       	ld.w %d15,[%a2]0
80007244:	96 08       	or %d15,8
80007246:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007248:	4c f0       	ld.w %d15,[%a15]0
8000724a:	2e 16       	jz.t %d15,1,80007256 <IfxScuWdt_disableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000724c:	4c f0       	ld.w %d15,[%a15]0
8000724e:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007252:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007254:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007256:	91 30 00 ff 	movh.a %a15,61443
8000725a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000725e:	4c f0       	ld.w %d15,[%a15]0
80007260:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007264:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007266:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007268:	4c f0       	ld.w %d15,[%a15]0
8000726a:	6f 0f ff 7f 	jz.t %d15,0,80007268 <IfxScuWdt_disableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000726e:	00 90       	ret 

80007270 <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007270:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007274:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80007276:	53 cf 20 f0 	mul %d15,%d15,12
8000727a:	06 24       	sh %d4,2
8000727c:	60 f2       	mov.a %a2,%d15
8000727e:	d9 2f 00 46 	lea %a15,[%a2]24832
80007282:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007286:	4c f0       	ld.w %d15,[%a15]0
80007288:	2e 16       	jz.t %d15,1,80007294 <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000728a:	4c f0       	ld.w %d15,[%a15]0
8000728c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007290:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007292:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007294:	4c f0       	ld.w %d15,[%a15]0
80007296:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000729a:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000729c:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000729e:	4c f0       	ld.w %d15,[%a15]0
800072a0:	6f 0f ff ff 	jnz.t %d15,0,8000729e <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
800072a4:	4c f1       	ld.w %d15,[%a15]4
800072a6:	8f 8f c0 f1 	andn %d15,%d15,8
800072aa:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800072ac:	4c f0       	ld.w %d15,[%a15]0
800072ae:	2e 16       	jz.t %d15,1,800072ba <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800072b0:	4c f0       	ld.w %d15,[%a15]0
800072b2:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800072b6:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800072b8:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800072ba:	4c f0       	ld.w %d15,[%a15]0
800072bc:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800072c0:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800072c2:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800072c4:	4c f0       	ld.w %d15,[%a15]0
800072c6:	6f 0f ff 7f 	jz.t %d15,0,800072c4 <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
800072ca:	00 90       	ret 

800072cc <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800072cc:	91 30 00 ff 	movh.a %a15,61443
800072d0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072d4:	4c f0       	ld.w %d15,[%a15]0
800072d6:	06 24       	sh %d4,2
800072d8:	2e 16       	jz.t %d15,1,800072e4 <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072da:	4c f0       	ld.w %d15,[%a15]0
800072dc:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072e0:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072e2:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072e4:	91 30 00 ff 	movh.a %a15,61443
800072e8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072ec:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800072ee:	40 f2       	mov.aa %a2,%a15
800072f0:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072f4:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072f6:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800072f8:	4c 20       	ld.w %d15,[%a2]0
800072fa:	91 30 00 ff 	movh.a %a15,61443
800072fe:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007302:	6f 0f fb ff 	jnz.t %d15,0,800072f8 <IfxScuWdt_enableSafetyWatchdog+0x2c>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
80007306:	91 30 00 2f 	movh.a %a2,61443
8000730a:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
8000730e:	4c 20       	ld.w %d15,[%a2]0
80007310:	8f 8f c0 f1 	andn %d15,%d15,8
80007314:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007316:	4c f0       	ld.w %d15,[%a15]0
80007318:	2e 16       	jz.t %d15,1,80007324 <IfxScuWdt_enableSafetyWatchdog+0x58>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000731a:	4c f0       	ld.w %d15,[%a15]0
8000731c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007320:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007322:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007324:	91 30 00 ff 	movh.a %a15,61443
80007328:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000732c:	4c f0       	ld.w %d15,[%a15]0
8000732e:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007332:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007334:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007336:	4c f0       	ld.w %d15,[%a15]0
80007338:	6f 0f ff 7f 	jz.t %d15,0,80007336 <IfxScuWdt_enableSafetyWatchdog+0x6a>
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000733c:	00 90       	ret 

8000733e <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000733e:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007342:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
80007344:	53 cf 20 f0 	mul %d15,%d15,12
80007348:	60 f2       	mov.a %a2,%d15
8000734a:	d9 2f 00 46 	lea %a15,[%a2]24832
8000734e:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80007352:	48 02       	ld.w %d2,[%a15]0
80007354:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
80007358:	8f f2 83 21 	xor %d2,%d2,63
8000735c:	00 90       	ret 

8000735e <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000735e:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007362:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
80007364:	53 cf 20 f0 	mul %d15,%d15,12
80007368:	60 f2       	mov.a %a2,%d15
8000736a:	d9 2f 00 46 	lea %a15,[%a2]24832
8000736e:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
80007372:	48 02       	ld.w %d2,[%a15]0
}
80007374:	8f 12 00 21 	and %d2,%d2,1
80007378:	00 90       	ret 

8000737a <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
8000737a:	91 30 00 ff 	movh.a %a15,61443
8000737e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007382:	48 02       	ld.w %d2,[%a15]0
80007384:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
80007388:	8f f2 83 21 	xor %d2,%d2,63
8000738c:	00 90       	ret 

8000738e <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
8000738e:	da 3c       	mov %d15,60
80007390:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
80007392:	82 cf       	mov %d15,-4
80007394:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
80007396:	82 0f       	mov %d15,0
80007398:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
8000739a:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
8000739c:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
8000739e:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
800073a0:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
800073a2:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
800073a4:	2c 4a       	st.b [%a4]10,%d15
800073a6:	00 90       	ret 

800073a8 <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800073a8:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800073ac:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800073ae:	53 cf 20 f0 	mul %d15,%d15,12
800073b2:	06 24       	sh %d4,2
800073b4:	60 f2       	mov.a %a2,%d15
800073b6:	d9 2f 00 46 	lea %a15,[%a2]24832
800073ba:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800073be:	4c f0       	ld.w %d15,[%a15]0
800073c0:	2e 16       	jz.t %d15,1,800073cc <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800073c2:	4c f0       	ld.w %d15,[%a15]0
800073c4:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800073c8:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800073ca:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800073cc:	4c f0       	ld.w %d15,[%a15]0
800073ce:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800073d2:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800073d4:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800073d6:	4c f0       	ld.w %d15,[%a15]0
800073d8:	6f 0f ff 7f 	jz.t %d15,0,800073d6 <IfxScuWdt_setCpuEndinit+0x2e>
}
800073dc:	00 90       	ret 

800073de <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
800073de:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
800073e0:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
800073e2:	6f 12 0b 00 	jz.t %d2,1,800073f8 <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800073e6:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
800073ea:	37 02 6e 31 	extr.u %d3,%d2,2,14
800073ee:	8f f3 83 31 	xor %d3,%d3,63
800073f2:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800073f6:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
800073f8:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
800073fa:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
800073fe:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
80007402:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
80007406:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000740a:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
8000740e:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007410:	54 42       	ld.w %d2,[%a4]
80007412:	6f 02 ff ff 	jnz.t %d2,0,80007410 <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
80007416:	39 52 04 00 	ld.bu %d2,[%a5]4
8000741a:	df 12 0a 00 	jeq %d2,1,8000742e <IfxScuWdt_initCpuWatchdog+0x50>
8000741e:	76 26       	jz %d2,8000742a <IfxScuWdt_initCpuWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
80007420:	8b 22 20 22 	ne %d2,%d2,2
80007424:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
80007428:	3c 07       	j 80007436 <IfxScuWdt_initCpuWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
8000742a:	82 0f       	mov %d15,0
        break;
8000742c:	3c 05       	j 80007436 <IfxScuWdt_initCpuWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000742e:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
80007432:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
80007436:	39 52 05 00 	ld.bu %d2,[%a5]5
8000743a:	8b 02 20 22 	ne %d2,%d2,0
8000743e:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
80007442:	39 52 06 00 	ld.bu %d2,[%a5]6
80007446:	8b 02 20 22 	ne %d2,%d2,0
8000744a:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
8000744e:	39 52 07 00 	ld.bu %d2,[%a5]7
80007452:	8b 02 20 22 	ne %d2,%d2,0
80007456:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
8000745a:	39 52 08 00 	ld.bu %d2,[%a5]8
8000745e:	8b 02 20 22 	ne %d2,%d2,0
80007462:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
80007466:	39 52 09 00 	ld.bu %d2,[%a5]9
8000746a:	8b 02 20 22 	ne %d2,%d2,0
8000746e:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
80007472:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
80007474:	b9 54 00 00 	ld.hu %d4,[%a5]0
80007478:	1d ff 98 ff 	j 800073a8 <IfxScuWdt_setCpuEndinit>

8000747c <IfxScuWdt_serviceCpuWatchdog>:
}


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
8000747c:	1d ff 96 ff 	j 800073a8 <IfxScuWdt_setCpuEndinit>

80007480 <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007480:	91 30 00 ff 	movh.a %a15,61443
80007484:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007488:	4c f0       	ld.w %d15,[%a15]0
8000748a:	06 24       	sh %d4,2
8000748c:	2e 16       	jz.t %d15,1,80007498 <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000748e:	4c f0       	ld.w %d15,[%a15]0
80007490:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007494:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007496:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007498:	91 30 00 ff 	movh.a %a15,61443
8000749c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800074a0:	4c f0       	ld.w %d15,[%a15]0
800074a2:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800074a6:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800074a8:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800074aa:	4c f0       	ld.w %d15,[%a15]0
800074ac:	6f 0f ff 7f 	jz.t %d15,0,800074aa <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
800074b0:	00 90       	ret 

800074b2 <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
800074b2:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
800074b4:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
800074b6:	6f 12 0b 00 	jz.t %d2,1,800074cc <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800074ba:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
800074be:	37 02 6e 31 	extr.u %d3,%d2,2,14
800074c2:	8f f3 83 31 	xor %d3,%d3,63
800074c6:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800074ca:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
800074cc:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
800074ce:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
800074d2:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
800074d6:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
800074da:	b9 53 02 00 	ld.hu %d3,[%a5]2
800074de:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
800074e2:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
800074e4:	54 42       	ld.w %d2,[%a4]
800074e6:	6f 02 ff ff 	jnz.t %d2,0,800074e4 <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
800074ea:	39 52 04 00 	ld.bu %d2,[%a5]4
800074ee:	df 12 0a 00 	jeq %d2,1,80007502 <IfxScuWdt_initSafetyWatchdog+0x50>
800074f2:	76 26       	jz %d2,800074fe <IfxScuWdt_initSafetyWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
800074f4:	8b 22 20 22 	ne %d2,%d2,2
800074f8:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
800074fc:	3c 07       	j 8000750a <IfxScuWdt_initSafetyWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
800074fe:	82 0f       	mov %d15,0
        break;
80007500:	3c 05       	j 8000750a <IfxScuWdt_initSafetyWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
80007502:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
80007506:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
8000750a:	39 52 05 00 	ld.bu %d2,[%a5]5
8000750e:	8b 02 20 22 	ne %d2,%d2,0
80007512:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
80007516:	39 52 06 00 	ld.bu %d2,[%a5]6
8000751a:	8b 02 20 22 	ne %d2,%d2,0
8000751e:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
80007522:	39 52 07 00 	ld.bu %d2,[%a5]7
80007526:	8b 02 20 22 	ne %d2,%d2,0
8000752a:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
8000752e:	39 52 08 00 	ld.bu %d2,[%a5]8
80007532:	8b 02 20 22 	ne %d2,%d2,0
80007536:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
8000753a:	39 52 09 00 	ld.bu %d2,[%a5]9
8000753e:	8b 02 20 22 	ne %d2,%d2,0
80007542:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 0 : 1;
80007546:	39 52 0a 00 	ld.bu %d2,[%a5]10
8000754a:	8b 02 00 22 	eq %d2,%d2,0
8000754e:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
80007552:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
80007554:	b9 54 00 00 	ld.hu %d4,[%a5]0
80007558:	1d ff 94 ff 	j 80007480 <IfxScuWdt_setSafetyEndinit>

8000755c <IfxScuWdt_serviceSafetyWatchdog>:
}


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
8000755c:	1d ff 92 ff 	j 80007480 <IfxScuWdt_setSafetyEndinit>

80007560 <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
80007560:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
80007564:	2e 07       	jz.t %d15,0,80007572 <IfxScuWdt_enableWatchdogWithDebugger+0x12>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
80007566:	3b 00 00 f3 	mov %d15,12288
8000756a:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
8000756e:	82 0f       	mov %d15,0
80007570:	3c 11       	j 80007592 <IfxScuWdt_enableWatchdogWithDebugger+0x32>

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
80007572:	3b 10 0a 20 	mov %d2,161
80007576:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
8000757a:	da 5e       	mov %d15,94
8000757c:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
80007580:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
80007584:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
80007588:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
8000758c:	6f 0f ed ff 	jnz.t %d15,0,80007566 <IfxScuWdt_enableWatchdogWithDebugger+0x6>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
80007590:	82 1f       	mov %d15,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
80007592:	85 f2 40 20 	ld.w %d2,f0000480 <_SMALL_DATA4_+0x3fff8480>
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
80007596:	37 02 e1 23 	extr.u %d2,%d2,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
8000759a:	ab 1f 80 22 	sel %d2,%d2,%d15,1
8000759e:	00 90       	ret 

800075a0 <IfxVadc_Adc_deInitGroup>:
    Ifx_VADC_G     *vadcG      = IfxVadc_Adc_getGroupRegsFromGroup(group);
    /* Get group index */
    IfxVadc_GroupId groupIndex = group->groupId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800075a0:	0c 48       	ld.bu %d15,[%a4]8
800075a2:	d4 4c       	ld.a %a12,[%a4]
800075a4:	1b 0f 01 f0 	addi %d15,%d15,16
800075a8:	16 ff       	and %d15,255
800075aa:	99 4d 04 00 	ld.a %a13,[%a4]4
800075ae:	02 f4       	mov %d4,%d15
800075b0:	40 c4       	mov.aa %a4,%a12
800075b2:	6d ff 91 e8 	call 800046d4 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_resetGroup(Ifx_VADC_G *vadcG)
{
    vadcG->ARBCFG.B.ANONC = IfxVadc_AnalogConverterMode_off;   /* turn off group */
800075b6:	54 d2       	ld.w %d2,[%a13]
    IfxVadc_resetGroup(vadcG);
    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800075b8:	40 c4       	mov.aa %a4,%a12
800075ba:	8f 32 c0 21 	andn %d2,%d2,3
800075be:	74 d2       	st.w [%a13],%d2
800075c0:	02 f4       	mov %d4,%d15
800075c2:	1d ff 6d e8 	j 8000469c <IfxVadc_disableAccess>

800075c6 <IfxVadc_Adc_disableModule>:
}


void IfxVadc_Adc_disableModule(Ifx_VADC *vadc)
{
800075c6:	40 4f       	mov.aa %a15,%a4
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800075c8:	6d ff bb fe 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
800075cc:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800075ce:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
800075d0:	6d ff b7 fd 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.B.DISR = 1;
800075d4:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setCpuEndinit(passwd);
800075d6:	02 f4       	mov %d4,%d15

IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->CLC.B.DISR = 1;
800075d8:	8f 12 40 21 	or %d2,%d2,1
800075dc:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
800075de:	1d ff e5 fe 	j 800073a8 <IfxScuWdt_setCpuEndinit>

800075e2 <IfxVadc_Adc_getChannelConfig>:
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
800075e2:	99 42 04 00 	ld.a %a2,[%a4]4
800075e6:	99 2d 04 00 	ld.a %a13,[%a2]4
    IfxVadc_ChannelId channelIndex = channel->channel;
800075ea:	79 42 00 00 	ld.b %d2,[%a4]0

    config->channelId = channel->channel;
    config->group     = channel->group;
800075ee:	b5 52 14 00 	st.a [%a5]20,%a2


IFX_INLINE Ifx_VADC_CHCTR IfxVadc_getChannelControlConfig(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U = vadcG->CHCTR[channelIndex].U;
800075f2:	1b 02 06 f0 	addi %d15,%d2,96
800075f6:	90 d2       	addsc.a %a2,%a13,%d15,2
void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
    IfxVadc_ChannelId channelIndex = channel->channel;

    config->channelId = channel->channel;
800075f8:	e9 52 0c 00 	st.b [%a5]12,%d2
800075fc:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
800075fe:	40 4c       	mov.aa %a12,%a4

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
80007600:	37 0f 62 30 	extr.u %d3,%d15,0,2
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
80007604:	40 5f       	mov.aa %a15,%a5

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
80007606:	e9 53 0d 00 	st.b [%a5]13,%d3
    config->reference           = (IfxVadc_ChannelReference)tempChctr.B.REFSEL;
8000760a:	37 0f e1 35 	extr.u %d3,%d15,11,1
8000760e:	e9 53 0e 00 	st.b [%a5]14,%d3
    config->resultRegister      = (IfxVadc_ChannelResult)tempChctr.B.RESREG;
80007612:	37 0f 64 38 	extr.u %d3,%d15,16,4
80007616:	e9 53 0f 00 	st.b [%a5]15,%d3
    config->globalResultUsage   = tempChctr.B.RESTBS;
8000761a:	37 0f 61 3a 	extr.u %d3,%d15,20,1
8000761e:	34 53       	st.b [%a5],%d3
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
80007620:	37 0f 62 32 	extr.u %d3,%d15,4,2
80007624:	e9 53 10 00 	st.b [%a5]16,%d3
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
80007628:	37 0f 62 33 	extr.u %d3,%d15,6,2
8000762c:	e9 53 11 00 	st.b [%a5]17,%d3
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
80007630:	37 0f 64 36 	extr.u %d3,%d15,12,4
80007634:	e9 53 12 00 	st.b [%a5]18,%d3
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
80007638:	37 0f 62 34 	extr.u %d3,%d15,8,2
8000763c:	e9 53 13 00 	st.b [%a5]19,%d3
    config->synchonize          = tempChctr.B.SYNC;
80007640:	37 0f 61 35 	extr.u %d3,%d15,10,1
    config->rightAlignedStorage = tempChctr.B.RESPOS;
80007644:	37 0f e1 fa 	extr.u %d15,%d15,21,1
    config->globalResultUsage   = tempChctr.B.RESTBS;
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
    config->synchonize          = tempChctr.B.SYNC;
80007648:	e9 53 01 00 	st.b [%a5]1,%d3
    config->rightAlignedStorage = tempChctr.B.RESPOS;
8000764c:	2c 53       	st.b [%a5]3,%d15


IFX_INLINE Ifx_VADC_G_CHASS IfxVadc_getAssignedChannels(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CHASS assignChannels;
    assignChannels.U = vadcG->CHASS.U;
8000764e:	4c d2       	ld.w %d15,[%a13]8

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
80007650:	57 0f 61 22 	extr.u %d2,%d15,%d2,1
80007654:	8f 12 80 21 	xor %d2,%d2,1
80007658:	e9 52 02 00 	st.b [%a5]2,%d2
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
8000765c:	99 42 04 00 	ld.a %a2,[%a4]4
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
80007660:	79 4f 00 00 	ld.b %d15,[%a4]0


IFX_INLINE Ifx_VADC_G_CEVNP0 IfxVadc_getChannelServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CEVNP0 serviceRequestNodePtr;
    serviceRequestNodePtr.U = vadcG->CEVNP0.U;
80007664:	19 d2 20 40 	ld.w %d2,[%a13]288
80007668:	06 2f       	sh %d15,2
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
8000766a:	57 02 64 ff 	extr.u %d15,%d2,%d15,4
    config->rightAlignedStorage = tempChctr.B.RESPOS;

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
8000766e:	39 28 08 00 	ld.bu %d8,[%a2]8
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
80007672:	0b 8f 10 48 	mov %e4,%d15,%d8
80007676:	6d ff 60 e9 	call 80004936 <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
8000767a:	54 22       	ld.w %d2,[%a2]
8000767c:	6f a2 0a 00 	jz.t %d2,10,80007690 <IfxVadc_Adc_getChannelConfig+0xae>
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)channelServiceRequestNodePtr;
80007680:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)src->B.SRPN;
80007682:	4c 20       	ld.w %d15,[%a2]0
80007684:	16 ff       	and %d15,255
80007686:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)src->B.TOS;
80007688:	4c 20       	ld.w %d15,[%a2]0
8000768a:	37 0f e2 f5 	extr.u %d15,%d15,11,2
8000768e:	3c 05       	j 80007698 <IfxVadc_Adc_getChannelConfig+0xb6>
    }
    else
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)0;
80007690:	82 0f       	mov %d15,0
80007692:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)0;
80007694:	82 0f       	mov %d15,0
80007696:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)0;
80007698:	28 9f       	st.b [%a15]9,%d15
    }

    uint32 resultServiceRequestNodePtr;

    if (config->resultRegister < IfxVadc_ChannelResult_8)
8000769a:	0c ff       	ld.bu %d15,[%a15]15
8000769c:	79 c2 00 00 	ld.b %d2,[%a12]0
800076a0:	ff 8f 08 80 	jge.u %d15,8,800076b0 <IfxVadc_Adc_getChannelConfig+0xce>


IFX_INLINE Ifx_VADC_G_REVNP0 IfxVadc_getChannelResultServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP0 resultServiceRequestNodePtr0;
    resultServiceRequestNodePtr0.U = vadcG->REVNP0.U;
800076a4:	19 df 30 40 	ld.w %d15,[%a13]304
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
800076a8:	06 22       	sh %d2,2
800076aa:	57 0f 64 f2 	extr.u %d15,%d15,%d2,4
800076ae:	3c 08       	j 800076be <IfxVadc_Adc_getChannelConfig+0xdc>
    }
    else
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer1(vadcG)).U >> ((channel->channel - IfxVadc_ChannelResult_8) * 4)) & 0xF;
800076b0:	9a 82       	add %d15,%d2,-8


IFX_INLINE Ifx_VADC_G_REVNP1 IfxVadc_getChannelResultServiceRequestNodePointer1(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP1 resultServiceRequestNodePtr1;
    resultServiceRequestNodePtr1.U = vadcG->REVNP1.U;
800076b2:	19 d3 34 40 	ld.w %d3,[%a13]308
800076b6:	8f 2f 00 20 	sh %d2,%d15,2
800076ba:	57 03 64 f2 	extr.u %d15,%d3,%d2,4
    }

    src = IfxVadc_getSrcAddress(groupIndex, resultServiceRequestNodePtr);
800076be:	16 ff       	and %d15,255
800076c0:	0b 8f 10 48 	mov %e4,%d15,%d8
800076c4:	6d ff 39 e9 	call 80004936 <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
800076c8:	54 22       	ld.w %d2,[%a2]
800076ca:	6f a2 0a 00 	jz.t %d2,10,800076de <IfxVadc_Adc_getChannelConfig+0xfc>
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)resultServiceRequestNodePtr;
800076ce:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)src->B.SRPN;
800076d0:	4c 20       	ld.w %d15,[%a2]0
800076d2:	16 ff       	and %d15,255
800076d4:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)src->B.TOS;
800076d6:	4c 20       	ld.w %d15,[%a2]0
800076d8:	37 0f e2 f5 	extr.u %d15,%d15,11,2
800076dc:	3c 05       	j 800076e6 <IfxVadc_Adc_getChannelConfig+0x104>
    }
    else
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)0;
800076de:	82 0f       	mov %d15,0
800076e0:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)0;
800076e2:	82 0f       	mov %d15,0
800076e4:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)0;
800076e6:	28 8f       	st.b [%a15]8,%d15
800076e8:	00 90       	ret 

800076ea <IfxVadc_Adc_getChannelConversionTime>:
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
800076ea:	cc 41       	ld.a %a15,[%a4]4
800076ec:	c8 12       	ld.a %a2,[%a15]4
}


IFX_INLINE IfxVadc_InputClasses IfxVadc_getChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    return (IfxVadc_InputClasses)vadcG->CHCTR[channelIndex].B.ICLSEL;
800076ee:	79 4f 00 00 	ld.b %d15,[%a4]0
800076f2:	08 8a       	ld.bu %d10,[%a15]8
800076f4:	c8 0f       	ld.a %a15,[%a15]0
800076f6:	1b 0f 06 f0 	addi %d15,%d15,96
800076fa:	90 22       	addsc.a %a2,%a2,%d15,2
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
800076fc:	20 08       	sub.a %sp,8
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
800076fe:	40 f4       	mov.aa %a4,%a15
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
80007700:	02 49       	mov %d9,%d4
80007702:	54 28       	ld.w %d8,[%a2]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007704:	6d ff 9a e8 	call 80004838 <IfxVadc_getAdcAnalogFrequency>
80007708:	02 2f       	mov %d15,%d2
8000770a:	6d ff b0 e8 	call 8000486a <IfxVadc_getAdcModuleFrequency>
8000770e:	8f 38 00 81 	and %d8,%d8,3
80007712:	74 a9       	st.w [%sp],%d9
80007714:	40 f4       	mov.aa %a4,%a15
80007716:	0b a8 10 48 	mov %e4,%d8,%d10
8000771a:	0b f2 10 68 	mov %e6,%d2,%d15
}
8000771e:	1d ff c1 e9 	j 80004aa0 <IfxVadc_getChannelConversionTime>

80007722 <IfxVadc_Adc_getGroupConfig>:

void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
80007722:	d4 4d       	ld.a %a13,[%a4]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
80007724:	40 4e       	mov.aa %a14,%a4
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
80007726:	99 4c 04 00 	ld.a %a12,[%a4]4
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
8000772a:	40 d4       	mov.aa %a4,%a13
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
8000772c:	40 5f       	mov.aa %a15,%a5
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
8000772e:	6d ff 85 e8 	call 80004838 <IfxVadc_getAdcAnalogFrequency>

    config->groupId                    = group->groupId;
80007732:	0c e8       	ld.bu %d15,[%a14]8
    config->module                     = &group->module;
80007734:	e8 0e       	st.a [%a15]0,%a14
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);

    config->groupId                    = group->groupId;
80007736:	28 4f       	st.b [%a15]4,%d15
}


IFX_INLINE IfxVadc_ArbitrationRounds IfxVadc_getArbiterRoundLength(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_ArbitrationRounds)vadcG->ARBCFG.B.ARBRND;
80007738:	4c c0       	ld.w %d15,[%a12]0
8000773a:	37 0f 62 f2 	extr.u %d15,%d15,4,2
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);
8000773e:	e9 ff 32 00 	st.b [%a15]50,%d15
80007742:	82 0f       	mov %d15,0
}


IFX_INLINE IfxVadc_ChannelResolution IfxVadc_getGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum)
{
    return (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
80007744:	1b 8f 00 30 	addi %d3,%d15,8
80007748:	01 c3 02 26 	addsc.a %a2,%a12,%d3,2

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
8000774c:	d0 f3       	addsc.a %a3,%a15,%d15,3
8000774e:	54 23       	ld.w %d3,[%a2]
80007750:	37 03 63 34 	extr.u %d3,%d3,8,3
80007754:	e9 33 0c 00 	st.b [%a3]12,%d3
}


IFX_INLINE float32 IfxVadc_getGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = vadcG->ICLASS[inputClassNum].B.STCS;
80007758:	54 23       	ld.w %d3,[%a2]
8000775a:	8f f3 01 31 	and %d3,%d3,31

    if (sampleTime > 16)
8000775e:	8b 13 61 42 	lt.u %d4,%d3,17
80007762:	f6 44       	jnz %d4,8000776a <IfxVadc_Adc_getGroupConfig+0x48>
    {
        sampleTime = (sampleTime - 15) * 16;
80007764:	1b 13 ff 3f 	addi %d3,%d3,-15
80007768:	06 43       	sh %d3,4
    }

    return (float32)(IFXVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
8000776a:	c2 23       	add %d3,2
8000776c:	4b 03 41 31 	itof %d3,%d3
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
80007770:	92 14       	add %d4,%d15,1
80007772:	4b 23 51 30 	div.f %d3,%d3,%d2
80007776:	01 f4 03 26 	addsc.a %a2,%a15,%d4,3
8000777a:	74 23       	st.w [%a2],%d3
    config->groupId                    = group->groupId;
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
8000777c:	1e 13       	jeq %d15,1,80007782 <IfxVadc_Adc_getGroupConfig+0x60>
8000777e:	82 1f       	mov %d15,1
80007780:	3c e2       	j 80007744 <IfxVadc_Adc_getGroupConfig+0x22>
}


IFX_INLINE boolean IfxVadc_isRequestScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN1;
80007782:	19 c2 04 00 	ld.w %d2,[%a12]4
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
    }

    if (IfxVadc_isRequestScanSlotEnabled(vadcG) == TRUE)
80007786:	ef 92 33 00 	jz.t %d2,25,800077ec <IfxVadc_Adc_getGroupConfig+0xca>
    {
        config->arbiter.requestSlotScanEnabled          = TRUE;
8000778a:	e9 ff 34 00 	st.b [%a15]52,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO1;
8000778e:	19 c2 04 00 	ld.w %d2,[%a12]4
80007792:	37 02 62 22 	extr.u %d2,%d2,4,2
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
80007796:	e9 f2 1e 00 	st.b [%a15]30,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM1;
8000779a:	19 c2 04 00 	ld.w %d2,[%a12]4
8000779e:	37 02 e1 23 	extr.u %d2,%d2,7,1
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);
800077a2:	e9 f2 1f 00 	st.b [%a15]31,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getScanSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->ASCTRL.B.XTSEL;
800077a6:	19 c3 20 20 	ld.w %d3,[%a12]160
800077aa:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
800077ae:	e9 f3 1b 00 	st.b [%a15]27,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getScanSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->ASCTRL.B.XTMODE;
800077b2:	19 c2 20 20 	ld.w %d2,[%a12]160
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800077b6:	8b f3 00 32 	eq %d3,%d3,15
800077ba:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotScanEnabled          = TRUE;
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);
800077be:	e9 f2 1d 00 	st.b [%a15]29,%d2

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800077c2:	f6 35       	jnz %d3,800077cc <IfxVadc_Adc_getGroupConfig+0xaa>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getScanSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->ASMR.B.ENGT;
800077c4:	19 cf 24 20 	ld.w %d15,[%a12]164
800077c8:	16 03       	and %d15,3
800077ca:	3c 02       	j 800077ce <IfxVadc_Adc_getGroupConfig+0xac>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_getScanSlotGatingMode(vadcG);
        }
        else if (config->scanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800077cc:	76 23       	jz %d2,800077d2 <IfxVadc_Adc_getGroupConfig+0xb0>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800077ce:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getScanSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->ASCTRL.B.GTSEL;
800077d2:	19 cf 20 20 	ld.w %d15,[%a12]160
800077d6:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->scanRequest.triggerConfig.gatingSource = IfxVadc_getScanSlotGatingSource(vadcG);
800077da:	e9 ff 1a 00 	st.b [%a15]26,%d15
}


IFX_INLINE boolean IfxVadc_isAutoScanEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ASMR.B.SCAN;
800077de:	19 cf 24 20 	ld.w %d15,[%a12]164
800077e2:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->scanRequest.autoscanEnabled            = IfxVadc_isAutoScanEnabled(vadcG);
800077e6:	e9 ff 18 00 	st.b [%a15]24,%d15
800077ea:	3c 0c       	j 80007802 <IfxVadc_Adc_getGroupConfig+0xe0>
    }
    else
    {
        config->scanRequest.autoscanEnabled             = FALSE;
800077ec:	82 0f       	mov %d15,0
800077ee:	e9 ff 18 00 	st.b [%a15]24,%d15
        config->scanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
800077f2:	e9 ff 1c 00 	st.b [%a15]28,%d15
        config->scanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;    /* Use CCU6061 TRIG0 */
800077f6:	e9 ff 1a 00 	st.b [%a15]26,%d15
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800077fa:	e9 ff 1d 00 	st.b [%a15]29,%d15
        config->scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;   /* Trigger source taken from Gating Input */
800077fe:	e9 ff 1b 00 	st.b [%a15]27,%d15
}


IFX_INLINE boolean IfxVadc_isRequestQueueSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN0;
80007802:	4c c1       	ld.w %d15,[%a12]4
80007804:	37 0f 61 fc 	extr.u %d15,%d15,24,1
    }

    if (IfxVadc_isRequestQueueSlotEnabled(vadcG) == TRUE)
80007808:	df 1f 30 80 	jne %d15,1,80007868 <IfxVadc_Adc_getGroupConfig+0x146>
    {
        config->arbiter.requestSlotQueueEnabled          = TRUE;
8000780c:	e9 ff 33 00 	st.b [%a15]51,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getQueueSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO0;
80007810:	19 c2 04 00 	ld.w %d2,[%a12]4
80007814:	8f 32 00 21 	and %d2,%d2,3
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
80007818:	e9 f2 26 00 	st.b [%a15]38,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getQueueSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM0;
8000781c:	19 c2 04 00 	ld.w %d2,[%a12]4
80007820:	37 02 e1 21 	extr.u %d2,%d2,3,1
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);
80007824:	e9 f2 27 00 	st.b [%a15]39,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getQueueSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->QCTRL0.B.XTSEL;
80007828:	19 c3 00 20 	ld.w %d3,[%a12]128
8000782c:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
80007830:	e9 f3 23 00 	st.b [%a15]35,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getQueueSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->QCTRL0.B.XTMODE;
80007834:	19 c2 00 20 	ld.w %d2,[%a12]128
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007838:	8b f3 00 32 	eq %d3,%d3,15
8000783c:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotQueueEnabled          = TRUE;
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);
80007840:	e9 f2 25 00 	st.b [%a15]37,%d2

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007844:	f6 35       	jnz %d3,8000784e <IfxVadc_Adc_getGroupConfig+0x12c>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getQueueSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->QMR0.B.ENGT;
80007846:	19 cf 04 20 	ld.w %d15,[%a12]132
8000784a:	16 03       	and %d15,3
8000784c:	3c 02       	j 80007850 <IfxVadc_Adc_getGroupConfig+0x12e>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_getQueueSlotGatingMode(vadcG);
        }
        else if (config->queueRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
8000784e:	76 23       	jz %d2,80007854 <IfxVadc_Adc_getGroupConfig+0x132>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80007850:	e9 ff 24 00 	st.b [%a15]36,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getQueueSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->QCTRL0.B.GTSEL;
80007854:	19 cf 00 20 	ld.w %d15,[%a12]128
80007858:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->queueRequest.triggerConfig.gatingSource = IfxVadc_getQueueSlotGatingSource(vadcG);
8000785c:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.flushQueueAfterInit        = FALSE;
80007860:	82 0f       	mov %d15,0
80007862:	e9 ff 20 00 	st.b [%a15]32,%d15
80007866:	3c 0c       	j 8000787e <IfxVadc_Adc_getGroupConfig+0x15c>
    }
    else
    {
        config->queueRequest.flushQueueAfterInit         = FALSE;
80007868:	82 0f       	mov %d15,0
8000786a:	e9 ff 20 00 	st.b [%a15]32,%d15
        config->queueRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
8000786e:	e9 ff 24 00 	st.b [%a15]36,%d15
        config->queueRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;        /* Use CCU6061 TRIG0 */
80007872:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
80007876:	e9 ff 25 00 	st.b [%a15]37,%d15
        config->queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;       /* Trigger source taken from Gating Input */
8000787a:	e9 ff 23 00 	st.b [%a15]35,%d15
}


IFX_INLINE boolean IfxVadc_isRequestBackgroundScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN2;
8000787e:	4c c1       	ld.w %d15,[%a12]4
80007880:	37 0f 61 fd 	extr.u %d15,%d15,26,1
    }

    if (IfxVadc_isRequestBackgroundScanSlotEnabled(vadcG) == TRUE)
80007884:	df 1f 33 80 	jne %d15,1,800078ea <IfxVadc_Adc_getGroupConfig+0x1c8>
    {
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
80007888:	e9 ff 35 00 	st.b [%a15]53,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getBackgroundScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO2;
8000788c:	19 c2 04 00 	ld.w %d2,[%a12]4
80007890:	37 02 62 24 	extr.u %d2,%d2,8,2
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
80007894:	e9 f2 2e 00 	st.b [%a15]46,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getBackgroundScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM2;
80007898:	19 c2 04 00 	ld.w %d2,[%a12]4
8000789c:	37 02 e1 25 	extr.u %d2,%d2,11,1
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);
800078a0:	e9 f2 2f 00 	st.b [%a15]47,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getBackgroundScanTriggerInput(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerSource)vadc->BRSCTRL.B.XTSEL;
800078a4:	19 d3 00 80 	ld.w %d3,[%a13]512
800078a8:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
800078ac:	e9 f3 2b 00 	st.b [%a15]43,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getBackgroundScanTriggerMode(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerMode)vadc->BRSCTRL.B.XTMODE;
800078b0:	19 d2 00 80 	ld.w %d2,[%a13]512
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800078b4:	8b f3 00 32 	eq %d3,%d3,15
800078b8:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);
800078bc:	e9 f2 2d 00 	st.b [%a15]45,%d2

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800078c0:	f6 35       	jnz %d3,800078ca <IfxVadc_Adc_getGroupConfig+0x1a8>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getBackgroundScanGatingMode(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingMode)vadc->BRSMR.B.ENGT;
800078c2:	19 df 04 80 	ld.w %d15,[%a13]516
800078c6:	16 03       	and %d15,3
800078c8:	3c 02       	j 800078cc <IfxVadc_Adc_getGroupConfig+0x1aa>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_getBackgroundScanGatingMode(vadc);
        }
        else if (config->backgroundScanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800078ca:	76 23       	jz %d2,800078d0 <IfxVadc_Adc_getGroupConfig+0x1ae>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800078cc:	e9 ff 2c 00 	st.b [%a15]44,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getBackgroundScanGatingSource(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingSource)vadc->BRSCTRL.B.GTSEL;
800078d0:	19 df 00 80 	ld.w %d15,[%a13]512
800078d4:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->backgroundScanRequest.triggerConfig.gatingSource = IfxVadc_getBackgroundScanGatingSource(vadc);
800078d8:	e9 ff 2a 00 	st.b [%a15]42,%d15
}


IFX_INLINE boolean IfxVadc_isAutoBackgroundScanEnabled(Ifx_VADC *vadc)
{
    return (boolean)vadc->BRSMR.B.SCAN;
800078dc:	19 df 04 80 	ld.w %d15,[%a13]516
800078e0:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->backgroundScanRequest.autoBackgroundScanEnabled  = IfxVadc_isAutoBackgroundScanEnabled(vadc);
800078e4:	e9 ff 28 00 	st.b [%a15]40,%d15
800078e8:	3c 0c       	j 80007900 <IfxVadc_Adc_getGroupConfig+0x1de>
    }
    else
    {
        config->backgroundScanRequest.autoBackgroundScanEnabled   = FALSE;
800078ea:	82 0f       	mov %d15,0
800078ec:	e9 ff 28 00 	st.b [%a15]40,%d15
        config->backgroundScanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
800078f0:	e9 ff 2c 00 	st.b [%a15]44,%d15
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
800078f4:	e9 ff 2a 00 	st.b [%a15]42,%d15
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800078f8:	e9 ff 2d 00 	st.b [%a15]45,%d15
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
800078fc:	e9 ff 2b 00 	st.b [%a15]43,%d15


IFX_INLINE uint8 IfxVadc_getMasterIndex(Ifx_VADC_G *vadcG)
{
    uint8 masterIndex = 0;
    masterIndex = vadcG->SYNCTR.B.STSEL;
80007900:	19 c3 00 10 	ld.w %d3,[%a12]64
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
80007904:	39 e7 08 00 	ld.bu %d7,[%a14]8
80007908:	8f 33 00 31 	and %d3,%d3,3
8000790c:	02 72       	mov %d2,%d7
IFX_INLINE IfxVadc_GroupId IfxVadc_Adc_getMasterId(IfxVadc_GroupId slave, IfxVadc_Adc_SYNCTR_STSEL masterIndex)
{
    uint8           i, idxOffset;
    IfxVadc_GroupId masterId = slave;

    if (masterIndex == 0)
8000790e:	df 03 1f 00 	jeq %d3,0,8000794c <IfxVadc_Adc_getGroupConfig+0x22a>
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007912:	7b 00 00 58 	movh %d5,32768
80007916:	1b 45 d5 50 	addi %d5,%d5,3412
8000791a:	13 87 20 55 	madd %d5,%d5,%d7,8
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
8000791e:	8b 47 60 42 	lt.u %d4,%d7,4
80007922:	82 02       	mov %d2,0
80007924:	ab 42 80 24 	sel %d2,%d4,%d2,4

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007928:	1a 25       	add %d15,%d5,%d2
8000792a:	60 f4       	mov.a %a4,%d15
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
8000792c:	82 04       	mov %d4,0

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
8000792e:	a0 32       	mov.a %a2,3
80007930:	01 44 00 36 	addsc.a %a3,%a4,%d4,0
80007934:	8f f4 0f 61 	and %d6,%d4,255
80007938:	14 35       	ld.bu %d5,[%a3]
8000793a:	5f 35 06 80 	jne %d5,%d3,80007946 <IfxVadc_Adc_getGroupConfig+0x224>
            {
                return (IfxVadc_GroupId)(i + idxOffset);
8000793e:	42 62       	add %d2,%d6
80007940:	8f f2 0f 21 	and %d2,%d2,255
80007944:	3c 04       	j 8000794c <IfxVadc_Adc_getGroupConfig+0x22a>
80007946:	c2 14       	add %d4,1
80007948:	fc 24       	loop %a2,80007930 <IfxVadc_Adc_getGroupConfig+0x20e>
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
8000794a:	02 72       	mov %d2,%d7
8000794c:	28 52       	st.b [%a15]5,%d2


IFX_INLINE Ifx_VADC_GLOBCFG IfxVadc_getGlobalConfigValue(Ifx_VADC *vadc)
{
    Ifx_VADC_GLOBCFG globCfg;
    globCfg.U = vadc->GLOBCFG.U;
8000794e:	19 d2 00 20 	ld.w %d2,[%a13]128

    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
80007952:	1b 07 01 f0 	addi %d15,%d7,16
80007956:	57 02 61 ff 	extr.u %d15,%d2,%d15,1
8000795a:	e9 ff 30 00 	st.b [%a15]48,%d15
8000795e:	00 90       	ret 

80007960 <IfxVadc_Adc_initChannel>:


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
80007960:	99 52 14 00 	ld.a %a2,[%a5]20
80007964:	d4 2e       	ld.a %a14,[%a2]
80007966:	99 2c 04 00 	ld.a %a12,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
8000796a:	39 28 08 00 	ld.bu %d8,[%a2]8
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
8000796e:	b5 42 04 00 	st.a [%a4]4,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80007972:	02 84       	mov %d4,%d8
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
80007974:	40 4d       	mov.aa %a13,%a4
    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80007976:	40 e4       	mov.aa %a4,%a14
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
80007978:	40 5f       	mov.aa %a15,%a5
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;
8000797a:	79 59 0c 00 	ld.b %d9,[%a5]12

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
8000797e:	6d ff ab e6 	call 800046d4 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
80007982:	1b 09 06 20 	addi %d2,%d9,96
80007986:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
8000798a:	0c fe       	ld.bu %d15,[%a15]14
8000798c:	54 22       	ld.w %d2,[%a2]
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000798e:	40 e4       	mov.aa %a4,%a14
80007990:	67 f2 0b f0 	ins.t %d15,%d2,11,%d15,0
80007994:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
80007996:	54 22       	ld.w %d2,[%a2]
80007998:	0c ff       	ld.bu %d15,[%a15]15
8000799a:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
8000799e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setLowerBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection lowerBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
800079a0:	54 22       	ld.w %d2,[%a2]
800079a2:	39 ff 10 00 	ld.bu %d15,[%a15]16
800079a6:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
800079aa:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setUpperBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection upperBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
800079ac:	54 22       	ld.w %d2,[%a2]
800079ae:	39 ff 11 00 	ld.bu %d15,[%a15]17
800079b2:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
800079b6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setSyncRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean synchonize)
{
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
800079b8:	54 22       	ld.w %d2,[%a2]
800079ba:	0c f1       	ld.bu %d15,[%a15]1
800079bc:	67 f2 0a f0 	ins.t %d15,%d2,10,%d15,0
800079c0:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_InputClasses inputClass)
{
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
800079c2:	54 22       	ld.w %d2,[%a2]
800079c4:	0c fd       	ld.bu %d15,[%a15]13
800079c6:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
800079ca:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelLimitCheckMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_LimitCheck limitCheck)
{
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
800079cc:	54 22       	ld.w %d2,[%a2]
800079ce:	39 ff 13 00 	ld.bu %d15,[%a15]19
800079d2:	37 f2 02 f4 	insert %d15,%d2,%d15,8,2
800079d6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setResultPosition(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean rightAlignedStorage)
{
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
800079d8:	54 22       	ld.w %d2,[%a2]
800079da:	0c f3       	ld.bu %d15,[%a15]3
800079dc:	67 f2 15 f0 	ins.t %d15,%d2,21,%d15,0
800079e0:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBackgroundResultTarget(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean globalResultUsage)
{
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
800079e2:	54 22       	ld.w %d2,[%a2]
800079e4:	0c f0       	ld.bu %d15,[%a15]0
800079e6:	67 f2 14 f0 	ins.t %d15,%d2,20,%d15,0
800079ea:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBoundaryMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundaryExtension boundaryMode)
{
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
800079ec:	54 22       	ld.w %d2,[%a2]
800079ee:	39 ff 12 00 	ld.bu %d15,[%a15]18
800079f2:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
800079f6:	6c 20       	st.w [%a2]0,%d15
800079f8:	1b 08 01 f0 	addi %d15,%d8,16
800079fc:	16 ff       	and %d15,255
800079fe:	02 f4       	mov %d4,%d15
80007a00:	6d ff 6a e6 	call 800046d4 <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
80007a04:	08 23       	ld.bu %d3,[%a15]2
80007a06:	82 12       	mov %d2,1
80007a08:	0f 92 00 20 	sh %d2,%d2,%d9
80007a0c:	f6 35       	jnz %d3,80007a16 <IfxVadc_Adc_initChannel+0xb6>
}


IFX_INLINE void IfxVadc_setGroupPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U |= (1 << channelIndex);
80007a0e:	19 c3 08 00 	ld.w %d3,[%a12]8
80007a12:	a6 32       	or %d2,%d3
80007a14:	3c 05       	j 80007a1e <IfxVadc_Adc_initChannel+0xbe>
}


IFX_INLINE void IfxVadc_setBackgroundPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U &= ~(1 << channelIndex);
80007a16:	19 c3 08 00 	ld.w %d3,[%a12]8
80007a1a:	0f 23 e0 20 	andn %d2,%d3,%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007a1e:	02 f4       	mov %d4,%d15
80007a20:	59 c2 08 00 	st.w [%a12]8,%d2
80007a24:	40 e4       	mov.aa %a4,%a14
80007a26:	6d ff 3b e6 	call 8000469c <IfxVadc_disableAccess>
}


IFX_INLINE void IfxVadc_setChannelEventNodePointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr channelSrcNr, IfxVadc_ChannelId channel)
{
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
80007a2a:	79 d3 00 00 	ld.b %d3,[%a13]0
80007a2e:	19 c5 20 40 	ld.w %d5,[%a12]288
80007a32:	8f 23 00 f0 	sh %d15,%d3,2
80007a36:	3b f0 00 20 	mov %d2,15
80007a3a:	0f f2 00 20 	sh %d2,%d2,%d15
80007a3e:	0f 25 e0 20 	andn %d2,%d5,%d2

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
80007a42:	08 b4       	ld.bu %d4,[%a15]11
80007a44:	59 c2 20 40 	st.w [%a12]288,%d2
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
80007a48:	19 c2 20 40 	ld.w %d2,[%a12]288
80007a4c:	0f f4 00 f0 	sh %d15,%d4,%d15
80007a50:	a6 2f       	or %d15,%d2
80007a52:	59 cf 20 40 	st.w [%a12]288,%d15

    if (config->channelPriority > 0)
80007a56:	b9 ff 06 00 	ld.hu %d15,[%a15]6
80007a5a:	6e 1f       	jz %d15,80007a98 <IfxVadc_Adc_initChannel+0x138>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
80007a5c:	02 84       	mov %d4,%d8
80007a5e:	08 b5       	ld.bu %d5,[%a15]11
80007a60:	6d ff 6b e7 	call 80004936 <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_clearChannelRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelId)
{
    vadcG->CEFCLR.U = 1 << channelId;
80007a64:	79 f2 0c 00 	ld.b %d2,[%a15]12
80007a68:	82 1f       	mov %d15,1
80007a6a:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007a6e:	59 cf 10 40 	st.w [%a12]272,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007a72:	54 22       	ld.w %d2,[%a2]
80007a74:	08 63       	ld.bu %d3,[%a15]6
80007a76:	8f f2 cf 21 	andn %d2,%d2,255
80007a7a:	a6 32       	or %d2,%d3

        IfxVadc_clearChannelRequest(vadcG, config->channelId);
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
80007a7c:	0c f9       	ld.bu %d15,[%a15]9
80007a7e:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007a80:	54 22       	ld.w %d2,[%a2]
80007a82:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007a86:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007a88:	4c 20       	ld.w %d15,[%a2]0
80007a8a:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007a8e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007a90:	4c 20       	ld.w %d15,[%a2]0
80007a92:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007a96:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80007a98:	0c ff       	ld.bu %d15,[%a15]15
80007a9a:	08 a2       	ld.bu %d2,[%a15]10
80007a9c:	ff 8f 15 80 	jge.u %d15,8,80007ac6 <IfxVadc_Adc_initChannel+0x166>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80007aa0:	19 c4 30 40 	ld.w %d4,[%a12]304
80007aa4:	06 2f       	sh %d15,2
80007aa6:	3b f0 00 30 	mov %d3,15
80007aaa:	0f f3 00 30 	sh %d3,%d3,%d15
80007aae:	0f 34 e0 30 	andn %d3,%d4,%d3
80007ab2:	59 c3 30 40 	st.w [%a12]304,%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
80007ab6:	19 c3 30 40 	ld.w %d3,[%a12]304
80007aba:	0f f2 00 f0 	sh %d15,%d2,%d15
80007abe:	a6 3f       	or %d15,%d3
80007ac0:	59 cf 30 40 	st.w [%a12]304,%d15
80007ac4:	3c 14       	j 80007aec <IfxVadc_Adc_initChannel+0x18c>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer1(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007ac6:	c2 8f       	add %d15,-8
80007ac8:	19 c4 34 40 	ld.w %d4,[%a12]308
80007acc:	06 2f       	sh %d15,2
80007ace:	3b f0 00 30 	mov %d3,15
80007ad2:	0f f3 00 30 	sh %d3,%d3,%d15
80007ad6:	0f 34 e0 30 	andn %d3,%d4,%d3
80007ada:	59 c3 34 40 	st.w [%a12]308,%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007ade:	19 c3 34 40 	ld.w %d3,[%a12]308
80007ae2:	0f f2 00 f0 	sh %d15,%d2,%d15
80007ae6:	a6 3f       	or %d15,%d3
80007ae8:	59 cf 34 40 	st.w [%a12]308,%d15
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80007aec:	b9 ff 04 00 	ld.hu %d15,[%a15]4
80007af0:	6e 24       	jz %d15,80007b38 <IfxVadc_Adc_initChannel+0x1d8>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
80007af2:	02 84       	mov %d4,%d8
80007af4:	08 a5       	ld.bu %d5,[%a15]10
80007af6:	6d ff 20 e7 	call 80004936 <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_enableServiceRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelResult resultRegister)
{
    vadcG->RCR[resultRegister].B.SRGEN = 1;
80007afa:	0c ff       	ld.bu %d15,[%a15]15
80007afc:	1b 0f 08 f0 	addi %d15,%d15,128
80007b00:	90 c3       	addsc.a %a3,%a12,%d15,2
80007b02:	4c 30       	ld.w %d15,[%a3]0
80007b04:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80007b08:	6c 30       	st.w [%a3]0,%d15
}


IFX_INLINE void IfxVadc_clearAllResultRequests(Ifx_VADC_G *vadcG)
{
    vadcG->REFCLR.U = 0x0000FFFFu;
80007b0a:	bb f0 ff ff 	mov.u %d15,65535
80007b0e:	59 cf 14 40 	st.w [%a12]276,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007b12:	54 22       	ld.w %d2,[%a2]
80007b14:	08 43       	ld.bu %d3,[%a15]4
80007b16:	8f f2 cf 21 	andn %d2,%d2,255
80007b1a:	a6 32       	or %d2,%d3

        IfxVadc_enableServiceRequest(vadcG, config->resultRegister);
        IfxVadc_clearAllResultRequests(vadcG);
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
80007b1c:	0c f8       	ld.bu %d15,[%a15]8
80007b1e:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007b20:	54 22       	ld.w %d2,[%a2]
80007b22:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007b26:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007b28:	4c 20       	ld.w %d15,[%a2]0
80007b2a:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007b2e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007b30:	4c 20       	ld.w %d15,[%a2]0
80007b32:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007b36:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80007b38:	40 e4       	mov.aa %a4,%a14
80007b3a:	02 84       	mov %d4,%d8
80007b3c:	6d ff b0 e5 	call 8000469c <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007b40:	0c ff       	ld.bu %d15,[%a15]15
    channel->channel   = config->channelId;

    return Status;
}
80007b42:	82 02       	mov %d2,0
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007b44:	2c d1       	st.b [%a13]1,%d15
    channel->channel   = config->channelId;
80007b46:	0c fc       	ld.bu %d15,[%a15]12
80007b48:	2c d0       	st.b [%a13]0,%d15

    return Status;
}
80007b4a:	00 90       	ret 

80007b4c <IfxVadc_Adc_initChannelConfig>:
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
80007b4c:	40 42       	mov.aa %a2,%a4
80007b4e:	d2 02       	mov %e2,0
80007b50:	89 22 48 01 	st.d [%a2+]8,%e2
80007b54:	89 22 48 01 	st.d [%a2+]8,%e2
80007b58:	89 22 48 01 	st.d [%a2+]8,%e2
    config->group = group;
80007b5c:	b5 45 14 00 	st.a [%a4]20,%a5
80007b60:	00 90       	ret 

80007b62 <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80007b62:	d4 52       	ld.a %a2,[%a5]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80007b64:	39 58 04 00 	ld.bu %d8,[%a5]4


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80007b68:	d4 2c       	ld.a %a12,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80007b6a:	8f a8 00 90 	sh %d9,%d8,10
80007b6e:	1b 09 48 f0 	addi %d15,%d9,1152
80007b72:	10 cd       	addsc.a %a13,%a12,%d15,0

    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
80007b74:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];

    /* check for write access */
    group->group   = vadcG;
80007b76:	b5 4d 04 00 	st.a [%a4]4,%a13
    group->module  = *config->module;
80007b7a:	6c 40       	st.w [%a4]0,%d15
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
80007b7c:	e9 48 08 00 	st.b [%a4]8,%d8
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007b80:	40 c4       	mov.aa %a4,%a12
    config->group = group;
}


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
80007b82:	40 5f       	mov.aa %a15,%a5
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007b84:	6d ff 5a e6 	call 80004838 <IfxVadc_getAdcAnalogFrequency>

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007b88:	1b 08 01 f0 	addi %d15,%d8,16
80007b8c:	8f ff 0f a1 	and %d10,%d15,255
80007b90:	40 c4       	mov.aa %a4,%a12
80007b92:	02 a4       	mov %d4,%d10
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007b94:	02 2b       	mov %d11,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007b96:	6d ff 9f e5 	call 800046d4 <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007b9a:	39 ff 33 00 	ld.bu %d15,[%a15]51
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007b9e:	40 d4       	mov.aa %a4,%a13
    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007ba0:	5e 17       	jne %d15,1,80007bae <IfxVadc_Adc_initGroup+0x4c>
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007ba2:	82 14       	mov %d4,1
80007ba4:	39 f5 26 00 	ld.bu %d5,[%a15]38
80007ba8:	39 f6 27 00 	ld.bu %d6,[%a15]39
80007bac:	3c 03       	j 80007bb2 <IfxVadc_Adc_initGroup+0x50>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80007bae:	d2 04       	mov %e4,0
80007bb0:	82 06       	mov %d6,0
80007bb2:	82 07       	mov %d7,0
80007bb4:	6d ff 06 e8 	call 80004bc0 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007bb8:	39 ff 34 00 	ld.bu %d15,[%a15]52
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007bbc:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007bbe:	5e 17       	jne %d15,1,80007bcc <IfxVadc_Adc_initGroup+0x6a>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007bc0:	82 14       	mov %d4,1
80007bc2:	39 f5 1e 00 	ld.bu %d5,[%a15]30
80007bc6:	39 f6 1f 00 	ld.bu %d6,[%a15]31
80007bca:	3c 03       	j 80007bd0 <IfxVadc_Adc_initGroup+0x6e>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80007bcc:	d2 04       	mov %e4,0
80007bce:	82 06       	mov %d6,0
80007bd0:	82 17       	mov %d7,1
80007bd2:	6d ff f7 e7 	call 80004bc0 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007bd6:	39 ff 35 00 	ld.bu %d15,[%a15]53
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007bda:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007bdc:	5e 17       	jne %d15,1,80007bea <IfxVadc_Adc_initGroup+0x88>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007bde:	82 14       	mov %d4,1
80007be0:	39 f5 2e 00 	ld.bu %d5,[%a15]46
80007be4:	39 f6 2f 00 	ld.bu %d6,[%a15]47
80007be8:	3c 03       	j 80007bee <IfxVadc_Adc_initGroup+0x8c>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
80007bea:	d2 04       	mov %e4,0
80007bec:	82 06       	mov %d6,0
80007bee:	82 27       	mov %d7,2
80007bf0:	6d ff e8 e7 	call 80004bc0 <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
80007bf4:	0c f5       	ld.bu %d15,[%a15]5
80007bf6:	be 8b       	jeq %d15,%d8,80007c2c <IfxVadc_Adc_initGroup+0xca>
}


IFX_INLINE IfxVadc_Adc_SYNCTR_STSEL IfxVadc_Adc_getMasterKernelIndex(IfxVadc_GroupId slave, IfxVadc_GroupId master)
{
    return IfxVadc_Adc_masterIndex[slave][master];
80007bf8:	13 88 20 ff 	madd %d15,%d15,%d8,8
80007bfc:	91 00 00 28 	movh.a %a2,32768
80007c00:	d9 22 d4 50 	lea %a2,[%a2]3412 <80000d54 <IfxVadc_Adc_masterIndex>>
80007c04:	10 22       	addsc.a %a2,%a2,%d15,0
80007c06:	0c 20       	ld.bu %d15,[%a2]0
}


IFX_INLINE void IfxVadc_setMasterIndex(Ifx_VADC_G *vadcG, uint8 masterIndex)
{
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80007c08:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007c0c:	8f 3f 00 21 	and %d2,%d15,3
80007c10:	19 23 40 30 	ld.w %d3,[%a2]1216
80007c14:	37 f3 02 f0 	insert %d15,%d3,%d15,0,2
80007c18:	59 2f 40 30 	st.w [%a2]1216,%d15
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
80007c1c:	19 23 40 30 	ld.w %d3,[%a2]1216
80007c20:	da 08       	mov %d15,8
80007c22:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007c26:	a6 3f       	or %d15,%d3
80007c28:	59 2f 40 30 	st.w [%a2]1216,%d15
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007c2c:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007c30:	19 2f 40 20 	ld.w %d15,[%a2]1152
80007c34:	8f 3f c0 f1 	andn %d15,%d15,3
80007c38:	59 2f 40 20 	st.w [%a2]1152,%d15
}


IFX_INLINE void IfxVadc_setArbitrationRoundLength(Ifx_VADC_G *vadcG, IfxVadc_ArbitrationRounds arbiterRoundLength)
{
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80007c3c:	39 ff 32 00 	ld.bu %d15,[%a15]50
80007c40:	19 22 40 20 	ld.w %d2,[%a2]1152
80007c44:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007c48:	59 2f 40 20 	st.w [%a2]1152,%d15
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007c4c:	39 ff 33 00 	ld.bu %d15,[%a15]51
80007c50:	df 1f 5a 80 	jne %d15,1,80007d04 <IfxVadc_Adc_initGroup+0x1a2>
    {
        const IfxVadc_Adc_QueueConfig *queueSlot = &config->queueRequest;

        /* configure external Trigger if enabled */
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007c54:	39 ff 25 00 	ld.bu %d15,[%a15]37
80007c58:	6e 28       	jz %d15,80007ca8 <IfxVadc_Adc_initGroup+0x146>
}


IFX_INLINE void IfxVadc_enableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80007c5a:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007c5e:	96 04       	or %d15,4
80007c60:	59 2f 44 40 	st.w [%a2]1284,%d15


IFX_INLINE void IfxVadc_setQueueSlotTriggerOperatingConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U        = vadcG->QCTRL0.U;
80007c64:	19 23 40 40 	ld.w %d3,[%a2]1280
        {
            /* enable external trigger */
            IfxVadc_enableQueueSlotExternalTrigger(vadcG);
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
80007c68:	39 f2 25 00 	ld.bu %d2,[%a15]37
80007c6c:	39 ff 23 00 	ld.bu %d15,[%a15]35
    qctrl0.B.XTWC   = 1;
80007c70:	b7 13 81 37 	insert %d3,%d3,1,15,1
    qctrl0.B.XTMODE = triggerMode;
80007c74:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    qctrl0.B.XTSEL  = triggerSource;
80007c78:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80007c7c:	59 23 40 40 	st.w [%a2]1280,%d3

            /* if last input is used the trigger input selection is extend by Gating inputs */
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80007c80:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007c84:	8b ff 20 f2 	ne %d15,%d15,15
80007c88:	ee 16       	jnz %d15,80007cb4 <IfxVadc_Adc_initGroup+0x152>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007c8a:	19 23 40 40 	ld.w %d3,[%a2]1280
            {
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007c8e:	39 ff 22 00 	ld.bu %d15,[%a15]34
    qctrl0.B.GTWC      = 1;
80007c92:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007c96:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007c9a:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007c9e:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007ca2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007ca6:	3c 05       	j 80007cb0 <IfxVadc_Adc_initGroup+0x14e>
}


IFX_INLINE void IfxVadc_disableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
80007ca8:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007cac:	8f 4f c0 f1 	andn %d15,%d15,4
80007cb0:	59 2f 44 40 	st.w [%a2]1284,%d15
            /* disable external trigger */
            IfxVadc_disableQueueSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007cb4:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007cb8:	8b ff 00 f2 	eq %d15,%d15,15
80007cbc:	ee 15       	jnz %d15,80007ce6 <IfxVadc_Adc_initGroup+0x184>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007cbe:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80007cc2:	39 f2 22 00 	ld.bu %d2,[%a15]34
80007cc6:	19 23 40 40 	ld.w %d3,[%a2]1280
80007cca:	39 ff 24 00 	ld.bu %d15,[%a15]36
    qctrl0.B.GTWC      = 1;
80007cce:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007cd2:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007cd6:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007cda:	19 22 44 40 	ld.w %d2,[%a2]1284
80007cde:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007ce2:	59 2f 44 40 	st.w [%a2]1284,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80007ce6:	39 f2 20 00 	ld.bu %d2,[%a15]32
}


IFX_INLINE void IfxVadc_clearQueue(Ifx_VADC_G *vadcG, boolean flushQueue)
{
    vadcG->QMR0.B.FLUSH = flushQueue;
80007cea:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007cee:	3b 00 40 f0 	mov %d15,1024
80007cf2:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80007cf6:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007cfa:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80007cfe:	a6 2f       	or %d15,%d2
80007d00:	59 2f 44 40 	st.w [%a2]1284,%d15
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007d04:	39 ff 34 00 	ld.bu %d15,[%a15]52
80007d08:	df 1f 5a 80 	jne %d15,1,80007dbc <IfxVadc_Adc_initGroup+0x25a>
    {
        const IfxVadc_Adc_ScanConfig *scanSlot = &config->scanRequest;

        /* configure external Trigger if enabled */
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007d0c:	39 ff 1d 00 	ld.bu %d15,[%a15]29
}


IFX_INLINE void IfxVadc_enableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
80007d10:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007d14:	6e 28       	jz %d15,80007d64 <IfxVadc_Adc_initGroup+0x202>
80007d16:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d1a:	96 04       	or %d15,4
80007d1c:	59 2f 64 40 	st.w [%a2]1316,%d15


IFX_INLINE void IfxVadc_setScanSlotTriggerConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U        = vadcG->ASCTRL.U;
80007d20:	19 23 60 40 	ld.w %d3,[%a2]1312
        {
            /* enable external trigger */
            IfxVadc_enableScanSlotExternalTrigger(vadcG);

            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80007d24:	39 f2 1d 00 	ld.bu %d2,[%a15]29
80007d28:	39 ff 1b 00 	ld.bu %d15,[%a15]27
    asctrl.B.XTWC   = 1;
80007d2c:	b7 13 81 37 	insert %d3,%d3,1,15,1
    asctrl.B.XTMODE = triggerMode;
80007d30:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    asctrl.B.XTSEL  = triggerSource;
80007d34:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->ASCTRL.U = asctrl.U;
80007d38:	59 23 60 40 	st.w [%a2]1312,%d3

            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007d3c:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007d40:	8b ff 20 f2 	ne %d15,%d15,15
80007d44:	ee 16       	jnz %d15,80007d70 <IfxVadc_Adc_initGroup+0x20e>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007d46:	19 23 60 40 	ld.w %d3,[%a2]1312
            {
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007d4a:	39 ff 1a 00 	ld.bu %d15,[%a15]26
    asctrl.B.GTWC      = 1;
80007d4e:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007d52:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007d56:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007d5a:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d5e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007d62:	3c 05       	j 80007d6c <IfxVadc_Adc_initGroup+0x20a>
}


IFX_INLINE void IfxVadc_disableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80007d64:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d68:	8f 4f c0 f1 	andn %d15,%d15,4
80007d6c:	59 2f 64 40 	st.w [%a2]1316,%d15
        {
            IfxVadc_disableScanSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007d70:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007d74:	8b ff 00 f2 	eq %d15,%d15,15
80007d78:	ee 15       	jnz %d15,80007da2 <IfxVadc_Adc_initGroup+0x240>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007d7a:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80007d7e:	39 f2 1a 00 	ld.bu %d2,[%a15]26
80007d82:	19 23 60 40 	ld.w %d3,[%a2]1312
80007d86:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    asctrl.B.GTWC      = 1;
80007d8a:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007d8e:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007d92:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007d96:	19 22 64 40 	ld.w %d2,[%a2]1316
80007d9a:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007d9e:	59 2f 64 40 	st.w [%a2]1316,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80007da2:	39 ff 18 00 	ld.bu %d15,[%a15]24
}


IFX_INLINE void IfxVadc_setAutoScan(Ifx_VADC_G *vadcG, boolean autoscanEnable)
{
    vadcG->ASMR.B.SCAN = autoscanEnable;
80007da6:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007daa:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007dae:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007db2:	8f 0f c1 f1 	andn %d15,%d15,16
80007db6:	a6 2f       	or %d15,%d2
80007db8:	59 2f 64 40 	st.w [%a2]1316,%d15
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007dbc:	39 ff 35 00 	ld.bu %d15,[%a15]53
80007dc0:	df 1f 4f 80 	jne %d15,1,80007e5e <IfxVadc_Adc_initGroup+0x2fc>
    {
        const IfxVadc_Adc_BackgroundScanConfig *backgroundScanSlot = &config->backgroundScanRequest;

        /* configure external Trigger if enabled */
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007dc4:	39 ff 2d 00 	ld.bu %d15,[%a15]45
80007dc8:	6e 29       	jz %d15,80007e1a <IfxVadc_Adc_initGroup+0x2b8>
}


IFX_INLINE void IfxVadc_enableBackgroundScanSlotExternalTrigger(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80007dca:	19 cf 04 80 	ld.w %d15,[%a12]516
80007dce:	96 04       	or %d15,4
80007dd0:	59 cf 04 80 	st.w [%a12]516,%d15


IFX_INLINE void IfxVadc_setBackgroundScanSlotTriggerConfig(Ifx_VADC *vadc, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U        = vadc->BRSCTRL.U;
80007dd4:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_enableBackgroundScanSlotExternalTrigger(vadc);

            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80007dd8:	39 f2 2d 00 	ld.bu %d2,[%a15]45
80007ddc:	39 ff 2b 00 	ld.bu %d15,[%a15]43
    brsctrl.B.XTWC   = 1;
80007de0:	b7 13 81 37 	insert %d3,%d3,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80007de4:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    brsctrl.B.XTSEL  = triggerSource;
80007de8:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
80007dec:	59 c3 00 80 	st.w [%a12]512,%d3

            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007df0:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007df4:	8b ff 20 f2 	ne %d15,%d15,15
80007df8:	ee 11       	jnz %d15,80007e1a <IfxVadc_Adc_initGroup+0x2b8>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007dfa:	19 c3 00 80 	ld.w %d3,[%a12]512
            {
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007dfe:	39 ff 2a 00 	ld.bu %d15,[%a15]42
    brsctrl.B.GTWC     = 1;
80007e02:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007e06:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
80007e0a:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007e0e:	19 cf 04 80 	ld.w %d15,[%a12]516
80007e12:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007e16:	59 cf 04 80 	st.w [%a12]516,%d15
        {
            /* do nothing */
        }

        /* configure Gating if enabled */
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007e1a:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007e1e:	8b ff 00 f2 	eq %d15,%d15,15
80007e22:	ee 13       	jnz %d15,80007e48 <IfxVadc_Adc_initGroup+0x2e6>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007e24:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80007e28:	39 f2 2a 00 	ld.bu %d2,[%a15]42
    brsctrl.B.GTWC     = 1;
80007e2c:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007e30:	37 23 04 38 	insert %d3,%d3,%d2,16,4
80007e34:	39 ff 2c 00 	ld.bu %d15,[%a15]44
    vadc->BRSCTRL.U    = brsctrl.U;
80007e38:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007e3c:	19 c2 04 80 	ld.w %d2,[%a12]516
80007e40:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007e44:	59 cf 04 80 	st.w [%a12]516,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
80007e48:	39 ff 28 00 	ld.bu %d15,[%a15]40
}


IFX_INLINE void IfxVadc_setAutoBackgroundScan(Ifx_VADC *vadc, boolean autoBackgroundScanEnable)
{
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80007e4c:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007e50:	19 cf 04 80 	ld.w %d15,[%a12]516
80007e54:	8f 0f c1 f1 	andn %d15,%d15,16
80007e58:	a6 2f       	or %d15,%d2
80007e5a:	59 cf 04 80 	st.w [%a12]516,%d15
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80007e5e:	0c f5       	ld.bu %d15,[%a15]5
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007e60:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007e64:	3a 8f       	eq %d15,%d15,%d8
80007e66:	ab 3f a0 2f 	seln %d2,%d15,%d15,3
80007e6a:	19 2f 40 20 	ld.w %d15,[%a2]1152
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80007e6e:	02 84       	mov %d4,%d8
80007e70:	8f 3f c0 f1 	andn %d15,%d15,3
80007e74:	a6 2f       	or %d15,%d2
80007e76:	59 2f 40 20 	st.w [%a2]1152,%d15
80007e7a:	39 f5 30 00 	ld.bu %d5,[%a15]48
80007e7e:	40 c4       	mov.aa %a4,%a12
80007e80:	6d ff 69 e4 	call 80004752 <IfxVadc_disablePostCalibration>
}


IFX_INLINE void IfxVadc_setGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
80007e84:	8f 88 00 80 	sh %d8,%d8,8
80007e88:	82 05       	mov %d5,0
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80007e8a:	3b f0 0f 40 	mov %d4,255

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
80007e8e:	01 f5 03 26 	addsc.a %a2,%a15,%d5,3
80007e92:	0b 58 00 20 	add %d2,%d8,%d5
80007e96:	1b 82 12 20 	addi %d2,%d2,296
80007e9a:	0c 2c       	ld.bu %d15,[%a2]12
80007e9c:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
80007ea0:	54 22       	ld.w %d2,[%a2]
80007ea2:	37 f2 03 f4 	insert %d15,%d2,%d15,8,3
80007ea6:	6c 20       	st.w [%a2]0,%d15
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
80007ea8:	9a 15       	add %d15,%d5,1
80007eaa:	d0 f2       	addsc.a %a2,%a15,%d15,3

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007eac:	54 23       	ld.w %d3,[%a2]
80007eae:	4b 3b 41 30 	mul.f %d3,%d11,%d3
80007eb2:	4b 03 71 31 	ftouz %d3,%d3
80007eb6:	c2 e3       	add %d3,-2

    if (ticks > 31)
80007eb8:	8b 03 62 f2 	lt.u %d15,%d3,32
80007ebc:	ee 04       	jnz %d15,80007ec4 <IfxVadc_Adc_initGroup+0x362>
    {
        ticks = (ticks / 16) + 15;
80007ebe:	06 c3       	sh %d3,-4
80007ec0:	1b f3 00 30 	addi %d3,%d3,15
80007ec4:	0b 43 90 31 	min.u %d3,%d3,%d4
}


IFX_INLINE void IfxVadc_setGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007ec8:	1a 58       	add %d15,%d8,%d5
80007eca:	1b 8f 12 f0 	addi %d15,%d15,296
80007ece:	90 c2       	addsc.a %a2,%a12,%d15,2
80007ed0:	4c 20       	ld.w %d15,[%a2]0
80007ed2:	37 3f 05 30 	insert %d3,%d15,%d3,0,5
80007ed6:	74 23       	st.w [%a2],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80007ed8:	df 15 04 00 	jeq %d5,1,80007ee0 <IfxVadc_Adc_initGroup+0x37e>
80007edc:	82 15       	mov %d5,1
80007ede:	3c d8       	j 80007e8e <IfxVadc_Adc_initGroup+0x32c>
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007ee0:	40 c4       	mov.aa %a4,%a12
80007ee2:	02 a4       	mov %d4,%d10
80007ee4:	6d ff dc e3 	call 8000469c <IfxVadc_disableAccess>

    return status;
}
80007ee8:	82 02       	mov %d2,0
80007eea:	00 90       	ret 

80007eec <IfxVadc_Adc_initGroupConfig>:
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80007eec:	40 42       	mov.aa %a2,%a4
80007eee:	7b 60 58 f3 	movh %d15,13702
80007ef2:	d2 02       	mov %e2,0
80007ef4:	a0 6f       	mov.a %a15,6
80007ef6:	89 22 48 01 	st.d [%a2+]8,%e2
80007efa:	fc fe       	loop %a15,80007ef6 <IfxVadc_Adc_initGroupConfig+0xa>
80007efc:	1b df 7b f3 	addi %d15,%d15,14269
80007f00:	6c 42       	st.w [%a4]8,%d15
80007f02:	6c 44       	st.w [%a4]16,%d15
80007f04:	82 1f       	mov %d15,1
80007f06:	e9 4f 1e 00 	st.b [%a4]30,%d15
80007f0a:	e9 4f 20 00 	st.b [%a4]32,%d15
80007f0e:	e9 4f 26 00 	st.b [%a4]38,%d15
80007f12:	e9 4f 2e 00 	st.b [%a4]46,%d15
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
80007f16:	f4 45       	st.a [%a4],%a5
80007f18:	00 90       	ret 

80007f1a <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80007f1a:	cc 50       	ld.a %a15,[%a5]0
    config->disablePostCalibration = FALSE;
}


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
80007f1c:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
    vadc->vadc = vadcSFR;
80007f1e:	ec 40       	st.a [%a4]0,%a15
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007f20:	6d ff 0f fa 	call 8000733e <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007f24:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007f26:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007f28:	6d ff 0b f9 	call 8000713e <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80007f2c:	82 02       	mov %d2,0
80007f2e:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007f30:	02 f4       	mov %d4,%d15
80007f32:	6d ff 3b fa 	call 800073a8 <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
80007f36:	40 f4       	mov.aa %a4,%a15
80007f38:	39 c4 21 00 	ld.bu %d4,[%a12]33
80007f3c:	6d ff 30 e6 	call 80004b9c <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007f40:	19 c4 18 00 	ld.w %d4,[%a12]24
80007f44:	40 f4       	mov.aa %a4,%a15
80007f46:	4b 04 71 41 	ftouz %d4,%d4
    {
        return IfxVadc_Status_notInitialised;
80007f4a:	82 1f       	mov %d15,1
    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007f4c:	6d ff 42 e5 	call 800049d0 <IfxVadc_initializeFAdcI>
80007f50:	df 02 57 00 	jeq %d2,0,80007ffe <IfxVadc_Adc_initModule+0xe4>
    {
        /* do nothing */
    }

    /* Set digital Frequency */
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
80007f54:	19 c4 14 00 	ld.w %d4,[%a12]20
80007f58:	40 f4       	mov.aa %a4,%a15
80007f5a:	4b 04 71 41 	ftouz %d4,%d4
80007f5e:	6d ff 24 e5 	call 800049a6 <IfxVadc_initializeFAdcD>

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
80007f62:	40 f4       	mov.aa %a4,%a15
80007f64:	6d ff 6a e4 	call 80004838 <IfxVadc_getAdcAnalogFrequency>
80007f68:	82 03       	mov %d3,0
80007f6a:	3b f0 0f 60 	mov %d6,255

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
    {
        /* configure ADC channel resolution ( conversion mode ) */
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
80007f6e:	9a 13       	add %d15,%d3,1
}


IFX_INLINE void IfxVadc_setGlobalResolution(Ifx_VADC *vadc, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
80007f70:	1b 83 02 40 	addi %d4,%d3,40
80007f74:	d0 c2       	addsc.a %a2,%a12,%d15,3
80007f76:	01 f4 02 36 	addsc.a %a3,%a15,%d4,2
80007f7a:	0c 20       	ld.bu %d15,[%a2]0
80007f7c:	54 35       	ld.w %d5,[%a3]
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
80007f7e:	01 c3 03 26 	addsc.a %a2,%a12,%d3,3
80007f82:	37 f5 03 f4 	insert %d15,%d5,%d15,8,3
80007f86:	6c 30       	st.w [%a3]0,%d15

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007f88:	4c 21       	ld.w %d15,[%a2]4
80007f8a:	4b f2 41 f0 	mul.f %d15,%d2,%d15
80007f8e:	4b 0f 71 f1 	ftouz %d15,%d15
80007f92:	c2 ef       	add %d15,-2

    if (ticks > 31)
80007f94:	8b 0f 62 52 	lt.u %d5,%d15,32
80007f98:	f6 54       	jnz %d5,80007fa0 <IfxVadc_Adc_initModule+0x86>
    {
        ticks = (ticks / 16) + 15;
80007f9a:	06 cf       	sh %d15,-4
80007f9c:	1b ff 00 f0 	addi %d15,%d15,15
80007fa0:	0b 6f 90 f1 	min.u %d15,%d15,%d6
}


IFX_INLINE void IfxVadc_setGlobalSampleTime(Ifx_VADC *vadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007fa4:	01 f4 02 26 	addsc.a %a2,%a15,%d4,2
80007fa8:	54 24       	ld.w %d4,[%a2]
80007faa:	37 f4 05 f0 	insert %d15,%d4,%d15,0,5
80007fae:	6c 20       	st.w [%a2]0,%d15
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80007fb0:	df 13 04 00 	jeq %d3,1,80007fb8 <IfxVadc_Adc_initModule+0x9e>
80007fb4:	82 13       	mov %d3,1
80007fb6:	3c dc       	j 80007f6e <IfxVadc_Adc_initModule+0x54>
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007fb8:	39 c2 20 00 	ld.bu %d2,[%a12]32

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
80007fbc:	82 0f       	mov %d15,0
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007fbe:	df 12 20 80 	jne %d2,1,80007ffe <IfxVadc_Adc_initModule+0xe4>
80007fc2:	82 08       	mov %d8,0
80007fc4:	1b 08 01 f0 	addi %d15,%d8,16
80007fc8:	16 ff       	and %d15,255
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007fca:	02 f4       	mov %d4,%d15
80007fcc:	40 f4       	mov.aa %a4,%a15
80007fce:	6d ff 83 e3 	call 800046d4 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007fd2:	8f a8 00 20 	sh %d2,%d8,10
80007fd6:	01 f2 00 26 	addsc.a %a2,%a15,%d2,0
80007fda:	c2 18       	add %d8,1
80007fdc:	19 22 40 20 	ld.w %d2,[%a2]1152
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007fe0:	02 f4       	mov %d4,%d15
80007fe2:	8f 32 40 21 	or %d2,%d2,3
80007fe6:	59 22 40 20 	st.w [%a2]1152,%d2
80007fea:	40 f4       	mov.aa %a4,%a15

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007fec:	8b 88 20 f2 	ne %d15,%d8,8
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007ff0:	6d ff 56 e3 	call 8000469c <IfxVadc_disableAccess>

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007ff4:	ee e8       	jnz %d15,80007fc4 <IfxVadc_Adc_initModule+0xaa>
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
        }

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
80007ff6:	40 f4       	mov.aa %a4,%a15
80007ff8:	6d ff 19 e6 	call 80004c2a <IfxVadc_startupCalibration>
    }

    return status;
80007ffc:	82 0f       	mov %d15,0
}
80007ffe:	02 f2       	mov %d2,%d15
80008000:	00 90       	ret 

80008002 <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80008002:	7b 90 b9 f4 	movh %d15,19353
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80008006:	40 4f       	mov.aa %a15,%a4
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80008008:	1b 0f 68 f9 	addi %d15,%d15,-27008
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
8000800c:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
8000800e:	e8 05       	st.a [%a15]0,%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80008010:	68 6f       	st.w [%a15]24,%d15

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
80008012:	6d ff 1f e4 	call 80004850 <IfxVadc_getAdcDigitalFrequency>
80008016:	68 52       	st.w [%a15]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
80008018:	6d ff cf f0 	call 800061b6 <IfxScuCcu_getSpbFrequency>
8000801c:	68 72       	st.w [%a15]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    config->globalInputClass[0].sampleTime = 1.0e-6;
8000801e:	7b 60 58 23 	movh %d2,13702
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80008022:	82 0f       	mov %d15,0
    config->globalInputClass[0].sampleTime = 1.0e-6;
80008024:	1b d2 7b 23 	addi %d2,%d2,14269
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80008028:	28 8f       	st.b [%a15]8,%d15
    config->globalInputClass[0].sampleTime = 1.0e-6;
8000802a:	68 12       	st.w [%a15]4,%d2
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
8000802c:	e9 ff 10 00 	st.b [%a15]16,%d15
    config->globalInputClass[1].sampleTime = 1.0e-6;
80008030:	68 32       	st.w [%a15]12,%d2
    config->startupCalibration             = FALSE;
80008032:	e9 ff 20 00 	st.b [%a15]32,%d15
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
80008036:	e9 ff 21 00 	st.b [%a15]33,%d15
8000803a:	00 90       	ret 

8000803c <IfxVadc_Adc_initExternalMultiplexerModeConfig>:
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
8000803c:	20 10       	sub.a %sp,16
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
8000803e:	82 0f       	mov %d15,0
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80008040:	40 a2       	mov.aa %a2,%sp


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80008042:	2c 49       	st.b [%a4]9,%d15
    emuxConfig->groupId               = IfxVadc_GroupId_0;
80008044:	2c 48       	st.b [%a4]8,%d15
    emuxConfig->emuxInterface         = IfxVadc_EmuxInterface_0;
80008046:	2c 4a       	st.b [%a4]10,%d15
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
80008048:	2c 45       	st.b [%a4]5,%d15
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
8000804a:	2c 46       	st.b [%a4]6,%d15
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
8000804c:	2c 47       	st.b [%a4]7,%d15
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
8000804e:	2c 44       	st.b [%a4]4,%d15
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
80008050:	e9 4f 1c 00 	st.b [%a4]28,%d15
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80008054:	d2 02       	mov %e2,0
80008056:	89 22 48 01 	st.d [%a2+]8,%e2
8000805a:	89 22 48 01 	st.d [%a2+]8,%e2
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
8000805e:	3b 00 f8 ff 	mov %d15,-128
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
80008062:	f4 45       	st.a [%a4],%a5
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80008064:	40 af       	mov.aa %a15,%sp
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
80008066:	2c ac       	st.b [%sp]12,%d15
80008068:	d9 44 0c 00 	lea %a4,[%a4]12
8000806c:	09 f2 48 01 	ld.d %e2,[%a15+]8
80008070:	89 42 48 01 	st.d [%a4+]8,%e2
80008074:	09 f2 48 01 	ld.d %e2,[%a15+]8
80008078:	89 42 48 01 	st.d [%a4+]8,%e2
8000807c:	00 90       	ret 

8000807e <IfxVadc_Adc_initExternalMultiplexerMode>:


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
8000807e:	0c 58       	ld.bu %d15,[%a5]8
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
80008080:	20 08       	sub.a %sp,8
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
80008082:	8f af 00 20 	sh %d2,%d15,10
80008086:	1b 02 48 20 	addi %d2,%d2,1152
8000808a:	01 42 00 e6 	addsc.a %a14,%a4,%d2,0
}


IFX_INLINE void IfxVadc_setEmuxInterfaceForGroup(Ifx_VADC *vadc, IfxVadc_EmuxInterface emuxInterface, IfxVadc_GroupId group)
{
    if (emuxInterface == IfxVadc_EmuxInterface_0)
8000808e:	39 52 0a 00 	ld.bu %d2,[%a5]10
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
80008092:	40 4c       	mov.aa %a12,%a4
80008094:	40 5f       	mov.aa %a15,%a5
80008096:	16 0f       	and %d15,15
80008098:	f6 2a       	jnz %d2,800080ac <IfxVadc_Adc_initExternalMultiplexerMode+0x2e>
    {
        vadc->EMUXSEL.B.EMUXGRP0 = group;
8000809a:	19 42 30 f0 	ld.w %d2,[%a4]1008
8000809e:	8f f2 c0 21 	andn %d2,%d2,15
800080a2:	a6 2f       	or %d15,%d2
800080a4:	59 cf 30 f0 	st.w [%a12]1008,%d15
800080a8:	82 0f       	mov %d15,0
800080aa:	3c 07       	j 800080b8 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
    }
    else
    {
        vadc->EMUXSEL.B.EMUXGRP1 = group;
800080ac:	19 42 30 f0 	ld.w %d2,[%a4]1008
800080b0:	06 4f       	sh %d15,4
800080b2:	8f 02 cf 21 	andn %d2,%d2,240
800080b6:	3c f6       	j 800080a2 <IfxVadc_Adc_initExternalMultiplexerMode+0x24>
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
    {
        if (emuxControl->emuxOutPinConfig.pins[count] != NULL_PTR)
800080b8:	90 f2       	addsc.a %a2,%a15,%d15,2
800080ba:	99 2d 0c 00 	ld.a %a13,[%a2]12
800080be:	bd 0d 19 00 	jz.a %a13,800080f0 <IfxVadc_Adc_initExternalMultiplexerMode+0x72>
800080c2:	39 d3 0c 00 	ld.bu %d3,[%a13]12
800080c6:	39 f2 18 00 	ld.bu %d2,[%a15]24
800080ca:	99 d4 04 00 	ld.a %a4,[%a13]4
800080ce:	0f 23 a0 50 	or %d5,%d3,%d2
800080d2:	39 d4 08 00 	ld.bu %d4,[%a13]8
800080d6:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
800080da:	39 f8 19 00 	ld.bu %d8,[%a15]25
800080de:	6d ff c4 ed 	call 80005c66 <IfxPort_setPinMode>


IFX_INLINE void IfxVadc_initEmuxPin(const IfxVadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(emux->pin.port, emux->pin.pinIndex, outputMode, emux->select);
    IfxPort_setPinPadDriver(emux->pin.port, emux->pin.pinIndex, padDriver);
800080e2:	99 d4 04 00 	ld.a %a4,[%a13]4
800080e6:	39 d4 08 00 	ld.bu %d4,[%a13]8
800080ea:	02 85       	mov %d5,%d8
800080ec:	6d ff 3b ee 	call 80005d62 <IfxPort_setPinPadDriver>
800080f0:	c2 1f       	add %d15,1
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
800080f2:	df 3f e3 ff 	jne %d15,3,800080b8 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
        }
    }

    IfxVadc_configExternalMultiplexerMode(vadc, vadcG, emuxControl->mode, emuxControl->channels, emuxControl->startChannel, emuxControl->code, emuxControl->sampleTimeControl, emuxControl->channelSelectionStyle);
800080f6:	0c f7       	ld.bu %d15,[%a15]7
800080f8:	08 44       	ld.bu %d4,[%a15]4
800080fa:	78 00       	st.w [%sp]0,%d15
800080fc:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80008100:	08 95       	ld.bu %d5,[%a15]9
80008102:	08 56       	ld.bu %d6,[%a15]5
80008104:	08 67       	ld.bu %d7,[%a15]6
80008106:	78 01       	st.w [%sp]4,%d15
80008108:	40 c4       	mov.aa %a4,%a12
8000810a:	40 e5       	mov.aa %a5,%a14
8000810c:	1d ff 00 e3 	j 8000470c <IfxVadc_configExternalMultiplexerMode>

80008110 <Ifx_CircularBuffer_get32>:

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80008110:	cc 40       	ld.a %a15,[%a4]0
80008112:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 4;

    if (buffer->index >= buffer->length)
80008116:	b9 43 06 00 	ld.hu %d3,[%a4]6

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
8000811a:	90 ff       	addsc.a %a15,%a15,%d15,2

    buffer->index += 4;
8000811c:	c2 4f       	add %d15,4
8000811e:	37 0f 70 f0 	extr.u %d15,%d15,0,16

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80008122:	48 02       	ld.w %d2,[%a15]0

    buffer->index += 4;
80008124:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80008126:	3f 3f 04 80 	jlt.u %d15,%d3,8000812e <Ifx_CircularBuffer_get32+0x1e>
    {
        buffer->index = 0;
8000812a:	82 0f       	mov %d15,0
8000812c:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
8000812e:	00 90       	ret 

80008130 <Ifx_CircularBuffer_get16>:


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80008130:	cc 40       	ld.a %a15,[%a4]0
80008132:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 2;

    if (buffer->index >= buffer->length)
80008136:	b9 43 06 00 	ld.hu %d3,[%a4]6
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
8000813a:	50 ff       	addsc.a %a15,%a15,%d15,1

    buffer->index += 2;
8000813c:	c2 2f       	add %d15,2
8000813e:	37 0f 70 f0 	extr.u %d15,%d15,0,16
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80008142:	b9 f2 00 00 	ld.hu %d2,[%a15]0

    buffer->index += 2;
80008146:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80008148:	3f 3f 04 80 	jlt.u %d15,%d3,80008150 <Ifx_CircularBuffer_get16+0x20>
    {
        buffer->index = 0;
8000814c:	82 0f       	mov %d15,0
8000814e:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
80008150:	00 90       	ret 

80008152 <Ifx_CircularBuffer_addDataIncr>:
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80008152:	cc 40       	ld.a %a15,[%a4]0
80008154:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    buffer->index                          += 4;

    if (buffer->index >= buffer->length)
80008158:	b9 42 06 00 	ld.hu %d2,[%a4]6
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
8000815c:	90 ff       	addsc.a %a15,%a15,%d15,2
    buffer->index                          += 4;
8000815e:	c2 4f       	add %d15,4
80008160:	37 0f 70 f0 	extr.u %d15,%d15,0,16
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80008164:	68 04       	st.w [%a15]0,%d4
    buffer->index                          += 4;
80008166:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80008168:	3f 2f 04 80 	jlt.u %d15,%d2,80008170 <Ifx_CircularBuffer_addDataIncr+0x1e>
    {
        buffer->index = 0;
8000816c:	82 0f       	mov %d15,0
8000816e:	ac 42       	st.h [%a4]4,%d15
80008170:	00 90       	ret 

80008172 <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
80008172:	80 52       	mov.d %d2,%a5
80008174:	37 04 70 40 	extr.u %d4,%d4,0,16
80008178:	8f 02 60 31 	nor %d3,%d2,0
8000817c:	1a 42       	add %d15,%d2,%d4
8000817e:	42 3f       	add %d15,%d3
80008180:	42 23       	add %d3,%d2
80008182:	42 43       	add %d3,%d4
    uint8 *Dest = (uint8 *)data;
80008184:	40 5f       	mov.aa %a15,%a5
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008186:	82 06       	mov %d6,0
80008188:	37 0f 70 f0 	extr.u %d15,%d15,0,16
8000818c:	6f f3 03 00 	jz.t %d3,15,80008192 <Ifx_CircularBuffer_read8+0x20>
80008190:	82 0f       	mov %d15,0
    uint8 *Dest = (uint8 *)data;

    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
80008192:	b9 43 04 00 	ld.hu %d3,[%a4]4
80008196:	d4 42       	ld.a %a2,[%a4]
80008198:	60 33       	mov.a %a3,%d3
8000819a:	30 32       	add.a %a2,%a3
8000819c:	14 23       	ld.bu %d3,[%a2]
8000819e:	24 f3       	st.b [%a15+],%d3
        Dest  = &Dest[1];
        buffer->index++;
800081a0:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
800081a4:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
        Dest  = &Dest[1];
        buffer->index++;
800081a8:	c2 13       	add %d3,1
800081aa:	37 03 70 30 	extr.u %d3,%d3,0,16
800081ae:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
800081b2:	3f 53 04 80 	jlt.u %d3,%d5,800081ba <Ifx_CircularBuffer_read8+0x48>
        {
            buffer->index = 0;
800081b6:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
800081ba:	9f 0f ec ff 	jned %d15,0,80008192 <Ifx_CircularBuffer_read8+0x20>
800081be:	c2 f4       	add %d4,-1
800081c0:	37 04 50 40 	extr %d4,%d4,0,16
800081c4:	8b 04 40 43 	max %d4,%d4,0
800081c8:	c2 14       	add %d4,1

    return Dest;
}
800081ca:	1a 42       	add %d15,%d2,%d4
800081cc:	60 f2       	mov.a %a2,%d15
800081ce:	00 90       	ret 

800081d0 <Ifx_CircularBuffer_read32>:


void *Ifx_CircularBuffer_read32(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
800081d0:	37 04 70 40 	extr.u %d4,%d4,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;
800081d4:	d4 42       	ld.a %a2,[%a4]
800081d6:	1b f4 ff 5f 	addi %d5,%d4,-1
800081da:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
800081de:	b9 46 06 00 	ld.hu %d6,[%a4]6
800081e2:	82 03       	mov %d3,0
800081e4:	37 05 70 20 	extr.u %d2,%d5,0,16
800081e8:	6f f5 03 00 	jz.t %d5,15,800081ee <Ifx_CircularBuffer_read32+0x1e>
800081ec:	82 02       	mov %d2,0
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
800081ee:	10 2f       	addsc.a %a15,%a2,%d15,0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
800081f0:	c2 4f       	add %d15,4
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
800081f2:	48 05       	ld.w %d5,[%a15]0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
800081f4:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
800081f8:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
800081fc:	c2 13       	add %d3,1
800081fe:	68 05       	st.w [%a15]0,%d5
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008200:	0b 6f 30 51 	lt.u %d5,%d15,%d6
80008204:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
80008208:	9f 02 f3 ff 	jned %d2,0,800081ee <Ifx_CircularBuffer_read32+0x1e>
8000820c:	c2 f4       	add %d4,-1
8000820e:	37 04 50 40 	extr %d4,%d4,0,16
80008212:	ac 42       	st.h [%a4]4,%d15
80008214:	8b 04 40 43 	max %d4,%d4,0
80008218:	c2 14       	add %d4,1

    return Dest;
}
8000821a:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
8000821e:	00 90       	ret 

80008220 <Ifx_CircularBuffer_write8>:


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
80008220:	80 52       	mov.d %d2,%a5
80008222:	37 04 70 40 	extr.u %d4,%d4,0,16
80008226:	8f 02 60 31 	nor %d3,%d2,0
8000822a:	1a 42       	add %d15,%d2,%d4
8000822c:	42 3f       	add %d15,%d3
8000822e:	42 23       	add %d3,%d2
80008230:	42 43       	add %d3,%d4
    const uint8 *source = (const uint8 *)data;
80008232:	40 5f       	mov.aa %a15,%a5
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008234:	82 06       	mov %d6,0
80008236:	37 0f 70 f0 	extr.u %d15,%d15,0,16
8000823a:	6f f3 03 00 	jz.t %d3,15,80008240 <Ifx_CircularBuffer_write8+0x20>
8000823e:	82 0f       	mov %d15,0
    const uint8 *source = (const uint8 *)data;

    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
80008240:	b9 43 04 00 	ld.hu %d3,[%a4]4
80008244:	d4 42       	ld.a %a2,[%a4]
80008246:	60 33       	mov.a %a3,%d3
80008248:	04 f5       	ld.bu %d5,[%a15+]
8000824a:	30 32       	add.a %a2,%a3
8000824c:	34 25       	st.b [%a2],%d5
        source                                 = &source[1];
        buffer->index++;
8000824e:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
80008252:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
        source                                 = &source[1];
        buffer->index++;
80008256:	c2 13       	add %d3,1
80008258:	37 03 70 30 	extr.u %d3,%d3,0,16
8000825c:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
80008260:	3f 53 04 80 	jlt.u %d3,%d5,80008268 <Ifx_CircularBuffer_write8+0x48>
        {
            buffer->index = 0;
80008264:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
80008268:	9f 0f ec ff 	jned %d15,0,80008240 <Ifx_CircularBuffer_write8+0x20>
8000826c:	c2 f4       	add %d4,-1
8000826e:	37 04 50 40 	extr %d4,%d4,0,16
80008272:	8b 04 40 43 	max %d4,%d4,0
80008276:	c2 14       	add %d4,1

    return source;
}
80008278:	1a 42       	add %d15,%d2,%d4
8000827a:	60 f2       	mov.a %a2,%d15
8000827c:	00 90       	ret 

8000827e <Ifx_CircularBuffer_write32>:


const void *Ifx_CircularBuffer_write32(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
8000827e:	37 04 70 40 	extr.u %d4,%d4,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;
80008282:	d4 42       	ld.a %a2,[%a4]
80008284:	1b f4 ff 5f 	addi %d5,%d4,-1
80008288:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *((uint32 *)(&base[buffer->index])) = *source;
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
8000828c:	b9 46 06 00 	ld.hu %d6,[%a4]6
80008290:	82 03       	mov %d3,0
80008292:	37 05 70 20 	extr.u %d2,%d5,0,16
80008296:	6f f5 03 00 	jz.t %d5,15,8000829c <Ifx_CircularBuffer_write32+0x1e>
8000829a:	82 02       	mov %d2,0
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
8000829c:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
800082a0:	c2 13       	add %d3,1
800082a2:	48 05       	ld.w %d5,[%a15]0
800082a4:	10 2f       	addsc.a %a15,%a2,%d15,0
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;
800082a6:	c2 4f       	add %d15,4
800082a8:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
800082ac:	68 05       	st.w [%a15]0,%d5
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
800082ae:	0b 6f 30 51 	lt.u %d5,%d15,%d6
800082b2:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
800082b6:	9f 02 f3 ff 	jned %d2,0,8000829c <Ifx_CircularBuffer_write32+0x1e>
800082ba:	c2 f4       	add %d4,-1
800082bc:	37 04 50 40 	extr %d4,%d4,0,16
800082c0:	ac 42       	st.h [%a4]4,%d15
800082c2:	8b 04 40 43 	max %d4,%d4,0
800082c6:	c2 14       	add %d4,1

    return source;
}
800082c8:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
800082cc:	00 90       	ret 

800082ce <Ifx_Fifo_destroy>:
}


void Ifx_Fifo_destroy(Ifx_Fifo *fifo)
{
    free(fifo);
800082ce:	1d 00 03 16 	j 8000aed4 <free>

800082d2 <Ifx_Fifo_init>:
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
800082d2:	82 0f       	mov %d15,0
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
800082d4:	80 42       	mov.d %d2,%a4
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
800082d6:	e9 4f 1c 00 	st.b [%a4]28,%d15
        fifo->eventWriter        = TRUE;
800082da:	82 1f       	mov %d15,1
800082dc:	e9 4f 1d 00 	st.b [%a4]29,%d15
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
800082e0:	1b 72 02 f0 	addi %d15,%d2,39
800082e4:	8f 7f c0 f1 	andn %d15,%d15,7
800082e8:	6c 40       	st.w [%a4]0,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
800082ea:	c2 34       	add %d4,3
    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
800082ec:	82 0f       	mov %d15,0
800082ee:	ac 42       	st.h [%a4]4,%d15
        fifo->shared.maxcount    = 0;
800082f0:	ac 48       	st.h [%a4]16,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
800082f2:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
800082f6:	82 0f       	mov %d15,0
    free(fifo);
}


Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
800082f8:	40 42       	mov.aa %a2,%a4
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
800082fa:	6c 43       	st.w [%a4]12,%d15
800082fc:	6c 42       	st.w [%a4]8,%d15
        fifo->startIndex         = fifo->endIndex = 0;
800082fe:	ac 4b       	st.h [%a4]22,%d15
80008300:	ac 4a       	st.h [%a4]20,%d15
        fifo->size               = size;
80008302:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
80008306:	f9 45 1a 00 	st.h [%a4]26,%d5
    }

    return fifo;
}
8000830a:	00 90       	ret 

8000830c <Ifx_Fifo_create>:
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
8000830c:	c2 34       	add %d4,3
8000830e:	37 04 50 f0 	extr %d15,%d4,0,16
 * This is valid is an OS is used.
 *
 */
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
80008312:	02 58       	mov %d8,%d5
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80008314:	8f 3f c0 f1 	andn %d15,%d15,3

    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
80008318:	1b 8f 02 40 	addi %d4,%d15,40
8000831c:	6d 00 d6 15 	call 8000aec8 <malloc>
80008320:	40 24       	mov.aa %a4,%a2

    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
80008322:	bc 25       	jz.a %a2,8000832c <Ifx_Fifo_create+0x20>
    {
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
80008324:	0b f8 10 48 	mov %e4,%d8,%d15
80008328:	1d ff d5 ff 	j 800082d2 <Ifx_Fifo_init>
    }

    return fifo;
}
8000832c:	00 90       	ret 

8000832e <Ifx_Fifo_canReadCount>:
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
8000832e:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be read from the buffer */
        result = FALSE;
80008330:	82 02       	mov %d2,0
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
80008332:	3f f4 6a 00 	jlt %d4,%d15,80008406 <Ifx_Fifo_canReadCount+0xd8>
80008336:	8c 4c       	ld.h %d15,[%a4]24
80008338:	3f 4f 67 00 	jlt %d15,%d4,80008406 <Ifx_Fifo_canReadCount+0xd8>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000833c:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
80008340:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008344:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008348:	00 00       	nop 
    else
    {
        boolean interruptState;
        sint32  waitCount;
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);
8000834a:	8c 42       	ld.h %d15,[%a4]4
8000834c:	a2 f4       	sub %d4,%d15

        if (waitCount <= 0)
8000834e:	4e 4c       	jgtz %d4,80008366 <Ifx_Fifo_canReadCount+0x38>
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE;
80008350:	82 1f       	mov %d15,1
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);

        if (waitCount <= 0)
        {
            fifo->shared.readerWaitx = 0;
80008352:	59 42 08 00 	st.w [%a4]8,%d2
            fifo->eventReader        = TRUE;
80008356:	e9 4f 1c 00 	st.b [%a4]28,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
8000835a:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000835c:	df 00 55 00 	jeq %d0,0,80008406 <Ifx_Fifo_canReadCount+0xd8>
    {
        __enable();
80008360:	0d 00 00 03 	enable 
80008364:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008366:	82 f2       	mov %d2,-1
80008368:	06 f2       	sh %d2,-1
8000836a:	ba f6       	eq %d15,%d6,-1
8000836c:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
80008370:	82 f5       	mov %d5,-1
80008372:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008374:	ee 16       	jnz %d15,800083a0 <Ifx_Fifo_canReadCount+0x72>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008376:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000837a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000837e:	0d 00 40 03 	disable 
80008382:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008384:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008388:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000838c:	02 15       	mov %d5,%d1
8000838e:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008392:	76 23       	jz %d2,80008398 <Ifx_Fifo_canReadCount+0x6a>
    {
        __enable();
80008394:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008398:	0b 65 40 50 	addx %d5,%d5,%d6
8000839c:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
800083a0:	82 0f       	mov %d15,0
800083a2:	e9 4f 1c 00 	st.b [%a4]28,%d15
            fifo->shared.readerWaitx = waitCount;
800083a6:	59 44 08 00 	st.w [%a4]8,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083aa:	76 03       	jz %d0,800083b0 <Ifx_Fifo_canReadCount+0x82>
    {
        __enable();
800083ac:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800083b0:	82 f6       	mov %d6,-1
800083b2:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800083b4:	39 4f 1c 00 	ld.bu %d15,[%a4]28
800083b8:	6e 08       	jz %d15,800083c8 <Ifx_Fifo_canReadCount+0x9a>
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
            result = fifo->eventReader == TRUE;
800083ba:	39 42 1c 00 	ld.bu %d2,[%a4]28
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
800083be:	82 0f       	mov %d15,0
800083c0:	6c 42       	st.w [%a4]8,%d15
            result = fifo->eventReader == TRUE;
800083c2:	8b 12 00 22 	eq %d2,%d2,1
800083c6:	00 90       	ret 
800083c8:	ba f5       	eq %d15,%d5,-1
800083ca:	0b 36 00 f2 	and.eq %d15,%d6,%d3
800083ce:	ee f3       	jnz %d15,800083b4 <Ifx_Fifo_canReadCount+0x86>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083d0:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800083d4:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083d8:	0d 00 40 03 	disable 
800083dc:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800083de:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800083e2:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800083e6:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800083ea:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083ee:	76 23       	jz %d2,800083f4 <Ifx_Fifo_canReadCount+0xc6>
    {
        __enable();
800083f0:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
            fifo->shared.readerWaitx = waitCount;
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800083f4:	0b 3f 00 21 	eq %d2,%d15,%d3
800083f8:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
800083fc:	0b 3f 90 22 	or.lt %d2,%d15,%d3
80008400:	df 02 da ff 	jne %d2,0,800083b4 <Ifx_Fifo_canReadCount+0x86>
80008404:	3c db       	j 800083ba <Ifx_Fifo_canReadCount+0x8c>
            result = fifo->eventReader == TRUE;
        }
    }

    return result;
}
80008406:	00 90       	ret 

80008408 <Ifx_Fifo_read>:
    return count - blockSize;
}

#include <stdio.h>
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80008408:	20 08       	sub.a %sp,8
8000840a:	40 4f       	mov.aa %a15,%a4
8000840c:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
8000840e:	df 04 b6 00 	jeq %d4,0,8000857a <Ifx_Fifo_read+0x172>
    {

        buffer.base   = fifo->buffer;
80008412:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008414:	82 f2       	mov %d2,-1
80008416:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
80008418:	8c 4c       	ld.h %d15,[%a4]24
8000841a:	06 f2       	sh %d2,-1
8000841c:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
8000841e:	8c 4a       	ld.h %d15,[%a4]20
    {
        deadLine = TIME_INFINITE;
80008420:	82 fa       	mov %d10,-1
80008422:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008424:	ba f6       	eq %d15,%d6,-1
80008426:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000842a:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000842c:	ee 16       	jnz %d15,80008458 <Ifx_Fifo_read+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000842e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008432:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008436:	0d 00 40 03 	disable 
8000843a:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000843c:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008440:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008444:	02 3a       	mov %d10,%d3
80008446:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000844a:	76 23       	jz %d2,80008450 <Ifx_Fifo_read+0x48>
    {
        __enable();
8000844c:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008450:	0b 6a 40 a0 	addx %d10,%d10,%d6
80008454:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008458:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
8000845a:	82 0d       	mov %d13,0
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventReader        = FALSE;
8000845c:	82 0e       	mov %d14,0
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
8000845e:	a0 0c       	mov.a %a12,0
80008460:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008462:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80008466:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000846a:	0d 00 40 03 	disable 
8000846e:	00 00       	nop 
{
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
80008470:	88 2b       	ld.h %d11,[%a15]4
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008472:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
80008476:	8c fd       	ld.h %d15,[%a15]26
80008478:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventReader        = FALSE;
8000847c:	e9 fe 1c 00 	st.b [%a15]28,%d14
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
80008480:	4b f2 01 22 	div %e2,%d2,%d15
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
80008484:	88 c2       	ld.h %d2,[%a15]24
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
80008486:	a2 3b       	sub %d11,%d3
80008488:	37 0b 70 b0 	extr.u %d11,%d11,0,16
8000848c:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
80008490:	0b f9 80 30 	sub %d3,%d9,%d15
80008494:	0b 23 80 21 	min %d2,%d3,%d2
80008498:	68 22       	st.w [%a15]8,%d2
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000849a:	76 43       	jz %d4,800084a0 <Ifx_Fifo_read+0x98>
    {
        __enable();
8000849c:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginRead(fifo, count);

            if (blockSize != 0)
800084a0:	6e 20       	jz %d15,800084e0 <Ifx_Fifo_read+0xd8>
            {
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
800084a2:	40 a4       	mov.aa %a4,%sp
800084a4:	02 f4       	mov %d4,%d15
800084a6:	6d ff 66 fe 	call 80008172 <Ifx_CircularBuffer_read8>
800084aa:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800084ac:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800084b0:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084b4:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800084b8:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
800084ba:	88 23       	ld.h %d3,[%a15]4
800084bc:	a2 b3       	sub %d3,%d11
800084be:	a8 23       	st.h [%a15]4,%d3

    if (fifo->shared.writerWaitx != 0)
800084c0:	48 33       	ld.w %d3,[%a15]12
800084c2:	76 39       	jz %d3,800084d4 <Ifx_Fifo_read+0xcc>
    {
        fifo->shared.writerWaitx -= blockSize;
800084c4:	5a f3       	sub %d15,%d3,%d15

        if (fifo->shared.writerWaitx <= 0)
800084c6:	8e f3       	jlez %d15,800084cc <Ifx_Fifo_read+0xc4>

    fifo->shared.count -= blockSize;

    if (fifo->shared.writerWaitx != 0)
    {
        fifo->shared.writerWaitx -= blockSize;
800084c8:	68 3f       	st.w [%a15]12,%d15
800084ca:	3c 05       	j 800084d4 <Ifx_Fifo_read+0xcc>

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE; /* Signal the writer */
800084cc:	82 1f       	mov %d15,1
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
800084ce:	e8 3c       	st.a [%a15]12,%a12
            fifo->eventWriter        = TRUE; /* Signal the writer */
800084d0:	e9 ff 1d 00 	st.b [%a15]29,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800084d4:	76 23       	jz %d2,800084da <Ifx_Fifo_read+0xd2>
    {
        __enable();
800084d6:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
800084da:	a2 b9       	sub %d9,%d11
800084dc:	37 09 50 90 	extr %d9,%d9,0,16
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800084e0:	76 d4       	jz %d13,800084e8 <Ifx_Fifo_read+0xe0>
            {
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
800084e2:	82 0f       	mov %d15,0
800084e4:	68 2f       	st.w [%a15]8,%d15
                break;
800084e6:	3c 48       	j 80008576 <Ifx_Fifo_read+0x16e>
800084e8:	ba fa       	eq %d15,%d10,-1
800084ea:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
800084ee:	ee 1b       	jnz %d15,80008524 <Ifx_Fifo_read+0x11c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800084f0:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800084f4:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084f8:	0d 00 40 03 	disable 
800084fc:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800084fe:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008502:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008506:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000850a:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000850e:	76 23       	jz %d2,80008514 <Ifx_Fifo_read+0x10c>
    {
        __enable();
80008510:	0d 00 00 03 	enable 
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008514:	0b 8f 00 21 	eq %d2,%d15,%d8
80008518:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
8000851c:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008520:	df 02 e1 ff 	jne %d2,0,800084e2 <Ifx_Fifo_read+0xda>
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
                break;
            }

            if (count != 0)
80008524:	df 09 29 00 	jeq %d9,0,80008576 <Ifx_Fifo_read+0x16e>
            {
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008528:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000852c:	ee 1f       	jnz %d15,8000856a <Ifx_Fifo_read+0x162>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000852e:	ba fa       	eq %d15,%d10,-1
80008530:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008534:	ee fa       	jnz %d15,80008528 <Ifx_Fifo_read+0x120>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008536:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000853a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000853e:	0d 00 40 03 	disable 
80008542:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008544:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008548:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000854c:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008550:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008554:	76 23       	jz %d2,8000855a <Ifx_Fifo_read+0x152>
    {
        __enable();
80008556:	0d 00 00 03 	enable 
8000855a:	0b 8f 00 21 	eq %d2,%d15,%d8
8000855e:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
80008562:	0b 8f 90 22 	or.lt %d2,%d15,%d8
80008566:	df 02 e1 ff 	jne %d2,0,80008528 <Ifx_Fifo_read+0x120>
                {}

                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
8000856a:	39 fd 1c 00 	ld.bu %d13,[%a15]28
8000856e:	8b 0d 00 d2 	eq %d13,%d13,0
80008572:	1d ff 78 ff 	j 80008462 <Ifx_Fifo_read+0x5a>
            }
        } while (count != 0);

        fifo->startIndex = buffer.index;
80008576:	8c a2       	ld.h %d15,[%sp]4
80008578:	a8 af       	st.h [%a15]20,%d15
    }

    return count;
}
8000857a:	02 92       	mov %d2,%d9
8000857c:	00 90       	ret 

8000857e <Ifx_Fifo_clear>:
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000857e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008582:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008586:	0d 00 40 03 	disable 
8000858a:	00 00       	nop 
{
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();

    if (fifo->shared.writerWaitx != 0)
8000858c:	4c 43       	ld.w %d15,[%a4]12
8000858e:	6e 06       	jz %d15,8000859a <Ifx_Fifo_clear+0x1c>
    {
        fifo->shared.writerWaitx = 0;
80008590:	82 0f       	mov %d15,0
80008592:	6c 43       	st.w [%a4]12,%d15
        fifo->eventWriter        = TRUE; /* Signal the writer */
80008594:	82 1f       	mov %d15,1
80008596:	e9 4f 1d 00 	st.b [%a4]29,%d15
    }

    fifo->eventReader        = FALSE;
8000859a:	82 0f       	mov %d15,0
8000859c:	e9 4f 1c 00 	st.b [%a4]28,%d15
    fifo->shared.readerWaitx = 0;
800085a0:	82 0f       	mov %d15,0
800085a2:	6c 42       	st.w [%a4]8,%d15
    fifo->shared.count       = 0;
800085a4:	ac 42       	st.h [%a4]4,%d15
    fifo->shared.maxcount    = 0;
800085a6:	ac 48       	st.h [%a4]16,%d15
    fifo->startIndex         = fifo->endIndex;
800085a8:	8c 4b       	ld.h %d15,[%a4]22
800085aa:	ac 4a       	st.h [%a4]20,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085ac:	76 23       	jz %d2,800085b2 <Ifx_Fifo_clear+0x34>
    {
        __enable();
800085ae:	0d 00 00 03 	enable 
800085b2:	00 90       	ret 

800085b4 <Ifx_Fifo_canWriteCount>:
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
800085b4:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be written to the buffer */
        result = FALSE;
800085b6:	82 02       	mov %d2,0
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
800085b8:	3f f4 75 00 	jlt %d4,%d15,800086a2 <Ifx_Fifo_canWriteCount+0xee>
800085bc:	8c 4c       	ld.h %d15,[%a4]24
800085be:	3f 4f 72 00 	jlt %d15,%d4,800086a2 <Ifx_Fifo_canWriteCount+0xee>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800085c2:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
800085c6:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085ca:	0d 00 40 03 	disable 
800085ce:	00 00       	nop 
    else
    {
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
800085d0:	c9 43 18 00 	ld.h %d3,[%a4]24
800085d4:	8c 42       	ld.h %d15,[%a4]4
800085d6:	5a f3       	sub %d15,%d3,%d15
800085d8:	3f 4f 0d 00 	jlt %d15,%d4,800085f2 <Ifx_Fifo_canWriteCount+0x3e>
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE;
800085dc:	82 1f       	mov %d15,1
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
        {
            fifo->shared.writerWaitx = 0;
800085de:	59 42 0c 00 	st.w [%a4]12,%d2
            fifo->eventWriter        = TRUE;
800085e2:	e9 4f 1d 00 	st.b [%a4]29,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
800085e6:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085e8:	df 00 5d 00 	jeq %d0,0,800086a2 <Ifx_Fifo_canWriteCount+0xee>
    {
        __enable();
800085ec:	0d 00 00 03 	enable 
800085f0:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800085f2:	82 f2       	mov %d2,-1
800085f4:	06 f2       	sh %d2,-1
800085f6:	ba f6       	eq %d15,%d6,-1
800085f8:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800085fc:	82 f5       	mov %d5,-1
800085fe:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008600:	ee 16       	jnz %d15,8000862c <Ifx_Fifo_canWriteCount+0x78>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008602:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008606:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000860a:	0d 00 40 03 	disable 
8000860e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008610:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008614:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008618:	02 15       	mov %d5,%d1
8000861a:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000861e:	76 23       	jz %d2,80008624 <Ifx_Fifo_canWriteCount+0x70>
    {
        __enable();
80008620:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008624:	0b 65 40 50 	addx %d5,%d5,%d6
80008628:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
8000862c:	82 0f       	mov %d15,0
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
8000862e:	c9 42 04 00 	ld.h %d2,[%a4]4
            result                   = TRUE;
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
80008632:	e9 4f 1d 00 	st.b [%a4]29,%d15
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
80008636:	8c 4c       	ld.h %d15,[%a4]24
80008638:	5a f2       	sub %d15,%d2,%d15
8000863a:	42 f4       	add %d4,%d15
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000863c:	82 02       	mov %d2,0
8000863e:	0b 42 a0 41 	max %d4,%d2,%d4
80008642:	59 44 0c 00 	st.w [%a4]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008646:	76 03       	jz %d0,8000864c <Ifx_Fifo_canWriteCount+0x98>
    {
        __enable();
80008648:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000864c:	82 f6       	mov %d6,-1
8000864e:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008650:	39 4f 1d 00 	ld.bu %d15,[%a4]29
80008654:	6e 08       	jz %d15,80008664 <Ifx_Fifo_canWriteCount+0xb0>
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
            result = fifo->eventWriter == TRUE;
80008656:	39 42 1d 00 	ld.bu %d2,[%a4]29
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
8000865a:	82 0f       	mov %d15,0
8000865c:	6c 43       	st.w [%a4]12,%d15
            result = fifo->eventWriter == TRUE;
8000865e:	8b 12 00 22 	eq %d2,%d2,1
80008662:	00 90       	ret 
80008664:	ba f5       	eq %d15,%d5,-1
80008666:	0b 36 00 f2 	and.eq %d15,%d6,%d3
8000866a:	ee f3       	jnz %d15,80008650 <Ifx_Fifo_canWriteCount+0x9c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000866c:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008670:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008674:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008678:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000867a:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000867e:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008682:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008686:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000868a:	76 23       	jz %d2,80008690 <Ifx_Fifo_canWriteCount+0xdc>
    {
        __enable();
8000868c:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008690:	0b 3f 00 21 	eq %d2,%d15,%d3
80008694:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
80008698:	0b 3f 90 22 	or.lt %d2,%d15,%d3
8000869c:	df 02 da ff 	jne %d2,0,80008650 <Ifx_Fifo_canWriteCount+0x9c>
800086a0:	3c db       	j 80008656 <Ifx_Fifo_canWriteCount+0xa2>
            result = fifo->eventWriter == TRUE;
        }
    }

    return result;
}
800086a2:	00 90       	ret 

800086a4 <Ifx_Fifo_write>:
}


#include <stdio.h>
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
800086a4:	20 08       	sub.a %sp,8
800086a6:	40 4f       	mov.aa %a15,%a4
800086a8:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
800086aa:	df 04 be 00 	jeq %d4,0,80008826 <Ifx_Fifo_write+0x182>
    {
        buffer.base   = fifo->buffer;
800086ae:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800086b0:	82 f2       	mov %d2,-1
800086b2:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
800086b4:	8c 4c       	ld.h %d15,[%a4]24
800086b6:	06 f2       	sh %d2,-1
800086b8:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
800086ba:	8c 4b       	ld.h %d15,[%a4]22
    {
        deadLine = TIME_INFINITE;
800086bc:	82 fa       	mov %d10,-1
800086be:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800086c0:	ba f6       	eq %d15,%d6,-1
800086c2:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800086c6:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800086c8:	ee 16       	jnz %d15,800086f4 <Ifx_Fifo_write+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800086ca:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800086ce:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800086d2:	0d 00 40 03 	disable 
800086d6:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800086d8:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800086dc:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800086e0:	02 3a       	mov %d10,%d3
800086e2:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800086e6:	76 23       	jz %d2,800086ec <Ifx_Fifo_write+0x48>
    {
        __enable();
800086e8:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800086ec:	0b 6a 40 a0 	addx %d10,%d10,%d6
800086f0:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800086f4:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
800086f6:	82 0d       	mov %d13,0
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventWriter        = FALSE;
800086f8:	82 0e       	mov %d14,0
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
800086fa:	a0 0c       	mov.a %a12,0
800086fc:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800086fe:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80008702:	37 05 e1 57 	extr.u %d5,%d5,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008706:	0d 00 40 03 	disable 
8000870a:	00 00       	nop 
{
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
8000870c:	88 c4       	ld.h %d4,[%a15]24
8000870e:	88 2b       	ld.h %d11,[%a15]4
80008710:	0b b4 80 b0 	sub %d11,%d4,%d11
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008714:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
80008718:	8c fd       	ld.h %d15,[%a15]26
8000871a:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventWriter        = FALSE;
8000871e:	e9 fe 1d 00 	st.b [%a15]29,%d14
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
80008722:	4b f2 01 22 	div %e2,%d2,%d15
80008726:	a2 3b       	sub %d11,%d3
80008728:	37 0b 70 b0 	extr.u %d11,%d11,0,16
8000872c:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventWriter        = FALSE;
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
80008730:	0b f9 80 20 	sub %d2,%d9,%d15
80008734:	0b 42 80 41 	min %d4,%d2,%d4
80008738:	68 34       	st.w [%a15]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000873a:	76 53       	jz %d5,80008740 <Ifx_Fifo_write+0x9c>
    {
        __enable();
8000873c:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
80008740:	6e 26       	jz %d15,8000878c <Ifx_Fifo_write+0xe8>
            {

                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
80008742:	40 a4       	mov.aa %a4,%sp
80008744:	02 f4       	mov %d4,%d15
80008746:	6d ff 6d fd 	call 80008220 <Ifx_CircularBuffer_write8>
8000874a:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000874c:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
80008750:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008754:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008758:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
8000875a:	88 22       	ld.h %d2,[%a15]4
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
8000875c:	88 84       	ld.h %d4,[%a15]16
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
8000875e:	42 b2       	add %d2,%d11
80008760:	37 02 50 20 	extr %d2,%d2,0,16
80008764:	a8 22       	st.h [%a15]4,%d2
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008766:	0b 24 a0 21 	max %d2,%d4,%d2
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
8000876a:	a8 82       	st.h [%a15]16,%d2

    if (fifo->shared.readerWaitx != 0)
8000876c:	48 22       	ld.w %d2,[%a15]8
8000876e:	76 29       	jz %d2,80008780 <Ifx_Fifo_write+0xdc>
    {
        fifo->shared.readerWaitx -= blockSize;
80008770:	5a f2       	sub %d15,%d2,%d15

        if (fifo->shared.readerWaitx <= 0)
80008772:	8e f3       	jlez %d15,80008778 <Ifx_Fifo_write+0xd4>
    fifo->shared.count   += blockSize;
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */

    if (fifo->shared.readerWaitx != 0)
    {
        fifo->shared.readerWaitx -= blockSize;
80008774:	68 2f       	st.w [%a15]8,%d15
80008776:	3c 05       	j 80008780 <Ifx_Fifo_write+0xdc>

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
80008778:	82 1f       	mov %d15,1
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
8000877a:	e8 2c       	st.a [%a15]8,%a12
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
8000877c:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008780:	76 33       	jz %d3,80008786 <Ifx_Fifo_write+0xe2>
    {
        __enable();
80008782:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
80008786:	a2 b9       	sub %d9,%d11
80008788:	37 09 50 90 	extr %d9,%d9,0,16
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
8000878c:	76 d4       	jz %d13,80008794 <Ifx_Fifo_write+0xf0>
            {
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
8000878e:	82 0f       	mov %d15,0
80008790:	68 3f       	st.w [%a15]12,%d15
                break;
80008792:	3c 48       	j 80008822 <Ifx_Fifo_write+0x17e>
80008794:	ba fa       	eq %d15,%d10,-1
80008796:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
8000879a:	ee 1b       	jnz %d15,800087d0 <Ifx_Fifo_write+0x12c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000879c:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800087a0:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800087a4:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800087a8:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800087aa:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800087ae:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800087b2:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800087b6:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800087ba:	76 23       	jz %d2,800087c0 <Ifx_Fifo_write+0x11c>
    {
        __enable();
800087bc:	0d 00 00 03 	enable 
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800087c0:	0b 8f 00 21 	eq %d2,%d15,%d8
800087c4:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
800087c8:	0b f8 90 22 	or.lt %d2,%d8,%d15
800087cc:	df 02 e1 ff 	jne %d2,0,8000878e <Ifx_Fifo_write+0xea>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
800087d0:	df 09 29 00 	jeq %d9,0,80008822 <Ifx_Fifo_write+0x17e>
            {
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800087d4:	39 ff 1d 00 	ld.bu %d15,[%a15]29
800087d8:	ee 1f       	jnz %d15,80008816 <Ifx_Fifo_write+0x172>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800087da:	ba fa       	eq %d15,%d10,-1
800087dc:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
800087e0:	ee fa       	jnz %d15,800087d4 <Ifx_Fifo_write+0x130>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800087e2:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800087e6:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800087ea:	0d 00 40 03 	disable 
800087ee:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800087f0:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800087f4:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800087f8:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800087fc:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008800:	76 23       	jz %d2,80008806 <Ifx_Fifo_write+0x162>
    {
        __enable();
80008802:	0d 00 00 03 	enable 
80008806:	0b 8f 00 21 	eq %d2,%d15,%d8
8000880a:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
8000880e:	0b 8f 90 22 	or.lt %d2,%d15,%d8
80008812:	df 02 e1 ff 	jne %d2,0,800087d4 <Ifx_Fifo_write+0x130>
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
80008816:	39 fd 1d 00 	ld.bu %d13,[%a15]29
8000881a:	8b 0d 00 d2 	eq %d13,%d13,0
8000881e:	1d ff 70 ff 	j 800086fe <Ifx_Fifo_write+0x5a>
            }
        } while (count != 0);

        fifo->endIndex = buffer.index;
80008822:	8c a2       	ld.h %d15,[%sp]4
80008824:	a8 bf       	st.h [%a15]22,%d15
    }

    return count;
}
80008826:	02 92       	mov %d2,%d9
80008828:	00 90       	ret 
	...

8000882c <syncInfoState>:
void initInfotainment(void){
    lcd_clear(); // LCD    
    printInfoDisplay(); 
}

void syncInfoState(void){
8000882c:	00 90       	ret 

8000882e <updatePacket>:


}

void updatePacket(void){
8000882e:	00 90       	ret 

80008830 <printStateLv1>:
    }

}

void printStateLv1(){
    sprintf(buf, "\xDB\xDB");
80008830:	91 00 00 f7 	movh.a %a15,28672
80008834:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
80008838:	91 00 00 28 	movh.a %a2,32768
8000883c:	d9 22 d4 60 	lea %a2,[%a2]3476 <80000d94 <IfxVadc_Adc_masterIndex+0x40>>
80008840:	40 f4       	mov.aa %a4,%a15
80008842:	04 2f       	ld.bu %d15,[%a2+]
80008844:	24 ff       	st.b [%a15+],%d15
80008846:	ee fe       	jnz %d15,80008842 <printStateLv1+0x12>
    lcd_print(buf);
80008848:	1d ff b7 dc 	j 800041b6 <lcd_print>

8000884c <printStateLv2>:
}
void printStateLv2(){
    sprintf(buf, "\xDB\xDB\xDB\xDB");
8000884c:	91 00 00 f7 	movh.a %a15,28672
80008850:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
80008854:	91 00 00 28 	movh.a %a2,32768
80008858:	d9 22 d7 60 	lea %a2,[%a2]3479 <80000d97 <IfxVadc_Adc_masterIndex+0x43>>
8000885c:	40 f4       	mov.aa %a4,%a15
8000885e:	04 2f       	ld.bu %d15,[%a2+]
80008860:	24 ff       	st.b [%a15+],%d15
80008862:	ee fe       	jnz %d15,8000885e <printStateLv2+0x12>
    lcd_print(buf);
80008864:	1d ff a9 dc 	j 800041b6 <lcd_print>

80008868 <printStateLv3>:
}
void printStateLv3(){
    sprintf(buf, "\xDB\xDB\xDB\xDB\xDB\xDB");
80008868:	91 00 00 f7 	movh.a %a15,28672
8000886c:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
80008870:	91 00 00 28 	movh.a %a2,32768
80008874:	d9 22 dc 60 	lea %a2,[%a2]3484 <80000d9c <IfxVadc_Adc_masterIndex+0x48>>
80008878:	40 f4       	mov.aa %a4,%a15
8000887a:	04 2f       	ld.bu %d15,[%a2+]
8000887c:	24 ff       	st.b [%a15+],%d15
8000887e:	ee fe       	jnz %d15,8000887a <printStateLv3+0x12>
    lcd_print(buf);
80008880:	1d ff 9b dc 	j 800041b6 <lcd_print>

80008884 <printStateLv4>:
}
void printStateLv4(){
    sprintf(buf, "\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB");
80008884:	91 00 00 f7 	movh.a %a15,28672
80008888:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
8000888c:	91 00 00 28 	movh.a %a2,32768
80008890:	d9 22 e3 60 	lea %a2,[%a2]3491 <80000da3 <IfxVadc_Adc_masterIndex+0x4f>>
80008894:	40 f4       	mov.aa %a4,%a15
80008896:	04 2f       	ld.bu %d15,[%a2+]
80008898:	24 ff       	st.b [%a15+],%d15
8000889a:	ee fe       	jnz %d15,80008896 <printStateLv4+0x12>
    lcd_print(buf);
8000889c:	1d ff 8d dc 	j 800041b6 <lcd_print>

800088a0 <printStateOn>:
}
void printStateOn(){
    sprintf(buf, "mode on");
800088a0:	91 00 00 f7 	movh.a %a15,28672
800088a4:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
800088a8:	91 00 00 28 	movh.a %a2,32768
800088ac:	d9 22 ec 60 	lea %a2,[%a2]3500 <80000dac <IfxVadc_Adc_masterIndex+0x58>>
800088b0:	40 f4       	mov.aa %a4,%a15
800088b2:	04 2f       	ld.bu %d15,[%a2+]
800088b4:	24 ff       	st.b [%a15+],%d15
800088b6:	ee fe       	jnz %d15,800088b2 <printStateOn+0x12>
    lcd_print(buf);
800088b8:	1d ff 7f dc 	j 800041b6 <lcd_print>

800088bc <printStateOff>:
}
void printStateOff(){
    sprintf(buf, "mode off");
800088bc:	91 00 00 f7 	movh.a %a15,28672
800088c0:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
800088c4:	91 00 00 28 	movh.a %a2,32768
800088c8:	d9 22 f4 60 	lea %a2,[%a2]3508 <80000db4 <IfxVadc_Adc_masterIndex+0x60>>
800088cc:	40 f4       	mov.aa %a4,%a15
800088ce:	04 2f       	ld.bu %d15,[%a2+]
800088d0:	24 ff       	st.b [%a15+],%d15
800088d2:	ee fe       	jnz %d15,800088ce <printStateOff+0x12>
    lcd_print(buf);
800088d4:	1d ff 71 dc 	j 800041b6 <lcd_print>

800088d8 <printStateRed>:
}
void printStateRed(){
    sprintf(buf, "light red");
800088d8:	91 00 00 f7 	movh.a %a15,28672
800088dc:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
800088e0:	91 00 00 28 	movh.a %a2,32768
800088e4:	d9 22 fd 60 	lea %a2,[%a2]3517 <80000dbd <IfxVadc_Adc_masterIndex+0x69>>
800088e8:	40 f4       	mov.aa %a4,%a15
800088ea:	04 2f       	ld.bu %d15,[%a2+]
800088ec:	24 ff       	st.b [%a15+],%d15
800088ee:	ee fe       	jnz %d15,800088ea <printStateRed+0x12>
    lcd_print(buf);
800088f0:	1d ff 63 dc 	j 800041b6 <lcd_print>

800088f4 <printStateGreen>:
}
void printStateGreen(){
    sprintf(buf, "light green");
800088f4:	91 00 00 f7 	movh.a %a15,28672
800088f8:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
800088fc:	91 00 00 28 	movh.a %a2,32768
80008900:	d9 22 c7 70 	lea %a2,[%a2]3527 <80000dc7 <IfxVadc_Adc_masterIndex+0x73>>
80008904:	40 f4       	mov.aa %a4,%a15
80008906:	04 2f       	ld.bu %d15,[%a2+]
80008908:	24 ff       	st.b [%a15+],%d15
8000890a:	ee fe       	jnz %d15,80008906 <printStateGreen+0x12>
    lcd_print(buf);
8000890c:	1d ff 55 dc 	j 800041b6 <lcd_print>

80008910 <printStateBlue>:
}
void printStateBlue(){
    sprintf(buf, "light blue");
80008910:	91 00 00 f7 	movh.a %a15,28672
80008914:	d9 ff c8 00 	lea %a15,[%a15]3080 <70000c08 <buf>>
80008918:	91 00 00 28 	movh.a %a2,32768
8000891c:	d9 22 d3 70 	lea %a2,[%a2]3539 <80000dd3 <IfxVadc_Adc_masterIndex+0x7f>>
80008920:	40 f4       	mov.aa %a4,%a15
80008922:	04 2f       	ld.bu %d15,[%a2+]
80008924:	24 ff       	st.b [%a15+],%d15
80008926:	ee fe       	jnz %d15,80008922 <printStateBlue+0x12>
    lcd_print(buf);
80008928:	1d ff 47 dc 	j 800041b6 <lcd_print>

8000892c <printInfoDisplay>:
    printInfoDisplay(); 
}


void printInfoDisplay(){
    lcd_goto(0,0);
8000892c:	d2 04       	mov %e4,0
8000892e:	6d ff 3d dc 	call 800041a8 <lcd_goto>
    switch (infoState) {
80008932:	91 00 00 c7 	movh.a %a12,28672
80008936:	19 cf e8 00 	ld.w %d15,[%a12]3112 <70000c28 <infoState>>
8000893a:	91 00 00 47 	movh.a %a4,28672
8000893e:	d9 44 c8 00 	lea %a4,[%a4]3080 <70000c08 <buf>>
80008942:	ff 7f 55 80 	jge.u %d15,7,800089ec <printInfoDisplay+0xc0>
80008946:	91 10 00 f8 	movh.a %a15,32769
8000894a:	d9 ff 94 58 	lea %a15,[%a15]-30380 <80008954 <printInfoDisplay+0x28>>
8000894e:	90 ff       	addsc.a %a15,%a15,%d15,2
80008950:	dc 0f       	ji %a15
80008952:	00 00       	nop 
80008954:	1d 00 0e 00 	j 80008970 <printInfoDisplay+0x44>
80008958:	1d 00 15 00 	j 80008982 <printInfoDisplay+0x56>
8000895c:	1d 00 1c 00 	j 80008994 <printInfoDisplay+0x68>
80008960:	1d 00 23 00 	j 800089a6 <printInfoDisplay+0x7a>
80008964:	1d 00 2a 00 	j 800089b8 <printInfoDisplay+0x8c>
80008968:	1d 00 31 00 	j 800089ca <printInfoDisplay+0x9e>
8000896c:	1d 00 38 00 	j 800089dc <printInfoDisplay+0xb0>
        case tunnelMode:
            sprintf(buf, "Tunnel Mode");
80008970:	91 00 00 28 	movh.a %a2,32768
80008974:	40 4f       	mov.aa %a15,%a4
80008976:	d9 22 de 70 	lea %a2,[%a2]3550 <80000dde <IfxVadc_Adc_masterIndex+0x8a>>
8000897a:	04 2f       	ld.bu %d15,[%a2+]
8000897c:	24 ff       	st.b [%a15+],%d15
8000897e:	ee fe       	jnz %d15,8000897a <printInfoDisplay+0x4e>
80008980:	3c 36       	j 800089ec <printInfoDisplay+0xc0>
            break;
        case airConditionMode:
            sprintf(buf,"Air Conditional");
80008982:	91 00 00 28 	movh.a %a2,32768
80008986:	40 4f       	mov.aa %a15,%a4
80008988:	d9 22 ea 70 	lea %a2,[%a2]3562 <80000dea <IfxVadc_Adc_masterIndex+0x96>>
8000898c:	04 2f       	ld.bu %d15,[%a2+]
8000898e:	24 ff       	st.b [%a15+],%d15
80008990:	ee fe       	jnz %d15,8000898c <printInfoDisplay+0x60>
80008992:	3c 2d       	j 800089ec <printInfoDisplay+0xc0>
            break;
        case chairDegree:
            sprintf(buf,"Chair Degree");
80008994:	91 00 00 28 	movh.a %a2,32768
80008998:	40 4f       	mov.aa %a15,%a4
8000899a:	d9 22 fa 70 	lea %a2,[%a2]3578 <80000dfa <IfxVadc_Adc_masterIndex+0xa6>>
8000899e:	04 2f       	ld.bu %d15,[%a2+]
800089a0:	24 ff       	st.b [%a15+],%d15
800089a2:	ee fe       	jnz %d15,8000899e <printInfoDisplay+0x72>
800089a4:	3c 24       	j 800089ec <printInfoDisplay+0xc0>
            break;
        case window:
            sprintf(buf,"window");
800089a6:	91 00 00 28 	movh.a %a2,32768
800089aa:	40 4f       	mov.aa %a15,%a4
800089ac:	d9 22 c7 80 	lea %a2,[%a2]3591 <80000e07 <IfxVadc_Adc_masterIndex+0xb3>>
800089b0:	04 2f       	ld.bu %d15,[%a2+]
800089b2:	24 ff       	st.b [%a15+],%d15
800089b4:	ee fe       	jnz %d15,800089b0 <printInfoDisplay+0x84>
800089b6:	3c 1b       	j 800089ec <printInfoDisplay+0xc0>
            break;
        case embientLight:
            sprintf(buf,"embient light");
800089b8:	91 00 00 28 	movh.a %a2,32768
800089bc:	40 4f       	mov.aa %a15,%a4
800089be:	d9 22 ce 80 	lea %a2,[%a2]3598 <80000e0e <IfxVadc_Adc_masterIndex+0xba>>
800089c2:	04 2f       	ld.bu %d15,[%a2+]
800089c4:	24 ff       	st.b [%a15+],%d15
800089c6:	ee fe       	jnz %d15,800089c2 <printInfoDisplay+0x96>
800089c8:	3c 12       	j 800089ec <printInfoDisplay+0xc0>
            break;
        case adasSensor:
            sprintf(buf,"adas sensor");
800089ca:	91 00 00 28 	movh.a %a2,32768
800089ce:	40 4f       	mov.aa %a15,%a4
800089d0:	d9 22 dc 80 	lea %a2,[%a2]3612 <80000e1c <IfxVadc_Adc_masterIndex+0xc8>>
800089d4:	04 2f       	ld.bu %d15,[%a2+]
800089d6:	24 ff       	st.b [%a15+],%d15
800089d8:	ee fe       	jnz %d15,800089d4 <printInfoDisplay+0xa8>
800089da:	3c 09       	j 800089ec <printInfoDisplay+0xc0>
            break;
        case driveLight:
            sprintf(buf,"Drive Light");
800089dc:	91 00 00 28 	movh.a %a2,32768
800089e0:	40 4f       	mov.aa %a15,%a4
800089e2:	d9 22 e8 80 	lea %a2,[%a2]3624 <80000e28 <IfxVadc_Adc_masterIndex+0xd4>>
800089e6:	04 2f       	ld.bu %d15,[%a2+]
800089e8:	24 ff       	st.b [%a15+],%d15
800089ea:	ee fe       	jnz %d15,800089e6 <printInfoDisplay+0xba>
            break;
    }
    lcd_print(buf); 
800089ec:	6d ff e5 db 	call 800041b6 <lcd_print>
    lcd_goto(1,0);
800089f0:	d2 14       	mov %e4,1
800089f2:	6d ff db db 	call 800041a8 <lcd_goto>
    // sprintf(buf, "state = %u", infotainmentArr[infoState]); 
    // lcd_print(buf); 

    if(infoState == tunnelMode || infoState == driveLight ){
800089f6:	19 cf e8 00 	ld.w %d15,[%a12]3112 <70000c28 <infoState>>
800089fa:	91 00 00 f7 	movh.a %a15,28672
800089fe:	8b 6f 00 22 	eq %d2,%d15,6
80008a02:	8b 0f e0 24 	or.eq %d2,%d15,0
80008a06:	d9 ff ec 00 	lea %a15,[%a15]3116 <70000c2c <infotainmentArr>>
80008a0a:	76 26       	jz %d2,80008a16 <printInfoDisplay+0xea>
        if (infotainmentArr[infoState] == 0) { //mode on
80008a0c:	90 ff       	addsc.a %a15,%a15,%d15,2
80008a0e:	4c f0       	ld.w %d15,[%a15]0
80008a10:	6e 36       	jz %d15,80008a7c <printInfoDisplay+0x150>
            printStateOff();
        }
        else{ //mode off
            printStateOn();
80008a12:	1d ff 47 ff 	j 800088a0 <printStateOn>
        } 
    }
    else if(infoState == embientLight){
80008a16:	5e 4b       	jne %d15,4,80008a2c <printInfoDisplay+0x100>
        switch(infotainmentArr[infoState]){
80008a18:	4c f4       	ld.w %d15,[%a15]16
80008a1a:	1e 15       	jeq %d15,1,80008a24 <printInfoDisplay+0xf8>
80008a1c:	1e 26       	jeq %d15,2,80008a28 <printInfoDisplay+0xfc>
80008a1e:	ee 37       	jnz %d15,80008a8c <printInfoDisplay+0x160>
            case 0:
                printStateRed();
80008a20:	1d ff 5c ff 	j 800088d8 <printStateRed>
                break;
            case 1:
                printStateGreen();
80008a24:	1d ff 68 ff 	j 800088f4 <printStateGreen>
                break;  
            case 2:
                printStateBlue();
80008a28:	1d ff 74 ff 	j 80008910 <printStateBlue>
                break;
        }
    }
    else if(infoState == chairDegree || infoState == window){
80008a2c:	92 e2       	add %d2,%d15,-2
80008a2e:	06 2f       	sh %d15,2
        switch(infotainmentArr[infoState]){
80008a30:	10 ff       	addsc.a %a15,%a15,%d15,0
80008a32:	4c f0       	ld.w %d15,[%a15]0
            case 2:
                printStateBlue();
                break;
        }
    }
    else if(infoState == chairDegree || infoState == window){
80008a34:	ff 22 14 80 	jge.u %d2,2,80008a5c <printInfoDisplay+0x130>
        switch(infotainmentArr[infoState]){
80008a38:	ff 4f 2a 80 	jge.u %d15,4,80008a8c <printInfoDisplay+0x160>
80008a3c:	91 10 00 f8 	movh.a %a15,32769
80008a40:	d9 ff 88 98 	lea %a15,[%a15]-30136 <80008a48 <printInfoDisplay+0x11c>>
80008a44:	90 ff       	addsc.a %a15,%a15,%d15,2
80008a46:	dc 0f       	ji %a15
80008a48:	1d 00 1c 00 	j 80008a80 <printInfoDisplay+0x154>
80008a4c:	1d 00 1c 00 	j 80008a84 <printInfoDisplay+0x158>
80008a50:	1d 00 1c 00 	j 80008a88 <printInfoDisplay+0x15c>
80008a54:	1d 00 02 00 	j 80008a58 <printInfoDisplay+0x12c>
                break;  
            case 2:
                printStateLv3();
                break;
            case 3:
                printStateLv4();
80008a58:	1d ff 16 ff 	j 80008884 <printStateLv4>
                break;
        }
    }
    else{
        switch(infotainmentArr[infoState]){
80008a5c:	ff 4f 18 80 	jge.u %d15,4,80008a8c <printInfoDisplay+0x160>
80008a60:	91 10 00 f8 	movh.a %a15,32769
80008a64:	d9 ff ac 98 	lea %a15,[%a15]-30100 <80008a6c <printInfoDisplay+0x140>>
80008a68:	90 ff       	addsc.a %a15,%a15,%d15,2
80008a6a:	dc 0f       	ji %a15
80008a6c:	1d 00 08 00 	j 80008a7c <printInfoDisplay+0x150>
80008a70:	1d 00 08 00 	j 80008a80 <printInfoDisplay+0x154>
80008a74:	1d 00 08 00 	j 80008a84 <printInfoDisplay+0x158>
80008a78:	1d 00 08 00 	j 80008a88 <printInfoDisplay+0x15c>
            case 0:
                printStateOff();
80008a7c:	1d ff 20 ff 	j 800088bc <printStateOff>
                break;
            case 1:
                printStateLv1();
80008a80:	1d ff d8 fe 	j 80008830 <printStateLv1>
                break;  
            case 2:
                printStateLv2();
80008a84:	1d ff e4 fe 	j 8000884c <printStateLv2>
                break;
            case 3:
                printStateLv3();
80008a88:	1d ff f0 fe 	j 80008868 <printStateLv3>
80008a8c:	00 90       	ret 

80008a8e <initInfotainment>:
#include "infotainment_System.h"
#include "bsw.h"


void initInfotainment(void){
    lcd_clear(); // LCD    
80008a8e:	6d ff 20 db 	call 800040ce <lcd_clear>
    printInfoDisplay(); 
80008a92:	1d ff 4d ff 	j 8000892c <printInfoDisplay>

80008a96 <updateInfoState>:


}

void updateInfoState(unsigned int buttonState){
    switch (buttonState) {
80008a96:	ff 44 4a 80 	jge.u %d4,4,80008b2a <updateInfoState+0x94>
80008a9a:	91 10 00 28 	movh.a %a2,32769
80008a9e:	d9 22 ac a8 	lea %a2,[%a2]-30036 <80008aac <updateInfoState+0x16>>
80008aa2:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80008aa6:	91 00 00 f7 	movh.a %a15,28672
80008aaa:	dc 02       	ji %a2
80008aac:	1d 00 08 00 	j 80008abc <updateInfoState+0x26>
80008ab0:	1d 00 10 00 	j 80008ad0 <updateInfoState+0x3a>
80008ab4:	1d 00 19 00 	j 80008ae6 <updateInfoState+0x50>
80008ab8:	1d 00 24 00 	j 80008b00 <updateInfoState+0x6a>
        case btnUP:
            if (infoState + 1 <= driveLight) {
80008abc:	19 ff e8 00 	ld.w %d15,[%a15]3112 <70000c28 <infoState>>
80008ac0:	91 00 00 27 	movh.a %a2,28672
80008ac4:	ff 6f 04 00 	jge %d15,6,80008acc <updateInfoState+0x36>
                infoState = infoState + 1;
80008ac8:	c2 1f       	add %d15,1
80008aca:	3c 09       	j 80008adc <updateInfoState+0x46>
            }
            else {
                infoState = tunnelMode;
80008acc:	82 0f       	mov %d15,0
80008ace:	3c 07       	j 80008adc <updateInfoState+0x46>
            }
            break;
        case btnDOWN:
            if (infoState - 1 >= tunnelMode) {
80008ad0:	19 ff e8 00 	ld.w %d15,[%a15]3112 <70000c28 <infoState>>
80008ad4:	91 00 00 27 	movh.a %a2,28672
80008ad8:	8e f5       	jlez %d15,80008ae2 <updateInfoState+0x4c>
                infoState = infoState - 1;
80008ada:	c2 ff       	add %d15,-1
80008adc:	59 2f e8 00 	st.w [%a2]3112 <70000c28 <infoState>>,%d15
80008ae0:	3c 25       	j 80008b2a <updateInfoState+0x94>
            }
            else {
                infoState = driveLight;
80008ae2:	82 6f       	mov %d15,6
80008ae4:	3c fc       	j 80008adc <updateInfoState+0x46>
            }
            break;
        case btnLEFT:
            if(infotainmentArr[infoState] -1 >= 0){
80008ae6:	19 ff e8 00 	ld.w %d15,[%a15]3112 <70000c28 <infoState>>
80008aea:	91 00 00 f7 	movh.a %a15,28672
80008aee:	d9 ff ec 00 	lea %a15,[%a15]3116 <70000c2c <infotainmentArr>>
80008af2:	90 ff       	addsc.a %a15,%a15,%d15,2
80008af4:	4c f0       	ld.w %d15,[%a15]0
80008af6:	8e f3       	jlez %d15,80008afc <updateInfoState+0x66>
                infotainmentArr[infoState] = infotainmentArr[infoState] - 1;
80008af8:	c2 ff       	add %d15,-1
80008afa:	3c 17       	j 80008b28 <updateInfoState+0x92>
            }
            else{
                infotainmentArr[infoState] = 0;
80008afc:	82 0f       	mov %d15,0
80008afe:	3c 15       	j 80008b28 <updateInfoState+0x92>
            }
            break;
        case btnRIGHT:
            if(infotainmentArr[infoState] +1 <=  stateMaxArr[infoState]){
80008b00:	19 ff e8 00 	ld.w %d15,[%a15]3112
80008b04:	91 00 00 28 	movh.a %a2,32768
80008b08:	91 00 00 f7 	movh.a %a15,28672
80008b0c:	06 2f       	sh %d15,2
80008b0e:	d9 ff ec 00 	lea %a15,[%a15]3116 <70000c2c <infotainmentArr>>
80008b12:	d9 22 f4 80 	lea %a2,[%a2]3636 <80000e34 <stateMaxArr>>
80008b16:	10 ff       	addsc.a %a15,%a15,%d15,0
80008b18:	10 22       	addsc.a %a2,%a2,%d15,0
80008b1a:	48 02       	ld.w %d2,[%a15]0
80008b1c:	4c 20       	ld.w %d15,[%a2]0
80008b1e:	7f f2 05 00 	jge %d2,%d15,80008b28 <updateInfoState+0x92>
                infotainmentArr[infoState] = infotainmentArr[infoState] +1;
80008b22:	c2 12       	add %d2,1
80008b24:	68 02       	st.w [%a15]0,%d2
80008b26:	3c 02       	j 80008b2a <updateInfoState+0x94>
            }
            else{
                infotainmentArr[infoState] = stateMaxArr[infoState];
80008b28:	68 0f       	st.w [%a15]0,%d15
            }
            break;
        
    }
    lcd_clear(); // LCD    
80008b2a:	6d ff d2 da 	call 800040ce <lcd_clear>
    printInfoDisplay(); 
80008b2e:	1d ff ff fe 	j 8000892c <printInfoDisplay>
	...

80008b34 <initUltrasonic>:
80008b34:	91 40 00 4f 	movh.a %a4,61444
80008b38:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80008b3c:	82 14       	mov %d4,1
80008b3e:	3b 00 08 50 	mov %d5,128
80008b42:	6d ff 92 e8 	call 80005c66 <IfxPort_setPinMode>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80008b46:	91 40 00 4f 	movh.a %a4,61444
80008b4a:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80008b4e:	82 24       	mov %d4,2
80008b50:	3b 80 00 50 	mov %d5,8
80008b54:	1d ff 89 e8 	j 80005c66 <IfxPort_setPinMode>

80008b58 <delay_ms>:
    IfxPort_setPinModeOutput(TRIG_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeInput(ECHO_PIN, IfxPort_InputMode_pullDown);
}

void delay_ms(unsigned long delay)
{
80008b58:	02 4a       	mov %d10,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80008b5a:	6d ff 6d ea 	call 80006034 <IfxScuCcu_getSourceFrequency>
80008b5e:	91 30 00 ff 	movh.a %a15,61443
80008b62:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008b66:	48 04       	ld.w %d4,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008b68:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008b6c:	37 04 64 44 	extr.u %d4,%d4,8,4
80008b70:	53 1f 40 00 	mul.u %e0,%d15,1
80008b74:	4b 04 41 41 	itof %d4,%d4
    result |= ((uint64)stm->CAP.U) << 32;
80008b78:	8f 0f 40 61 	or %d6,%d15,0
80008b7c:	4b 42 51 20 	div.f %d2,%d2,%d4
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
    uint64 ticks_per_ms = freq / 1000;
80008b80:	3b 80 3e 40 	mov %d4,1000
    IfxPort_setPinModeInput(ECHO_PIN, IfxPort_InputMode_pullDown);
}

void delay_ms(unsigned long delay)
{
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
80008b84:	4b 02 71 21 	ftouz %d2,%d2
    uint64 ticks_per_ms = freq / 1000;
80008b88:	4b 42 11 22 	div.u %e2,%d2,%d4
80008b8c:	85 f3 2c 00 	ld.w %d3,f000002c <_SMALL_DATA4_+0x3fff802c>
    uint64 start = IfxStm_get(&MODULE_STM0);
    uint64 wait_ticks = delay * ticks_per_ms;
80008b90:	73 a2 68 40 	mul.u %e4,%d2,%d10
80008b94:	0f 13 a0 70 	or %d7,%d3,%d1

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008b98:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008b9c:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008ba0:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80008ba4:	8f 0f 40 81 	or %d8,%d15,0
80008ba8:	0f 32 a0 90 	or %d9,%d2,%d3

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
80008bac:	0b 68 c0 20 	subx %d2,%d8,%d6
80008bb0:	0b 79 d0 30 	subc %d3,%d9,%d7
80008bb4:	3a 53       	eq %d15,%d3,%d5
80008bb6:	0b 42 30 f2 	and.lt.u %d15,%d2,%d4
80008bba:	0b 53 a0 f2 	or.lt.u %d15,%d3,%d5
80008bbe:	ee ed       	jnz %d15,80008b98 <delay_ms+0x40>
}
80008bc0:	00 90       	ret 

80008bc2 <delay_us>:

void delay_us(unsigned long delay)
{
80008bc2:	02 4a       	mov %d10,%d4
80008bc4:	6d ff 38 ea 	call 80006034 <IfxScuCcu_getSourceFrequency>
80008bc8:	91 30 00 ff 	movh.a %a15,61443
80008bcc:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008bd0:	48 04       	ld.w %d4,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008bd2:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008bd6:	37 04 64 44 	extr.u %d4,%d4,8,4
80008bda:	53 1f 40 00 	mul.u %e0,%d15,1
80008bde:	4b 04 41 41 	itof %d4,%d4
    result |= ((uint64)stm->CAP.U) << 32;
80008be2:	8f 0f 40 61 	or %d6,%d15,0
80008be6:	4b 42 51 20 	div.f %d2,%d2,%d4
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
    uint64 ticks_per_us = freq / 1000000;
80008bea:	7b f0 00 40 	movh %d4,15
80008bee:	1b 04 24 44 	addi %d4,%d4,16960
    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
}

void delay_us(unsigned long delay)
{
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
80008bf2:	4b 02 71 21 	ftouz %d2,%d2
    uint64 ticks_per_us = freq / 1000000;
80008bf6:	4b 42 11 22 	div.u %e2,%d2,%d4
80008bfa:	85 f3 2c 00 	ld.w %d3,f000002c <_SMALL_DATA4_+0x3fff802c>
    uint64 start = IfxStm_get(&MODULE_STM0);
    uint64 wait_ticks = delay * ticks_per_us;
80008bfe:	73 a2 68 40 	mul.u %e4,%d2,%d10
80008c02:	0f 13 a0 70 	or %d7,%d3,%d1

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008c06:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008c0a:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008c0e:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80008c12:	8f 0f 40 81 	or %d8,%d15,0
80008c16:	0f 32 a0 90 	or %d9,%d2,%d3

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
80008c1a:	0b 68 c0 20 	subx %d2,%d8,%d6
80008c1e:	0b 79 d0 30 	subc %d3,%d9,%d7
80008c22:	3a 53       	eq %d15,%d3,%d5
80008c24:	0b 42 30 f2 	and.lt.u %d15,%d2,%d4
80008c28:	0b 53 a0 f2 	or.lt.u %d15,%d3,%d5
80008c2c:	ee ed       	jnz %d15,80008c06 <delay_us+0x44>
}
80008c2e:	00 90       	ret 

80008c30 <sendTrigger>:
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
80008c30:	91 40 00 ff 	movh.a %a15,61444
80008c34:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80008c38:	82 2f       	mov %d15,2
80008c3a:	68 1f       	st.w [%a15]4,%d15
}

void sendTrigger()
{
    IfxPort_setPinHigh(TRIG_PIN);
    delay_us(10);
80008c3c:	3b a0 00 40 	mov %d4,10
80008c40:	7b 20 00 f0 	movh %d15,2
80008c44:	6d ff bf ff 	call 80008bc2 <delay_us>
80008c48:	68 1f       	st.w [%a15]4,%d15
80008c4a:	00 90       	ret 

80008c4c <measureEchoTick>:
}


IFX_INLINE boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex)
{
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
80008c4c:	91 40 00 ff 	movh.a %a15,61444
long measureEchoTick()
{
    uint64 startTick = 0, elapsedTick = 0;
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008c50:	7b 40 07 10 	movh %d1,116
    IfxPort_setPinLow(TRIG_PIN);
}

long measureEchoTick()
{
    uint64 startTick = 0, elapsedTick = 0;
80008c54:	d2 02       	mov %e2,0
80008c56:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008c5a:	1b 01 78 1f 	addi %d1,%d1,-2176
80008c5e:	4c f9       	ld.w %d15,[%a15]36
}

long measureEchoTick()
{
    uint64 startTick = 0, elapsedTick = 0;
    while (IfxPort_getPinState(ECHO_PIN) == 0){
80008c60:	6f 2f 13 80 	jnz.t %d15,2,80008c86 <measureEchoTick+0x3a>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008c64:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008c68:	85 f0 2c 00 	ld.w %d0,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008c6c:	53 1f 40 40 	mul.u %e4,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008c70:	8f 0f 40 21 	or %d2,%d15,0
80008c74:	0f 50 a0 30 	or %d3,%d0,%d5
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008c78:	ba 03       	eq %d15,%d3,0
80008c7a:	0b 12 50 f2 	and.ge.u %d15,%d2,%d1
80008c7e:	8b 03 00 f5 	or.ne %d15,%d3,0
80008c82:	6e ee       	jz %d15,80008c5e <measureEchoTick+0x12>
80008c84:	3c 2c       	j 80008cdc <measureEchoTick+0x90>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008c86:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008c8a:	85 f8 2c 00 	ld.w %d8,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008c8e:	53 1f 40 00 	mul.u %e0,%d15,1
80008c92:	91 40 00 ff 	movh.a %a15,61444
    };
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 1){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008c96:	7b 40 07 00 	movh %d0,116
    result |= ((uint64)stm->CAP.U) << 32;
80008c9a:	8f 0f 40 41 	or %d4,%d15,0
80008c9e:	0f 18 a0 50 	or %d5,%d8,%d1
80008ca2:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80008ca6:	1b 00 78 0f 	addi %d0,%d0,-2176
80008caa:	4c f9       	ld.w %d15,[%a15]36
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
    };
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 1){
80008cac:	6f 2f 17 00 	jz.t %d15,2,80008cda <measureEchoTick+0x8e>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008cb0:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008cb4:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008cb8:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80008cbc:	8f 0f 40 61 	or %d6,%d15,0
80008cc0:	0f 32 a0 70 	or %d7,%d2,%d3
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
80008cc4:	0b 46 c0 20 	subx %d2,%d6,%d4
80008cc8:	0b 57 d0 30 	subc %d3,%d7,%d5
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008ccc:	ba 03       	eq %d15,%d3,0
80008cce:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80008cd2:	8b 03 00 f5 	or.ne %d15,%d3,0
80008cd6:	6e ea       	jz %d15,80008caa <measureEchoTick+0x5e>
80008cd8:	3c 02       	j 80008cdc <measureEchoTick+0x90>
    };
    return (long)elapsedTick;
80008cda:	00 90       	ret 
long measureEchoTick()
{
    uint64 startTick = 0, elapsedTick = 0;
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008cdc:	82 f2       	mov %d2,-1
    while (IfxPort_getPinState(ECHO_PIN) == 1){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
    };
    return (long)elapsedTick;
}
80008cde:	00 90       	ret 

80008ce0 <getUltrasonic>:

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
}

int getUltrasonic(){
    sendTrigger();
80008ce0:	6d ff a8 ff 	call 80008c30 <sendTrigger>
    long echoTicks = measureEchoTick();
80008ce4:	6d ff b4 ff 	call 80008c4c <measureEchoTick>
80008ce8:	02 2f       	mov %d15,%d2
    if(echoTicks==-1)return -1;
80008cea:	82 f2       	mov %d2,-1
80008cec:	1e fb       	jeq %d15,-1,80008d02 <getUltrasonic+0x22>
    return (long)elapsedTick;
}

int calculateDistanceCm(long elapsedTicks)
{
    long timeUs = elapsedTicks / 200;
80008cee:	3b 80 0c 20 	mov %d2,200
80008cf2:	4b 2f 01 22 	div %e2,%d15,%d2
    long distanceCm = timeUs * 34 / 1000 / 2;
80008cf6:	3b 80 3e f0 	mov %d15,1000
80008cfa:	53 12 21 20 	mul %d2,%d2,17
80008cfe:	4b f2 01 22 	div %e2,%d2,%d15
    sendTrigger();
    long echoTicks = measureEchoTick();
    if(echoTicks==-1)return -1;
    int distanceCm = calculateDistanceCm(echoTicks);
    return distanceCm;
}
80008d02:	00 90       	ret 

80008d04 <calculateDistanceCm>:
    return (long)elapsedTick;
}

int calculateDistanceCm(long elapsedTicks)
{
    long timeUs = elapsedTicks / 200;
80008d04:	3b 80 0c 20 	mov %d2,200
80008d08:	4b 24 01 42 	div %e4,%d4,%d2
    long distanceCm = timeUs * 34 / 1000 / 2;
80008d0c:	3b 80 3e 20 	mov %d2,1000
80008d10:	53 14 21 40 	mul %d4,%d4,17
80008d14:	4b 24 01 22 	div %e2,%d4,%d2
    return (int) distanceCm;
}
80008d18:	00 90       	ret 

80008d1a <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008d1a:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008d1e:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008d22:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008d26:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008d2a:	54 25       	ld.w %d5,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008d2c:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008d2e:	37 05 6e 51 	extr.u %d5,%d5,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008d32:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80008d36:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008d3a:	8f f5 83 51 	xor %d5,%d5,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008d3e:	8f f8 83 81 	xor %d8,%d8,63
80008d42:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
80008d46:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80008d48:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80008d4c:	3b 00 b8 f0 	mov %d15,2944
80008d50:	cd 4f e0 0f 	mtcr $psw,%d15
80008d54:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80008d58:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80008d5c:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80008d60:	cd 0f e0 0f 	mtcr $pcxi,%d15
80008d64:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008d68:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008d6c:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008d6e:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008d72:	cd 42 20 09 	mtcr $pcon1,%d2
80008d76:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008d7a:	53 cf 20 f0 	mul %d15,%d15,12
80008d7e:	10 22       	addsc.a %a2,%a2,%d15,0
80008d80:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008d82:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008d84:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008d88:	d9 2f 00 46 	lea %a15,[%a2]24832
80008d8c:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008d90:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008d92:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008d96:	2e 16       	jz.t %d15,1,80008da2 <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008d98:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008d9c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008da0:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008da2:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008da6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008daa:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008dac:	4c f0       	ld.w %d15,[%a15]0
80008dae:	6f 0f ff ff 	jnz.t %d15,0,80008dac <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80008db2:	82 0f       	mov %d15,0
80008db4:	cd cf 20 09 	mtcr $pcon0,%d15
80008db8:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008dbc:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008dbe:	2e 16       	jz.t %d15,1,80008dca <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008dc0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008dc4:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008dc8:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008dca:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008dce:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008dd2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008dd4:	4c f0       	ld.w %d15,[%a15]0
80008dd6:	6f 0f ff 7f 	jz.t %d15,0,80008dd4 <osEE_tc_core0_start+0xba>
80008dda:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008dde:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008de2:	91 30 00 ff 	movh.a %a15,61443
80008de6:	53 cf 20 f0 	mul %d15,%d15,12
80008dea:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008dee:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008df0:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008df2:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008df4:	d9 2f 00 46 	lea %a15,[%a2]24832
80008df8:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008dfc:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008e00:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008e02:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008e06:	2e 16       	jz.t %d15,1,80008e12 <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008e08:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008e0c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008e10:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008e12:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008e16:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008e1a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008e1c:	4c f0       	ld.w %d15,[%a15]0
80008e1e:	6f 0f ff ff 	jnz.t %d15,0,80008e1c <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80008e22:	82 0f       	mov %d15,0
80008e24:	cd 0f 04 09 	mtcr $dcon0,%d15
80008e28:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008e2c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008e2e:	2e 16       	jz.t %d15,1,80008e3a <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008e30:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008e34:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008e38:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008e3a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008e3e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008e42:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008e44:	4c f0       	ld.w %d15,[%a15]0
80008e46:	6f 0f ff 7f 	jz.t %d15,0,80008e44 <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008e4a:	91 30 00 ff 	movh.a %a15,61443
80008e4e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008e52:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008e54:	2e 16       	jz.t %d15,1,80008e60 <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008e56:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008e5a:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008e5e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008e60:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008e64:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008e68:	91 30 00 ff 	movh.a %a15,61443
80008e6c:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008e70:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008e72:	4c f0       	ld.w %d15,[%a15]0
80008e74:	91 30 00 2f 	movh.a %a2,61443
80008e78:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008e7c:	6f 0f fb ff 	jnz.t %d15,0,80008e72 <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
80008e80:	7b 00 00 f8 	movh %d15,32768
80008e84:	1b 0f 20 f1 	addi %d15,%d15,4608
80008e88:	cd 4f e2 0f 	mtcr $btv,%d15
80008e8c:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
80008e90:	7b 00 00 f8 	movh %d15,32768
80008e94:	1b 0f 00 f2 	addi %d15,%d15,8192
80008e98:	cd 0f e2 0f 	mtcr $biv,%d15
80008e9c:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
80008ea0:	7b 20 00 f7 	movh %d15,28674
80008ea4:	1b 0f b0 f9 	addi %d15,%d15,-25856
80008ea8:	cd 8f e2 0f 	mtcr $isp,%d15
80008eac:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008eb0:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008eb2:	2e 16       	jz.t %d15,1,80008ebe <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008eb4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008eb8:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008ebc:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008ebe:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008ec2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008ec6:	91 30 00 ff 	movh.a %a15,61443
80008eca:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008ece:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008ed0:	4c f0       	ld.w %d15,[%a15]0
80008ed2:	6f 0f ff 7f 	jz.t %d15,0,80008ed0 <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
80008ed6:	91 10 00 f7 	movh.a %a15,28673
80008eda:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80008ede:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80008ee0:	91 10 00 f8 	movh.a %a15,32769
80008ee4:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008ee8:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
80008eea:	91 10 00 f8 	movh.a %a15,32769
80008eee:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008ef2:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
80008ef4:	91 10 00 fb 	movh.a %a15,45057
80008ef8:	d9 ff 00 08 	lea %a15,[%a15]-32768 <b0008000 <_SMALL_DATA4_>>
80008efc:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80008efe:	7b 20 00 f7 	movh %d15,28674
80008f02:	7b 20 00 47 	movh %d4,28674
80008f06:	1b 0f c0 69 	addi %d6,%d15,-25600
80008f0a:	1b 04 c0 4b 	addi %d4,%d4,-17408
80008f0e:	a2 64       	sub %d4,%d6
80008f10:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80008f12:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80008f14:	df 04 16 00 	jeq %d4,0,80008f40 <osEE_tc_core0_start+0x226>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80008f18:	9a f4       	add %d15,%d4,-1
80008f1a:	06 6f       	sh %d15,6
80008f1c:	12 63       	add %d3,%d15,%d6

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008f1e:	60 3f       	mov.a %a15,%d3
80008f20:	82 00       	mov %d0,0
80008f22:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008f24:	60 4f       	mov.a %a15,%d4
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008f26:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008f2a:	37 03 70 73 	extr.u %d7,%d3,6,16
80008f2e:	1b 0f fc ff 	addi %d15,%d15,-64

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008f32:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008f34:	37 27 10 28 	insert %d2,%d7,%d2,16,16
80008f38:	42 6f       	add %d15,%d6

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008f3a:	82 53       	mov %d3,5
80008f3c:	fd f0 11 01 	loop %a15,8000915e <osEE_tc_core0_start+0x444>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
80008f40:	cd 82 e3 0f 	mtcr $fcx,%d2
80008f44:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008f48:	91 30 00 ff 	movh.a %a15,61443
80008f4c:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008f50:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008f52:	2e 16       	jz.t %d15,1,80008f5e <osEE_tc_core0_start+0x244>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008f54:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008f58:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008f5c:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008f5e:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008f62:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008f66:	91 30 00 ff 	movh.a %a15,61443
80008f6a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008f6e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008f70:	40 f2       	mov.aa %a2,%a15
80008f72:	4c 20       	ld.w %d15,[%a2]0
80008f74:	91 30 00 ff 	movh.a %a15,61443
80008f78:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008f7c:	6f 0f fb ff 	jnz.t %d15,0,80008f72 <osEE_tc_core0_start+0x258>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
80008f80:	4c f1       	ld.w %d15,[%a15]4
80008f82:	96 08       	or %d15,8
80008f84:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008f86:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008f88:	2e 16       	jz.t %d15,1,80008f94 <osEE_tc_core0_start+0x27a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008f8a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008f8e:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008f92:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008f94:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008f98:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008f9c:	91 30 00 ff 	movh.a %a15,61443
80008fa0:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008fa4:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008fa6:	4c f0       	ld.w %d15,[%a15]0
80008fa8:	6f 0f ff 7f 	jz.t %d15,0,80008fa6 <osEE_tc_core0_start+0x28c>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008fac:	91 30 00 ff 	movh.a %a15,61443
80008fb0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008fb4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008fb6:	2e 16       	jz.t %d15,1,80008fc2 <osEE_tc_core0_start+0x2a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008fb8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008fbc:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008fc0:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008fc2:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008fc6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80008fca:	91 30 00 ff 	movh.a %a15,61443
80008fce:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008fd2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008fd4:	40 f2       	mov.aa %a2,%a15
80008fd6:	4c 20       	ld.w %d15,[%a2]0
80008fd8:	91 30 00 ff 	movh.a %a15,61443
80008fdc:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008fe0:	6f 0f fb ff 	jnz.t %d15,0,80008fd6 <osEE_tc_core0_start+0x2bc>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80008fe4:	4c f1       	ld.w %d15,[%a15]4
80008fe6:	96 08       	or %d15,8
80008fe8:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008fea:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008fec:	2e 16       	jz.t %d15,1,80008ff8 <osEE_tc_core0_start+0x2de>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008fee:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008ff2:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008ff6:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008ff8:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008ffc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80009000:	91 30 00 ff 	movh.a %a15,61443
80009004:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009008:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000900a:	4c f0       	ld.w %d15,[%a15]0
8000900c:	6f 0f ff 7f 	jz.t %d15,0,8000900a <osEE_tc_core0_start+0x2f0>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80009010:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
80009014:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80009016:	d9 44 38 01 	lea %a4,[%a4]4152 <80001038 <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
8000901a:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
8000901c:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
8000901e:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
80009020:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
80009022:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80009024:	9e f6       	jeq %d15,-1,80009050 <osEE_tc_core0_start+0x336>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
80009026:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000902a:	76 49       	jz %d4,8000903c <osEE_tc_core0_start+0x322>
        *block_to_clear.p_ull = 0ULL;
8000902c:	60 4f       	mov.a %a15,%d4
8000902e:	40 32       	mov.aa %a2,%a3
80009030:	b0 ff       	add.a %a15,-1
80009032:	89 22 48 01 	st.d [%a2+]8,%e2
80009036:	fc fe       	loop %a15,80009032 <osEE_tc_core0_start+0x318>
80009038:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
8000903c:	2e 22       	jz.t %d15,2,80009040 <osEE_tc_core0_start+0x326>
        *block_to_clear.p_ui = 0x0U;
8000903e:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
80009040:	2e 12       	jz.t %d15,1,80009044 <osEE_tc_core0_start+0x32a>
        *block_to_clear.p_us = 0x0U;
80009042:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80009044:	2e 02       	jz.t %d15,0,80009048 <osEE_tc_core0_start+0x32e>
        *block_to_clear.p_uc = 0x0U;
80009046:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
80009048:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
8000904c:	bd 04 ea ff 	jnz.a %a4,80009020 <osEE_tc_core0_start+0x306>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
80009050:	91 00 00 68 	movh.a %a6,32768
80009054:	d9 66 20 21 	lea %a6,[%a6]4256 <800010a0 <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
80009058:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
8000905a:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
8000905c:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80009060:	df ff 21 00 	jeq %d15,-1,800090a2 <osEE_tc_core0_start+0x388>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
80009064:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
80009068:	76 4f       	jz %d4,80009086 <osEE_tc_core0_start+0x36c>
8000906a:	60 4f       	mov.a %a15,%d4
8000906c:	40 43       	mov.aa %a3,%a4
8000906e:	40 52       	mov.aa %a2,%a5
80009070:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
80009072:	09 22 48 01 	ld.d %e2,[%a2+]8
80009076:	89 32 48 01 	st.d [%a3+]8,%e2
8000907a:	fc fc       	loop %a15,80009072 <osEE_tc_core0_start+0x358>
8000907c:	06 34       	sh %d4,3
8000907e:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
80009082:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
80009086:	2e 23       	jz.t %d15,2,8000908c <osEE_tc_core0_start+0x372>
        *block_dest.p_ui = *block_src.p_ui;
80009088:	44 52       	ld.w %d2,[%a5+]
8000908a:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
8000908c:	2e 14       	jz.t %d15,1,80009094 <osEE_tc_core0_start+0x37a>
        *block_dest.p_us = *block_src.p_us;
8000908e:	09 52 c2 00 	ld.hu %d2,[%a5+]2
80009092:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80009094:	2e 03       	jz.t %d15,0,8000909a <osEE_tc_core0_start+0x380>
        *block_dest.p_uc = *block_src.p_uc;
80009096:	0c 50       	ld.bu %d15,[%a5]0
80009098:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
8000909a:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
8000909e:	bd 06 dd ff 	jnz.a %a6,80009058 <osEE_tc_core0_start+0x33e>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
800090a2:	91 30 00 ff 	movh.a %a15,61443
800090a6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800090aa:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
800090ac:	2e 16       	jz.t %d15,1,800090b8 <osEE_tc_core0_start+0x39e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
800090ae:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
800090b2:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
800090b6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
800090b8:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
800090bc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
800090c0:	91 30 00 ff 	movh.a %a15,61443
800090c4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800090c8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
800090ca:	4c f0       	ld.w %d15,[%a15]0
800090cc:	6f 0f ff ff 	jnz.t %d15,0,800090ca <osEE_tc_core0_start+0x3b0>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
800090d0:	7b 20 22 f1 	movh %d15,4642
800090d4:	91 30 00 ff 	movh.a %a15,61443
800090d8:	1b 1f 10 f0 	addi %d15,%d15,257
800090dc:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090e0:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
800090e2:	7b 00 00 f5 	movh %d15,20480
800090e6:	91 30 00 ff 	movh.a %a15,61443
800090ea:	1b 0f 10 f1 	addi %d15,%d15,4352
800090ee:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800090f2:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
800090f4:	7b 70 00 f0 	movh %d15,7
800090f8:	91 30 00 ff 	movh.a %a15,61443
800090fc:	1b cf 01 f0 	addi %d15,%d15,28
80009100:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80009104:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
80009106:	4c f0       	ld.w %d15,[%a15]0
80009108:	6f 1f ff 7f 	jz.t %d15,1,80009106 <osEE_tc_core0_start+0x3ec>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
8000910c:	91 30 00 ff 	movh.a %a15,61443
80009110:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80009114:	4c f0       	ld.w %d15,[%a15]0
80009116:	6f 8f ff 7f 	jz.t %d15,8,80009114 <osEE_tc_core0_start+0x3fa>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
8000911a:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000911e:	91 30 00 ff 	movh.a %a15,61443
80009122:	1b 04 20 4c 	addi %d4,%d4,-15872
80009126:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000912a:	6d 00 58 00 	call 800091da <osEE_tc_set_pll_fsource>
8000912e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80009130:	2e 16       	jz.t %d15,1,8000913c <osEE_tc_core0_start+0x422>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80009132:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80009136:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000913a:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000913c:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80009140:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80009144:	91 30 00 ff 	movh.a %a15,61443
80009148:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000914c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000914e:	4c f0       	ld.w %d15,[%a15]0
80009150:	6f 0f ff 7f 	jz.t %d15,0,8000914e <osEE_tc_core0_start+0x434>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
80009154:	6d ff 78 da 	call 80004644 <main>
80009158:	02 24       	mov %d4,%d2
8000915a:	6d 00 3d 28 	call 8000e1d4 <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000915e:	60 f2       	mov.a %a2,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80009160:	8f 4f 1e 40 	sh %d4,%d15,-28
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80009164:	74 22       	st.w [%a2],%d2
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80009166:	c2 f3       	add %d3,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80009168:	37 0f 70 23 	extr.u %d2,%d15,6,16
8000916c:	37 42 10 28 	insert %d2,%d2,%d4,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80009170:	76 36       	jz %d3,8000917c <osEE_tc_core0_start+0x462>
80009172:	1b 0f fc ff 	addi %d15,%d15,-64
80009176:	fc f4       	loop %a15,8000915e <osEE_tc_core0_start+0x444>
80009178:	1d ff e4 fe 	j 80008f40 <osEE_tc_core0_start+0x226>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
8000917c:	cd c2 e3 0f 	mtcr $lcx,%d2
80009180:	0d 00 c0 04 	isync 
80009184:	3c f7       	j 80009172 <osEE_tc_core0_start+0x458>

80009186 <osEE_tc_stm_us_ticks>:
#if (defined(__TASKING__))
#define OS_STOP_SEC_GLOBAL_VAR_CLEARED
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
80009186:	40 ae       	mov.aa %a14,%sp
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
80009188:	91 00 00 f7 	movh.a %a15,28672
8000918c:	19 ff c8 10 	ld.w %d15,[%a15]3144 <70000c48 <osEE_tc_stm_freq_khz>>
80009190:	3b 80 3e 20 	mov %d2,1000
80009194:	3f 2f 0c 80 	jlt.u %d15,%d2,800091ac <osEE_tc_stm_us_ticks+0x26>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
80009198:	7b 20 06 21 	movh %d2,4194
8000919c:	1b 32 dd 24 	addi %d2,%d2,19923
800091a0:	73 2f 68 20 	mul.u %e2,%d15,%d2
800091a4:	8f a3 1f 20 	sh %d2,%d3,-6
800091a8:	e2 42       	mul %d2,%d4
800091aa:	00 90       	ret 
  } else if (usec >= OSEE_KILO) {
800091ac:	02 25       	mov %d5,%d2
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
800091ae:	73 f4 0a 20 	mul %d2,%d4,%d15
800091b2:	7b 20 06 31 	movh %d3,4194
800091b6:	1b 33 dd 34 	addi %d3,%d3,19923
800091ba:	73 32 68 20 	mul.u %e2,%d2,%d3
800091be:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
800091c2:	3f 54 0b 80 	jlt.u %d4,%d5,800091d8 <osEE_tc_stm_us_ticks+0x52>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
800091c6:	7b 20 06 21 	movh %d2,4194
800091ca:	1b 32 dd 24 	addi %d2,%d2,19923
800091ce:	73 24 68 40 	mul.u %e4,%d4,%d2
800091d2:	8f a5 1f 20 	sh %d2,%d5,-6
800091d6:	e2 f2       	mul %d2,%d15
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
  }
  return ticks;
}
800091d8:	00 90       	ret 

800091da <osEE_tc_set_pll_fsource>:
#define OSEE_TC_K2_MIN      (1U)
#define OSEE_TC_N_MAX       (128U)  /* '7 bits */
#define OSEE_TC_N_MIN       (1U)
#define OSEE_TC_DEV_ALLOWED (2U)

void osEE_tc_set_pll_fsource(OsEE_reg fpll) {
800091da:	40 ae       	mov.aa %a14,%sp
  fPllLeastError  = OSEE_TC_CLOCK_MAX;
  fPllError       = OSEE_TC_CLOCK_MAX;

  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
800091dc:	7b e0 e4 20 	movh %d2,3662
800091e0:	1b 12 c0 21 	addi %d2,%d2,7169
800091e4:	0b 24 30 f1 	lt.u %d15,%d4,%d2
800091e8:	82 22       	mov %d2,2
800091ea:	ab 12 80 ff 	sel %d15,%d15,%d2,1
800091ee:	60 f4       	mov.a %a4,%d15
800091f0:	53 ff 20 f0 	mul %d15,%d15,15
800091f4:	60 f5       	mov.a %a5,%d15
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800091f6:	3b 00 01 e0 	mov %d14,16
800091fa:	82 03       	mov %d3,0
800091fc:	7b c0 be 20 	movh %d2,3052
80009200:	1b 02 20 2c 	addi %d2,%d2,-15872
80009204:	02 28       	mov %d8,%d2
80009206:	82 01       	mov %d1,0
80009208:	82 0b       	mov %d11,0
8000920a:	82 0d       	mov %d13,0
8000920c:	82 0c       	mov %d12,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000920e:	7b 10 13 a0 	movh %d10,305
80009212:	1b 0a d0 a2 	addi %d10,%d10,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80009216:	91 40 0f 60 	movh.a %a6,244
8000921a:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
    {
      for (
8000921e:	a0 1d       	mov.a %a13,1
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80009220:	53 14 40 60 	mul.u %e6,%d4,1
80009224:	60 62       	mov.a %a2,%d6
80009226:	60 73       	mov.a %a3,%d7

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80009228:	91 80 7d f1 	movh.a %a15,6104
8000922c:	d9 ff 41 08 	lea %a15,[%a15]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
        {
          for (
80009230:	a0 1c       	mov.a %a12,1
80009232:	3c 5e       	j 800092ee <osEE_tc_set_pll_fsource+0x114>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80009234:	4b ea 11 62 	div.u %e6,%d10,%d14
80009238:	82 07       	mov %d7,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000923a:	7b 60 f8 ff 	movh %d15,65414
8000923e:	1b 0f e0 fe 	addi %d15,%d15,-4608
80009242:	0b f6 40 60 	addx %d6,%d6,%d15
80009246:	8b f7 bf 50 	addc %d5,%d7,-1
8000924a:	ba 05       	eq %d15,%d5,0
8000924c:	80 67       	mov.d %d7,%a6
8000924e:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80009252:	8b 05 00 f5 	or.ne %d15,%d5,0
80009256:	ee 4a       	jnz %d15,800092ea <osEE_tc_set_pll_fsource+0x110>
    {
      for (
80009258:	df 00 56 00 	jeq %d0,0,80009304 <osEE_tc_set_pll_fsource+0x12a>
8000925c:	02 e9       	mov %d9,%d14
8000925e:	80 d0       	mov.d %d0,%a13
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80009260:	60 e7       	mov.a %a7,%d14
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80009262:	80 2f       	mov.d %d15,%a2
80009264:	73 f0 68 60 	mul.u %e6,%d0,%d15
80009268:	80 3f       	mov.d %d15,%a3
8000926a:	03 f0 0a 77 	madd %d7,%d7,%d0,%d15

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000926e:	7b 80 82 fe 	movh %d15,59432
80009272:	1b 0f c0 f7 	addi %d15,%d15,31744
80009276:	0b f6 40 60 	addx %d6,%d6,%d15
8000927a:	8b f7 bf 50 	addc %d5,%d7,-1
8000927e:	ba 05       	eq %d15,%d5,0
80009280:	80 f7       	mov.d %d7,%a15
80009282:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80009286:	8b 05 00 f5 	or.ne %d15,%d5,0
8000928a:	ee 25       	jnz %d15,800092d4 <osEE_tc_set_pll_fsource+0xfa>
        {
          for (
8000928c:	0f 23 a0 f0 	or %d15,%d3,%d2
80009290:	6e 2d       	jz %d15,800092ea <osEE_tc_set_pll_fsource+0x110>
80009292:	80 c6       	mov.d %d6,%a12
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
80009294:	4b 96 11 22 	div.u %e2,%d6,%d9
80009298:	02 2f       	mov %d15,%d2
8000929a:	e2 af       	mul %d15,%d10
8000929c:	a2 4f       	sub %d15,%d4
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
8000929e:	53 1f 40 20 	mul.u %e2,%d15,1
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800092a2:	df 0f ac 00 	jeq %d15,0,800093fa <osEE_tc_set_pll_fsource+0x220>
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
800092a6:	0b 13 00 51 	eq %d5,%d3,%d1
800092aa:	0b 8f 50 52 	and.ge.u %d5,%d15,%d8
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
800092ae:	2b f8 40 85 	sel %d8,%d5,%d8,%d15
800092b2:	ab 01 80 15 	sel %d1,%d5,%d1,0
800092b6:	2b eb 40 b5 	sel %d11,%d5,%d11,%d14
800092ba:	2b 6d 40 d5 	sel %d13,%d5,%d13,%d6
800092be:	2b 0c 40 c5 	sel %d12,%d5,%d12,%d0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
800092c2:	c2 16       	add %d6,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
800092c4:	8b 16 68 52 	lt.u %d5,%d6,129
800092c8:	8b 0f 20 54 	and.ne %d5,%d15,0
800092cc:	df 05 e4 ff 	jne %d5,0,80009294 <osEE_tc_set_pll_fsource+0xba>
800092d0:	02 d6       	mov %d6,%d13
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800092d2:	02 6d       	mov %d13,%d6
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
800092d4:	80 4f       	mov.d %d15,%a4
800092d6:	42 f0       	add %d0,%d15
800092d8:	80 56       	mov.d %d6,%a5
800092da:	42 69       	add %d9,%d6

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
800092dc:	0f 32 a0 50 	or %d5,%d2,%d3
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
800092e0:	8b d0 61 f2 	lt.u %d15,%d0,29
800092e4:	8b 05 20 f4 	and.ne %d15,%d5,0
800092e8:	ee bd       	jnz %d15,80009262 <osEE_tc_set_pll_fsource+0x88>
800092ea:	01 45 20 50 	sub.a %a5,%a5,%a4
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
800092ee:	c2 fe       	add %d14,-1
    k2Steps = 1;
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
800092f0:	0f 32 a0 f0 	or %d15,%d2,%d3
800092f4:	8b 0f 20 02 	ne %d0,%d15,0
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
800092f8:	8b 0e 20 52 	ne %d5,%d14,0
800092fc:	8b 0f 20 54 	and.ne %d5,%d15,0
80009300:	df 05 9a ff 	jne %d5,0,80009234 <osEE_tc_set_pll_fsource+0x5a>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
80009304:	06 14       	sh %d4,1
80009306:	7b c0 1e f5 	movh %d15,20972
8000930a:	1b ff 51 f8 	addi %d15,%d15,-31457
8000930e:	73 f4 68 40 	mul.u %e4,%d4,%d15
80009312:	8f b5 1f 20 	sh %d2,%d5,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
80009316:	ba 01       	eq %d15,%d1,0
80009318:	0b 28 50 f2 	and.ge.u %d15,%d8,%d2
8000931c:	8b 01 00 f5 	or.ne %d15,%d1,0
80009320:	ee 73       	jnz %d15,80009406 <osEE_tc_set_pll_fsource+0x22c>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
80009322:	c2 fc       	add %d12,-1
80009324:	91 30 00 ff 	movh.a %a15,61443
80009328:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000932c:	4c f0       	ld.w %d15,[%a15]0
8000932e:	37 cf 07 c0 	insert %d12,%d15,%d12,0,7
80009332:	68 0c       	st.w [%a15]0,%d12

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
80009334:	91 30 00 ff 	movh.a %a15,61443
80009338:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000933c:	4c f0       	ld.w %d15,[%a15]0
8000933e:	6f 5f ff 7f 	jz.t %d15,5,8000933c <osEE_tc_set_pll_fsource+0x162>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
80009342:	91 30 00 ff 	movh.a %a15,61443
80009346:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000934a:	4c f0       	ld.w %d15,[%a15]0
8000934c:	96 01       	or %d15,1
8000934e:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
80009350:	91 30 00 ff 	movh.a %a15,61443
80009354:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009358:	4c f0       	ld.w %d15,[%a15]0
8000935a:	6f 0f ff 7f 	jz.t %d15,0,80009358 <osEE_tc_set_pll_fsource+0x17e>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000935e:	9a fb       	add %d15,%d11,-1
80009360:	91 30 00 ff 	movh.a %a15,61443
80009364:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009368:	16 0f       	and %d15,15
8000936a:	8f 8f 01 f0 	sh %d15,%d15,24
8000936e:	48 02       	ld.w %d2,[%a15]0
80009370:	b7 02 04 2c 	insert %d2,%d2,0,24,4
80009374:	a6 2f       	or %d15,%d2
80009376:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
80009378:	9a fd       	add %d15,%d13,-1
8000937a:	16 7f       	and %d15,127
8000937c:	8f 9f 00 f0 	sh %d15,%d15,9
80009380:	48 02       	ld.w %d2,[%a15]0
80009382:	b7 02 87 24 	insert %d2,%d2,0,9,7
80009386:	a6 2f       	or %d15,%d2
80009388:	68 0f       	st.w [%a15]0,%d15

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
8000938a:	4c f0       	ld.w %d15,[%a15]0
8000938c:	8f 2f c0 f1 	andn %d15,%d15,2
80009390:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
80009392:	4c f0       	ld.w %d15,[%a15]0
80009394:	96 40       	or %d15,64
80009396:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
80009398:	4c f0       	ld.w %d15,[%a15]0
8000939a:	96 20       	or %d15,32
8000939c:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
8000939e:	91 30 00 ff 	movh.a %a15,61443
800093a2:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800093a6:	4c f0       	ld.w %d15,[%a15]0
800093a8:	6f 3f ff ff 	jnz.t %d15,3,800093a6 <osEE_tc_set_pll_fsource+0x1cc>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
800093ac:	91 30 00 ff 	movh.a %a15,61443
800093b0:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800093b4:	4c f0       	ld.w %d15,[%a15]0
800093b6:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
800093ba:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
800093bc:	91 30 00 ff 	movh.a %a15,61443
800093c0:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800093c4:	4c f0       	ld.w %d15,[%a15]0
800093c6:	6f 2f ff 7f 	jz.t %d15,2,800093c4 <osEE_tc_set_pll_fsource+0x1ea>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
800093ca:	91 30 00 ff 	movh.a %a15,61443
800093ce:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800093d2:	4c f0       	ld.w %d15,[%a15]0
800093d4:	8f 1f c0 f1 	andn %d15,%d15,1
800093d8:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
800093da:	91 30 00 ff 	movh.a %a15,61443
800093de:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800093e2:	4c f0       	ld.w %d15,[%a15]0
800093e4:	6f 0f ff ff 	jnz.t %d15,0,800093e2 <osEE_tc_set_pll_fsource+0x208>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
800093e8:	91 30 00 ff 	movh.a %a15,61443
800093ec:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800093f0:	4c f0       	ld.w %d15,[%a15]0
800093f2:	8f 0f c4 f1 	andn %d15,%d15,64
800093f6:	68 0f       	st.w [%a15]0,%d15
800093f8:	00 90       	ret 
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
            {
              fPllLeastError = fPllError;
800093fa:	02 28       	mov %d8,%d2
800093fc:	02 31       	mov %d1,%d3
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
800093fe:	80 7b       	mov.d %d11,%a7
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80009400:	02 0c       	mov %d12,%d0
80009402:	1d ff 68 ff 	j 800092d2 <osEE_tc_set_pll_fsource+0xf8>
80009406:	00 90       	ret 

80009408 <osEE_tc_get_fsource>:
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
  }

}

OsEE_reg osEE_tc_get_fsource(void) {
80009408:	40 ae       	mov.aa %a14,%sp
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000940a:	91 30 00 ff 	movh.a %a15,61443
8000940e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009412:	4c f0       	ld.w %d15,[%a15]0
80009414:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
80009418:	7b 60 5f 20 	movh %d2,1526
8000941c:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80009420:	6e 45       	jz %d15,800094aa <osEE_tc_get_fsource+0xa2>
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
80009422:	91 30 00 ff 	movh.a %a15,61443
80009426:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000942a:	4c f0       	ld.w %d15,[%a15]0
8000942c:	6f 0f 11 00 	jz.t %d15,0,8000944e <osEE_tc_get_fsource+0x46>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
80009430:	91 30 00 ff 	movh.a %a15,61443
80009434:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009438:	48 02       	ld.w %d2,[%a15]0
8000943a:	37 02 67 28 	extr.u %d2,%d2,16,7
8000943e:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
80009440:	7b 10 13 f0 	movh %d15,305
80009444:	1b 0f d0 f2 	addi %d15,%d15,11520
80009448:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000944c:	00 90       	ret 
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000944e:	4c f0       	ld.w %d15,[%a15]0
80009450:	6f 3f 11 00 	jz.t %d15,3,80009472 <osEE_tc_get_fsource+0x6a>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009454:	91 30 00 ff 	movh.a %a15,61443
80009458:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000945c:	48 02       	ld.w %d2,[%a15]0
8000945e:	8f f2 07 21 	and %d2,%d2,127
80009462:	9a 12       	add %d15,%d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
80009464:	7b 10 13 20 	movh %d2,305
80009468:	1b 02 d0 22 	addi %d2,%d2,11520
8000946c:	4b f2 11 22 	div.u %e2,%d2,%d15
80009470:	00 90       	ret 
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009472:	91 30 00 ff 	movh.a %a15,61443
80009476:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000947a:	4c f0       	ld.w %d15,[%a15]0
8000947c:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
80009480:	91 30 00 ff 	movh.a %a15,61443
80009484:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009488:	4c f0       	ld.w %d15,[%a15]0
8000948a:	37 0f 64 3c 	extr.u %d3,%d15,24,4
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000948e:	48 02       	ld.w %d2,[%a15]0
80009490:	37 02 e7 44 	extr.u %d4,%d2,9,7
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009494:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
80009496:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
8000949a:	7b 10 13 20 	movh %d2,305
8000949e:	1b 02 d0 22 	addi %d2,%d2,11520
800094a2:	4b f2 11 22 	div.u %e2,%d2,%d15
800094a6:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
800094aa:	00 90       	ret 

800094ac <osEE_tc_stm_set_clockpersec>:
  return ticks;
}

/* Set inside std time reference  */
void osEE_tc_stm_set_clockpersec(void)
{
800094ac:	40 ae       	mov.aa %a14,%sp
#if (defined(__TASKING__))
  /* I don't know where is declared */
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
800094ae:	6d ff ad ff 	call 80009408 <osEE_tc_get_fsource>
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
800094b2:	91 30 00 ff 	movh.a %a15,61443
800094b6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800094ba:	4c f0       	ld.w %d15,[%a15]0
800094bc:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800094c0:	c2 12       	add %d2,1
800094c2:	4b f2 11 22 	div.u %e2,%d2,%d15

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
800094c6:	7b 20 06 f1 	movh %d15,4194
800094ca:	1b 3f dd f4 	addi %d15,%d15,19923
800094ce:	73 f2 68 20 	mul.u %e2,%d2,%d15
800094d2:	8f a3 1f f0 	sh %d15,%d3,-6
800094d6:	91 00 00 f7 	movh.a %a15,28672
800094da:	59 ff c8 10 	st.w [%a15]3144 <70000c48 <osEE_tc_stm_freq_khz>>,%d15
800094de:	00 90       	ret 

800094e0 <osEE_tc_stm_set_sr0>:
    that qualifier on pointers.
 */

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0(OsEE_reg usec,
    OsEE_tc_isr_hw_prio intvec)
{
800094e0:	40 ae       	mov.aa %a14,%sp
800094e2:	02 59       	mov %d9,%d5
800094e4:	4d c0 e1 8f 	mfcr %d8,$core_id
    5U;
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
800094e8:	6d ff 4f fe 	call 80009186 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
800094ec:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
800094f0:	8f 38 00 f1 	and %d15,%d8,3
800094f4:	9b 0f 0f 40 	addih %d4,%d15,240
800094f8:	8f 84 00 40 	sh %d4,%d4,8
800094fc:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
800094fe:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80009500:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
80009502:	68 c2       	st.w [%a15]48,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80009504:	df 09 23 00 	jeq %d9,0,8000954a <osEE_tc_stm_set_sr0+0x6a>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
80009508:	48 e2       	ld.w %d2,[%a15]56
8000950a:	b7 02 05 24 	insert %d2,%d2,0,8,5
8000950e:	68 e2       	st.w [%a15]56,%d2
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80009510:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
80009514:	48 e2       	ld.w %d2,[%a15]56
80009516:	37 32 05 30 	insert %d3,%d2,%d3,0,5
8000951a:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
8000951c:	48 f2       	ld.w %d2,[%a15]60
8000951e:	8f 42 c0 21 	andn %d2,%d2,4
80009522:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
80009524:	48 f2       	ld.w %d2,[%a15]60
80009526:	8f 12 40 21 	or %d2,%d2,1
8000952a:	68 f2       	st.w [%a15]60,%d2

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
8000952c:	06 3f       	sh %d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000952e:	60 f2       	mov.a %a2,%d15
80009530:	d9 2f 50 28 	lea %a15,[%a2]-31600
80009534:	11 4f 00 ff 	addih.a %a15,%a15,61444
80009538:	b7 89 99 93 	insert %d9,%d9,8,7,25
8000953c:	8f 38 00 81 	and %d8,%d8,3
80009540:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80009544:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009546:	68 09       	st.w [%a15]0,%d9
80009548:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en                 = 0U;
8000954a:	48 f2       	ld.w %d2,[%a15]60
8000954c:	8f 12 c0 21 	andn %d2,%d2,1
80009550:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
80009552:	1b 2f 09 f7 	addi %d15,%d15,28818
80009556:	9b 0f e0 f1 	addih %d15,%d15,7680
8000955a:	06 3f       	sh %d15,3
8000955c:	82 02       	mov %d2,0
8000955e:	60 ff       	mov.a %a15,%d15
80009560:	68 02       	st.w [%a15]0,%d2
80009562:	00 90       	ret 

80009564 <osEE_tc_stm_set_sr0_next_match>:
  }
}

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0_next_match(OsEE_reg usec)
{
80009564:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009566:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
8000956a:	6d ff 0e fe 	call 80009186 <osEE_tc_stm_us_ticks>
8000956e:	16 03       	and %d15,3
80009570:	9b 0f 0f f0 	addih %d15,%d15,240
80009574:	8f 8f 00 f0 	sh %d15,%d15,8
80009578:	60 ff       	mov.a %a15,%d15
8000957a:	4c fc       	ld.w %d15,[%a15]48
8000957c:	42 f2       	add %d2,%d15
8000957e:	68 c2       	st.w [%a15]48,%d2
80009580:	00 90       	ret 

80009582 <osEE_tc_stm_set_sr1>:
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1(OsEE_reg usec,
  OsEE_tc_isr_hw_prio intvec)
{
80009582:	40 ae       	mov.aa %a14,%sp
80009584:	02 59       	mov %d9,%d5
80009586:	4d c0 e1 8f 	mfcr %d8,$core_id
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
8000958a:	6d ff fe fd 	call 80009186 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000958e:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009592:	8f 38 00 f1 	and %d15,%d8,3
80009596:	9b 0f 0f 40 	addih %d4,%d15,240
8000959a:	8f 84 00 40 	sh %d4,%d4,8
8000959e:	60 4f       	mov.a %a15,%d4
800095a0:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
800095a2:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
800095a4:	68 d2       	st.w [%a15]52,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
800095a6:	df 09 28 00 	jeq %d9,0,800095f6 <osEE_tc_stm_set_sr1+0x74>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
800095aa:	48 e2       	ld.w %d2,[%a15]56
800095ac:	b7 02 05 2c 	insert %d2,%d2,0,24,5
800095b0:	68 e2       	st.w [%a15]56,%d2
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
800095b2:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
800095b6:	8f f3 01 31 	and %d3,%d3,31
800095ba:	8f 03 01 30 	sh %d3,%d3,16
800095be:	48 e2       	ld.w %d2,[%a15]56
800095c0:	b7 02 05 28 	insert %d2,%d2,0,16,5
800095c4:	a6 23       	or %d3,%d2
800095c6:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
800095c8:	48 f2       	ld.w %d2,[%a15]60
800095ca:	8f 02 44 21 	or %d2,%d2,64
800095ce:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
800095d0:	48 f2       	ld.w %d2,[%a15]60
800095d2:	8f 02 41 21 	or %d2,%d2,16
800095d6:	68 f2       	st.w [%a15]60,%d2
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
800095d8:	06 3f       	sh %d15,3
800095da:	60 f2       	mov.a %a2,%d15
800095dc:	d9 2f 54 28 	lea %a15,[%a2]-31596
800095e0:	11 4f 00 ff 	addih.a %a15,%a15,61444
800095e4:	b7 89 99 93 	insert %d9,%d9,8,7,25
800095e8:	8f 38 00 81 	and %d8,%d8,3
800095ec:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
800095f0:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
800095f2:	68 09       	st.w [%a15]0,%d9
800095f4:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
800095f6:	48 f2       	ld.w %d2,[%a15]60
800095f8:	8f 02 c1 21 	andn %d2,%d2,16
800095fc:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
800095fe:	06 3f       	sh %d15,3
80009600:	60 f2       	mov.a %a2,%d15
80009602:	d9 2f 54 28 	lea %a15,[%a2]-31596
80009606:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000960a:	82 0f       	mov %d15,0
8000960c:	68 0f       	st.w [%a15]0,%d15
8000960e:	00 90       	ret 

80009610 <osEE_tc_stm_set_sr1_next_match>:
  }
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1_next_match(OsEE_reg usec)
{
80009610:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009612:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
80009616:	6d ff b8 fd 	call 80009186 <osEE_tc_stm_us_ticks>
8000961a:	16 03       	and %d15,3
8000961c:	9b 0f 0f f0 	addih %d15,%d15,240
80009620:	8f 8f 00 f0 	sh %d15,%d15,8
80009624:	60 ff       	mov.a %a15,%d15
80009626:	4c fd       	ld.w %d15,[%a15]52
80009628:	42 f2       	add %d2,%d15
8000962a:	68 d2       	st.w [%a15]52,%d2
8000962c:	00 90       	ret 

8000962e <osEE_tc_delay>:
}

void osEE_tc_delay(OsEE_reg usec)
{
8000962e:	40 ae       	mov.aa %a14,%sp
80009630:	4d c0 e1 ff 	mfcr %d15,$core_id
80009634:	16 03       	and %d15,3
80009636:	9b 0f 0f f0 	addih %d15,%d15,240
8000963a:	8f 8f 00 f0 	sh %d15,%d15,8
8000963e:	60 f2       	mov.a %a2,%d15
80009640:	d9 2f 10 00 	lea %a15,[%a2]16
80009644:	19 28 10 00 	ld.w %d8,[%a2]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);
80009648:	6d ff 9f fd 	call 80009186 <osEE_tc_stm_us_ticks>
8000964c:	4c f0       	ld.w %d15,[%a15]0

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
8000964e:	a2 8f       	sub %d15,%d8
80009650:	3f 2f fe ff 	jlt.u %d15,%d2,8000964c <osEE_tc_delay+0x1e>
    ; /* Wait */
  }
}
80009654:	00 90       	ret 

80009656 <osEE_tc_isr2_wrapper>:

#if (defined(__GNUC__))
#pragma section
#endif /* __GNUC__ */

static void OSEE_COMPILER_KEEP osEE_tc_isr2_wrapper(TaskType isr2_tid) {
80009656:	40 ae       	mov.aa %a14,%sp
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
80009658:	6d 00 86 05 	call 8000a164 <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
8000965c:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
80009660:	00 80       	rfe 
80009662:	00 90       	ret 

80009664 <osEE_shutdown_os>:
  osEE_shutdown_os
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
80009664:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009666:	cc 40       	ld.a %a15,[%a4]0
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80009668:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000966c:	82 32       	mov %d2,3
8000966e:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
80009672:	e9 f4 12 00 	st.b [%a15]18,%d4

  if (os_status == OSEE_KERNEL_STARTED) {
80009676:	5e 25       	jne %d15,2,80009680 <osEE_shutdown_os+0x1c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
80009678:	99 44 04 00 	ld.a %a4,[%a4]4
8000967c:	6d 00 89 06 	call 8000a38e <osEE_idle_task_terminate>
  } else {
    osEE_call_shutdown_hook(p_ccb, Error);
  }
  for (;;) {
    ; /* Endless Loop (entered only if Kernel Not Started) */
  }
80009680:	3c 00       	j 80009680 <osEE_shutdown_os+0x1c>

80009682 <DisableAllInterrupts>:
FUNC(void, OS_CODE)
  DisableAllInterrupts
(
  void
)
{
80009682:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009684:	91 00 00 f8 	movh.a %a15,32768
80009688:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000968c:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
80009690:	82 1f       	mov %d15,1
80009692:	e9 ff 1e 00 	st.b [%a15]30,%d15
80009696:	00 90       	ret 

80009698 <EnableAllInterrupts>:
FUNC(void, OS_CODE)
  EnableAllInterrupts
(
  void
)
{
80009698:	40 ae       	mov.aa %a14,%sp
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000969a:	91 00 00 f8 	movh.a %a15,32768
8000969e:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
800096a2:	39 ff 1e 00 	ld.bu %d15,[%a15]30 <800000cc <osEE_cdb_var>>
800096a6:	6e 06       	jz %d15,800096b2 <EnableAllInterrupts+0x1a>
    p_ccb->d_isr_all_cnt = 0U;
800096a8:	82 0f       	mov %d15,0
800096aa:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
800096ae:	0d 00 00 03 	enable 
800096b2:	00 90       	ret 

800096b4 <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
800096b4:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800096b6:	91 00 00 f8 	movh.a %a15,32768
800096ba:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
800096be:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000cc <osEE_cdb_var>>
800096c2:	ee 0c       	jnz %d15,800096da <SuspendAllInterrupts+0x26>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800096c4:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
800096c8:	0d 00 40 03 	disable 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
800096cc:	68 5f       	st.w [%a15]20,%d15
    ++p_ccb->s_isr_all_cnt;
800096ce:	39 ff 1c 00 	ld.bu %d15,[%a15]28
800096d2:	c2 1f       	add %d15,1
800096d4:	e9 ff 1c 00 	st.b [%a15]28,%d15
800096d8:	00 90       	ret 
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
800096da:	8b ff 0f 22 	eq %d2,%d15,255
800096de:	f6 25       	jnz %d2,800096e8 <SuspendAllInterrupts+0x34>
    ++p_ccb->s_isr_all_cnt;
800096e0:	c2 1f       	add %d15,1
800096e2:	e9 ff 1c 00 	st.b [%a15]28,%d15
800096e6:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
800096e8:	91 00 00 48 	movh.a %a4,32768
800096ec:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
800096f0:	3b 90 01 40 	mov %d4,25
800096f4:	3c b8       	j 80009664 <osEE_shutdown_os>

800096f6 <ResumeAllInterrupts>:
FUNC(void, OS_CODE)
  ResumeAllInterrupts
(
  void
)
{
800096f6:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800096f8:	91 00 00 f8 	movh.a %a15,32768
800096fc:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
80009700:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000cc <osEE_cdb_var>>
80009704:	6e 0b       	jz %d15,8000971a <ResumeAllInterrupts+0x24>
    --p_ccb->s_isr_all_cnt;
80009706:	c2 ff       	add %d15,-1
80009708:	16 ff       	and %d15,255
8000970a:	e9 ff 1c 00 	st.b [%a15]28,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
8000970e:	ee 06       	jnz %d15,8000971a <ResumeAllInterrupts+0x24>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009710:	4c f5       	ld.w %d15,[%a15]20
80009712:	cd cf e2 0f 	mtcr $icr,%d15
80009716:	0d 00 c0 04 	isync 
8000971a:	00 90       	ret 

8000971c <SuspendOSInterrupts>:
FUNC(void, OS_CODE)
  SuspendOSInterrupts
(
  void
)
{
8000971c:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000971e:	91 00 00 f8 	movh.a %a15,32768
80009722:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
80009726:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000cc <osEE_cdb_var>>
8000972a:	ee 18       	jnz %d15,8000975a <SuspendOSInterrupts+0x3e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000972c:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009730:	8f f2 0f f1 	and %d15,%d2,255
80009734:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009738:	ee 0a       	jnz %d15,8000974c <SuspendOSInterrupts+0x30>
    OsEE_icr icr_temp = icr;
8000973a:	02 2f       	mov %d15,%d2
8000973c:	3b 30 01 30 	mov %d3,19
80009740:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009744:	cd cf e2 0f 	mtcr $icr,%d15
80009748:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
8000974c:	68 62       	st.w [%a15]24,%d2
    ++p_ccb->s_isr_os_cnt;
8000974e:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80009752:	c2 1f       	add %d15,1
80009754:	e9 ff 1d 00 	st.b [%a15]29,%d15
80009758:	00 90       	ret 
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
8000975a:	8b ff 0f 22 	eq %d2,%d15,255
8000975e:	f6 25       	jnz %d2,80009768 <SuspendOSInterrupts+0x4c>
    ++p_ccb->s_isr_os_cnt;
80009760:	c2 1f       	add %d15,1
80009762:	e9 ff 1d 00 	st.b [%a15]29,%d15
80009766:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
80009768:	91 00 00 48 	movh.a %a4,32768
8000976c:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
80009770:	3b 90 01 40 	mov %d4,25
80009774:	1d ff 78 ff 	j 80009664 <osEE_shutdown_os>

80009778 <ResumeOSInterrupts>:
FUNC(void, OS_CODE)
  ResumeOSInterrupts
(
  void
)
{
80009778:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000977a:	91 00 00 f8 	movh.a %a15,32768
8000977e:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
80009782:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000cc <osEE_cdb_var>>
80009786:	6e 16       	jz %d15,800097b2 <ResumeOSInterrupts+0x3a>
    --p_ccb->s_isr_os_cnt;
80009788:	c2 ff       	add %d15,-1
8000978a:	16 ff       	and %d15,255
8000978c:	e9 ff 1d 00 	st.b [%a15]29,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
80009790:	ee 11       	jnz %d15,800097b2 <ResumeOSInterrupts+0x3a>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
80009792:	48 62       	ld.w %d2,[%a15]24
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009794:	4d c0 e2 3f 	mfcr %d3,$icr
80009798:	02 3f       	mov %d15,%d3
8000979a:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000979e:	8f f2 0f 21 	and %d2,%d2,255
800097a2:	5f 23 08 00 	jeq %d3,%d2,800097b2 <ResumeOSInterrupts+0x3a>
800097a6:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800097aa:	cd cf e2 0f 	mtcr $icr,%d15
800097ae:	0d 00 c0 04 	isync 
800097b2:	00 90       	ret 

800097b4 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
800097b4:	40 ae       	mov.aa %a14,%sp
800097b6:	02 49       	mov %d9,%d4
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800097b8:	91 00 00 f8 	movh.a %a15,32768
800097bc:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800097c0:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800097c4:	8f f8 0f f1 	and %d15,%d8,255
800097c8:	8b 3f a1 f2 	ge.u %d15,%d15,19
800097cc:	ee 0a       	jnz %d15,800097e0 <StartOS+0x2c>
    OsEE_icr icr_temp = icr;
800097ce:	02 8f       	mov %d15,%d8
800097d0:	3b 30 01 20 	mov %d2,19
800097d4:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800097d8:	cd cf e2 0f 	mtcr $icr,%d15
800097dc:	0d 00 c0 04 	isync 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
800097e0:	39 ff 10 00 	ld.bu %d15,[%a15]16
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
800097e4:	82 15       	mov %d5,1
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
800097e6:	ee 21       	jnz %d15,80009828 <StartOS+0x74>
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
800097e8:	6d 00 e6 05 	call 8000a3b4 <osEE_cpu_startos>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
800097ec:	3b 80 01 50 	mov %d5,24
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
800097f0:	df 02 1c 00 	jeq %d2,0,80009828 <StartOS+0x74>
800097f4:	3c 24       	j 8000983c <StartOS+0x88>
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
      p_ccb->os_status = OSEE_KERNEL_STARTED;
800097f6:	82 2f       	mov %d15,2
800097f8:	e9 ff 10 00 	st.b [%a15]16,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
800097fc:	39 ff 10 00 	ld.bu %d15,[%a15]16
80009800:	5e 2a       	jne %d15,2,80009814 <StartOS+0x60>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
80009802:	40 c4       	mov.aa %a4,%a12
80009804:	99 c5 04 00 	ld.a %a5,[%a12]4
80009808:	40 56       	mov.aa %a6,%a5
8000980a:	6d 00 3a 06 	call 8000a47e <osEE_hal_save_ctx_and_ready2stacked>
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
8000980e:	40 c4       	mov.aa %a4,%a12
80009810:	6d 00 8a 04 	call 8000a124 <osEE_task_end>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009814:	0d 00 40 03 	disable 
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
80009818:	3c 00       	j 80009818 <StartOS+0x64>
8000981a:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000981e:	cd cf e2 0f 	mtcr $icr,%d15
80009822:	0d 00 c0 04 	isync 
80009826:	3c 1b       	j 8000985c <StartOS+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009828:	4d c0 e2 4f 	mfcr %d4,$icr
8000982c:	02 4f       	mov %d15,%d4
8000982e:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009832:	8f f8 0f 31 	and %d3,%d8,255
80009836:	5f 34 f2 ff 	jne %d4,%d3,8000981a <StartOS+0x66>
8000983a:	3c 11       	j 8000985c <StartOS+0xa8>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
8000983c:	91 00 00 28 	movh.a %a2,32768
80009840:	d9 22 0c 30 	lea %a2,[%a2]204 <800000cc <osEE_cdb_var>>
80009844:	99 2c 04 00 	ld.a %a12,[%a2]4 <80000004 <BootModeHeader0+0x4>>
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80009848:	82 1f       	mov %d15,1
8000984a:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
8000984e:	e9 f9 11 00 	st.b [%a15]17,%d9
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
80009852:	39 ff 10 00 	ld.bu %d15,[%a15]16
80009856:	df 1f d3 ff 	jne %d15,1,800097fc <StartOS+0x48>
8000985a:	3c ce       	j 800097f6 <StartOS+0x42>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
8000985c:	02 52       	mov %d2,%d5
8000985e:	00 90       	ret 

80009860 <GetActiveApplicationMode>:
FUNC(AppModeType, OS_CODE)
  GetActiveApplicationMode
(
  void
)
{
80009860:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
80009862:	91 00 00 f8 	movh.a %a15,32768
80009866:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
8000986a:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000cc <osEE_cdb_var>>
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
8000986e:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80009872:	6e 03       	jz %d15,80009878 <GetActiveApplicationMode+0x18>
    app_mode = p_ccb->app_mode;
80009874:	39 f2 11 00 	ld.bu %d2,[%a15]17
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
80009878:	00 90       	ret 

8000987a <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
8000987a:	40 ae       	mov.aa %a14,%sp
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000987c:	91 00 00 f8 	movh.a %a15,32768
80009880:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009884:	4c f2       	ld.w %d15,[%a15]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009886:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009888:	7f f4 39 80 	jge.u %d4,%d15,800098fa <ActivateTask+0x80>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000988c:	91 00 00 f8 	movh.a %a15,32768
80009890:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009894:	c8 1f       	ld.a %a15,[%a15]4
80009896:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000989a:	c8 0f       	ld.a %a15,[%a15]0

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000989c:	39 ff 14 00 	ld.bu %d15,[%a15]20
800098a0:	ff 2f 2d 80 	jge.u %d15,2,800098fa <ActivateTask+0x80>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800098a4:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800098a8:	8f f9 0f f1 	and %d15,%d9,255
800098ac:	8b 3f a1 f2 	ge.u %d15,%d15,19
800098b0:	ee 0a       	jnz %d15,800098c4 <ActivateTask+0x4a>
    OsEE_icr icr_temp = icr;
800098b2:	02 9f       	mov %d15,%d9
800098b4:	3b 30 01 20 	mov %d2,19
800098b8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800098bc:	cd cf e2 0f 	mtcr $icr,%d15
800098c0:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
800098c4:	40 f4       	mov.aa %a4,%a15
800098c6:	6d 00 23 04 	call 8000a10c <osEE_task_activated>
800098ca:	02 28       	mov %d8,%d2

      if (ev == E_OK) {
800098cc:	f6 28       	jnz %d2,800098dc <ActivateTask+0x62>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
800098ce:	91 00 00 48 	movh.a %a4,32768
800098d2:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
800098d6:	40 f5       	mov.aa %a5,%a15
800098d8:	6d 00 57 04 	call 8000a186 <osEE_scheduler_task_activated>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800098dc:	4d c0 e2 3f 	mfcr %d3,$icr
800098e0:	02 3f       	mov %d15,%d3
800098e2:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800098e6:	8f f9 0f 21 	and %d2,%d9,255
800098ea:	5f 23 08 00 	jeq %d3,%d2,800098fa <ActivateTask+0x80>
800098ee:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800098f2:	cd cf e2 0f 	mtcr $icr,%d15
800098f6:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
800098fa:	02 82       	mov %d2,%d8
800098fc:	00 90       	ret 

800098fe <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
800098fe:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
80009900:	91 00 00 f8 	movh.a %a15,32768
80009904:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
80009908:	48 03       	ld.w %d3,[%a15]0
8000990a:	91 00 00 28 	movh.a %a2,32768
8000990e:	d9 22 38 20 	lea %a2,[%a2]184 <800000b8 <osEE_kdb_var>>
80009912:	4c 22       	ld.w %d15,[%a2]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009914:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009916:	7f f4 5e 80 	jge.u %d4,%d15,800099d2 <ChainTask+0xd4>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000991a:	91 00 00 28 	movh.a %a2,32768
8000991e:	d9 22 38 20 	lea %a2,[%a2]184 <800000b8 <osEE_kdb_var>>
80009922:	99 22 04 00 	ld.a %a2,[%a2]4 <80000004 <BootModeHeader0+0x4>>
80009926:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000992a:	d4 2c       	ld.a %a12,[%a2]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000992c:	39 cf 14 00 	ld.bu %d15,[%a12]20
80009930:	ff 2f 51 80 	jge.u %d15,2,800099d2 <ChainTask+0xd4>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80009934:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80009938:	6e 09       	jz %d15,8000994a <ChainTask+0x4c>
        p_ccb->s_isr_all_cnt = 0U;
8000993a:	82 0f       	mov %d15,0
8000993c:	e9 ff 1c 00 	st.b [%a15]28,%d15
80009940:	4c f5       	ld.w %d15,[%a15]20
80009942:	cd cf e2 0f 	mtcr $icr,%d15
80009946:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000994a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000994e:	6e 06       	jz %d15,8000995a <ChainTask+0x5c>
        p_ccb->d_isr_all_cnt = 0U;
80009950:	82 0f       	mov %d15,0
80009952:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009956:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000995a:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000995e:	8f f8 0f f1 	and %d15,%d8,255
80009962:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009966:	ee 0a       	jnz %d15,8000997a <ChainTask+0x7c>
    OsEE_icr icr_temp = icr;
80009968:	02 8f       	mov %d15,%d8
8000996a:	3b 30 01 20 	mov %d2,19
8000996e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009972:	cd cf e2 0f 	mtcr $icr,%d15
80009976:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
8000997a:	80 cf       	mov.d %d15,%a12
8000997c:	7e 35       	jne %d15,%d3,80009986 <ChainTask+0x88>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
8000997e:	cc c3       	ld.a %a15,[%a12]12
80009980:	82 5f       	mov %d15,5
80009982:	28 2f       	st.b [%a15]2,%d15
80009984:	3c 15       	j 800099ae <ChainTask+0xb0>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
80009986:	40 c4       	mov.aa %a4,%a12
80009988:	6d 00 c2 03 	call 8000a10c <osEE_task_activated>
        if (ev == E_OK) {
8000998c:	df 02 1a 80 	jne %d2,0,800099c0 <ChainTask+0xc2>
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
80009990:	91 00 00 48 	movh.a %a4,32768
80009994:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
80009998:	40 c5       	mov.aa %a5,%a12
8000999a:	6d 00 2a 04 	call 8000a1ee <osEE_scheduler_task_insert>
8000999e:	3c 08       	j 800099ae <ChainTask+0xb0>
800099a0:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
800099a4:	cd cf e2 0f 	mtcr $icr,%d15
800099a8:	0d 00 c0 04 	isync 
800099ac:	00 90       	ret 
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
800099ae:	91 00 00 f8 	movh.a %a15,32768
800099b2:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
800099b6:	c8 0f       	ld.a %a15,[%a15]0
800099b8:	c8 14       	ld.a %a4,[%a15]4
800099ba:	a0 05       	mov.a %a5,0
800099bc:	1d 00 98 05 	j 8000a4ec <osEE_hal_terminate_ctx>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800099c0:	4d c0 e2 3f 	mfcr %d3,$icr
800099c4:	02 3f       	mov %d15,%d3
800099c6:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800099ca:	8f f8 0f 81 	and %d8,%d8,255
800099ce:	5f 83 e9 ff 	jne %d3,%d8,800099a0 <ChainTask+0xa2>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
800099d2:	00 90       	ret 

800099d4 <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
800099d4:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
800099d6:	91 00 00 f8 	movh.a %a15,32768
800099da:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
800099de:	c8 02       	ld.a %a2,[%a15]0
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
800099e0:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000cc <osEE_cdb_var>>
800099e4:	6e 09       	jz %d15,800099f6 <TerminateTask+0x22>
        p_ccb->s_isr_all_cnt = 0U;
800099e6:	82 0f       	mov %d15,0
800099e8:	e9 ff 1c 00 	st.b [%a15]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800099ec:	4c f5       	ld.w %d15,[%a15]20
800099ee:	cd cf e2 0f 	mtcr $icr,%d15
800099f2:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
800099f6:	39 ff 1e 00 	ld.bu %d15,[%a15]30
800099fa:	6e 06       	jz %d15,80009a06 <TerminateTask+0x32>
        p_ccb->d_isr_all_cnt = 0U;
800099fc:	82 0f       	mov %d15,0
800099fe:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009a02:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009a06:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009a0a:	8f ff 0f 21 	and %d2,%d15,255
80009a0e:	8b 32 a1 22 	ge.u %d2,%d2,19
80009a12:	f6 29       	jnz %d2,80009a24 <TerminateTask+0x50>
80009a14:	3b 30 01 20 	mov %d2,19
80009a18:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009a1c:	cd cf e2 0f 	mtcr $icr,%d15
80009a20:	0d 00 c0 04 	isync 
80009a24:	99 24 04 00 	ld.a %a4,[%a2]4
80009a28:	a0 05       	mov.a %a5,0
80009a2a:	1d 00 61 05 	j 8000a4ec <osEE_hal_terminate_ctx>

80009a2e <Schedule>:
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
80009a2e:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
80009a30:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
80009a34:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
80009a38:	c8 0f       	ld.a %a15,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
80009a3a:	c8 3c       	ld.a %a12,[%a15]12
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
80009a3c:	39 c2 01 00 	ld.bu %d2,[%a12]1 <800000cc <osEE_cdb_var>>
80009a40:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000cc <osEE_cdb_var>>
80009a44:	5f f2 2d 80 	jne %d2,%d15,80009a9e <Schedule+0x70>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009a48:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009a4c:	8f f8 0f f1 	and %d15,%d8,255
80009a50:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009a54:	ee 0a       	jnz %d15,80009a68 <Schedule+0x3a>
    OsEE_icr icr_temp = icr;
80009a56:	02 8f       	mov %d15,%d8
80009a58:	3b 30 01 20 	mov %d2,19
80009a5c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009a60:	cd cf e2 0f 	mtcr $icr,%d15
80009a64:	0d 00 c0 04 	isync 
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
80009a68:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80009a6c:	2c c1       	st.b [%a12]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
80009a6e:	91 00 00 48 	movh.a %a4,32768
80009a72:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
80009a76:	6d 00 36 04 	call 8000a2e2 <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
80009a7a:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80009a7e:	2c c1       	st.b [%a12]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009a80:	4d c0 e2 3f 	mfcr %d3,$icr
80009a84:	02 3f       	mov %d15,%d3
80009a86:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009a8a:	8f f8 0f 21 	and %d2,%d8,255
80009a8e:	5f 23 08 00 	jeq %d3,%d2,80009a9e <Schedule+0x70>
80009a92:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009a96:	cd cf e2 0f 	mtcr $icr,%d15
80009a9a:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
80009a9e:	82 02       	mov %d2,0
80009aa0:	00 90       	ret 

80009aa2 <GetResource>:
FUNC(StatusType, OS_CODE)
  GetResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
80009aa2:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009aa4:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
80009aa8:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
80009aac:	c8 04       	ld.a %a4,[%a15]0
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (res_id < p_kdb->p_kcb->free_res_index);
#else
  return (res_id < p_kdb->res_array_size);
80009aae:	91 00 00 f8 	movh.a %a15,32768
80009ab2:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009ab6:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
80009ab8:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
80009aba:	7f f4 4c 80 	jge.u %d4,%d15,80009b52 <GetResource+0xb0>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
80009abe:	91 00 00 f8 	movh.a %a15,32768
80009ac2:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009ac6:	c8 3f       	ld.a %a15,[%a15]12
80009ac8:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009acc:	c8 03       	ld.a %a3,[%a15]0
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
80009ace:	d4 32       	ld.a %a2,[%a3]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
80009ad0:	cc 43       	ld.a %a15,[%a4]12
    CONST(TaskPrio, AUTOMATIC)
      reso_prio     = p_reso_db->prio;
80009ad2:	0c 34       	ld.bu %d15,[%a3]4
    CONST(TaskPrio, AUTOMATIC)
      current_prio  = p_curr_tcb->current_prio;
80009ad4:	08 14       	ld.bu %d4,[%a15]1
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009ad6:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009ada:	8f f2 0f 31 	and %d3,%d2,255
80009ade:	8b 33 a1 32 	ge.u %d3,%d3,19
80009ae2:	f6 3a       	jnz %d3,80009af6 <GetResource+0x54>
    OsEE_icr icr_temp = icr;
80009ae4:	02 23       	mov %d3,%d2
80009ae6:	3b 30 01 50 	mov %d5,19
80009aea:	37 53 08 30 	insert %d3,%d3,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009aee:	cd c3 e2 0f 	mtcr $icr,%d3
80009af2:	0d 00 c0 04 	isync 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
80009af6:	02 23       	mov %d3,%d2
      ev = E_OS_CORE;
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
80009af8:	7f f4 16 80 	jge.u %d4,%d15,80009b24 <GetResource+0x82>
        p_curr_tcb->current_prio = reso_prio;
80009afc:	28 1f       	st.b [%a15]1,%d15

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
80009afe:	37 0f 48 50 	extr %d5,%d15,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
80009b02:	8b ff 2f 72 	ne %d7,%d15,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
80009b06:	16 7f       	and %d15,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
80009b08:	c2 1f       	add %d15,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
80009b0a:	8f 02 d0 61 	andn %d6,%d2,256
80009b0e:	8f f2 cf 31 	andn %d3,%d2,255
80009b12:	a6 f3       	or %d3,%d15
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009b14:	8f f2 cf 21 	andn %d2,%d2,255
80009b18:	2b 63 40 37 	sel %d3,%d7,%d3,%d6
80009b1c:	8b 05 40 52 	lt %d5,%d5,0
80009b20:	2b 23 40 35 	sel %d3,%d5,%d3,%d2
        flags = osEE_hal_prepare_ipl(flags, reso_prio);
      }

      p_reso_cb->p_owner    = p_curr;
80009b24:	b5 24 08 00 	st.a [%a2]8,%a4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009b28:	4d c0 e2 5f 	mfcr %d5,$icr
80009b2c:	02 5f       	mov %d15,%d5
80009b2e:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009b32:	8f f3 0f 21 	and %d2,%d3,255
80009b36:	5f 25 08 00 	jeq %d5,%d2,80009b46 <GetResource+0xa4>
80009b3a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009b3e:	cd cf e2 0f 	mtcr $icr,%d15
80009b42:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
80009b46:	4c f1       	ld.w %d15,[%a15]4
80009b48:	6c 20       	st.w [%a2]0,%d15
      p_reso_cb->prev_prio  = current_prio;
80009b4a:	e9 24 04 00 	st.b [%a2]4,%d4
      p_curr_tcb->p_last_m  = p_reso_db;
80009b4e:	e8 13       	st.a [%a15]4,%a3

      ev = E_OK;
80009b50:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
80009b52:	00 90       	ret 

80009b54 <ReleaseResource>:
FUNC(StatusType, OS_CODE)
  ReleaseResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
80009b54:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009b56:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_curr = p_ccb->p_curr;
80009b5a:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
80009b5e:	c8 03       	ld.a %a3,[%a15]0
80009b60:	91 00 00 f8 	movh.a %a15,32768
80009b64:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009b68:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
80009b6a:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
80009b6c:	7f f4 69 80 	jge.u %d4,%d15,80009c3e <ReleaseResource+0xea>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
80009b70:	cc 33       	ld.a %a15,[%a3]12
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
80009b72:	91 00 00 28 	movh.a %a2,32768
80009b76:	d9 22 38 20 	lea %a2,[%a2]184 <800000b8 <osEE_kdb_var>>
80009b7a:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
80009b7e:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, TYPEDEF)
      p_reso_cb   = p_reso_db->p_cb;
80009b82:	d4 22       	ld.a %a2,[%a2]
80009b84:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009b86:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009b8a:	8f ff 0f 21 	and %d2,%d15,255
80009b8e:	8b 32 a1 22 	ge.u %d2,%d2,19
80009b92:	f6 2a       	jnz %d2,80009ba6 <ReleaseResource+0x52>
    OsEE_icr icr_temp = icr;
80009b94:	02 f2       	mov %d2,%d15
80009b96:	3b 30 01 30 	mov %d3,19
80009b9a:	37 32 08 20 	insert %d2,%d2,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009b9e:	cd c2 e2 0f 	mtcr $icr,%d2
80009ba2:	0d 00 c0 04 	isync 
    {
      VAR(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      /* Pop the Resources head */
      p_curr_tcb->p_last_m = p_curr_tcb->p_last_m->p_cb->p_next;
80009ba6:	c8 14       	ld.a %a4,[%a15]4
80009ba8:	d4 44       	ld.a %a4,[%a4]
80009baa:	54 42       	ld.w %d2,[%a4]
80009bac:	68 12       	st.w [%a15]4,%d2

      if (p_curr_tcb->p_last_m != NULL) {
80009bae:	df 02 1a 00 	jeq %d2,0,80009be2 <ReleaseResource+0x8e>
        CONST(TaskPrio, AUTOMATIC)
          prev_prio = p_reso_cb->prev_prio;
80009bb2:	39 23 04 00 	ld.bu %d3,[%a2]4

        p_curr_tcb->current_prio = prev_prio;
80009bb6:	28 13       	st.b [%a15]1,%d3

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
80009bb8:	37 03 48 40 	extr %d4,%d3,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
80009bbc:	8b f3 2f 62 	ne %d6,%d3,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
80009bc0:	8f f3 07 31 	and %d3,%d3,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
80009bc4:	c2 13       	add %d3,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
80009bc6:	8f 0f d0 51 	andn %d5,%d15,256
80009bca:	8f ff cf 21 	andn %d2,%d15,255
80009bce:	a6 32       	or %d2,%d3
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009bd0:	8f ff cf f1 	andn %d15,%d15,255
80009bd4:	2b 52 40 26 	sel %d2,%d6,%d2,%d5
80009bd8:	8b 04 40 42 	lt %d4,%d4,0
80009bdc:	2b f2 40 f4 	sel %d15,%d4,%d2,%d15
80009be0:	3c 17       	j 80009c0e <ReleaseResource+0xba>
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;
80009be2:	39 35 1d 00 	ld.bu %d5,[%a3]29

        p_curr_tcb->current_prio = dispatch_prio;
80009be6:	28 15       	st.b [%a15]1,%d5

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
80009be8:	37 05 48 60 	extr %d6,%d5,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
80009bec:	8b f5 2f 42 	ne %d4,%d5,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
80009bf0:	8f f5 07 51 	and %d5,%d5,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
80009bf4:	c2 15       	add %d5,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
80009bf6:	8f 0f d0 21 	andn %d2,%d15,256
80009bfa:	8f ff cf 31 	andn %d3,%d15,255
80009bfe:	a6 53       	or %d3,%d5
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009c00:	8f ff cf 51 	andn %d5,%d15,255
80009c04:	2b 23 40 34 	sel %d3,%d4,%d3,%d2
80009c08:	fa 06       	lt %d15,%d6,0
80009c0a:	2b 53 40 ff 	sel %d15,%d15,%d3,%d5
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_reso_cb->p_owner = NULL;
80009c0e:	82 02       	mov %d2,0
80009c10:	59 22 08 00 	st.w [%a2]8,%d2

      /* Preemption point */
      (void)osEE_scheduler_task_preemption_point(p_kdb);
80009c14:	91 00 00 48 	movh.a %a4,32768
80009c18:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
80009c1c:	6d 00 63 03 	call 8000a2e2 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009c20:	4d c0 e2 5f 	mfcr %d5,$icr
80009c24:	02 53       	mov %d3,%d5
80009c26:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009c2a:	16 ff       	and %d15,255
80009c2c:	5f f5 08 00 	jeq %d5,%d15,80009c3c <ReleaseResource+0xe8>
80009c30:	37 f3 08 30 	insert %d3,%d3,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c34:	cd c3 e2 0f 	mtcr $icr,%d3
80009c38:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      ev = E_OK;
80009c3c:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
80009c3e:	00 90       	ret 

80009c40 <ShutdownOS>:
FUNC(StatusType, OS_CODE)
  ShutdownOS
(
  VAR(StatusType, AUTOMATIC) Error
)
{
80009c40:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009c42:	91 00 00 f8 	movh.a %a15,32768
80009c46:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009c4a:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009c4e:	8f f2 0f f1 	and %d15,%d2,255
80009c52:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009c56:	ee 0a       	jnz %d15,80009c6a <ShutdownOS+0x2a>
    OsEE_icr icr_temp = icr;
80009c58:	02 2f       	mov %d15,%d2
80009c5a:	3b 30 01 30 	mov %d3,19
80009c5e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c62:	cd cf e2 0f 	mtcr $icr,%d15
80009c66:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80009c6a:	39 ff 10 00 	ld.bu %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
80009c6e:	c2 ff       	add %d15,-1
80009c70:	16 ff       	and %d15,255
80009c72:	ff 2f 08 80 	jge.u %d15,2,80009c82 <ShutdownOS+0x42>
        (os_status == OSEE_KERNEL_STARTING))
    {
      osEE_shutdown_os(p_cdb, Error);
80009c76:	91 00 00 48 	movh.a %a4,32768
80009c7a:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
80009c7e:	1d ff f3 fc 	j 80009664 <osEE_shutdown_os>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009c82:	4d c0 e2 3f 	mfcr %d3,$icr
80009c86:	02 3f       	mov %d15,%d3
80009c88:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009c8c:	8f f2 0f 21 	and %d2,%d2,255
80009c90:	5f 23 08 00 	jeq %d3,%d2,80009ca0 <ShutdownOS+0x60>
80009c94:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c98:	cd cf e2 0f 	mtcr $icr,%d15
80009c9c:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
80009ca0:	82 72       	mov %d2,7
80009ca2:	00 90       	ret 

80009ca4 <GetTaskID>:
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
80009ca4:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009ca6:	91 00 00 f8 	movh.a %a15,32768
80009caa:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
80009cae:	3b e0 00 20 	mov %d2,14
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
80009cb2:	bd 04 24 00 	jz.a %a4,80009cfa <GetTaskID+0x56>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
80009cb6:	c8 02       	ld.a %a2,[%a15]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009cb8:	39 2f 14 00 	ld.bu %d15,[%a2]20
80009cbc:	ff 2f 05 80 	jge.u %d15,2,80009cc6 <GetTaskID+0x22>
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
80009cc0:	19 22 10 00 	ld.w %d2,[%a2]16
80009cc4:	3c 19       	j 80009cf6 <GetTaskID+0x52>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80009cc6:	82 f2       	mov %d2,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009cc8:	de 27       	jne %d15,2,80009cf6 <GetTaskID+0x52>
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
80009cca:	c8 3f       	ld.a %a15,[%a15]12
80009ccc:	c8 0f       	ld.a %a15,[%a15]0

      while (p_sn != NULL) {
80009cce:	bd 0f 14 00 	jz.a %a15,80009cf6 <GetTaskID+0x52>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009cd2:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009cd4:	39 2f 14 00 	ld.bu %d15,[%a2]20
80009cd8:	ff 2f 0b 80 	jge.u %d15,2,80009cee <GetTaskID+0x4a>
80009cdc:	3c 06       	j 80009ce8 <GetTaskID+0x44>
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009cde:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009ce0:	39 2f 14 00 	ld.bu %d15,[%a2]20
80009ce4:	ff 2f 05 80 	jge.u %d15,2,80009cee <GetTaskID+0x4a>
          tid = p_searched_tdb->tid;
80009ce8:	19 22 10 00 	ld.w %d2,[%a2]16
          break;
80009cec:	3c 05       	j 80009cf6 <GetTaskID+0x52>
        } else {
          p_sn = p_sn->p_next;
80009cee:	c8 0f       	ld.a %a15,[%a15]0
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
80009cf0:	bd 0f f7 ff 	jnz.a %a15,80009cde <GetTaskID+0x3a>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80009cf4:	82 f2       	mov %d2,-1
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
80009cf6:	74 42       	st.w [%a4],%d2
    ev = E_OK;
80009cf8:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
80009cfa:	00 90       	ret 

80009cfc <GetTaskState>:
  GetTaskState
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(TaskStateRefType, AUTOMATIC)  State
)
{
80009cfc:	40 ae       	mov.aa %a14,%sp
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
80009cfe:	3b e0 00 20 	mov %d2,14
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
80009d02:	bd 04 38 00 	jz.a %a4,80009d72 <GetTaskState+0x76>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80009d06:	91 00 00 f8 	movh.a %a15,32768
80009d0a:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009d0e:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009d10:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009d12:	7f f4 30 80 	jge.u %d4,%d15,80009d72 <GetTaskState+0x76>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009d16:	91 00 00 f8 	movh.a %a15,32768
80009d1a:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009d1e:	c8 1f       	ld.a %a15,[%a15]4
80009d20:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
80009d24:	c8 0f       	ld.a %a15,[%a15]0
80009d26:	c8 3f       	ld.a %a15,[%a15]12
    switch (local_state) {
80009d28:	0c f2       	ld.bu %d15,[%a15]2
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009d2a:	82 02       	mov %d2,0
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
80009d2c:	ff 6f 23 80 	jge.u %d15,6,80009d72 <GetTaskState+0x76>
80009d30:	91 10 00 f8 	movh.a %a15,32769
80009d34:	d9 ff fc 49 	lea %a15,[%a15]-25284 <80009d3c <GetTaskState+0x40>>
80009d38:	90 ff       	addsc.a %a15,%a15,%d15,2
80009d3a:	dc 0f       	ji %a15
80009d3c:	1d 00 0c 00 	j 80009d54 <GetTaskState+0x58>
80009d40:	1d 00 0e 00 	j 80009d5c <GetTaskState+0x60>
80009d44:	1d 00 0c 00 	j 80009d5c <GetTaskState+0x60>
80009d48:	1d 00 0e 00 	j 80009d64 <GetTaskState+0x68>
80009d4c:	1d 00 10 00 	j 80009d6c <GetTaskState+0x70>
80009d50:	1d 00 0e 00 	j 80009d6c <GetTaskState+0x70>
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
80009d54:	82 0f       	mov %d15,0
80009d56:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009d58:	82 02       	mov %d2,0
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
80009d5a:	00 90       	ret 
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
80009d5c:	82 1f       	mov %d15,1
80009d5e:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009d60:	82 02       	mov %d2,0
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
80009d62:	00 90       	ret 
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
80009d64:	82 3f       	mov %d15,3
80009d66:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009d68:	82 02       	mov %d2,0
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
80009d6a:	00 90       	ret 
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
80009d6c:	82 4f       	mov %d15,4
80009d6e:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009d70:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
80009d72:	00 90       	ret 

80009d74 <WaitEvent>:
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009d74:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
80009d76:	91 00 00 f8 	movh.a %a15,32768
80009d7a:	99 fc 0c 30 	ld.a %a12,[%a15]204 <800000cc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009d7e:	d4 cd       	ld.a %a13,[%a12]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80009d80:	cc d3       	ld.a %a15,[%a13]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009d82:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009d86:	8f f8 0f f1 	and %d15,%d8,255
80009d8a:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009d8e:	ee 0a       	jnz %d15,80009da2 <WaitEvent+0x2e>
    OsEE_icr icr_temp = icr;
80009d90:	02 8f       	mov %d15,%d8
80009d92:	3b 30 01 20 	mov %d2,19
80009d96:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009d9a:	cd cf e2 0f 	mtcr $icr,%d15
80009d9e:	0d 00 c0 04 	isync 
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
80009da2:	4c f3       	ld.w %d15,[%a15]12
80009da4:	26 4f       	and %d15,%d4
80009da6:	ee 13       	jnz %d15,80009dcc <WaitEvent+0x58>
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
80009da8:	68 24       	st.w [%a15]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
80009daa:	91 00 00 48 	movh.a %a4,32768
80009dae:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
80009db2:	d9 c5 04 00 	lea %a5,[%a12]4 <800000cc <osEE_cdb_var>>
80009db6:	6d 00 98 01 	call 8000a0e6 <osEE_scheduler_core_pop_running>
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
80009dba:	e8 42       	st.a [%a15]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
80009dbc:	82 3f       	mov %d15,3
80009dbe:	28 2f       	st.b [%a15]2,%d15

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
80009dc0:	40 d4       	mov.aa %a4,%a13
80009dc2:	d4 c5       	ld.a %a5,[%a12]
80009dc4:	6d 00 c1 02 	call 8000a346 <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
80009dc8:	82 0f       	mov %d15,0
80009dca:	68 2f       	st.w [%a15]8,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009dcc:	4d c0 e2 3f 	mfcr %d3,$icr
80009dd0:	02 3f       	mov %d15,%d3
80009dd2:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009dd6:	8f f8 0f 21 	and %d2,%d8,255
80009dda:	5f 23 08 00 	jeq %d3,%d2,80009dea <WaitEvent+0x76>
80009dde:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009de2:	cd cf e2 0f 	mtcr $icr,%d15
80009de6:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
80009dea:	82 02       	mov %d2,0
80009dec:	00 90       	ret 

80009dee <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009dee:	40 ae       	mov.aa %a14,%sp
80009df0:	20 08       	sub.a %sp,8
80009df2:	91 00 00 f8 	movh.a %a15,32768
80009df6:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009dfa:	4c f2       	ld.w %d15,[%a15]8
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009dfc:	3f f4 06 80 	jlt.u %d4,%d15,80009e08 <SetEvent+0x1a>
    ev = E_OS_ID;
80009e00:	82 3f       	mov %d15,3
80009e02:	e9 ef ff ff 	st.b [%a14]-1,%d15
80009e06:	3c 3c       	j 80009e7e <SetEvent+0x90>
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009e08:	91 00 00 f8 	movh.a %a15,32768
80009e0c:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009e10:	c8 1f       	ld.a %a15,[%a15]4
80009e12:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009e16:	c8 04       	ld.a %a4,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009e18:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009e1c:	8f f8 0f f1 	and %d15,%d8,255
80009e20:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009e24:	ee 0a       	jnz %d15,80009e38 <SetEvent+0x4a>
    OsEE_icr icr_temp = icr;
80009e26:	02 8f       	mov %d15,%d8
80009e28:	3b 30 01 20 	mov %d2,19
80009e2c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009e30:	cd cf e2 0f 	mtcr $icr,%d15
80009e34:	0d 00 c0 04 	isync 
80009e38:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
80009e3a:	d9 e5 ff ff 	lea %a5,[%a14]-1
80009e3e:	6d 00 82 01 	call 8000a142 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
80009e42:	bc 2f       	jz.a %a2,80009e60 <SetEvent+0x72>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
80009e44:	91 00 00 48 	movh.a %a4,32768
80009e48:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
80009e4c:	40 25       	mov.aa %a5,%a2
80009e4e:	6d 00 e7 01 	call 8000a21c <osEE_scheduler_task_unblocked>
80009e52:	76 27       	jz %d2,80009e60 <SetEvent+0x72>
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
80009e54:	91 00 00 48 	movh.a %a4,32768
80009e58:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
80009e5c:	6d 00 43 02 	call 8000a2e2 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009e60:	4d c0 e2 3f 	mfcr %d3,$icr
80009e64:	02 3f       	mov %d15,%d3
80009e66:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009e6a:	8f f8 0f 21 	and %d2,%d8,255
80009e6e:	5f 23 08 00 	jeq %d3,%d2,80009e7e <SetEvent+0x90>
80009e72:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009e76:	cd cf e2 0f 	mtcr $icr,%d15
80009e7a:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009e7e:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80009e82:	00 90       	ret 

80009e84 <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
80009e84:	40 ae       	mov.aa %a14,%sp
80009e86:	91 00 00 f8 	movh.a %a15,32768
80009e8a:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009e8e:	4c f2       	ld.w %d15,[%a15]8
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009e90:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009e92:	7f f4 11 80 	jge.u %d4,%d15,80009eb4 <GetEvent+0x30>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009e96:	91 00 00 f8 	movh.a %a15,32768
80009e9a:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
80009e9e:	c8 1f       	ld.a %a15,[%a15]4
80009ea0:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
80009ea4:	c8 0f       	ld.a %a15,[%a15]0
80009ea6:	c8 3f       	ld.a %a15,[%a15]12
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
80009ea8:	3b e0 00 20 	mov %d2,14
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
80009eac:	bc 44       	jz.a %a4,80009eb4 <GetEvent+0x30>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
80009eae:	4c f3       	ld.w %d15,[%a15]12
80009eb0:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
80009eb2:	82 02       	mov %d2,0
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009eb4:	00 90       	ret 

80009eb6 <ClearEvent>:
FUNC(StatusType, OS_CODE)
  ClearEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009eb6:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
80009eb8:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009ebc:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80009ec0:	c8 0f       	ld.a %a15,[%a15]0
80009ec2:	c8 3f       	ld.a %a15,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009ec4:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009ec8:	8f f2 0f f1 	and %d15,%d2,255
80009ecc:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009ed0:	ee 0a       	jnz %d15,80009ee4 <ClearEvent+0x2e>
    OsEE_icr icr_temp = icr;
80009ed2:	02 2f       	mov %d15,%d2
80009ed4:	3b 30 01 30 	mov %d3,19
80009ed8:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009edc:	cd cf e2 0f 	mtcr $icr,%d15
80009ee0:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
80009ee4:	4c f3       	ld.w %d15,[%a15]12
80009ee6:	0f 4f e0 40 	andn %d4,%d15,%d4
80009eea:	68 34       	st.w [%a15]12,%d4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009eec:	4d c0 e2 3f 	mfcr %d3,$icr
80009ef0:	02 3f       	mov %d15,%d3
80009ef2:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009ef6:	8f f2 0f 21 	and %d2,%d2,255
80009efa:	5f 23 08 00 	jeq %d3,%d2,80009f0a <ClearEvent+0x54>
80009efe:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009f02:	cd cf e2 0f 	mtcr $icr,%d15
80009f06:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
80009f0a:	82 02       	mov %d2,0
80009f0c:	00 90       	ret 

80009f0e <GetISRID>:
FUNC(ISRType, OS_CODE)
  GetISRID
(
  void
)
{
80009f0e:	40 ae       	mov.aa %a14,%sp
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80009f10:	91 00 00 f8 	movh.a %a15,32768
80009f14:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
80009f18:	c8 0f       	ld.a %a15,[%a15]0
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009f1a:	39 ff 14 00 	ld.bu %d15,[%a15]20 <800000cc <osEE_cdb_var>>
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
80009f1e:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009f20:	5e 22       	jne %d15,2,80009f24 <GetISRID+0x16>
    isr_id = p_tdb->tid;
80009f22:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
80009f24:	00 90       	ret 
	...

80009f28 <osEE_release_all_m>:
static FUNC_P2VAR(OsEE_MDB, OS_APPL_CONST, OS_CODE)
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
80009f28:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
80009f2a:	99 43 0c 00 	ld.a %a3,[%a4]12

  while ((p_tcb->p_last_m != NULL)
80009f2e:	cc 31       	ld.a %a15,[%a3]4
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
80009f30:	a0 02       	mov.a %a2,0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
80009f32:	bc fb       	jz.a %a15,80009f48 <osEE_release_all_m+0x20>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
80009f34:	82 0f       	mov %d15,0
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
80009f36:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
80009f38:	68 2f       	st.w [%a15]8,%d15
    /* Save the first M not realesed */
    if (p_mdb == NULL) {
80009f3a:	7c 23       	jnz.a %a2,80009f40 <osEE_release_all_m+0x18>
      p_mdb = p_tcb->p_last_m;
80009f3c:	99 32 04 00 	ld.a %a2,[%a3]4
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
80009f40:	c8 0f       	ld.a %a15,[%a15]0
80009f42:	ec 31       	st.a [%a3]4,%a15
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
80009f44:	bd 0f f9 ff 	jnz.a %a15,80009f36 <osEE_release_all_m+0xe>
    p_tcb->p_last_m = NULL;
  }
#endif /* OSEE_HAS_SPINLOCKS */

  return p_mdb;
}
80009f48:	00 90       	ret 

80009f4a <osEE_scheduler_task_wrapper_restore>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_restore
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
80009f4a:	40 ae       	mov.aa %a14,%sp
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
80009f4c:	cc 43       	ld.a %a15,[%a4]12
80009f4e:	82 4f       	mov %d15,4
80009f50:	28 2f       	st.b [%a15]2,%d15
80009f52:	00 90       	ret 

80009f54 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
80009f54:	40 ae       	mov.aa %a14,%sp
80009f56:	40 4f       	mov.aa %a15,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
80009f58:	99 42 0c 00 	ld.a %a2,[%a4]12
80009f5c:	39 22 01 00 	ld.bu %d2,[%a2]1
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
80009f60:	82 4f       	mov %d15,4
80009f62:	2c 22       	st.b [%a2]2,%d15
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_priority < OSEE_ISR_ALL_PRIO) {
80009f64:	8b f2 0f f2 	eq %d15,%d2,255
80009f68:	ee 13       	jnz %d15,80009f8e <osEE_scheduler_task_wrapper_run+0x3a>
80009f6a:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
80009f6e:	37 02 48 40 	extr %d4,%d2,0,8
80009f72:	82 03       	mov %d3,0
80009f74:	ce 45       	jgez %d4,80009f7e <osEE_scheduler_task_wrapper_run+0x2a>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
80009f76:	8f f2 07 21 	and %d2,%d2,127
80009f7a:	1b 12 00 30 	addi %d3,%d2,1
80009f7e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009f82:	cd cf e2 0f 	mtcr $icr,%d15
80009f86:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009f8a:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
80009f8e:	c8 62       	ld.a %a2,[%a15]24
80009f90:	2d 02 00 00 	calli %a2
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
80009f94:	91 00 00 28 	movh.a %a2,32768
80009f98:	99 22 0c 30 	ld.a %a2,[%a2]204 <800000cc <osEE_cdb_var>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
80009f9c:	82 0f       	mov %d15,0
80009f9e:	e9 2f 1d 00 	st.b [%a2]29,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
80009fa2:	39 2f 1c 00 	ld.bu %d15,[%a2]28
80009fa6:	6e 09       	jz %d15,80009fb8 <osEE_scheduler_task_wrapper_run+0x64>
    p_ccb->s_isr_all_cnt = 0U;
80009fa8:	82 0f       	mov %d15,0
80009faa:	e9 2f 1c 00 	st.b [%a2]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009fae:	4c 25       	ld.w %d15,[%a2]20
80009fb0:	cd cf e2 0f 	mtcr $icr,%d15
80009fb4:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
80009fb8:	39 2f 1e 00 	ld.bu %d15,[%a2]30
80009fbc:	6e 06       	jz %d15,80009fc8 <osEE_scheduler_task_wrapper_run+0x74>
    p_ccb->d_isr_all_cnt = 0U;
80009fbe:	82 0f       	mov %d15,0
80009fc0:	e9 2f 1e 00 	st.b [%a2]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009fc4:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009fc8:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009fcc:	8f ff 0f 21 	and %d2,%d15,255
80009fd0:	8b 32 a1 22 	ge.u %d2,%d2,19
80009fd4:	f6 29       	jnz %d2,80009fe6 <osEE_scheduler_task_wrapper_run+0x92>
80009fd6:	3b 30 01 20 	mov %d2,19
80009fda:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009fde:	cd cf e2 0f 	mtcr $icr,%d15
80009fe2:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
80009fe6:	39 ff 14 00 	ld.bu %d15,[%a15]20
80009fea:	5e 24       	jne %d15,2,80009ff2 <osEE_scheduler_task_wrapper_run+0x9e>
  /* [SWS_Os_00369]: If a Category 2 ISR calls GetResource() and ends (returns)
      without calling the corresponding ReleaseResource(), the Operating System
      module shall perform the ReleaseResource() call and shall call the
      ErrorHook() E_OS_RESOURCE */
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_mdb = osEE_release_all_m(p_to_term);
80009fec:	40 f4       	mov.aa %a4,%a15
80009fee:	5c 9d       	call 80009f28 <osEE_release_all_m>
80009ff0:	3c 03       	j 80009ff6 <osEE_scheduler_task_wrapper_run+0xa2>
    osEE_call_error_hook(p_ccb, E_OS_MISSINGEND);
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
/* [SWS_Os_0070]: If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and still holds OSEK Resources,
    the Operating System shall release them. */
    (void)osEE_release_all_m(p_to_term);
80009ff2:	40 f4       	mov.aa %a4,%a15
80009ff4:	5c 9a       	call 80009f28 <osEE_release_all_m>
80009ff6:	c8 14       	ld.a %a4,[%a15]4
80009ff8:	a0 05       	mov.a %a5,0
80009ffa:	1d 00 79 02 	j 8000a4ec <osEE_hal_terminate_ctx>

80009ffe <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
80009ffe:	40 ae       	mov.aa %a14,%sp
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000a000:	91 00 00 f8 	movh.a %a15,32768
8000a004:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
8000a008:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000cc <osEE_cdb_var>>
8000a00c:	df 2f fe 7f 	jeq %d15,2,8000a008 <osEE_idle_hook_wrapper+0xa>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
8000a010:	91 00 00 f8 	movh.a %a15,32768
8000a014:	d9 ff 0c 30 	lea %a15,[%a15]204 <800000cc <osEE_cdb_var>>
8000a018:	c8 14       	ld.a %a4,[%a15]4
8000a01a:	6d 00 ba 01 	call 8000a38e <osEE_idle_task_terminate>
8000a01e:	00 90       	ret 

8000a020 <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
8000a020:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a022:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000a024:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
8000a026:	99 32 0c 00 	ld.a %a2,[%a3]12

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000a02a:	bd 02 13 00 	jz.a %a2,8000a050 <osEE_scheduler_core_rq_preempt_stk+0x30>
    p_ret_tdb = p_ret_sn->p_tdb;
8000a02e:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
8000a032:	bd 0f 1b 00 	jz.a %a15,8000a068 <osEE_scheduler_core_rq_preempt_stk+0x48>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000a036:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000a03a:	c8 16       	ld.a %a6,[%a15]4
8000a03c:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000a040:	39 42 01 00 	ld.bu %d2,[%a4]1
8000a044:	0c 61       	ld.bu %d15,[%a6]1
8000a046:	7f f2 13 80 	jge.u %d2,%d15,8000a06c <osEE_scheduler_core_rq_preempt_stk+0x4c>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
8000a04a:	82 2f       	mov %d15,2
8000a04c:	2c 42       	st.b [%a4]2,%d15
8000a04e:	3c 11       	j 8000a070 <osEE_scheduler_core_rq_preempt_stk+0x50>
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000a050:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000a052:	bd 0f 1e 00 	jz.a %a15,8000a08e <osEE_scheduler_core_rq_preempt_stk+0x6e>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
8000a056:	99 42 04 00 	ld.a %a2,[%a4]4
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000a05a:	99 24 0c 00 	ld.a %a4,[%a2]12
8000a05e:	82 2f       	mov %d15,2
8000a060:	2c 42       	st.b [%a4]2,%d15
8000a062:	3c 07       	j 8000a070 <osEE_scheduler_core_rq_preempt_stk+0x50>
  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
    if (p_tcb->current_prio < dispatch_prio) {
      p_tcb->current_prio = dispatch_prio;
8000a064:	2c 51       	st.b [%a5]1,%d15
8000a066:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000a068:	a0 02       	mov.a %a2,0
8000a06a:	00 90       	ret 
8000a06c:	a0 02       	mov.a %a2,0
8000a06e:	00 90       	ret 
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000a070:	4c f0       	ld.w %d15,[%a15]0
8000a072:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000a074:	c8 14       	ld.a %a4,[%a15]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000a076:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000a07a:	4c 33       	ld.w %d15,[%a3]12
8000a07c:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000a07e:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000a080:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000a082:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000a086:	39 52 01 00 	ld.bu %d2,[%a5]1
8000a08a:	3f f2 ed ff 	jlt.u %d2,%d15,8000a064 <osEE_scheduler_core_rq_preempt_stk+0x44>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
8000a08e:	00 90       	ret 

8000a090 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
8000a090:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
8000a092:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
8000a094:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000a096:	76 44       	jz %d4,8000a09e <osEE_sn_priority_insert+0xe>
8000a098:	39 f2 1c 00 	ld.bu %d2,[%a15]28
8000a09c:	3c 03       	j 8000a0a2 <osEE_sn_priority_insert+0x12>
8000a09e:	39 22 01 00 	ld.bu %d2,[%a2]1
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000a0a2:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000a0a4:	a0 06       	mov.a %a6,0
8000a0a6:	7c f3       	jnz.a %a15,8000a0ac <osEE_sn_priority_insert+0x1c>
8000a0a8:	3c 14       	j 8000a0d0 <osEE_sn_priority_insert+0x40>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000a0aa:	60 ff       	mov.a %a15,%d15
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
8000a0ac:	c8 12       	ld.a %a2,[%a15]4
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000a0ae:	99 23 0c 00 	ld.a %a3,[%a2]12

    if (as_ready) {
8000a0b2:	76 44       	jz %d4,8000a0ba <osEE_sn_priority_insert+0x2a>
      prio_to_check = p_cur_tdb->ready_prio;
8000a0b4:	39 2f 1c 00 	ld.bu %d15,[%a2]28
8000a0b8:	3c 02       	j 8000a0bc <osEE_sn_priority_insert+0x2c>
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000a0ba:	0c 31       	ld.bu %d15,[%a3]1
    }

    if (new_task_prio <= prio_to_check)
8000a0bc:	3f 2f 06 80 	jlt.u %d15,%d2,8000a0c8 <osEE_sn_priority_insert+0x38>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000a0c0:	4c f0       	ld.w %d15,[%a15]0
8000a0c2:	40 f6       	mov.aa %a6,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000a0c4:	ee f3       	jnz %d15,8000a0aa <osEE_sn_priority_insert+0x1a>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000a0c6:	60 ff       	mov.a %a15,%d15
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
8000a0c8:	bc 64       	jz.a %a6,8000a0d0 <osEE_sn_priority_insert+0x40>
    p_prev->p_next = p_sn_new;
8000a0ca:	f4 65       	st.a [%a6],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000a0cc:	82 02       	mov %d2,0
8000a0ce:	3c 03       	j 8000a0d4 <osEE_sn_priority_insert+0x44>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000a0d0:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
8000a0d2:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
8000a0d4:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000a0d6:	00 90       	ret 

8000a0d8 <osEE_scheduler_rq_insert>:
(
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
8000a0d8:	40 ae       	mov.aa %a14,%sp
  p_sn_new->p_tdb = p_tdb_new;
8000a0da:	b5 56 04 00 	st.a [%a5]4,%a6

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
8000a0de:	82 14       	mov %d4,1
8000a0e0:	6d ff d8 ff 	call 8000a090 <osEE_sn_priority_insert>
#else
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_FALSE);
#endif /* !OSEE_SCHEDULER_GLOBAL */
}
8000a0e4:	00 90       	ret 

8000a0e6 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
8000a0e6:	40 ae       	mov.aa %a14,%sp
8000a0e8:	40 4d       	mov.aa %a13,%a4
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
8000a0ea:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
8000a0ec:	c8 3c       	ld.a %a12,[%a15]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
8000a0ee:	4c c0       	ld.w %d15,[%a12]0
8000a0f0:	68 3f       	st.w [%a15]12,%d15
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
8000a0f2:	6d ff 97 ff 	call 8000a020 <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
8000a0f6:	4c f3       	ld.w %d15,[%a15]12

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
8000a0f8:	7c 28       	jnz.a %a2,8000a108 <osEE_scheduler_core_pop_running+0x22>
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
8000a0fa:	80 d3       	mov.d %d3,%a13
8000a0fc:	c2 43       	add %d3,4
8000a0fe:	92 42       	add %d2,%d15,4
8000a100:	6a 32       	cmovn %d2,%d15,%d3
8000a102:	60 2d       	mov.a %a13,%d2
8000a104:	4c d0       	ld.w %d15,[%a13]0
8000a106:	68 0f       	st.w [%a15]0,%d15
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
8000a108:	40 c2       	mov.aa %a2,%a12
8000a10a:	00 90       	ret 

8000a10c <osEE_task_activated>:

FUNC(StatusType, OS_CODE) osEE_task_activated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000a10c:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
8000a10e:	cc 43       	ld.a %a15,[%a4]12
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000a110:	0c f0       	ld.bu %d15,[%a15]0
8000a112:	39 43 1e 00 	ld.bu %d3,[%a4]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
8000a116:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000a118:	7f 3f 05 80 	jge.u %d15,%d3,8000a122 <osEE_task_activated+0x16>
    ++p_tcb_act->current_num_of_act;
8000a11c:	c2 1f       	add %d15,1
8000a11e:	28 0f       	st.b [%a15]0,%d15
    ev = E_OK;
8000a120:	82 02       	mov %d2,0
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000a122:	00 90       	ret 

8000a124 <osEE_task_end>:
FUNC(void, OS_CODE)
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
8000a124:	40 ae       	mov.aa %a14,%sp
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000a126:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
8000a128:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000a12c:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
8000a12e:	0c f0       	ld.bu %d15,[%a15]0
8000a130:	c2 ff       	add %d15,-1
8000a132:	16 ff       	and %d15,255
8000a134:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
8000a136:	ee 03       	jnz %d15,8000a13c <osEE_task_end+0x18>
    p_tcb->status = OSEE_TASK_SUSPENDED;
8000a138:	28 2f       	st.b [%a15]2,%d15
8000a13a:	00 90       	ret 
  } else {
    p_tcb->status = OSEE_TASK_READY;
8000a13c:	82 1f       	mov %d15,1
8000a13e:	28 2f       	st.b [%a15]2,%d15
8000a140:	00 90       	ret 

8000a142 <osEE_task_event_set_mask>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)    p_tdb_waking_up,
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
8000a142:	40 ae       	mov.aa %a14,%sp
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
8000a144:	cc 43       	ld.a %a15,[%a4]12
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000a146:	02 42       	mov %d2,%d4
8000a148:	02 43       	mov %d3,%d4
8000a14a:	49 f2 4c 08 	ldmst [%a15]12,%e2

    *p_ev = E_OK;
8000a14e:	82 0f       	mov %d15,0
8000a150:	2c 50       	st.b [%a5]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000a152:	4c f2       	ld.w %d15,[%a15]8
8000a154:	26 f4       	and %d4,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000a156:	a0 02       	mov.a %a2,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000a158:	76 45       	jz %d4,8000a162 <osEE_task_event_set_mask+0x20>
      p_own_sn = p_tcb_waking_up->p_own_sn;
8000a15a:	c8 42       	ld.a %a2,[%a15]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
8000a15c:	bc 23       	jz.a %a2,8000a162 <osEE_task_event_set_mask+0x20>
        p_tcb_waking_up->p_own_sn = NULL;
8000a15e:	82 0f       	mov %d15,0
8000a160:	68 4f       	st.w [%a15]16,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
8000a162:	00 90       	ret 

8000a164 <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
8000a164:	40 ae       	mov.aa %a14,%sp
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000a166:	91 00 00 48 	movh.a %a4,32768
8000a16a:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
8000a16e:	cc 41       	ld.a %a15,[%a4]4
8000a170:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000a174:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
8000a176:	cc 53       	ld.a %a15,[%a5]12
8000a178:	0c f0       	ld.bu %d15,[%a15]0
8000a17a:	c2 1f       	add %d15,1
8000a17c:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000a17e:	a0 06       	mov.a %a6,0
8000a180:	6d 00 c4 00 	call 8000a308 <osEE_scheduler_task_set_running>
8000a184:	00 90       	ret 

8000a186 <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000a186:	40 ae       	mov.aa %a14,%sp
8000a188:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
8000a18a:	99 52 0c 00 	ld.a %a2,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000a18e:	91 00 00 f8 	movh.a %a15,32768
8000a192:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
8000a196:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
8000a198:	99 43 0c 00 	ld.a %a3,[%a4]12 <800000cc <osEE_cdb_var>>
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
8000a19c:	39 32 01 00 	ld.bu %d2,[%a3]1 <800000cc <osEE_cdb_var>>
8000a1a0:	0c 21       	ld.bu %d15,[%a2]1
8000a1a2:	7f f2 15 80 	jge.u %d2,%d15,8000a1cc <osEE_scheduler_task_activated+0x46>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a1a6:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a1a8:	4c 20       	ld.w %d15,[%a2]0
8000a1aa:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a1ac:	82 02       	mov %d2,0
8000a1ae:	74 22       	st.w [%a2],%d2
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
8000a1b0:	82 2f       	mov %d15,2
8000a1b2:	2c 32       	st.b [%a3]2,%d15

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
8000a1b4:	b5 25 04 00 	st.a [%a2]4,%a5
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000a1b8:	4c f3       	ld.w %d15,[%a15]12
8000a1ba:	6c 20       	st.w [%a2]0,%d15
    p_ccb->p_stk_sn             = p_new_stk;
8000a1bc:	e8 32       	st.a [%a15]12,%a2
    p_ccb->p_curr               = p_tdb_act;
8000a1be:	e8 05       	st.a [%a15]0,%a5
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
8000a1c0:	cc 53       	ld.a %a15,[%a5]12
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
8000a1c2:	68 32       	st.w [%a15]12,%d2

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
8000a1c4:	6d 00 c1 00 	call 8000a346 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000a1c8:	82 12       	mov %d2,1
8000a1ca:	00 90       	ret 
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000a1cc:	0c 22       	ld.bu %d15,[%a2]2
8000a1ce:	ee 05       	jnz %d15,8000a1d8 <osEE_scheduler_task_activated+0x52>
    p_tcb_act->status = OSEE_TASK_READY;
8000a1d0:	82 1f       	mov %d15,1
8000a1d2:	2c 22       	st.b [%a2]2,%d15
8000a1d4:	82 0f       	mov %d15,0
8000a1d6:	6c 23       	st.w [%a2]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a1d8:	c8 25       	ld.a %a5,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a1da:	4c 50       	ld.w %d15,[%a5]0
8000a1dc:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a1de:	82 0f       	mov %d15,0
8000a1e0:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000a1e2:	d9 f4 04 00 	lea %a4,[%a15]4
8000a1e6:	6d ff 79 ff 	call 8000a0d8 <osEE_scheduler_rq_insert>
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
8000a1ea:	82 02       	mov %d2,0
  }

  return is_preemption;
}
8000a1ec:	00 90       	ret 

8000a1ee <osEE_scheduler_task_insert>:
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000a1ee:	40 ae       	mov.aa %a14,%sp
8000a1f0:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
8000a1f2:	cc 53       	ld.a %a15,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000a1f4:	91 00 00 28 	movh.a %a2,32768
8000a1f8:	99 24 0c 30 	ld.a %a4,[%a2]204 <800000cc <osEE_cdb_var>>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000a1fc:	0c f2       	ld.bu %d15,[%a15]2
8000a1fe:	ee 05       	jnz %d15,8000a208 <osEE_scheduler_task_insert+0x1a>
    p_tcb_act->status = OSEE_TASK_READY;
8000a200:	82 1f       	mov %d15,1
8000a202:	28 2f       	st.b [%a15]2,%d15
8000a204:	82 0f       	mov %d15,0
8000a206:	68 3f       	st.w [%a15]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a208:	99 45 08 00 	ld.a %a5,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a20c:	4c 50       	ld.w %d15,[%a5]0
8000a20e:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a210:	82 0f       	mov %d15,0
8000a212:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000a214:	b0 44       	add.a %a4,4
8000a216:	6d ff 61 ff 	call 8000a0d8 <osEE_scheduler_rq_insert>

    osEE_unlock_core(p_cdb);
  }

  return head_changed;
}
8000a21a:	00 90       	ret 

8000a21c <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
8000a21c:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
8000a21e:	99 56 04 00 	ld.a %a6,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
8000a222:	cc 63       	ld.a %a15,[%a6]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000a224:	91 00 00 28 	movh.a %a2,32768
8000a228:	99 2c 0c 30 	ld.a %a12,[%a2]204 <800000cc <osEE_cdb_var>>

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
8000a22c:	82 2f       	mov %d15,2
8000a22e:	28 2f       	st.b [%a15]2,%d15
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000a230:	39 6f 1c 00 	ld.bu %d15,[%a6]28
8000a234:	28 1f       	st.b [%a15]1,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000a236:	d9 c4 04 00 	lea %a4,[%a12]4
8000a23a:	6d ff 4f ff 	call 8000a0d8 <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
8000a23e:	82 0f       	mov %d15,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
8000a240:	df 12 0a 80 	jne %d2,1,8000a254 <osEE_scheduler_task_unblocked+0x38>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
8000a244:	d4 c2       	ld.a %a2,[%a12]
8000a246:	99 22 0c 00 	ld.a %a2,[%a2]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
8000a24a:	0c f1       	ld.bu %d15,[%a15]1
8000a24c:	39 22 01 00 	ld.bu %d2,[%a2]1
8000a250:	0b f2 30 f1 	lt.u %d15,%d2,%d15
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
8000a254:	02 f2       	mov %d2,%d15
8000a256:	00 90       	ret 

8000a258 <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
8000a258:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a25a:	91 00 00 f8 	movh.a %a15,32768
8000a25e:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
8000a262:	c8 0d       	ld.a %a13,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
8000a264:	99 dc 0c 00 	ld.a %a12,[%a13]12 <800000cc <osEE_cdb_var>>

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
8000a268:	f4 5d       	st.a [%a5],%a13

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
8000a26a:	0c c2       	ld.bu %d15,[%a12]2
8000a26c:	de 4a       	jne %d15,4,8000a2a0 <osEE_scheduler_task_terminated+0x48>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000a26e:	91 00 00 48 	movh.a %a4,32768
8000a272:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
8000a276:	d9 f5 04 00 	lea %a5,[%a15]4 <800000cc <osEE_cdb_var>>
8000a27a:	6d ff 36 ff 	call 8000a0e6 <osEE_scheduler_core_pop_running>
8000a27e:	80 28       	mov.d %d8,%a2

      p_tdb_to = p_ccb->p_curr;
8000a280:	4c f0       	ld.w %d15,[%a15]0

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000a282:	80 d2       	mov.d %d2,%a13
8000a284:	5f f2 06 00 	jeq %d2,%d15,8000a290 <osEE_scheduler_task_terminated+0x38>
        osEE_task_end(p_tdb_term);
8000a288:	40 d4       	mov.aa %a4,%a13
8000a28a:	6d ff 4d ff 	call 8000a124 <osEE_task_end>
8000a28e:	3c 04       	j 8000a296 <osEE_scheduler_task_terminated+0x3e>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
8000a290:	14 c2       	ld.bu %d2,[%a12]
8000a292:	c2 f2       	add %d2,-1
8000a294:	34 c2       	st.b [%a12],%d2
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
8000a296:	48 22       	ld.w %d2,[%a15]8
8000a298:	60 82       	mov.a %a2,%d8
8000a29a:	74 22       	st.w [%a2],%d2
  (*pp_first)       = p_to_free;
8000a29c:	68 28       	st.w [%a15]8,%d8
8000a29e:	3c 20       	j 8000a2de <osEE_scheduler_task_terminated+0x86>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
8000a2a0:	c8 35       	ld.a %a5,[%a15]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
8000a2a2:	54 52       	ld.w %d2,[%a5]
8000a2a4:	68 32       	st.w [%a15]12,%d2
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
8000a2a6:	39 df 1c 00 	ld.bu %d15,[%a13]28
8000a2aa:	2c c1       	st.b [%a12]1,%d15
      p_tcb_term->status = OSEE_TASK_READY;
8000a2ac:	82 1f       	mov %d15,1
8000a2ae:	2c c2       	st.b [%a12]2,%d15
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
8000a2b0:	0c c0       	ld.bu %d15,[%a12]0
8000a2b2:	5e 13       	jne %d15,1,8000a2b8 <osEE_scheduler_task_terminated+0x60>
8000a2b4:	82 0f       	mov %d15,0
8000a2b6:	6c c3       	st.w [%a12]12,%d15
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
8000a2b8:	d9 fc 04 00 	lea %a12,[%a15]4
8000a2bc:	40 c4       	mov.aa %a4,%a12
8000a2be:	40 d6       	mov.aa %a6,%a13
8000a2c0:	6d ff 0c ff 	call 8000a0d8 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000a2c4:	91 00 00 48 	movh.a %a4,32768
8000a2c8:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
8000a2cc:	40 c5       	mov.aa %a5,%a12
8000a2ce:	6d ff a9 fe 	call 8000a020 <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
8000a2d2:	7c 25       	jnz.a %a2,8000a2dc <osEE_scheduler_task_terminated+0x84>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
8000a2d4:	c8 32       	ld.a %a2,[%a15]12
8000a2d6:	4c 21       	ld.w %d15,[%a2]4
          p_ccb->p_curr           = p_tdb_to;
8000a2d8:	68 0f       	st.w [%a15]0,%d15
8000a2da:	3c 02       	j 8000a2de <osEE_scheduler_task_terminated+0x86>
        } else {
          p_tdb_to = p_ccb->p_curr;
8000a2dc:	4c f0       	ld.w %d15,[%a15]0
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
8000a2de:	60 f2       	mov.a %a2,%d15
8000a2e0:	00 90       	ret 

8000a2e2 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
8000a2e2:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a2e4:	91 00 00 48 	movh.a %a4,32768
8000a2e8:	99 4f 0c 30 	ld.a %a15,[%a4]204 <800000cc <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000a2ec:	d9 44 0c 30 	lea %a4,[%a4]204 <800000cc <osEE_cdb_var>>
8000a2f0:	d9 f5 04 00 	lea %a5,[%a15]4 <800000cc <osEE_cdb_var>>
8000a2f4:	6d ff 96 fe 	call 8000a020 <osEE_scheduler_core_rq_preempt_stk>

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
8000a2f8:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
8000a2fa:	bc 26       	jz.a %a2,8000a306 <osEE_scheduler_task_preemption_point+0x24>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
8000a2fc:	40 24       	mov.aa %a4,%a2
8000a2fe:	c8 05       	ld.a %a5,[%a15]0
8000a300:	6d 00 23 00 	call 8000a346 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000a304:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
8000a306:	00 90       	ret 

8000a308 <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
8000a308:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000a30a:	91 00 00 f8 	movh.a %a15,32768
8000a30e:	99 ff 0c 30 	ld.a %a15,[%a15]204 <800000cc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
8000a312:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
8000a314:	48 32       	ld.w %d2,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000a316:	99 42 0c 00 	ld.a %a2,[%a4]12 <800000cc <osEE_cdb_var>>
8000a31a:	0c 22       	ld.bu %d15,[%a2]2
8000a31c:	5e 43       	jne %d15,4,8000a322 <osEE_scheduler_task_set_running+0x1a>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000a31e:	82 2f       	mov %d15,2
8000a320:	2c 22       	st.b [%a2]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
8000a322:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000a324:	7c 68       	jnz.a %a6,8000a334 <osEE_scheduler_task_set_running+0x2c>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000a326:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000a328:	4c 20       	ld.w %d15,[%a2]0
8000a32a:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000a32c:	82 0f       	mov %d15,0
8000a32e:	6c 20       	st.w [%a2]0,%d15
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
8000a330:	e8 32       	st.a [%a15]12,%a2
8000a332:	3c 02       	j 8000a336 <osEE_scheduler_task_set_running+0x2e>
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
8000a334:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000a336:	c8 32       	ld.a %a2,[%a15]12
8000a338:	b5 25 04 00 	st.a [%a2]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000a33c:	c8 3f       	ld.a %a15,[%a15]12
8000a33e:	68 02       	st.w [%a15]0,%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000a340:	6d 00 03 00 	call 8000a346 <osEE_change_context_from_running>
8000a344:	00 90       	ret 

8000a346 <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a346:	40 ae       	mov.aa %a14,%sp
8000a348:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a34a:	99 52 0c 00 	ld.a %a2,[%a5]12
8000a34e:	0c 22       	ld.bu %d15,[%a2]2
8000a350:	5e 28       	jne %d15,2,8000a360 <osEE_change_context_from_running+0x1a>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000a352:	40 54       	mov.aa %a4,%a5
8000a354:	99 55 04 00 	ld.a %a5,[%a5]4
8000a358:	c8 16       	ld.a %a6,[%a15]4
8000a35a:	6d 00 73 00 	call 8000a440 <osEE_hal_save_ctx_and_restore_ctx>
8000a35e:	00 90       	ret 
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
8000a360:	40 54       	mov.aa %a4,%a5
8000a362:	99 55 04 00 	ld.a %a5,[%a5]4
8000a366:	c8 16       	ld.a %a6,[%a15]4
8000a368:	6d 00 8b 00 	call 8000a47e <osEE_hal_save_ctx_and_ready2stacked>
8000a36c:	00 90       	ret 

8000a36e <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a36e:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a370:	cc 53       	ld.a %a15,[%a5]12
8000a372:	0c f2       	ld.bu %d15,[%a15]2
8000a374:	5e 27       	jne %d15,2,8000a382 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000a376:	40 54       	mov.aa %a4,%a5
8000a378:	99 55 04 00 	ld.a %a5,[%a5]4
8000a37c:	6d 00 74 00 	call 8000a464 <osEE_hal_restore_ctx>
8000a380:	00 90       	ret 
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
8000a382:	40 54       	mov.aa %a4,%a5
8000a384:	99 55 04 00 	ld.a %a5,[%a5]4
8000a388:	6d 00 8d 00 	call 8000a4a2 <osEE_hal_ready2stacked>
8000a38c:	00 90       	ret 

8000a38e <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
8000a38e:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
8000a390:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000a394:	cc 40       	ld.a %a15,[%a4]0
8000a396:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000a398:	cc 50       	ld.a %a15,[%a5]0
8000a39a:	3c 02       	j 8000a39e <osEE_idle_task_terminate+0x10>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000a39c:	60 ff       	mov.a %a15,%d15
8000a39e:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
8000a3a0:	8b 0f 20 22 	ne %d2,%d15,0
8000a3a4:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000a3a8:	df 02 fa ff 	jne %d2,0,8000a39c <osEE_idle_task_terminate+0xe>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000a3ac:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
8000a3ae:	6d 00 5b 00 	call 8000a464 <osEE_hal_restore_ctx>
8000a3b2:	00 90       	ret 

8000a3b4 <osEE_cpu_startos>:
}
#endif /* OSEE_SINGLECORE */
#endif /* OSEE_TC_HAS_ISR1_TO_CONF */

OsEE_bool osEE_cpu_startos(void)
{
8000a3b4:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000a3b6:	4d c0 e1 5f 	mfcr %d5,$core_id
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000a3ba:	91 00 00 f8 	movh.a %a15,32768
8000a3be:	d9 ff 38 20 	lea %a15,[%a15]184 <800000b8 <osEE_kdb_var>>
8000a3c2:	c8 2f       	ld.a %a15,[%a15]8
8000a3c4:	b0 ff       	add.a %a15,-1
  for (i = 0U; i < tdb_size; ++i) {
8000a3c6:	bd 0f 2a 00 	jz.a %a15,8000a41a <osEE_cpu_startos+0x66>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000a3ca:	91 00 00 28 	movh.a %a2,32768
8000a3ce:	d9 22 38 20 	lea %a2,[%a2]184 <800000b8 <osEE_kdb_var>>
8000a3d2:	19 23 04 00 	ld.w %d3,[%a2]4 <80000004 <BootModeHeader0+0x4>>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000a3d6:	8f 35 00 51 	and %d5,%d5,3
8000a3da:	8f b5 00 50 	sh %d5,%d5,11
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000a3de:	bb f0 ff 4f 	mov.u %d4,65535
8000a3e2:	82 0f       	mov %d15,0
8000a3e4:	b0 ff       	add.a %a15,-1
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000a3e6:	60 33       	mov.a %a3,%d3
8000a3e8:	90 32       	addsc.a %a2,%a3,%d15,2
8000a3ea:	d4 22       	ld.a %a2,[%a2]
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a3ec:	39 22 14 00 	ld.bu %d2,[%a2]20
8000a3f0:	df 22 12 80 	jne %d2,2,8000a414 <osEE_cpu_startos+0x60>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000a3f4:	b9 22 08 00 	ld.hu %d2,[%a2]8
8000a3f8:	5f 42 0e 00 	jeq %d2,%d4,8000a414 <osEE_cpu_startos+0x60>
8000a3fc:	60 24       	mov.a %a4,%d2
8000a3fe:	d9 43 00 08 	lea %a3,[%a4]-32768
8000a402:	11 43 00 3f 	addih.a %a3,%a3,61444
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000a406:	39 22 1c 00 	ld.bu %d2,[%a2]28
8000a40a:	c2 12       	add %d2,1
8000a40c:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000a410:	a6 52       	or %d2,%d5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000a412:	74 32       	st.w [%a3],%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000a414:	c2 1f       	add %d15,1
8000a416:	fd f0 e8 7f 	loop %a15,8000a3e6 <osEE_cpu_startos+0x32>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000a41a:	82 12       	mov %d2,1
8000a41c:	00 90       	ret 

8000a41e <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a41e:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a422:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a424:	0c 22       	ld.bu %d15,[%a2]2
8000a426:	1e 27       	jeq %d15,2,8000a434 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000a428:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000a42a:	c8 1f       	ld.a %a15,[%a15]4
8000a42c:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
8000a42e:	1d 00 3a 00 	j 8000a4a2 <osEE_hal_ready2stacked>
8000a432:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
8000a434:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000a436:	c8 1f       	ld.a %a15,[%a15]4
8000a438:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000a43a:	1d 00 15 00 	j 8000a464 <osEE_hal_restore_ctx>
8000a43e:	00 90       	ret 

8000a440 <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000a440:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000a442:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000a446:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000a448:	4c 60       	ld.w %d15,[%a6]0
8000a44a:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a44e:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000a452:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000a456:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000a458:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000a45c:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
8000a45e:	1d 00 03 00 	j 8000a464 <osEE_hal_restore_ctx>
8000a462:	00 90       	ret 

8000a464 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
8000a464:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000a466:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
8000a468:	4c f2       	ld.w %d15,[%a15]8
8000a46a:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000a46c:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000a470:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
8000a474:	4c f0       	ld.w %d15,[%a15]0
8000a476:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
8000a478:	1d ff 69 fd 	j 80009f4a <osEE_scheduler_task_wrapper_restore>
8000a47c:	00 90       	ret 

8000a47e <osEE_hal_save_ctx_and_ready2stacked>:
8000a47e:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000a480:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000a484:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000a486:	4c 60       	ld.w %d15,[%a6]0
8000a488:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a48c:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000a490:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000a494:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000a496:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000a49a:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
8000a49c:	1d 00 03 00 	j 8000a4a2 <osEE_hal_ready2stacked>
8000a4a0:	00 90       	ret 

8000a4a2 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000a4a2:	cc 50       	ld.a %a15,[%a5]0
8000a4a4:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
8000a4a6:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000a4aa:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000a4ac:	d9 f2 f0 ff 	lea %a2,[%a15]-16
8000a4b0:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000a4b2:	4c 50       	ld.w %d15,[%a5]0
8000a4b4:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a4b8:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000a4bc:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000a4c0:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000a4c2:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000a4c6:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000a4c8:	1d ff 46 fd 	j 80009f54 <osEE_scheduler_task_wrapper_run>
8000a4cc:	00 90       	ret 

8000a4ce <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
8000a4ce:	4d 40 e0 ff 	mfcr %d15,$psw
8000a4d2:	8f ff c7 f1 	andn %d15,%d15,127
8000a4d6:	cd 4f e0 0f 	mtcr $psw,%d15
8000a4da:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000a4de:	91 10 00 f8 	movh.a %a15,32769
8000a4e2:	d9 ff 5e 0a 	lea %a15,[%a15]-23522 <8000a41e <osEE_tc_change_context_from_task_end>>
8000a4e6:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000a4e8:	00 80       	rfe 
8000a4ea:	00 90       	ret 

8000a4ec <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000a4ec:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
8000a4ee:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a4f2:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
8000a4f6:	cc 40       	ld.a %a15,[%a4]0
8000a4f8:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000a4fa:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000a4fe:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000a502:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000a504:	8f c3 01 30 	sh %d3,%d3,28
8000a508:	a6 43       	or %d3,%d4
8000a50a:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000a50c:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
8000a50e:	bc f3       	jz.a %a15,8000a514 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
8000a510:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
8000a512:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
8000a514:	cd 8f e3 0f 	mtcr $fcx,%d15
8000a518:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000a51c:	cd 03 e0 0f 	mtcr $pcxi,%d3
8000a520:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
8000a524:	cc 40       	ld.a %a15,[%a4]0
8000a526:	4c f0       	ld.w %d15,[%a15]0
8000a528:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000a52a:	91 00 00 48 	movh.a %a4,32768
8000a52e:	d9 44 38 20 	lea %a4,[%a4]184 <800000b8 <osEE_kdb_var>>
8000a532:	d9 a5 04 00 	lea %a5,[%sp]4 <800000b8 <osEE_kdb_var>>
8000a536:	6d ff 91 fe 	call 8000a258 <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000a53a:	d8 01       	ld.a %a15,[%sp]4
8000a53c:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000a540:	1e 25       	jeq %d15,2,8000a54a <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
8000a542:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
8000a544:	1d ff 6d ff 	j 8000a41e <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000a548:	3c 00       	j 8000a548 <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000a54a:	40 24       	mov.aa %a4,%a2
8000a54c:	6d ff c1 ff 	call 8000a4ce <osEE_tc_change_context_from_isr2_end>
8000a550:	3c fc       	j 8000a548 <osEE_hal_terminate_ctx+0x5c>

8000a552 <__lshrdi3>:
8000a552:	6f 56 0c 80 	jnz.t %d6,5,8000a56a <__lshrdi3+0x18>
8000a556:	8b 06 02 71 	rsub %d7,%d6,32
8000a55a:	32 56       	rsub %d6
8000a55c:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
8000a560:	0f 65 00 30 	sh %d3,%d5,%d6
8000a564:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
8000a568:	00 90       	ret 
8000a56a:	8b 06 02 60 	add %d6,%d6,32
8000a56e:	32 56       	rsub %d6
8000a570:	0f 65 00 20 	sh %d2,%d5,%d6
8000a574:	82 03       	mov %d3,0
8000a576:	00 90       	ret 

8000a578 <__floatundisf>:
8000a578:	7b 00 02 20 	movh %d2,32
8000a57c:	0b 25 30 f1 	lt.u %d15,%d5,%d2
8000a580:	02 4a       	mov %d10,%d4
8000a582:	02 54       	mov %d4,%d5
8000a584:	ee 08       	jnz %d15,8000a594 <__floatundisf+0x1c>
8000a586:	b7 0a 95 f5 	insert %d15,%d10,0,11,21
8000a58a:	6e 05       	jz %d15,8000a594 <__floatundisf+0x1c>
8000a58c:	b7 0a 0b a0 	insert %d10,%d10,0,0,11
8000a590:	b7 fa 81 a5 	insert %d10,%d10,15,11,1
8000a594:	6d 00 ea 02 	call 8000ab68 <__floatunsidf>
8000a598:	0b 23 10 48 	mov %e4,%d3,%d2
8000a59c:	82 06       	mov %d6,0
8000a59e:	7b 00 1f 74 	movh %d7,16880
8000a5a2:	6d 00 34 01 	call 8000a80a <__muldf3>
8000a5a6:	02 a4       	mov %d4,%d10
8000a5a8:	0b 23 10 88 	mov %e8,%d3,%d2
8000a5ac:	6d 00 de 02 	call 8000ab68 <__floatunsidf>
8000a5b0:	0b 89 10 48 	mov %e4,%d9,%d8
8000a5b4:	0b 23 10 68 	mov %e6,%d3,%d2
8000a5b8:	6d 00 ed 00 	call 8000a792 <__adddf3>
8000a5bc:	0b 23 10 48 	mov %e4,%d3,%d2
8000a5c0:	1d 00 b6 02 	j 8000ab2c <__truncdfsf2>

8000a5c4 <__extendsfdf2>:
8000a5c4:	20 20       	sub.a %sp,32
8000a5c6:	d9 a4 20 00 	lea %a4,[%sp]32
8000a5ca:	89 44 2c f5 	st.w [+%a4]-20,%d4
8000a5ce:	d9 a5 10 00 	lea %a5,[%sp]16
8000a5d2:	6d 00 f1 02 	call 8000abb4 <__unpack_f>
8000a5d6:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000a5da:	39 a4 10 00 	ld.bu %d4,[%sp]16
8000a5de:	8f e2 1f f0 	sh %d15,%d2,-2
8000a5e2:	8f e2 01 20 	sh %d2,%d2,30
8000a5e6:	74 a2       	st.w [%sp],%d2
8000a5e8:	78 01       	st.w [%sp]4,%d15
8000a5ea:	19 a5 14 00 	ld.w %d5,[%sp]20
8000a5ee:	19 a6 18 00 	ld.w %d6,[%sp]24
8000a5f2:	1d 00 8e 02 	j 8000ab0e <__make_dp>

8000a5f6 <_fpadd_parts>:
8000a5f6:	0c 40       	ld.bu %d15,[%a4]0
8000a5f8:	40 42       	mov.aa %a2,%a4
8000a5fa:	bf 2f cb 80 	jlt.u %d15,2,8000a790 <_fpadd_parts+0x19a>
8000a5fe:	14 52       	ld.bu %d2,[%a5]
8000a600:	40 52       	mov.aa %a2,%a5
8000a602:	bf 22 c7 80 	jlt.u %d2,2,8000a790 <_fpadd_parts+0x19a>
8000a606:	5e 4e       	jne %d15,4,8000a622 <_fpadd_parts+0x2c>
8000a608:	40 42       	mov.aa %a2,%a4
8000a60a:	df 42 c3 80 	jne %d2,4,8000a790 <_fpadd_parts+0x19a>
8000a60e:	19 42 04 00 	ld.w %d2,[%a4]4
8000a612:	4c 51       	ld.w %d15,[%a5]4
8000a614:	5f f2 be 00 	jeq %d2,%d15,8000a790 <_fpadd_parts+0x19a>
8000a618:	91 00 00 f8 	movh.a %a15,32768
8000a61c:	d9 f2 d0 90 	lea %a2,[%a15]3664 <80000e50 <__thenan_df>>
8000a620:	00 90       	ret 
8000a622:	40 52       	mov.aa %a2,%a5
8000a624:	df 42 b6 00 	jeq %d2,4,8000a790 <_fpadd_parts+0x19a>
8000a628:	df 22 11 80 	jne %d2,2,8000a64a <_fpadd_parts+0x54>
8000a62c:	40 42       	mov.aa %a2,%a4
8000a62e:	df 2f b1 80 	jne %d15,2,8000a790 <_fpadd_parts+0x19a>
8000a632:	40 63       	mov.aa %a3,%a6
8000a634:	a0 4f       	mov.a %a15,4
8000a636:	44 4f       	ld.w %d15,[%a4+]
8000a638:	64 3f       	st.w [%a3+],%d15
8000a63a:	fc fe       	loop %a15,8000a636 <_fpadd_parts+0x40>
8000a63c:	4c 21       	ld.w %d15,[%a2]4
8000a63e:	19 52 04 00 	ld.w %d2,[%a5]4
8000a642:	40 62       	mov.aa %a2,%a6
8000a644:	26 2f       	and %d15,%d2
8000a646:	6c 61       	st.w [%a6]4,%d15
8000a648:	00 90       	ret 
8000a64a:	40 52       	mov.aa %a2,%a5
8000a64c:	df 2f a2 00 	jeq %d15,2,8000a790 <_fpadd_parts+0x19a>
8000a650:	4c 42       	ld.w %d15,[%a4]8
8000a652:	19 52 08 00 	ld.w %d2,[%a5]8
8000a656:	40 6f       	mov.aa %a15,%a6
8000a658:	52 23       	sub %d3,%d15,%d2
8000a65a:	0b 30 c0 c1 	abs %d12,%d3
8000a65e:	8b 0c 84 42 	ge %d4,%d12,64
8000a662:	40 5c       	mov.aa %a12,%a5
8000a664:	40 4d       	mov.aa %a13,%a4
8000a666:	09 4a 4c 09 	ld.d %e10,[%a4]12
8000a66a:	09 58 4c 09 	ld.d %e8,[%a5]12
8000a66e:	df 04 35 80 	jne %d4,0,8000a6d8 <_fpadd_parts+0xe2>
8000a672:	bf 13 19 00 	jlt %d3,1,8000a6a4 <_fpadd_parts+0xae>
8000a676:	0b 89 10 48 	mov %e4,%d9,%d8
8000a67a:	02 c6       	mov %d6,%d12
8000a67c:	6d ff 6b ff 	call 8000a552 <__lshrdi3>
8000a680:	d2 14       	mov %e4,1
8000a682:	02 c6       	mov %d6,%d12
8000a684:	02 2e       	mov %d14,%d2
8000a686:	02 3d       	mov %d13,%d3
8000a688:	6d 00 89 02 	call 8000ab9a <__ashldi3>
8000a68c:	8b f2 9f 20 	addx %d2,%d2,-1
8000a690:	8b f3 bf 30 	addc %d3,%d3,-1
8000a694:	26 82       	and %d2,%d8
8000a696:	26 93       	and %d3,%d9
8000a698:	a6 23       	or %d3,%d2
8000a69a:	02 e8       	mov %d8,%d14
8000a69c:	8b 03 00 85 	or.ne %d8,%d3,0
8000a6a0:	02 d9       	mov %d9,%d13
8000a6a2:	3c 21       	j 8000a6e4 <_fpadd_parts+0xee>
8000a6a4:	df 03 20 00 	jeq %d3,0,8000a6e4 <_fpadd_parts+0xee>
8000a6a8:	0b ab 10 48 	mov %e4,%d11,%d10
8000a6ac:	02 c6       	mov %d6,%d12
8000a6ae:	6d ff 52 ff 	call 8000a552 <__lshrdi3>
8000a6b2:	d2 14       	mov %e4,1
8000a6b4:	02 c6       	mov %d6,%d12
8000a6b6:	02 2e       	mov %d14,%d2
8000a6b8:	02 3d       	mov %d13,%d3
8000a6ba:	6d 00 70 02 	call 8000ab9a <__ashldi3>
8000a6be:	8b f2 9f 20 	addx %d2,%d2,-1
8000a6c2:	8b f3 bf 30 	addc %d3,%d3,-1
8000a6c6:	26 a2       	and %d2,%d10
8000a6c8:	26 b3       	and %d3,%d11
8000a6ca:	a6 23       	or %d3,%d2
8000a6cc:	02 ea       	mov %d10,%d14
8000a6ce:	42 cf       	add %d15,%d12
8000a6d0:	8b 03 00 a5 	or.ne %d10,%d3,0
8000a6d4:	02 db       	mov %d11,%d13
8000a6d6:	3c 07       	j 8000a6e4 <_fpadd_parts+0xee>
8000a6d8:	3f f2 05 00 	jlt %d2,%d15,8000a6e2 <_fpadd_parts+0xec>
8000a6dc:	02 2f       	mov %d15,%d2
8000a6de:	d2 0a       	mov %e10,0
8000a6e0:	3c 02       	j 8000a6e4 <_fpadd_parts+0xee>
8000a6e2:	d2 08       	mov %e8,0
8000a6e4:	19 d4 04 00 	ld.w %d4,[%a13]4
8000a6e8:	19 c2 04 00 	ld.w %d2,[%a12]4
8000a6ec:	5f 24 34 00 	jeq %d4,%d2,8000a754 <_fpadd_parts+0x15e>
8000a6f0:	0b 8a c0 20 	subx %d2,%d10,%d8
8000a6f4:	0b 9b d0 30 	subc %d3,%d11,%d9
8000a6f8:	76 45       	jz %d4,8000a702 <_fpadd_parts+0x10c>
8000a6fa:	0b a8 c0 20 	subx %d2,%d8,%d10
8000a6fe:	0b b9 d0 30 	subc %d3,%d9,%d11
8000a702:	0e 37       	jltz %d3,8000a710 <_fpadd_parts+0x11a>
8000a704:	82 04       	mov %d4,0
8000a706:	68 14       	st.w [%a15]4,%d4
8000a708:	68 2f       	st.w [%a15]8,%d15
8000a70a:	89 f2 4c 09 	st.d [%a15]12,%e2
8000a70e:	3c 0c       	j 8000a726 <_fpadd_parts+0x130>
8000a710:	68 2f       	st.w [%a15]8,%d15
8000a712:	8b 03 00 f1 	rsub %d15,%d3,0
8000a716:	82 14       	mov %d4,1
8000a718:	8b 02 00 31 	rsub %d3,%d2,0
8000a71c:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
8000a720:	68 14       	st.w [%a15]4,%d4
8000a722:	68 33       	st.w [%a15]12,%d3
8000a724:	68 4f       	st.w [%a15]16,%d15
8000a726:	82 f5       	mov %d5,-1
8000a728:	06 c5       	sh %d5,-4
8000a72a:	48 32       	ld.w %d2,[%a15]12
8000a72c:	48 43       	ld.w %d3,[%a15]16
8000a72e:	8b f2 9f 60 	addx %d6,%d2,-1
8000a732:	8b f3 bf 40 	addc %d4,%d3,-1
8000a736:	3a 54       	eq %d15,%d4,%d5
8000a738:	8b f6 3f f4 	and.ne %d15,%d6,-1
8000a73c:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
8000a740:	6e 12       	jz %d15,8000a764 <_fpadd_parts+0x16e>
8000a742:	4c f2       	ld.w %d15,[%a15]8
8000a744:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a748:	c2 ff       	add %d15,-1
8000a74a:	06 12       	sh %d2,1
8000a74c:	68 32       	st.w [%a15]12,%d2
8000a74e:	68 43       	st.w [%a15]16,%d3
8000a750:	68 2f       	st.w [%a15]8,%d15
8000a752:	3c ec       	j 8000a72a <_fpadd_parts+0x134>
8000a754:	0b a8 40 20 	addx %d2,%d8,%d10
8000a758:	68 2f       	st.w [%a15]8,%d15
8000a75a:	0b b9 50 f0 	addc %d15,%d9,%d11
8000a75e:	68 14       	st.w [%a15]4,%d4
8000a760:	68 32       	st.w [%a15]12,%d2
8000a762:	68 4f       	st.w [%a15]16,%d15
8000a764:	82 3f       	mov %d15,3
8000a766:	28 0f       	st.b [%a15]0,%d15
8000a768:	4c f4       	ld.w %d15,[%a15]16
8000a76a:	7b 00 00 42 	movh %d4,8192
8000a76e:	0b 4f 30 31 	lt.u %d3,%d15,%d4
8000a772:	48 32       	ld.w %d2,[%a15]12
8000a774:	40 f2       	mov.aa %a2,%a15
8000a776:	f6 3d       	jnz %d3,8000a790 <_fpadd_parts+0x19a>
8000a778:	8f 12 00 31 	and %d3,%d2,1
8000a77c:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
8000a780:	06 ff       	sh %d15,-1
8000a782:	96 00       	or %d15,0
8000a784:	68 4f       	st.w [%a15]16,%d15
8000a786:	4c f2       	ld.w %d15,[%a15]8
8000a788:	a6 32       	or %d2,%d3
8000a78a:	c2 1f       	add %d15,1
8000a78c:	68 32       	st.w [%a15]12,%d2
8000a78e:	68 2f       	st.w [%a15]8,%d15
8000a790:	00 90       	ret 

8000a792 <__adddf3>:
8000a792:	20 50       	sub.a %sp,80
8000a794:	d9 a4 04 00 	lea %a4,[%sp]4
8000a798:	d9 a5 14 00 	lea %a5,[%sp]20
8000a79c:	89 a4 44 09 	st.d [%sp]4,%e4
8000a7a0:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a7a4:	6d 00 d9 02 	call 8000ad56 <__unpack_d>
8000a7a8:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a7ac:	d9 a5 28 00 	lea %a5,[%sp]40
8000a7b0:	6d 00 d3 02 	call 8000ad56 <__unpack_d>
8000a7b4:	d9 a4 14 00 	lea %a4,[%sp]20
8000a7b8:	d9 a5 28 00 	lea %a5,[%sp]40
8000a7bc:	d9 a6 3c 00 	lea %a6,[%sp]60
8000a7c0:	6d ff 1b ff 	call 8000a5f6 <_fpadd_parts>
8000a7c4:	40 24       	mov.aa %a4,%a2
8000a7c6:	1d 00 3f 02 	j 8000ac44 <__pack_d>

8000a7ca <__subdf3>:
8000a7ca:	20 50       	sub.a %sp,80
8000a7cc:	d9 a4 04 00 	lea %a4,[%sp]4
8000a7d0:	d9 a5 14 00 	lea %a5,[%sp]20
8000a7d4:	89 a4 44 09 	st.d [%sp]4,%e4
8000a7d8:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a7dc:	6d 00 bd 02 	call 8000ad56 <__unpack_d>
8000a7e0:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a7e4:	d9 a5 28 00 	lea %a5,[%sp]40
8000a7e8:	6d 00 b7 02 	call 8000ad56 <__unpack_d>
8000a7ec:	58 0b       	ld.w %d15,[%sp]44
8000a7ee:	d9 a4 14 00 	lea %a4,[%sp]20
8000a7f2:	8f 1f 80 f1 	xor %d15,%d15,1
8000a7f6:	d9 a5 28 00 	lea %a5,[%sp]40
8000a7fa:	d9 a6 3c 00 	lea %a6,[%sp]60
8000a7fe:	78 0b       	st.w [%sp]44,%d15
8000a800:	6d ff fb fe 	call 8000a5f6 <_fpadd_parts>
8000a804:	40 24       	mov.aa %a4,%a2
8000a806:	1d 00 1f 02 	j 8000ac44 <__pack_d>

8000a80a <__muldf3>:
8000a80a:	20 50       	sub.a %sp,80
8000a80c:	d9 a4 04 00 	lea %a4,[%sp]4
8000a810:	d9 a5 14 00 	lea %a5,[%sp]20
8000a814:	89 a4 44 09 	st.d [%sp]4,%e4
8000a818:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a81c:	6d 00 9d 02 	call 8000ad56 <__unpack_d>
8000a820:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a824:	d9 a5 28 00 	lea %a5,[%sp]40
8000a828:	6d 00 97 02 	call 8000ad56 <__unpack_d>
8000a82c:	39 a3 14 00 	ld.bu %d3,[%sp]20
8000a830:	ff 23 0c 80 	jge.u %d3,2,8000a848 <__muldf3+0x3e>
8000a834:	19 a2 18 00 	ld.w %d2,[%sp]24
8000a838:	58 0b       	ld.w %d15,[%sp]44
8000a83a:	d9 a4 14 00 	lea %a4,[%sp]20
8000a83e:	0b f2 10 f1 	ne %d15,%d2,%d15
8000a842:	78 06       	st.w [%sp]24,%d15
8000a844:	1d 00 b3 00 	j 8000a9aa <__muldf3+0x1a0>
8000a848:	39 af 28 00 	ld.bu %d15,[%sp]40
8000a84c:	ff 2f 0c 80 	jge.u %d15,2,8000a864 <__muldf3+0x5a>
8000a850:	58 0b       	ld.w %d15,[%sp]44
8000a852:	19 a2 18 00 	ld.w %d2,[%sp]24
8000a856:	d9 a4 28 00 	lea %a4,[%sp]40
8000a85a:	0b f2 10 f1 	ne %d15,%d2,%d15
8000a85e:	78 0b       	st.w [%sp]44,%d15
8000a860:	1d 00 a5 00 	j 8000a9aa <__muldf3+0x1a0>
8000a864:	df 43 09 80 	jne %d3,4,8000a876 <__muldf3+0x6c>
8000a868:	91 00 00 48 	movh.a %a4,32768
8000a86c:	d9 44 d0 90 	lea %a4,[%a4]3664 <80000e50 <__thenan_df>>
8000a870:	df 2f 9d 00 	jeq %d15,2,8000a9aa <__muldf3+0x1a0>
8000a874:	3c e0       	j 8000a834 <__muldf3+0x2a>
8000a876:	5e 48       	jne %d15,4,8000a886 <__muldf3+0x7c>
8000a878:	91 00 00 48 	movh.a %a4,32768
8000a87c:	d9 44 d0 90 	lea %a4,[%a4]3664 <80000e50 <__thenan_df>>
8000a880:	df 23 95 00 	jeq %d3,2,8000a9aa <__muldf3+0x1a0>
8000a884:	3c e6       	j 8000a850 <__muldf3+0x46>
8000a886:	df 23 d7 7f 	jeq %d3,2,8000a834 <__muldf3+0x2a>
8000a88a:	df 2f e3 7f 	jeq %d15,2,8000a850 <__muldf3+0x46>
8000a88e:	58 08       	ld.w %d15,[%sp]32
8000a890:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
8000a894:	d2 00       	mov %e0,0
8000a896:	19 a0 34 00 	ld.w %d0,[%sp]52
8000a89a:	73 bf 68 60 	mul.u %e6,%d15,%d11
8000a89e:	82 0c       	mov %d12,0
8000a8a0:	73 0f 68 40 	mul.u %e4,%d15,%d0
8000a8a4:	19 aa 24 00 	ld.w %d10,[%sp]36
8000a8a8:	82 02       	mov %d2,0
8000a8aa:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
8000a8ae:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
8000a8b2:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
8000a8b6:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
8000a8ba:	82 0d       	mov %d13,0
8000a8bc:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
8000a8c0:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
8000a8c4:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
8000a8c8:	0b 54 10 08 	mov %e0,%d4,%d5
8000a8cc:	42 20       	add %d0,%d2
8000a8ce:	3a 73       	eq %d15,%d3,%d7
8000a8d0:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
8000a8d4:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
8000a8d8:	8b 0f 00 62 	eq %d6,%d15,0
8000a8dc:	3a 50       	eq %d15,%d0,%d5
8000a8de:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
8000a8e2:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
8000a8e6:	ba 0f       	eq %d15,%d15,0
8000a8e8:	53 1f 40 40 	mul.u %e4,%d15,1
8000a8ec:	02 38       	mov %d8,%d3
8000a8ee:	82 09       	mov %d9,0
8000a8f0:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
8000a8f4:	02 5f       	mov %d15,%d5
8000a8f6:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
8000a8fa:	42 6f       	add %d15,%d6
8000a8fc:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
8000a900:	0b 4f 10 68 	mov %e6,%d15,%d4
8000a904:	0b 62 40 40 	addx %d4,%d2,%d6
8000a908:	0b 73 50 20 	addc %d2,%d3,%d7
8000a90c:	58 07       	ld.w %d15,[%sp]28
8000a90e:	19 a3 30 00 	ld.w %d3,[%sp]48
8000a912:	19 a5 18 00 	ld.w %d5,[%sp]24
8000a916:	42 3f       	add %d15,%d3
8000a918:	19 a3 2c 00 	ld.w %d3,[%sp]44
8000a91c:	c2 4f       	add %d15,4
8000a91e:	0b 35 10 31 	ne %d3,%d5,%d3
8000a922:	59 a3 00 10 	st.w [%sp]64,%d3
8000a926:	7b 00 00 52 	movh %d5,8192
8000a92a:	0b 52 50 31 	ge.u %d3,%d2,%d5
8000a92e:	df 03 1b 00 	jeq %d3,0,8000a964 <__muldf3+0x15a>
8000a932:	8f 14 00 31 	and %d3,%d4,1
8000a936:	76 37       	jz %d3,8000a944 <__muldf3+0x13a>
8000a938:	8f f0 1f 30 	sh %d3,%d0,-1
8000a93c:	77 10 80 1f 	dextr %d1,%d0,%d1,31
8000a940:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
8000a944:	77 42 80 4f 	dextr %d4,%d2,%d4,31
8000a948:	c2 1f       	add %d15,1
8000a94a:	06 f2       	sh %d2,-1
8000a94c:	3c ed       	j 8000a926 <__muldf3+0x11c>
8000a94e:	77 42 80 20 	dextr %d2,%d2,%d4,1
8000a952:	06 14       	sh %d4,1
8000a954:	ce 04       	jgez %d0,8000a95c <__muldf3+0x152>
8000a956:	8f 14 40 51 	or %d5,%d4,1
8000a95a:	02 54       	mov %d4,%d5
8000a95c:	77 10 80 00 	dextr %d0,%d0,%d1,1
8000a960:	c2 ff       	add %d15,-1
8000a962:	06 11       	sh %d1,1
8000a964:	7b 00 00 51 	movh %d5,4096
8000a968:	0b 52 30 31 	lt.u %d3,%d2,%d5
8000a96c:	df 03 f1 ff 	jne %d3,0,8000a94e <__muldf3+0x144>
8000a970:	78 11       	st.w [%sp]68,%d15
8000a972:	02 4f       	mov %d15,%d4
8000a974:	16 ff       	and %d15,255
8000a976:	8b 0f 28 f2 	ne %d15,%d15,128
8000a97a:	ee 0f       	jnz %d15,8000a998 <__muldf3+0x18e>
8000a97c:	a6 10       	or %d0,%d1
8000a97e:	77 42 00 fc 	dextr %d15,%d2,%d4,24
8000a982:	8b 00 20 02 	ne %d0,%d0,0
8000a986:	0f f0 e0 00 	andn %d0,%d0,%d15
8000a98a:	76 07       	jz %d0,8000a998 <__muldf3+0x18e>
8000a98c:	8b 04 88 40 	addx %d4,%d4,128
8000a990:	8b 02 a0 20 	addc %d2,%d2,0
8000a994:	8f f4 cf 41 	andn %d4,%d4,255
8000a998:	d9 a4 10 10 	lea %a4,[%sp]80
8000a99c:	82 3f       	mov %d15,3
8000a99e:	59 a4 08 10 	st.w [%sp]72,%d4
8000a9a2:	59 a2 0c 10 	st.w [%sp]76,%d2
8000a9a6:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <IfxAsclin1_TX_P33_12_OUT>>,%d15
8000a9aa:	1d 00 4d 01 	j 8000ac44 <__pack_d>

8000a9ae <__divdf3>:
8000a9ae:	20 38       	sub.a %sp,56
8000a9b0:	40 a4       	mov.aa %a4,%sp
8000a9b2:	d9 a5 10 00 	lea %a5,[%sp]16
8000a9b6:	89 a4 40 09 	st.d [%sp],%e4
8000a9ba:	89 a6 48 09 	st.d [%sp]8,%e6
8000a9be:	6d 00 cc 01 	call 8000ad56 <__unpack_d>
8000a9c2:	d9 a4 08 00 	lea %a4,[%sp]8
8000a9c6:	d9 a5 24 00 	lea %a5,[%sp]36
8000a9ca:	6d 00 c6 01 	call 8000ad56 <__unpack_d>
8000a9ce:	39 a2 10 00 	ld.bu %d2,[%sp]16
8000a9d2:	bf 22 76 80 	jlt.u %d2,2,8000aabe <__divdf3+0x110>
8000a9d6:	39 af 24 00 	ld.bu %d15,[%sp]36
8000a9da:	d9 a4 24 00 	lea %a4,[%sp]36
8000a9de:	bf 2f 72 80 	jlt.u %d15,2,8000aac2 <__divdf3+0x114>
8000a9e2:	19 a4 14 00 	ld.w %d4,[%sp]20
8000a9e6:	19 a3 28 00 	ld.w %d3,[%sp]40
8000a9ea:	c6 43       	xor %d3,%d4
8000a9ec:	59 a3 14 00 	st.w [%sp]20,%d3
8000a9f0:	1b e2 ff 3f 	addi %d3,%d2,-2
8000a9f4:	8f d3 0f 31 	and %d3,%d3,253
8000a9f8:	f6 38       	jnz %d3,8000aa08 <__divdf3+0x5a>
8000a9fa:	91 00 00 48 	movh.a %a4,32768
8000a9fe:	d9 44 d0 90 	lea %a4,[%a4]3664 <80000e50 <__thenan_df>>
8000aa02:	5f f2 5e 80 	jne %d2,%d15,8000aabe <__divdf3+0x110>
8000aa06:	3c 5e       	j 8000aac2 <__divdf3+0x114>
8000aa08:	5e 47       	jne %d15,4,8000aa16 <__divdf3+0x68>
8000aa0a:	d2 02       	mov %e2,0
8000aa0c:	82 0f       	mov %d15,0
8000aa0e:	89 a2 5c 09 	st.d [%sp]28,%e2
8000aa12:	78 06       	st.w [%sp]24,%d15
8000aa14:	3c 55       	j 8000aabe <__divdf3+0x110>
8000aa16:	5e 25       	jne %d15,2,8000aa20 <__divdf3+0x72>
8000aa18:	82 4f       	mov %d15,4
8000aa1a:	e9 af 10 00 	st.b [%sp]16,%d15
8000aa1e:	3c 50       	j 8000aabe <__divdf3+0x110>
8000aa20:	58 06       	ld.w %d15,[%sp]24
8000aa22:	09 a2 5c 09 	ld.d %e2,[%sp]28
8000aa26:	09 a4 70 09 	ld.d %e4,[%sp]48
8000aa2a:	19 a6 2c 00 	ld.w %d6,[%sp]44
8000aa2e:	52 66       	sub %d6,%d15,%d6
8000aa30:	3a 53       	eq %d15,%d3,%d5
8000aa32:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
8000aa36:	59 a6 18 00 	st.w [%sp]24,%d6
8000aa3a:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
8000aa3e:	ee 07       	jnz %d15,8000aa4c <__divdf3+0x9e>
8000aa40:	c2 f6       	add %d6,-1
8000aa42:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000aa46:	59 a6 18 00 	st.w [%sp]24,%d6
8000aa4a:	06 12       	sh %d2,1
8000aa4c:	82 01       	mov %d1,0
8000aa4e:	7b 00 00 f1 	movh %d15,4096
8000aa52:	82 00       	mov %d0,0
8000aa54:	82 07       	mov %d7,0
8000aa56:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
8000aa5a:	0b 53 00 61 	eq %d6,%d3,%d5
8000aa5e:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8000aa62:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8000aa66:	f6 6b       	jnz %d6,8000aa7c <__divdf3+0xce>
8000aa68:	0f 10 a0 80 	or %d8,%d0,%d1
8000aa6c:	0f f7 a0 60 	or %d6,%d7,%d15
8000aa70:	0b 42 c0 20 	subx %d2,%d2,%d4
8000aa74:	02 80       	mov %d0,%d8
8000aa76:	02 67       	mov %d7,%d6
8000aa78:	0b 53 d0 30 	subc %d3,%d3,%d5
8000aa7c:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
8000aa80:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000aa84:	06 ff       	sh %d15,-1
8000aa86:	06 12       	sh %d2,1
8000aa88:	fd f0 e9 7f 	loop %a15,8000aa5a <__divdf3+0xac>
8000aa8c:	02 0f       	mov %d15,%d0
8000aa8e:	16 ff       	and %d15,255
8000aa90:	8b 0f 28 f2 	ne %d15,%d15,128
8000aa94:	0b 70 10 48 	mov %e4,%d0,%d7
8000aa98:	ee 0f       	jnz %d15,8000aab6 <__divdf3+0x108>
8000aa9a:	a6 32       	or %d2,%d3
8000aa9c:	77 07 00 fc 	dextr %d15,%d7,%d0,24
8000aaa0:	8b 02 20 22 	ne %d2,%d2,0
8000aaa4:	0f f2 e0 20 	andn %d2,%d2,%d15
8000aaa8:	76 27       	jz %d2,8000aab6 <__divdf3+0x108>
8000aaaa:	8b 00 88 00 	addx %d0,%d0,128
8000aaae:	8b 07 a0 40 	addc %d4,%d7,0
8000aab2:	8f f0 cf 51 	andn %d5,%d0,255
8000aab6:	59 a5 1c 00 	st.w [%sp]28,%d5
8000aaba:	59 a4 20 00 	st.w [%sp]32,%d4
8000aabe:	d9 a4 10 00 	lea %a4,[%sp]16
8000aac2:	1d 00 c1 00 	j 8000ac44 <__pack_d>

8000aac6 <__floatsidf>:
8000aac6:	20 18       	sub.a %sp,24
8000aac8:	82 3f       	mov %d15,3
8000aaca:	2c a4       	st.b [%sp]4,%d15
8000aacc:	8f 14 1e f0 	sh %d15,%d4,-31
8000aad0:	78 02       	st.w [%sp]8,%d15
8000aad2:	f6 44       	jnz %d4,8000aada <__floatsidf+0x14>
8000aad4:	82 2f       	mov %d15,2
8000aad6:	2c a4       	st.b [%sp]4,%d15
8000aad8:	3c 16       	j 8000ab04 <__floatsidf+0x3e>
8000aada:	6e 09       	jz %d15,8000aaec <__floatsidf+0x26>
8000aadc:	7b 00 00 f8 	movh %d15,32768
8000aae0:	82 02       	mov %d2,0
8000aae2:	7b 00 1e 3c 	movh %d3,49632
8000aae6:	5f f4 13 00 	jeq %d4,%d15,8000ab0c <__floatsidf+0x46>
8000aaea:	32 54       	rsub %d4
8000aaec:	0f 04 b0 f1 	clz %d15,%d4
8000aaf0:	1b df 01 60 	addi %d6,%d15,29
8000aaf4:	82 05       	mov %d5,0
8000aaf6:	6d 00 52 00 	call 8000ab9a <__ashldi3>
8000aafa:	8b ff 01 f1 	rsub %d15,%d15,31
8000aafe:	89 a2 50 09 	st.d [%sp]16,%e2
8000ab02:	78 03       	st.w [%sp]12,%d15
8000ab04:	d9 a4 04 00 	lea %a4,[%sp]4
8000ab08:	6d 00 9e 00 	call 8000ac44 <__pack_d>
8000ab0c:	00 90       	ret 

8000ab0e <__make_dp>:
8000ab0e:	20 18       	sub.a %sp,24
8000ab10:	09 a2 58 09 	ld.d %e2,[%sp]24
8000ab14:	d9 a4 04 00 	lea %a4,[%sp]4
8000ab18:	e9 a4 04 00 	st.b [%sp]4,%d4
8000ab1c:	59 a5 08 00 	st.w [%sp]8,%d5
8000ab20:	59 a6 0c 00 	st.w [%sp]12,%d6
8000ab24:	89 a2 50 09 	st.d [%sp]16,%e2
8000ab28:	1d 00 8e 00 	j 8000ac44 <__pack_d>

8000ab2c <__truncdfsf2>:
8000ab2c:	20 20       	sub.a %sp,32
8000ab2e:	d9 a4 20 00 	lea %a4,[%sp]32
8000ab32:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000ab36:	d9 a5 0c 00 	lea %a5,[%sp]12
8000ab3a:	6d 00 0e 01 	call 8000ad56 <__unpack_d>
8000ab3e:	19 a7 18 00 	ld.w %d7,[%sp]24
8000ab42:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000ab46:	39 a4 0c 00 	ld.bu %d4,[%sp]12
8000ab4a:	77 72 00 21 	dextr %d2,%d2,%d7,2
8000ab4e:	b7 07 02 7f 	insert %d7,%d7,0,30,2
8000ab52:	02 23       	mov %d3,%d2
8000ab54:	8f 12 40 21 	or %d2,%d2,1
8000ab58:	19 a5 10 00 	ld.w %d5,[%sp]16
8000ab5c:	19 a6 14 00 	ld.w %d6,[%sp]20
8000ab60:	2b 32 40 77 	sel %d7,%d7,%d2,%d3
8000ab64:	1d 00 65 00 	j 8000ac2e <__make_fp>

8000ab68 <__floatunsidf>:
8000ab68:	20 18       	sub.a %sp,24
8000ab6a:	82 0f       	mov %d15,0
8000ab6c:	78 02       	st.w [%sp]8,%d15
8000ab6e:	f6 44       	jnz %d4,8000ab76 <__floatunsidf+0xe>
8000ab70:	82 2f       	mov %d15,2
8000ab72:	2c a4       	st.b [%sp]4,%d15
8000ab74:	3c 0f       	j 8000ab92 <__floatunsidf+0x2a>
8000ab76:	82 3f       	mov %d15,3
8000ab78:	2c a4       	st.b [%sp]4,%d15
8000ab7a:	0f 04 b0 f1 	clz %d15,%d4
8000ab7e:	1b df 01 60 	addi %d6,%d15,29
8000ab82:	82 05       	mov %d5,0
8000ab84:	6d 00 0b 00 	call 8000ab9a <__ashldi3>
8000ab88:	8b ff 01 f1 	rsub %d15,%d15,31
8000ab8c:	89 a2 50 09 	st.d [%sp]16,%e2
8000ab90:	78 03       	st.w [%sp]12,%d15
8000ab92:	d9 a4 04 00 	lea %a4,[%sp]4
8000ab96:	1d 00 57 00 	j 8000ac44 <__pack_d>

8000ab9a <__ashldi3>:
8000ab9a:	6f 56 07 80 	jnz.t %d6,5,8000aba8 <__ashldi3+0xe>
8000ab9e:	0f 64 00 20 	sh %d2,%d4,%d6
8000aba2:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
8000aba6:	00 90       	ret 
8000aba8:	8b 06 1e 60 	add %d6,%d6,-32
8000abac:	82 02       	mov %d2,0
8000abae:	0f 64 00 30 	sh %d3,%d4,%d6
8000abb2:	00 90       	ret 

8000abb4 <__unpack_f>:
8000abb4:	54 43       	ld.w %d3,[%a4]
8000abb6:	37 03 77 f0 	extr.u %d15,%d3,0,23
8000abba:	37 03 e8 2b 	extr.u %d2,%d3,23,8
8000abbe:	8f 13 1e 30 	sh %d3,%d3,-31
8000abc2:	59 53 04 00 	st.w [%a5]4,%d3
8000abc6:	df 02 18 80 	jne %d2,0,8000abf6 <__unpack_f+0x42>
8000abca:	ee 03       	jnz %d15,8000abd0 <__unpack_f+0x1c>
8000abcc:	82 2f       	mov %d15,2
8000abce:	3c 19       	j 8000ac00 <__unpack_f+0x4c>
8000abd0:	3b 20 f8 2f 	mov %d2,-126
8000abd4:	59 52 08 00 	st.w [%a5]8,%d2
8000abd8:	82 32       	mov %d2,3
8000abda:	34 52       	st.b [%a5],%d2
8000abdc:	06 7f       	sh %d15,7
8000abde:	3b 10 f8 2f 	mov %d2,-127
8000abe2:	7b 00 00 44 	movh %d4,16384
8000abe6:	06 1f       	sh %d15,1
8000abe8:	02 23       	mov %d3,%d2
8000abea:	c2 f2       	add %d2,-1
8000abec:	3f 4f fd ff 	jlt.u %d15,%d4,8000abe6 <__unpack_f+0x32>
8000abf0:	59 53 08 00 	st.w [%a5]8,%d3
8000abf4:	3c 1b       	j 8000ac2a <__unpack_f+0x76>
8000abf6:	8b f2 2f 32 	ne %d3,%d2,255
8000abfa:	f6 3f       	jnz %d3,8000ac18 <__unpack_f+0x64>
8000abfc:	ee 04       	jnz %d15,8000ac04 <__unpack_f+0x50>
8000abfe:	82 4f       	mov %d15,4
8000ac00:	2c 50       	st.b [%a5]0,%d15
8000ac02:	00 90       	ret 
8000ac04:	7b 00 04 20 	movh %d2,64
8000ac08:	26 f2       	and %d2,%d15
8000ac0a:	76 22       	jz %d2,8000ac0e <__unpack_f+0x5a>
8000ac0c:	82 12       	mov %d2,1
8000ac0e:	b7 0f 01 fb 	insert %d15,%d15,0,22,1
8000ac12:	34 52       	st.b [%a5],%d2
8000ac14:	06 7f       	sh %d15,7
8000ac16:	3c 0a       	j 8000ac2a <__unpack_f+0x76>
8000ac18:	1b 12 f8 2f 	addi %d2,%d2,-127
8000ac1c:	06 7f       	sh %d15,7
8000ac1e:	59 52 08 00 	st.w [%a5]8,%d2
8000ac22:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000ac26:	82 32       	mov %d2,3
8000ac28:	34 52       	st.b [%a5],%d2
8000ac2a:	6c 53       	st.w [%a5]12,%d15
8000ac2c:	00 90       	ret 

8000ac2e <__make_fp>:
8000ac2e:	20 10       	sub.a %sp,16
8000ac30:	40 a4       	mov.aa %a4,%sp
8000ac32:	34 a4       	st.b [%sp],%d4
8000ac34:	59 a5 04 00 	st.w [%sp]4,%d5
8000ac38:	59 a6 08 00 	st.w [%sp]8,%d6
8000ac3c:	59 a7 0c 00 	st.w [%sp]12,%d7
8000ac40:	1d 00 e1 00 	j 8000ae02 <__pack_f>

8000ac44 <__pack_d>:
8000ac44:	14 42       	ld.bu %d2,[%a4]
8000ac46:	19 49 0c 00 	ld.w %d9,[%a4]12
8000ac4a:	19 48 10 00 	ld.w %d8,[%a4]16
8000ac4e:	19 4c 04 00 	ld.w %d12,[%a4]4
8000ac52:	ff 22 0b 80 	jge.u %d2,2,8000ac68 <__pack_d+0x24>
8000ac56:	77 98 00 9c 	dextr %d9,%d8,%d9,24
8000ac5a:	06 88       	sh %d8,-8
8000ac5c:	02 95       	mov %d5,%d9
8000ac5e:	b7 18 8d 49 	insert %d4,%d8,1,19,13
8000ac62:	3b f0 7f f0 	mov %d15,2047
8000ac66:	3c 6f       	j 8000ad44 <__pack_d+0x100>
8000ac68:	3b f0 7f f0 	mov %d15,2047
8000ac6c:	d2 04       	mov %e4,0
8000ac6e:	df 42 6b 00 	jeq %d2,4,8000ad44 <__pack_d+0x100>
8000ac72:	0f 89 a0 f0 	or %d15,%d9,%d8
8000ac76:	8b 22 00 32 	eq %d3,%d2,2
8000ac7a:	8b 0f e0 34 	or.eq %d3,%d15,0
8000ac7e:	82 0f       	mov %d15,0
8000ac80:	df 03 62 80 	jne %d3,0,8000ad44 <__pack_d+0x100>
8000ac84:	19 42 08 00 	ld.w %d2,[%a4]8
8000ac88:	3b 20 c0 ff 	mov %d15,-1022
8000ac8c:	7f f2 36 00 	jge %d2,%d15,8000acf8 <__pack_d+0xb4>
8000ac90:	a2 2f       	sub %d15,%d2
8000ac92:	8b 9f 83 42 	ge %d4,%d15,57
8000ac96:	82 02       	mov %d2,0
8000ac98:	df 04 18 80 	jne %d4,0,8000acc8 <__pack_d+0x84>
8000ac9c:	0b 98 10 48 	mov %e4,%d8,%d9
8000aca0:	02 f6       	mov %d6,%d15
8000aca2:	6d ff 58 fc 	call 8000a552 <__lshrdi3>
8000aca6:	d2 14       	mov %e4,1
8000aca8:	02 f6       	mov %d6,%d15
8000acaa:	0b 32 10 a8 	mov %e10,%d2,%d3
8000acae:	6d ff 76 ff 	call 8000ab9a <__ashldi3>
8000acb2:	8b f2 9f 20 	addx %d2,%d2,-1
8000acb6:	8b f3 bf 30 	addc %d3,%d3,-1
8000acba:	26 29       	and %d9,%d2
8000acbc:	26 38       	and %d8,%d3
8000acbe:	a6 98       	or %d8,%d9
8000acc0:	02 b2       	mov %d2,%d11
8000acc2:	8b 08 00 25 	or.ne %d2,%d8,0
8000acc6:	02 a3       	mov %d3,%d10
8000acc8:	02 2f       	mov %d15,%d2
8000acca:	16 ff       	and %d15,255
8000accc:	8b 0f 28 f2 	ne %d15,%d15,128
8000acd0:	ee 07       	jnz %d15,8000acde <__pack_d+0x9a>
8000acd2:	8f 02 10 f1 	and %d15,%d2,256
8000acd6:	6e 08       	jz %d15,8000ace6 <__pack_d+0xa2>
8000acd8:	8b 02 88 20 	addx %d2,%d2,128
8000acdc:	3c 03       	j 8000ace2 <__pack_d+0x9e>
8000acde:	8b f2 87 20 	addx %d2,%d2,127
8000ace2:	8b 03 a0 30 	addc %d3,%d3,0
8000ace6:	7b 00 00 41 	movh %d4,4096
8000acea:	0b 43 50 f1 	ge.u %d15,%d3,%d4
8000acee:	77 23 00 5c 	dextr %d5,%d3,%d2,24
8000acf2:	8f 83 1f 40 	sh %d4,%d3,-8
8000acf6:	3c 27       	j 8000ad44 <__pack_d+0x100>
8000acf8:	3b 00 40 30 	mov %d3,1024
8000acfc:	3b f0 7f f0 	mov %d15,2047
8000ad00:	7f 32 22 00 	jge %d2,%d3,8000ad44 <__pack_d+0x100>
8000ad04:	02 9f       	mov %d15,%d9
8000ad06:	16 ff       	and %d15,255
8000ad08:	8b 0f 28 f2 	ne %d15,%d15,128
8000ad0c:	ee 07       	jnz %d15,8000ad1a <__pack_d+0xd6>
8000ad0e:	8f 09 10 f1 	and %d15,%d9,256
8000ad12:	6e 08       	jz %d15,8000ad22 <__pack_d+0xde>
8000ad14:	8b 09 88 90 	addx %d9,%d9,128
8000ad18:	3c 03       	j 8000ad1e <__pack_d+0xda>
8000ad1a:	8b f9 87 90 	addx %d9,%d9,127
8000ad1e:	8b 08 a0 80 	addc %d8,%d8,0
8000ad22:	7b 00 00 32 	movh %d3,8192
8000ad26:	0b 38 50 f1 	ge.u %d15,%d8,%d3
8000ad2a:	ee 04       	jnz %d15,8000ad32 <__pack_d+0xee>
8000ad2c:	1b f2 3f f0 	addi %d15,%d2,1023
8000ad30:	3c 06       	j 8000ad3c <__pack_d+0xf8>
8000ad32:	77 98 80 9f 	dextr %d9,%d8,%d9,31
8000ad36:	1b 02 40 f0 	addi %d15,%d2,1024
8000ad3a:	06 f8       	sh %d8,-1
8000ad3c:	77 98 00 5c 	dextr %d5,%d8,%d9,24
8000ad40:	8f 88 1f 40 	sh %d4,%d8,-8
8000ad44:	d2 02       	mov %e2,0
8000ad46:	37 43 14 40 	insert %d4,%d3,%d4,0,20
8000ad4a:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
8000ad4e:	02 52       	mov %d2,%d5
8000ad50:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
8000ad54:	00 90       	ret 

8000ad56 <__unpack_d>:
8000ad56:	19 44 04 00 	ld.w %d4,[%a4]4
8000ad5a:	54 42       	ld.w %d2,[%a4]
8000ad5c:	37 04 74 50 	extr.u %d5,%d4,0,20
8000ad60:	37 04 6b fa 	extr.u %d15,%d4,20,11
8000ad64:	8f 14 1e 40 	sh %d4,%d4,-31
8000ad68:	59 54 04 00 	st.w [%a5]4,%d4
8000ad6c:	02 53       	mov %d3,%d5
8000ad6e:	ee 21       	jnz %d15,8000adb0 <__unpack_d+0x5a>
8000ad70:	0f 25 a0 f0 	or %d15,%d5,%d2
8000ad74:	ee 03       	jnz %d15,8000ad7a <__unpack_d+0x24>
8000ad76:	82 2f       	mov %d15,2
8000ad78:	3c 23       	j 8000adbe <__unpack_d+0x68>
8000ad7a:	3b 20 c0 ff 	mov %d15,-1022
8000ad7e:	6c 52       	st.w [%a5]8,%d15
8000ad80:	82 3f       	mov %d15,3
8000ad82:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000ad86:	2c 50       	st.b [%a5]0,%d15
8000ad88:	8f 82 00 20 	sh %d2,%d2,8
8000ad8c:	3b 10 c0 ff 	mov %d15,-1023
8000ad90:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000ad94:	7b 00 00 61 	movh %d6,4096
8000ad98:	0b 63 30 51 	lt.u %d5,%d3,%d6
8000ad9c:	02 f4       	mov %d4,%d15
8000ad9e:	06 12       	sh %d2,1
8000ada0:	c2 ff       	add %d15,-1
8000ada2:	df 05 f7 ff 	jne %d5,0,8000ad90 <__unpack_d+0x3a>
8000ada6:	59 54 08 00 	st.w [%a5]8,%d4
8000adaa:	59 52 0c 00 	st.w [%a5]12,%d2
8000adae:	3c 27       	j 8000adfc <__unpack_d+0xa6>
8000adb0:	3b f0 7f 40 	mov %d4,2047
8000adb4:	fe 47       	jne %d15,%d4,8000ade2 <__unpack_d+0x8c>
8000adb6:	0f 25 a0 f0 	or %d15,%d5,%d2
8000adba:	ee 04       	jnz %d15,8000adc2 <__unpack_d+0x6c>
8000adbc:	82 4f       	mov %d15,4
8000adbe:	2c 50       	st.b [%a5]0,%d15
8000adc0:	00 90       	ret 
8000adc2:	7b 80 00 f0 	movh %d15,8
8000adc6:	26 5f       	and %d15,%d5
8000adc8:	6e 02       	jz %d15,8000adcc <__unpack_d+0x76>
8000adca:	82 1f       	mov %d15,1
8000adcc:	2c 50       	st.b [%a5]0,%d15
8000adce:	b7 03 81 f9 	insert %d15,%d3,0,19,1
8000add2:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
8000add6:	8f 82 00 40 	sh %d4,%d2,8
8000adda:	59 54 0c 00 	st.w [%a5]12,%d4
8000adde:	6c 54       	st.w [%a5]16,%d15
8000ade0:	00 90       	ret 
8000ade2:	1b 1f c0 ff 	addi %d15,%d15,-1023
8000ade6:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000adea:	6c 52       	st.w [%a5]8,%d15
8000adec:	8f 82 00 20 	sh %d2,%d2,8
8000adf0:	82 3f       	mov %d15,3
8000adf2:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
8000adf6:	2c 50       	st.b [%a5]0,%d15
8000adf8:	59 52 0c 00 	st.w [%a5]12,%d2
8000adfc:	59 53 10 00 	st.w [%a5]16,%d3
8000ae00:	00 90       	ret 

8000ae02 <__pack_f>:
8000ae02:	14 45       	ld.bu %d5,[%a4]
8000ae04:	4c 43       	ld.w %d15,[%a4]12
8000ae06:	19 47 04 00 	ld.w %d7,[%a4]4
8000ae0a:	ff 25 09 80 	jge.u %d5,2,8000ae1c <__pack_f+0x1a>
8000ae0e:	37 0f f6 33 	extr.u %d3,%d15,7,22
8000ae12:	b7 f3 01 3b 	insert %d3,%d3,15,22,1
8000ae16:	3b f0 0f 40 	mov %d4,255
8000ae1a:	3c 4f       	j 8000aeb8 <__pack_f+0xb6>
8000ae1c:	3b f0 0f 40 	mov %d4,255
8000ae20:	82 03       	mov %d3,0
8000ae22:	df 45 4b 00 	jeq %d5,4,8000aeb8 <__pack_f+0xb6>
8000ae26:	8b 25 00 62 	eq %d6,%d5,2
8000ae2a:	8b 0f e0 64 	or.eq %d6,%d15,0
8000ae2e:	82 04       	mov %d4,0
8000ae30:	df 06 44 80 	jne %d6,0,8000aeb8 <__pack_f+0xb6>
8000ae34:	19 45 08 00 	ld.w %d5,[%a4]8
8000ae38:	8b 25 98 42 	ge %d4,%d5,-126
8000ae3c:	df 04 24 80 	jne %d4,0,8000ae84 <__pack_f+0x82>
8000ae40:	8b 25 18 51 	rsub %d5,%d5,-126
8000ae44:	8b a5 81 42 	ge %d4,%d5,26
8000ae48:	f6 4c       	jnz %d4,8000ae60 <__pack_f+0x5e>
8000ae4a:	82 12       	mov %d2,1
8000ae4c:	0f 52 00 20 	sh %d2,%d2,%d5
8000ae50:	8b 05 00 31 	rsub %d3,%d5,0
8000ae54:	c2 f2       	add %d2,-1
8000ae56:	0f 3f 00 30 	sh %d3,%d15,%d3
8000ae5a:	26 2f       	and %d15,%d2
8000ae5c:	8b 0f 00 35 	or.ne %d3,%d15,0
8000ae60:	8f f3 07 f1 	and %d15,%d3,127
8000ae64:	8b 0f 24 f2 	ne %d15,%d15,64
8000ae68:	ee 06       	jnz %d15,8000ae74 <__pack_f+0x72>
8000ae6a:	8f 03 08 f1 	and %d15,%d3,128
8000ae6e:	ab 03 04 3f 	cadd %d3,%d15,%d3,64
8000ae72:	3c 03       	j 8000ae78 <__pack_f+0x76>
8000ae74:	1b f3 03 30 	addi %d3,%d3,63
8000ae78:	7b 00 00 f4 	movh %d15,16384
8000ae7c:	0b f3 50 41 	ge.u %d4,%d3,%d15
8000ae80:	06 93       	sh %d3,-7
8000ae82:	3c 1b       	j 8000aeb8 <__pack_f+0xb6>
8000ae84:	8b 05 88 62 	ge %d6,%d5,128
8000ae88:	3b f0 0f 40 	mov %d4,255
8000ae8c:	df 06 16 80 	jne %d6,0,8000aeb8 <__pack_f+0xb6>
8000ae90:	8f ff 07 31 	and %d3,%d15,127
8000ae94:	8b 03 24 32 	ne %d3,%d3,64
8000ae98:	f6 36       	jnz %d3,8000aea4 <__pack_f+0xa2>
8000ae9a:	8f 0f 08 31 	and %d3,%d15,128
8000ae9e:	ab 0f 04 f3 	cadd %d15,%d3,%d15,64
8000aea2:	3c 03       	j 8000aea8 <__pack_f+0xa6>
8000aea4:	1b ff 03 f0 	addi %d15,%d15,63
8000aea8:	1b f5 07 40 	addi %d4,%d5,127
8000aeac:	ce f4       	jgez %d15,8000aeb4 <__pack_f+0xb2>
8000aeae:	06 ff       	sh %d15,-1
8000aeb0:	1b 05 08 40 	addi %d4,%d5,128
8000aeb4:	8f 9f 1f 30 	sh %d3,%d15,-7
8000aeb8:	82 02       	mov %d2,0
8000aeba:	37 32 17 20 	insert %d2,%d2,%d3,0,23
8000aebe:	37 42 88 2b 	insert %d2,%d2,%d4,23,8
8000aec2:	37 72 81 2f 	insert %d2,%d2,%d7,31,1
8000aec6:	00 90       	ret 

8000aec8 <malloc>:
8000aec8:	91 00 00 f7 	movh.a %a15,28672
8000aecc:	99 f4 48 40 	ld.a %a4,[%a15]1288 <70000508 <_impure_ptr>>
8000aed0:	1d 00 09 00 	j 8000aee2 <_malloc_r>

8000aed4 <free>:
8000aed4:	91 00 00 f7 	movh.a %a15,28672
8000aed8:	40 45       	mov.aa %a5,%a4
8000aeda:	99 f4 48 40 	ld.a %a4,[%a15]1288 <70000508 <_impure_ptr>>
8000aede:	1d 00 f7 02 	j 8000b4cc <_free_r>

8000aee2 <_malloc_r>:
8000aee2:	1b b4 00 f0 	addi %d15,%d4,11
8000aee6:	8b 7f 61 82 	lt.u %d8,%d15,23
8000aeea:	8f 7f c0 f1 	andn %d15,%d15,7
8000aeee:	ab 0f a1 88 	seln %d8,%d8,%d15,16
8000aef2:	0b 48 30 41 	lt.u %d4,%d8,%d4
8000aef6:	8b 08 20 45 	or.lt %d4,%d8,0
8000aefa:	40 4d       	mov.aa %a13,%a4
8000aefc:	76 45       	jz %d4,8000af06 <_malloc_r+0x24>
8000aefe:	da 0c       	mov %d15,12
8000af00:	6c 40       	st.w [%a4]0,%d15
8000af02:	1d 00 2a 02 	j 8000b356 <_malloc_r+0x474>
8000af06:	91 00 00 f7 	movh.a %a15,28672
8000af0a:	8b 88 bf f2 	ge.u %d15,%d8,504
8000af0e:	6d 00 37 02 	call 8000b37c <__malloc_lock>
8000af12:	d9 ff 00 40 	lea %a15,[%a15]256 <70000100 <__malloc_av_>>
8000af16:	ee 19       	jnz %d15,8000af48 <_malloc_r+0x66>
8000af18:	8f d8 1f 20 	sh %d2,%d8,-3
8000af1c:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000af20:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000af24:	7d 2c 09 80 	jne.a %a12,%a2,8000af36 <_malloc_r+0x54>
8000af28:	d9 c2 08 00 	lea %a2,[%a12]8
8000af2c:	99 cc 14 00 	ld.a %a12,[%a12]20
8000af30:	c2 22       	add %d2,2
8000af32:	7d 2c 58 00 	jeq.a %a12,%a2,8000afe2 <_malloc_r+0x100>
8000af36:	cc c3       	ld.a %a15,[%a12]12
8000af38:	99 c2 08 00 	ld.a %a2,[%a12]8
8000af3c:	4c c1       	ld.w %d15,[%a12]4
8000af3e:	ec 23       	st.a [%a2]12,%a15
8000af40:	8f 3f c0 f1 	andn %d15,%d15,3
8000af44:	e8 22       	st.a [%a15]8,%a2
8000af46:	3c 74       	j 8000b02e <_malloc_r+0x14c>
8000af48:	8f 78 1f f0 	sh %d15,%d8,-9
8000af4c:	3b f0 03 20 	mov %d2,63
8000af50:	6e 27       	jz %d15,8000af9e <_malloc_r+0xbc>
8000af52:	8f a8 1f 20 	sh %d2,%d8,-6
8000af56:	1b 82 03 20 	addi %d2,%d2,56
8000af5a:	bf 5f 22 80 	jlt.u %d15,5,8000af9e <_malloc_r+0xbc>
8000af5e:	8b 5f a1 22 	ge.u %d2,%d15,21
8000af62:	f6 24       	jnz %d2,8000af6a <_malloc_r+0x88>
8000af64:	1b bf 05 20 	addi %d2,%d15,91
8000af68:	3c 1b       	j 8000af9e <_malloc_r+0xbc>
8000af6a:	8b 5f a5 22 	ge.u %d2,%d15,85
8000af6e:	f6 26       	jnz %d2,8000af7a <_malloc_r+0x98>
8000af70:	8f 48 1f 20 	sh %d2,%d8,-12
8000af74:	1b e2 06 20 	addi %d2,%d2,110
8000af78:	3c 13       	j 8000af9e <_malloc_r+0xbc>
8000af7a:	8b 5f b5 22 	ge.u %d2,%d15,341
8000af7e:	f6 26       	jnz %d2,8000af8a <_malloc_r+0xa8>
8000af80:	8f 18 1f 20 	sh %d2,%d8,-15
8000af84:	1b 72 07 20 	addi %d2,%d2,119
8000af88:	3c 0b       	j 8000af9e <_malloc_r+0xbc>
8000af8a:	3b 50 55 30 	mov %d3,1365
8000af8e:	3b e0 07 20 	mov %d2,126
8000af92:	7f 3f 06 80 	jge.u %d15,%d3,8000af9e <_malloc_r+0xbc>
8000af96:	8f e8 1e 20 	sh %d2,%d8,-18
8000af9a:	1b c2 07 20 	addi %d2,%d2,124
8000af9e:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000afa2:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000afa6:	7d 2c 1d 00 	jeq.a %a12,%a2,8000afe0 <_malloc_r+0xfe>
8000afaa:	19 c4 04 00 	ld.w %d4,[%a12]4
8000afae:	8f 34 c0 41 	andn %d4,%d4,3
8000afb2:	5a 84       	sub %d15,%d4,%d8
8000afb4:	8b 0f 41 32 	lt %d3,%d15,16
8000afb8:	f6 33       	jnz %d3,8000afbe <_malloc_r+0xdc>
8000afba:	c2 f2       	add %d2,-1
8000afbc:	3c 12       	j 8000afe0 <_malloc_r+0xfe>
8000afbe:	0e fe       	jltz %d15,8000afda <_malloc_r+0xf8>
8000afc0:	cc c3       	ld.a %a15,[%a12]12
8000afc2:	99 c2 08 00 	ld.a %a2,[%a12]8
8000afc6:	ec 23       	st.a [%a2]12,%a15
8000afc8:	e8 22       	st.a [%a15]8,%a2
8000afca:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
8000afce:	b7 10 21 20 	imask %e2,1,0,1
8000afd2:	49 f2 44 08 	ldmst [%a15]4,%e2
8000afd6:	1d 00 cc 01 	j 8000b36e <_malloc_r+0x48c>
8000afda:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000afde:	3c e4       	j 8000afa6 <_malloc_r+0xc4>
8000afe0:	c2 12       	add %d2,1
8000afe2:	c8 4c       	ld.a %a12,[%a15]16
8000afe4:	91 00 00 37 	movh.a %a3,28672
8000afe8:	d9 33 08 40 	lea %a3,[%a3]264 <70000108 <__malloc_av_+0x8>>
8000afec:	7d 3c 83 00 	jeq.a %a12,%a3,8000b0f2 <_malloc_r+0x210>
8000aff0:	4c c1       	ld.w %d15,[%a12]4
8000aff2:	8f 3f c0 f1 	andn %d15,%d15,3
8000aff6:	52 83       	sub %d3,%d15,%d8
8000aff8:	8b 03 41 42 	lt %d4,%d3,16
8000affc:	df 04 16 80 	jne %d4,0,8000b028 <_malloc_r+0x146>
8000b000:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b004:	8f 18 40 81 	or %d8,%d8,1
8000b008:	59 c8 04 00 	st.w [%a12]4,%d8
8000b00c:	e8 52       	st.a [%a15]20,%a2
8000b00e:	e8 42       	st.a [%a15]16,%a2
8000b010:	8f 13 40 f1 	or %d15,%d3,1
8000b014:	b5 23 0c 00 	st.a [%a2]12,%a3
8000b018:	b5 23 08 00 	st.a [%a2]8,%a3
8000b01c:	6c 21       	st.w [%a2]4,%d15
8000b01e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000b022:	74 23       	st.w [%a2],%d3
8000b024:	1d 00 a5 01 	j 8000b36e <_malloc_r+0x48c>
8000b028:	e8 53       	st.a [%a15]20,%a3
8000b02a:	e8 43       	st.a [%a15]16,%a3
8000b02c:	0e 33       	jltz %d3,8000b032 <_malloc_r+0x150>
8000b02e:	10 cf       	addsc.a %a15,%a12,%d15,0
8000b030:	3c cf       	j 8000afce <_malloc_r+0xec>
8000b032:	3b 00 20 30 	mov %d3,512
8000b036:	7f 3f 15 80 	jge.u %d15,%d3,8000b060 <_malloc_r+0x17e>
8000b03a:	06 df       	sh %d15,-3
8000b03c:	d0 f2       	addsc.a %a2,%a15,%d15,3
8000b03e:	48 14       	ld.w %d4,[%a15]4
8000b040:	99 24 08 00 	ld.a %a4,[%a2]8
8000b044:	8f ef 3f 30 	sha %d3,%d15,-2
8000b048:	b5 c2 0c 00 	st.a [%a12]12,%a2
8000b04c:	b5 c4 08 00 	st.a [%a12]8,%a4
8000b050:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
8000b054:	b5 2c 08 00 	st.a [%a2]8,%a12
8000b058:	68 13       	st.w [%a15]4,%d3
8000b05a:	b5 4c 0c 00 	st.a [%a4]12,%a12
8000b05e:	3c 4a       	j 8000b0f2 <_malloc_r+0x210>
8000b060:	8f af 1f 40 	sh %d4,%d15,-6
8000b064:	8f 7f 1f 30 	sh %d3,%d15,-9
8000b068:	1b 84 03 40 	addi %d4,%d4,56
8000b06c:	bf 53 22 80 	jlt.u %d3,5,8000b0b0 <_malloc_r+0x1ce>
8000b070:	8b 53 a1 42 	ge.u %d4,%d3,21
8000b074:	f6 44       	jnz %d4,8000b07c <_malloc_r+0x19a>
8000b076:	1b b3 05 40 	addi %d4,%d3,91
8000b07a:	3c 1b       	j 8000b0b0 <_malloc_r+0x1ce>
8000b07c:	8b 53 a5 42 	ge.u %d4,%d3,85
8000b080:	f6 46       	jnz %d4,8000b08c <_malloc_r+0x1aa>
8000b082:	8f 4f 1f 40 	sh %d4,%d15,-12
8000b086:	1b e4 06 40 	addi %d4,%d4,110
8000b08a:	3c 13       	j 8000b0b0 <_malloc_r+0x1ce>
8000b08c:	8b 53 b5 42 	ge.u %d4,%d3,341
8000b090:	f6 46       	jnz %d4,8000b09c <_malloc_r+0x1ba>
8000b092:	8f 1f 1f 40 	sh %d4,%d15,-15
8000b096:	1b 74 07 40 	addi %d4,%d4,119
8000b09a:	3c 0b       	j 8000b0b0 <_malloc_r+0x1ce>
8000b09c:	3b 50 55 50 	mov %d5,1365
8000b0a0:	3b e0 07 40 	mov %d4,126
8000b0a4:	7f 53 06 80 	jge.u %d3,%d5,8000b0b0 <_malloc_r+0x1ce>
8000b0a8:	8f ef 1e 40 	sh %d4,%d15,-18
8000b0ac:	1b c4 07 40 	addi %d4,%d4,124
8000b0b0:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
8000b0b4:	99 42 08 00 	ld.a %a2,[%a4]8
8000b0b8:	7d 42 0d 80 	jne.a %a2,%a4,8000b0d2 <_malloc_r+0x1f0>
8000b0bc:	4c f1       	ld.w %d15,[%a15]4
8000b0be:	86 e4       	sha %d4,-2
8000b0c0:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
8000b0c4:	40 24       	mov.aa %a4,%a2
8000b0c6:	68 14       	st.w [%a15]4,%d4
8000b0c8:	3c 0d       	j 8000b0e2 <_malloc_r+0x200>
8000b0ca:	99 22 08 00 	ld.a %a2,[%a2]8
8000b0ce:	7d 42 08 00 	jeq.a %a2,%a4,8000b0de <_malloc_r+0x1fc>
8000b0d2:	19 23 04 00 	ld.w %d3,[%a2]4
8000b0d6:	8f 33 c0 31 	andn %d3,%d3,3
8000b0da:	3f 3f f8 ff 	jlt.u %d15,%d3,8000b0ca <_malloc_r+0x1e8>
8000b0de:	99 24 0c 00 	ld.a %a4,[%a2]12
8000b0e2:	b5 c4 0c 00 	st.a [%a12]12,%a4
8000b0e6:	b5 c2 08 00 	st.a [%a12]8,%a2
8000b0ea:	b5 4c 08 00 	st.a [%a4]8,%a12
8000b0ee:	b5 2c 0c 00 	st.a [%a2]12,%a12
8000b0f2:	8f e2 3f 30 	sha %d3,%d2,-2
8000b0f6:	82 1f       	mov %d15,1
8000b0f8:	0f 3f 00 f0 	sh %d15,%d15,%d3
8000b0fc:	48 13       	ld.w %d3,[%a15]4
8000b0fe:	3f f3 73 80 	jlt.u %d3,%d15,8000b1e4 <_malloc_r+0x302>
8000b102:	0f 3f 80 40 	and %d4,%d15,%d3
8000b106:	f6 49       	jnz %d4,8000b118 <_malloc_r+0x236>
8000b108:	8f 32 c0 21 	andn %d2,%d2,3
8000b10c:	06 1f       	sh %d15,1
8000b10e:	0f 3f 80 40 	and %d4,%d15,%d3
8000b112:	c2 42       	add %d2,4
8000b114:	df 04 fc 7f 	jeq %d4,0,8000b10c <_malloc_r+0x22a>
8000b118:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000b11c:	02 24       	mov %d4,%d2
8000b11e:	40 24       	mov.aa %a4,%a2
8000b120:	99 4c 0c 00 	ld.a %a12,[%a4]12
8000b124:	7d 4c 3c 00 	jeq.a %a12,%a4,8000b19c <_malloc_r+0x2ba>
8000b128:	19 c6 04 00 	ld.w %d6,[%a12]4
8000b12c:	8f 36 c0 61 	andn %d6,%d6,3
8000b130:	0b 86 80 30 	sub %d3,%d6,%d8
8000b134:	8b 03 41 52 	lt %d5,%d3,16
8000b138:	df 05 1d 80 	jne %d5,0,8000b172 <_malloc_r+0x290>
8000b13c:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b140:	8f 18 40 81 	or %d8,%d8,1
8000b144:	59 c8 04 00 	st.w [%a12]4,%d8
8000b148:	99 c4 0c 00 	ld.a %a4,[%a12]12
8000b14c:	09 c5 88 05 	ld.a %a5,[+%a12]8
8000b150:	8f 13 40 f1 	or %d15,%d3,1
8000b154:	b5 54 0c 00 	st.a [%a5]12,%a4
8000b158:	b5 45 08 00 	st.a [%a4]8,%a5
8000b15c:	e8 52       	st.a [%a15]20,%a2
8000b15e:	e8 42       	st.a [%a15]16,%a2
8000b160:	b5 23 0c 00 	st.a [%a2]12,%a3
8000b164:	b5 23 08 00 	st.a [%a2]8,%a3
8000b168:	6c 21       	st.w [%a2]4,%d15
8000b16a:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000b16e:	74 23       	st.w [%a2],%d3
8000b170:	3c 0e       	j 8000b18c <_malloc_r+0x2aa>
8000b172:	bf 03 12 00 	jlt %d3,0,8000b196 <_malloc_r+0x2b4>
8000b176:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
8000b17a:	b7 10 21 20 	imask %e2,1,0,1
8000b17e:	49 f2 44 08 	ldmst [%a15]4,%e2
8000b182:	cc c3       	ld.a %a15,[%a12]12
8000b184:	09 c2 88 05 	ld.a %a2,[+%a12]8
8000b188:	ec 23       	st.a [%a2]12,%a15
8000b18a:	e8 22       	st.a [%a15]8,%a2
8000b18c:	40 d4       	mov.aa %a4,%a13
8000b18e:	6d 00 f8 00 	call 8000b37e <__malloc_unlock>
8000b192:	1d 00 f3 00 	j 8000b378 <_malloc_r+0x496>
8000b196:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000b19a:	3c c5       	j 8000b124 <_malloc_r+0x242>
8000b19c:	c2 14       	add %d4,1
8000b19e:	8f 34 00 31 	and %d3,%d4,3
8000b1a2:	d9 44 08 00 	lea %a4,[%a4]8
8000b1a6:	df 03 bd ff 	jne %d3,0,8000b120 <_malloc_r+0x23e>
8000b1aa:	8f 32 00 31 	and %d3,%d2,3
8000b1ae:	f6 36       	jnz %d3,8000b1ba <_malloc_r+0x2d8>
8000b1b0:	48 12       	ld.w %d2,[%a15]4
8000b1b2:	0f f2 e0 20 	andn %d2,%d2,%d15
8000b1b6:	68 12       	st.w [%a15]4,%d2
8000b1b8:	3c 07       	j 8000b1c6 <_malloc_r+0x2e4>
8000b1ba:	d9 24 f8 ff 	lea %a4,[%a2]-8
8000b1be:	d4 22       	ld.a %a2,[%a2]
8000b1c0:	c2 f2       	add %d2,-1
8000b1c2:	7d 42 f4 7f 	jeq.a %a2,%a4,8000b1aa <_malloc_r+0x2c8>
8000b1c6:	06 1f       	sh %d15,1
8000b1c8:	48 12       	ld.w %d2,[%a15]4
8000b1ca:	8b 0f 20 32 	ne %d3,%d15,0
8000b1ce:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
8000b1d2:	76 39       	jz %d3,8000b1e4 <_malloc_r+0x302>
8000b1d4:	0f 2f 80 30 	and %d3,%d15,%d2
8000b1d8:	f6 34       	jnz %d3,8000b1e0 <_malloc_r+0x2fe>
8000b1da:	c2 44       	add %d4,4
8000b1dc:	06 1f       	sh %d15,1
8000b1de:	3c fb       	j 8000b1d4 <_malloc_r+0x2f2>
8000b1e0:	02 42       	mov %d2,%d4
8000b1e2:	3c 9b       	j 8000b118 <_malloc_r+0x236>
8000b1e4:	c8 2c       	ld.a %a12,[%a15]8
8000b1e6:	19 ca 04 00 	ld.w %d10,[%a12]4
8000b1ea:	8f 3a c0 a1 	andn %d10,%d10,3
8000b1ee:	5a 8a       	sub %d15,%d10,%d8
8000b1f0:	8b 0f 41 22 	lt %d2,%d15,16
8000b1f4:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
8000b1f8:	df 02 b1 00 	jeq %d2,0,8000b35a <_malloc_r+0x478>
8000b1fc:	91 00 00 27 	movh.a %a2,28672
8000b200:	19 2b c0 20 	ld.w %d11,[%a2]3200 <70000c80 <__malloc_top_pad>>
8000b204:	91 00 00 27 	movh.a %a2,28672
8000b208:	42 8b       	add %d11,%d8
8000b20a:	19 23 38 30 	ld.w %d3,[%a2]248 <700000f8 <__malloc_sbrk_base>>
8000b20e:	1b fb 00 f1 	addi %d15,%d11,4111
8000b212:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000b216:	1b 0b 01 20 	addi %d2,%d11,16
8000b21a:	8b f3 3f b2 	ne %d11,%d3,-1
8000b21e:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
8000b222:	40 d4       	mov.aa %a4,%a13
8000b224:	02 b4       	mov %d4,%d11
8000b226:	80 2c       	mov.d %d12,%a2
8000b228:	6d 00 ac 00 	call 8000b380 <_sbrk_r>
8000b22c:	80 29       	mov.d %d9,%a2
8000b22e:	df f9 86 00 	jeq %d9,-1,8000b33a <_malloc_r+0x458>
8000b232:	80 c2       	mov.d %d2,%a12
8000b234:	80 c3       	mov.d %d3,%a12
8000b236:	42 a2       	add %d2,%d10
8000b238:	80 f4       	mov.d %d4,%a15
8000b23a:	0b 29 30 f1 	lt.u %d15,%d9,%d2
8000b23e:	0b 43 10 f2 	and.ne %d15,%d3,%d4
8000b242:	01 fc 10 d4 	ne.a %d13,%a12,%a15
8000b246:	ee 7a       	jnz %d15,8000b33a <_malloc_r+0x458>
8000b248:	91 00 00 e7 	movh.a %a14,28672
8000b24c:	19 e3 d0 10 	ld.w %d3,[%a14]3152 <70000c50 <__malloc_current_mallinfo>>
8000b250:	42 b3       	add %d3,%d11
8000b252:	59 e3 d0 10 	st.w [%a14]3152 <70000c50 <__malloc_current_mallinfo>>,%d3
8000b256:	5f 29 0c 80 	jne %d9,%d2,8000b26e <_malloc_r+0x38c>
8000b25a:	b7 09 14 f6 	insert %d15,%d9,0,12,20
8000b25e:	ee 08       	jnz %d15,8000b26e <_malloc_r+0x38c>
8000b260:	c8 22       	ld.a %a2,[%a15]8
8000b262:	42 ba       	add %d10,%d11
8000b264:	8f 1a 40 a1 	or %d10,%d10,1
8000b268:	59 2a 04 00 	st.w [%a2]4,%d10
8000b26c:	3c 55       	j 8000b316 <_malloc_r+0x434>
8000b26e:	60 c2       	mov.a %a2,%d12
8000b270:	19 2f 38 30 	ld.w %d15,[%a2]248
8000b274:	5e f6       	jne %d15,-1,8000b280 <_malloc_r+0x39e>
8000b276:	91 00 00 27 	movh.a %a2,28672
8000b27a:	59 29 38 30 	st.w [%a2]248 <700000f8 <__malloc_sbrk_base>>,%d9
8000b27e:	3c 06       	j 8000b28a <_malloc_r+0x3a8>
8000b280:	0b 29 80 20 	sub %d2,%d9,%d2
8000b284:	42 23       	add %d3,%d2
8000b286:	59 e3 d0 10 	st.w [%a14]3152 <70000c50 <__malloc_current_mallinfo>>,%d3
8000b28a:	8f 79 00 21 	and %d2,%d9,7
8000b28e:	82 0f       	mov %d15,0
8000b290:	76 24       	jz %d2,8000b298 <_malloc_r+0x3b6>
8000b292:	8b 82 00 f1 	rsub %d15,%d2,8
8000b296:	42 f9       	add %d9,%d15
8000b298:	42 9b       	add %d11,%d9
8000b29a:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
8000b29e:	1b 0f 00 21 	addi %d2,%d15,4096
8000b2a2:	5a b2       	sub %d15,%d2,%d11
8000b2a4:	40 d4       	mov.aa %a4,%a13
8000b2a6:	02 f4       	mov %d4,%d15
8000b2a8:	6d 00 6c 00 	call 8000b380 <_sbrk_r>
8000b2ac:	80 22       	mov.d %d2,%a2
8000b2ae:	df f2 04 80 	jne %d2,-1,8000b2b6 <_malloc_r+0x3d4>
8000b2b2:	60 92       	mov.a %a2,%d9
8000b2b4:	82 0f       	mov %d15,0
8000b2b6:	80 2b       	mov.d %d11,%a2
8000b2b8:	19 e2 d0 10 	ld.w %d2,[%a14]3152 <70000c50 <__malloc_current_mallinfo>>
8000b2bc:	a2 9b       	sub %d11,%d9
8000b2be:	42 f2       	add %d2,%d15
8000b2c0:	60 92       	mov.a %a2,%d9
8000b2c2:	42 bf       	add %d15,%d11
8000b2c4:	68 29       	st.w [%a15]8,%d9
8000b2c6:	8f 1f 40 31 	or %d3,%d15,1
8000b2ca:	59 e2 d0 10 	st.w [%a14]3152 <70000c50 <__malloc_current_mallinfo>>,%d2
8000b2ce:	59 23 04 00 	st.w [%a2]4 <70000c50 <__malloc_current_mallinfo>>,%d3
8000b2d2:	df 0d 22 00 	jeq %d13,0,8000b316 <_malloc_r+0x434>
8000b2d6:	8b 0a a1 f2 	ge.u %d15,%d10,16
8000b2da:	ee 05       	jnz %d15,8000b2e4 <_malloc_r+0x402>
8000b2dc:	82 12       	mov %d2,1
8000b2de:	59 22 04 00 	st.w [%a2]4,%d2
8000b2e2:	3c 2c       	j 8000b33a <_malloc_r+0x458>
8000b2e4:	1b 4a ff af 	addi %d10,%d10,-12
8000b2e8:	8f 7a c0 f1 	andn %d15,%d10,7
8000b2ec:	10 c2       	addsc.a %a2,%a12,%d15,0
8000b2ee:	82 52       	mov %d2,5
8000b2f0:	59 22 04 00 	st.w [%a2]4,%d2
8000b2f4:	59 22 08 00 	st.w [%a2]8,%d2
8000b2f8:	19 c2 04 00 	ld.w %d2,[%a12]4
8000b2fc:	8f 12 00 21 	and %d2,%d2,1
8000b300:	a6 f2       	or %d2,%d15
8000b302:	59 c2 04 00 	st.w [%a12]4,%d2
8000b306:	8b 0f 61 f2 	lt.u %d15,%d15,16
8000b30a:	ee 06       	jnz %d15,8000b316 <_malloc_r+0x434>
8000b30c:	40 d4       	mov.aa %a4,%a13
8000b30e:	d9 c5 08 00 	lea %a5,[%a12]8
8000b312:	6d 00 dd 00 	call 8000b4cc <_free_r>
8000b316:	91 00 00 27 	movh.a %a2,28672
8000b31a:	19 ef d0 10 	ld.w %d15,[%a14]3152 <70000c50 <__malloc_current_mallinfo>>
8000b31e:	19 22 fc 10 	ld.w %d2,[%a2]3196 <70000c7c <__malloc_max_sbrked_mem>>
8000b322:	7f f2 04 80 	jge.u %d2,%d15,8000b32a <_malloc_r+0x448>
8000b326:	59 2f fc 10 	st.w [%a2]3196 <70000c7c <__malloc_max_sbrked_mem>>,%d15
8000b32a:	91 00 00 27 	movh.a %a2,28672
8000b32e:	19 22 f8 10 	ld.w %d2,[%a2]3192 <70000c78 <__malloc_max_total_mem>>
8000b332:	7f f2 04 80 	jge.u %d2,%d15,8000b33a <_malloc_r+0x458>
8000b336:	59 2f f8 10 	st.w [%a2]3192 <70000c78 <__malloc_max_total_mem>>,%d15
8000b33a:	c8 22       	ld.a %a2,[%a15]8
8000b33c:	19 22 04 00 	ld.w %d2,[%a2]4 <70000c78 <__malloc_max_total_mem>>
8000b340:	8f 32 c0 21 	andn %d2,%d2,3
8000b344:	5a 82       	sub %d15,%d2,%d8
8000b346:	8b 0f 41 32 	lt %d3,%d15,16
8000b34a:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
8000b34e:	76 36       	jz %d3,8000b35a <_malloc_r+0x478>
8000b350:	40 d4       	mov.aa %a4,%a13
8000b352:	6d 00 16 00 	call 8000b37e <__malloc_unlock>
8000b356:	a0 0c       	mov.a %a12,0
8000b358:	3c 10       	j 8000b378 <_malloc_r+0x496>
8000b35a:	c8 2c       	ld.a %a12,[%a15]8
8000b35c:	8f 18 40 21 	or %d2,%d8,1
8000b360:	96 01       	or %d15,1
8000b362:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b366:	59 c2 04 00 	st.w [%a12]4,%d2
8000b36a:	e8 22       	st.a [%a15]8,%a2
8000b36c:	6c 21       	st.w [%a2]4,%d15
8000b36e:	40 d4       	mov.aa %a4,%a13
8000b370:	6d 00 07 00 	call 8000b37e <__malloc_unlock>
8000b374:	d9 cc 08 00 	lea %a12,[%a12]8
8000b378:	40 c2       	mov.aa %a2,%a12
8000b37a:	00 90       	ret 

8000b37c <__malloc_lock>:
8000b37c:	00 90       	ret 

8000b37e <__malloc_unlock>:
8000b37e:	00 90       	ret 

8000b380 <_sbrk_r>:
8000b380:	82 0f       	mov %d15,0
8000b382:	91 00 00 c7 	movh.a %a12,28672
8000b386:	59 cf c8 20 	st.w [%a12]3208 <70000c88 <errno>>,%d15
8000b38a:	40 4f       	mov.aa %a15,%a4
8000b38c:	6d 00 2c 17 	call 8000e1e4 <sbrk>
8000b390:	80 2f       	mov.d %d15,%a2
8000b392:	5e f5       	jne %d15,-1,8000b39c <_sbrk_r+0x1c>
8000b394:	19 cf c8 20 	ld.w %d15,[%a12]3208 <70000c88 <errno>>
8000b398:	6e 02       	jz %d15,8000b39c <_sbrk_r+0x1c>
8000b39a:	68 0f       	st.w [%a15]0,%d15
8000b39c:	00 90       	ret 

8000b39e <strlen>:
8000b39e:	80 42       	mov.d %d2,%a4
8000b3a0:	80 4f       	mov.d %d15,%a4
8000b3a2:	60 ff       	mov.a %a15,%d15
8000b3a4:	79 f3 00 00 	ld.b %d3,[%a15]0
8000b3a8:	76 33       	jz %d3,8000b3ae <strlen+0x10>
8000b3aa:	c2 1f       	add %d15,1
8000b3ac:	3c fb       	j 8000b3a2 <strlen+0x4>
8000b3ae:	52 22       	sub %d2,%d15,%d2
8000b3b0:	00 90       	ret 

8000b3b2 <_vsnprintf_r>:
8000b3b2:	20 68       	sub.a %sp,104
8000b3b4:	40 4f       	mov.aa %a15,%a4
8000b3b6:	ce 45       	jgez %d4,8000b3c0 <_vsnprintf_r+0xe>
8000b3b8:	da 8b       	mov %d15,139
8000b3ba:	6c 40       	st.w [%a4]0,%d15
8000b3bc:	82 f2       	mov %d2,-1
8000b3be:	00 90       	ret 
8000b3c0:	02 4f       	mov %d15,%d4
8000b3c2:	3b 80 20 20 	mov %d2,520
8000b3c6:	f9 a2 0c 00 	st.h [%sp]12,%d2
8000b3ca:	92 f2       	add %d2,%d15,-1
8000b3cc:	ea 02       	cmovn %d2,%d15,0
8000b3ce:	f4 a5       	st.a [%sp],%a5
8000b3d0:	b5 a5 10 00 	st.a [%sp]16,%a5
8000b3d4:	59 a2 08 00 	st.w [%sp]8,%d2
8000b3d8:	59 a2 14 00 	st.w [%sp]20,%d2
8000b3dc:	40 a5       	mov.aa %a5,%sp
8000b3de:	82 f2       	mov %d2,-1
8000b3e0:	f9 a2 0e 00 	st.h [%sp]14,%d2
8000b3e4:	6d 00 4a 01 	call 8000b678 <_svfprintf_r>
8000b3e8:	ff f2 05 00 	jge %d2,-1,8000b3f2 <_vsnprintf_r+0x40>
8000b3ec:	3b b0 08 30 	mov %d3,139
8000b3f0:	68 03       	st.w [%a15]0,%d3
8000b3f2:	6e 04       	jz %d15,8000b3fa <_vsnprintf_r+0x48>
8000b3f4:	d8 00       	ld.a %a15,[%sp]0
8000b3f6:	82 0f       	mov %d15,0
8000b3f8:	28 0f       	st.b [%a15]0,%d15
8000b3fa:	00 90       	ret 

8000b3fc <vsnprintf>:
8000b3fc:	91 00 00 37 	movh.a %a3,28672
8000b400:	40 42       	mov.aa %a2,%a4
8000b402:	99 34 48 40 	ld.a %a4,[%a3]1288 <70000508 <_impure_ptr>>
8000b406:	40 5f       	mov.aa %a15,%a5
8000b408:	40 67       	mov.aa %a7,%a6
8000b40a:	40 25       	mov.aa %a5,%a2
8000b40c:	40 f6       	mov.aa %a6,%a15
8000b40e:	1d ff d2 ff 	j 8000b3b2 <_vsnprintf_r>

8000b412 <_malloc_trim_r>:
8000b412:	02 4f       	mov %d15,%d4
8000b414:	40 4f       	mov.aa %a15,%a4
8000b416:	6d ff b3 ff 	call 8000b37c <__malloc_lock>
8000b41a:	91 00 00 c7 	movh.a %a12,28672
8000b41e:	d9 cc 00 40 	lea %a12,[%a12]256 <70000100 <__malloc_av_>>
8000b422:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <g_vadcChannelIDs>>
8000b426:	3b 00 00 21 	mov %d2,4096
8000b42a:	19 28 04 00 	ld.w %d8,[%a2]4
8000b42e:	8f 38 c0 81 	andn %d8,%d8,3
8000b432:	5a f8       	sub %d15,%d8,%d15
8000b434:	1b ff fe f0 	addi %d15,%d15,4079
8000b438:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000b43c:	1b 0f 00 ff 	addi %d15,%d15,-4096
8000b440:	7f 2f 07 00 	jge %d15,%d2,8000b44e <_malloc_trim_r+0x3c>
8000b444:	40 f4       	mov.aa %a4,%a15
8000b446:	6d ff 9c ff 	call 8000b37e <__malloc_unlock>
8000b44a:	82 02       	mov %d2,0
8000b44c:	00 90       	ret 
8000b44e:	40 f4       	mov.aa %a4,%a15
8000b450:	82 04       	mov %d4,0
8000b452:	6d ff 97 ff 	call 8000b380 <_sbrk_r>
8000b456:	99 c3 08 00 	ld.a %a3,[%a12]8
8000b45a:	60 84       	mov.a %a4,%d8
8000b45c:	30 43       	add.a %a3,%a4
8000b45e:	7d 32 f3 ff 	jne.a %a2,%a3,8000b444 <_malloc_trim_r+0x32>
8000b462:	40 f4       	mov.aa %a4,%a15
8000b464:	8b 0f 00 41 	rsub %d4,%d15,0
8000b468:	6d ff 8c ff 	call 8000b380 <_sbrk_r>
8000b46c:	80 22       	mov.d %d2,%a2
8000b46e:	df f2 1c 80 	jne %d2,-1,8000b4a6 <_malloc_trim_r+0x94>
8000b472:	40 f4       	mov.aa %a4,%a15
8000b474:	82 04       	mov %d4,0
8000b476:	6d ff 85 ff 	call 8000b380 <_sbrk_r>
8000b47a:	99 c3 08 00 	ld.a %a3,[%a12]8
8000b47e:	01 32 20 40 	sub.a %a4,%a2,%a3
8000b482:	80 4f       	mov.d %d15,%a4
8000b484:	8b 0f 41 22 	lt %d2,%d15,16
8000b488:	df 02 de ff 	jne %d2,0,8000b444 <_malloc_trim_r+0x32>
8000b48c:	91 00 00 47 	movh.a %a4,28672
8000b490:	99 44 38 30 	ld.a %a4,[%a4]248 <700000f8 <__malloc_sbrk_base>>
8000b494:	96 01       	or %d15,1
8000b496:	6c 31       	st.w [%a3]4,%d15
8000b498:	01 42 20 20 	sub.a %a2,%a2,%a4
8000b49c:	91 00 00 47 	movh.a %a4,28672
8000b4a0:	b5 42 d0 10 	st.a [%a4]3152 <70000c50 <__malloc_current_mallinfo>>,%a2
8000b4a4:	3c d0       	j 8000b444 <_malloc_trim_r+0x32>
8000b4a6:	99 c2 08 00 	ld.a %a2,[%a12]8
8000b4aa:	a2 f8       	sub %d8,%d15
8000b4ac:	8f 18 40 81 	or %d8,%d8,1
8000b4b0:	59 28 04 00 	st.w [%a2]4,%d8
8000b4b4:	91 00 00 27 	movh.a %a2,28672
8000b4b8:	19 22 d0 10 	ld.w %d2,[%a2]3152 <70000c50 <__malloc_current_mallinfo>>
8000b4bc:	40 f4       	mov.aa %a4,%a15
8000b4be:	5a f2       	sub %d15,%d2,%d15
8000b4c0:	59 2f d0 10 	st.w [%a2]3152 <70000c50 <__malloc_current_mallinfo>>,%d15
8000b4c4:	6d ff 5d ff 	call 8000b37e <__malloc_unlock>
8000b4c8:	82 12       	mov %d2,1
8000b4ca:	00 90       	ret 

8000b4cc <_free_r>:
8000b4cc:	40 4d       	mov.aa %a13,%a4
8000b4ce:	bd 05 d4 00 	jz.a %a5,8000b676 <_free_r+0x1aa>
8000b4d2:	40 5c       	mov.aa %a12,%a5
8000b4d4:	6d ff 54 ff 	call 8000b37c <__malloc_lock>
8000b4d8:	19 c4 fc ff 	ld.w %d4,[%a12]-4
8000b4dc:	d9 cf f8 ff 	lea %a15,[%a12]-8
8000b4e0:	8f 14 c0 f1 	andn %d15,%d4,1
8000b4e4:	91 00 00 27 	movh.a %a2,28672
8000b4e8:	10 f3       	addsc.a %a3,%a15,%d15,0
8000b4ea:	d9 22 00 40 	lea %a2,[%a2]256 <70000100 <__malloc_av_>>
8000b4ee:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <g_vadcChannelIDs>>
8000b4f2:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <g_vadcChannelIDs>>
8000b4f6:	8f 14 00 41 	and %d4,%d4,1
8000b4fa:	8f 33 c0 31 	andn %d3,%d3,3
8000b4fe:	7d 43 24 80 	jne.a %a3,%a4,8000b546 <_free_r+0x7a>
8000b502:	42 3f       	add %d15,%d3
8000b504:	f6 4d       	jnz %d4,8000b51e <_free_r+0x52>
8000b506:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000b50a:	60 23       	mov.a %a3,%d2
8000b50c:	42 2f       	add %d15,%d2
8000b50e:	01 3f 20 f0 	sub.a %a15,%a15,%a3
8000b512:	c8 33       	ld.a %a3,[%a15]12
8000b514:	c8 24       	ld.a %a4,[%a15]8
8000b516:	b5 43 0c 00 	st.a [%a4]12,%a3
8000b51a:	b5 34 08 00 	st.a [%a3]8,%a4
8000b51e:	8f 1f 40 21 	or %d2,%d15,1
8000b522:	68 12       	st.w [%a15]4,%d2
8000b524:	ec 22       	st.a [%a2]8,%a15
8000b526:	91 00 00 f7 	movh.a %a15,28672
8000b52a:	19 f2 3c 30 	ld.w %d2,[%a15]252 <700000fc <__malloc_trim_threshold>>
8000b52e:	3f 2f 09 80 	jlt.u %d15,%d2,8000b540 <_free_r+0x74>
8000b532:	91 00 00 f7 	movh.a %a15,28672
8000b536:	40 d4       	mov.aa %a4,%a13
8000b538:	19 f4 c0 20 	ld.w %d4,[%a15]3200 <70000c80 <__malloc_top_pad>>
8000b53c:	6d ff 6b ff 	call 8000b412 <_malloc_trim_r>
8000b540:	40 d4       	mov.aa %a4,%a13
8000b542:	1d ff 1e ff 	j 8000b37e <__malloc_unlock>
8000b546:	59 33 04 00 	st.w [%a3]4,%d3
8000b54a:	82 02       	mov %d2,0
8000b54c:	df 04 16 80 	jne %d4,0,8000b578 <_free_r+0xac>
8000b550:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000b554:	60 24       	mov.a %a4,%d2
8000b556:	42 2f       	add %d15,%d2
8000b558:	01 4f 20 f0 	sub.a %a15,%a15,%a4
8000b55c:	c8 25       	ld.a %a5,[%a15]8
8000b55e:	91 00 00 47 	movh.a %a4,28672
8000b562:	d9 44 08 40 	lea %a4,[%a4]264 <70000108 <__malloc_av_+0x8>>
8000b566:	82 12       	mov %d2,1
8000b568:	7d 45 08 00 	jeq.a %a5,%a4,8000b578 <_free_r+0xac>
8000b56c:	c8 34       	ld.a %a4,[%a15]12
8000b56e:	82 02       	mov %d2,0
8000b570:	b5 54 0c 00 	st.a [%a5]12,%a4
8000b574:	b5 45 08 00 	st.a [%a4]8,%a5
8000b578:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
8000b57c:	19 44 04 00 	ld.w %d4,[%a4]4
8000b580:	6f 04 18 80 	jnz.t %d4,0,8000b5b0 <_free_r+0xe4>
8000b584:	42 3f       	add %d15,%d3
8000b586:	99 35 08 00 	ld.a %a5,[%a3]8
8000b58a:	f6 2d       	jnz %d2,8000b5a4 <_free_r+0xd8>
8000b58c:	91 00 00 47 	movh.a %a4,28672
8000b590:	d9 44 08 40 	lea %a4,[%a4]264 <70000108 <__malloc_av_+0x8>>
8000b594:	7d 45 08 80 	jne.a %a5,%a4,8000b5a4 <_free_r+0xd8>
8000b598:	ec 25       	st.a [%a2]20,%a15
8000b59a:	ec 24       	st.a [%a2]16,%a15
8000b59c:	e8 35       	st.a [%a15]12,%a5
8000b59e:	e8 25       	st.a [%a15]8,%a5
8000b5a0:	82 12       	mov %d2,1
8000b5a2:	3c 07       	j 8000b5b0 <_free_r+0xe4>
8000b5a4:	99 33 0c 00 	ld.a %a3,[%a3]12
8000b5a8:	b5 53 0c 00 	st.a [%a5]12,%a3
8000b5ac:	b5 35 08 00 	st.a [%a3]8,%a5
8000b5b0:	8f 1f 40 31 	or %d3,%d15,1
8000b5b4:	10 f3       	addsc.a %a3,%a15,%d15,0
8000b5b6:	68 13       	st.w [%a15]4,%d3
8000b5b8:	6c 30       	st.w [%a3]0,%d15
8000b5ba:	df 02 c3 ff 	jne %d2,0,8000b540 <_free_r+0x74>
8000b5be:	3b 00 20 20 	mov %d2,512
8000b5c2:	7f 2f 12 80 	jge.u %d15,%d2,8000b5e6 <_free_r+0x11a>
8000b5c6:	19 23 04 00 	ld.w %d3,[%a2]4
8000b5ca:	06 df       	sh %d15,-3
8000b5cc:	8f ef 3f 20 	sha %d2,%d15,-2
8000b5d0:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
8000b5d4:	59 22 04 00 	st.w [%a2]4,%d2
8000b5d8:	d0 22       	addsc.a %a2,%a2,%d15,3
8000b5da:	99 23 08 00 	ld.a %a3,[%a2]8
8000b5de:	e8 32       	st.a [%a15]12,%a2
8000b5e0:	e8 23       	st.a [%a15]8,%a3
8000b5e2:	ec 22       	st.a [%a2]8,%a15
8000b5e4:	3c 46       	j 8000b670 <_free_r+0x1a4>
8000b5e6:	8f af 1f 30 	sh %d3,%d15,-6
8000b5ea:	8f 7f 1f 20 	sh %d2,%d15,-9
8000b5ee:	1b 83 03 30 	addi %d3,%d3,56
8000b5f2:	bf 52 22 80 	jlt.u %d2,5,8000b636 <_free_r+0x16a>
8000b5f6:	8b 52 a1 32 	ge.u %d3,%d2,21
8000b5fa:	f6 34       	jnz %d3,8000b602 <_free_r+0x136>
8000b5fc:	1b b2 05 30 	addi %d3,%d2,91
8000b600:	3c 1b       	j 8000b636 <_free_r+0x16a>
8000b602:	8b 52 a5 32 	ge.u %d3,%d2,85
8000b606:	f6 36       	jnz %d3,8000b612 <_free_r+0x146>
8000b608:	8f 4f 1f 30 	sh %d3,%d15,-12
8000b60c:	1b e3 06 30 	addi %d3,%d3,110
8000b610:	3c 13       	j 8000b636 <_free_r+0x16a>
8000b612:	8b 52 b5 32 	ge.u %d3,%d2,341
8000b616:	f6 36       	jnz %d3,8000b622 <_free_r+0x156>
8000b618:	8f 1f 1f 30 	sh %d3,%d15,-15
8000b61c:	1b 73 07 30 	addi %d3,%d3,119
8000b620:	3c 0b       	j 8000b636 <_free_r+0x16a>
8000b622:	3b 50 55 40 	mov %d4,1365
8000b626:	3b e0 07 30 	mov %d3,126
8000b62a:	7f 42 06 80 	jge.u %d2,%d4,8000b636 <_free_r+0x16a>
8000b62e:	8f ef 1e 30 	sh %d3,%d15,-18
8000b632:	1b c3 07 30 	addi %d3,%d3,124
8000b636:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
8000b63a:	99 65 08 00 	ld.a %a5,[%a6]8
8000b63e:	40 53       	mov.aa %a3,%a5
8000b640:	7d 65 0d 80 	jne.a %a5,%a6,8000b65a <_free_r+0x18e>
8000b644:	4c 21       	ld.w %d15,[%a2]4
8000b646:	86 e3       	sha %d3,-2
8000b648:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
8000b64c:	59 23 04 00 	st.w [%a2]4,%d3
8000b650:	3c 0d       	j 8000b66a <_free_r+0x19e>
8000b652:	99 33 08 00 	ld.a %a3,[%a3]8
8000b656:	7d 63 08 00 	jeq.a %a3,%a6,8000b666 <_free_r+0x19a>
8000b65a:	19 32 04 00 	ld.w %d2,[%a3]4
8000b65e:	8f 32 c0 21 	andn %d2,%d2,3
8000b662:	3f 2f f8 ff 	jlt.u %d15,%d2,8000b652 <_free_r+0x186>
8000b666:	99 35 0c 00 	ld.a %a5,[%a3]12
8000b66a:	e8 35       	st.a [%a15]12,%a5
8000b66c:	e8 23       	st.a [%a15]8,%a3
8000b66e:	ec 52       	st.a [%a5]8,%a15
8000b670:	ec 33       	st.a [%a3]12,%a15
8000b672:	1d ff 67 ff 	j 8000b540 <_free_r+0x74>
8000b676:	00 90       	ret 

8000b678 <_svfprintf_r>:
8000b678:	20 d0       	sub.a %sp,208
8000b67a:	80 5b       	mov.d %d11,%a5
8000b67c:	80 4c       	mov.d %d12,%a4
8000b67e:	b5 a6 18 00 	st.a [%sp]24,%a6
8000b682:	40 7f       	mov.aa %a15,%a7
8000b684:	6d 00 c4 0f 	call 8000d60c <_localeconv_r>
8000b688:	d4 22       	ld.a %a2,[%a2]
8000b68a:	40 24       	mov.aa %a4,%a2
8000b68c:	b5 a2 34 00 	st.a [%sp]52,%a2
8000b690:	6d ff 87 fe 	call 8000b39e <strlen>
8000b694:	60 b2       	mov.a %a2,%d11
8000b696:	59 a2 20 00 	st.w [%sp]32,%d2
8000b69a:	8c 26       	ld.h %d15,[%a2]12
8000b69c:	6f 7f 16 00 	jz.t %d15,7,8000b6c8 <_svfprintf_r+0x50>
8000b6a0:	4c 24       	ld.w %d15,[%a2]16
8000b6a2:	ee 13       	jnz %d15,8000b6c8 <_svfprintf_r+0x50>
8000b6a4:	60 c4       	mov.a %a4,%d12
8000b6a6:	3b 00 04 40 	mov %d4,64
8000b6aa:	6d ff 1c fc 	call 8000aee2 <_malloc_r>
8000b6ae:	60 b3       	mov.a %a3,%d11
8000b6b0:	f4 32       	st.a [%a3],%a2
8000b6b2:	b5 32 10 00 	st.a [%a3]16,%a2
8000b6b6:	7c 26       	jnz.a %a2,8000b6c2 <_svfprintf_r+0x4a>
8000b6b8:	60 cf       	mov.a %a15,%d12
8000b6ba:	da 0c       	mov %d15,12
8000b6bc:	68 0f       	st.w [%a15]0,%d15
8000b6be:	82 f2       	mov %d2,-1
8000b6c0:	00 90       	ret 
8000b6c2:	60 b2       	mov.a %a2,%d11
8000b6c4:	da 40       	mov %d15,64
8000b6c6:	6c 25       	st.w [%a2]20,%d15
8000b6c8:	82 0f       	mov %d15,0
8000b6ca:	d9 a2 10 20 	lea %a2,[%sp]144
8000b6ce:	a0 03       	mov.a %a3,0
8000b6d0:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000b6d4:	78 19       	st.w [%sp]100,%d15
8000b6d6:	78 18       	st.w [%sp]96,%d15
8000b6d8:	78 05       	st.w [%sp]20,%d15
8000b6da:	78 0b       	st.w [%sp]44,%d15
8000b6dc:	78 0c       	st.w [%sp]48,%d15
8000b6de:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000b6e2:	78 0e       	st.w [%sp]56,%d15
8000b6e4:	78 0a       	st.w [%sp]40,%d15
8000b6e6:	40 2e       	mov.aa %a14,%a2
8000b6e8:	99 ac 18 00 	ld.a %a12,[%sp]24
8000b6ec:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b6f0:	8b 0f 20 32 	ne %d3,%d15,0
8000b6f4:	8b 5f 22 34 	and.ne %d3,%d15,37
8000b6f8:	76 33       	jz %d3,8000b6fe <_svfprintf_r+0x86>
8000b6fa:	b0 1c       	add.a %a12,1
8000b6fc:	3c f8       	j 8000b6ec <_svfprintf_r+0x74>
8000b6fe:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b702:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000b706:	80 3f       	mov.d %d15,%a3
8000b708:	6e 23       	jz %d15,8000b74e <_svfprintf_r+0xd6>
8000b70a:	19 a3 24 10 	ld.w %d3,[%sp]100
8000b70e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b712:	42 f3       	add %d3,%d15
8000b714:	59 a3 24 10 	st.w [%sp]100,%d3
8000b718:	19 a3 20 10 	ld.w %d3,[%sp]96
8000b71c:	f4 e3       	st.a [%a14],%a3
8000b71e:	c2 13       	add %d3,1
8000b720:	6c e1       	st.w [%a14]4,%d15
8000b722:	59 a3 20 10 	st.w [%sp]96,%d3
8000b726:	8b 83 80 32 	ge %d3,%d3,8
8000b72a:	d9 ee 08 00 	lea %a14,[%a14]8
8000b72e:	76 3b       	jz %d3,8000b744 <_svfprintf_r+0xcc>
8000b730:	60 c4       	mov.a %a4,%d12
8000b732:	60 b5       	mov.a %a5,%d11
8000b734:	d9 a6 1c 10 	lea %a6,[%sp]92
8000b738:	6d 00 7d 12 	call 8000dc32 <__ssprint_r>
8000b73c:	df 02 69 88 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000b740:	d9 ae 10 20 	lea %a14,[%sp]144
8000b744:	19 a2 28 00 	ld.w %d2,[%sp]40
8000b748:	42 f2       	add %d2,%d15
8000b74a:	59 a2 28 00 	st.w [%sp]40,%d2
8000b74e:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b752:	df 0f 56 08 	jeq %d15,0,8000c7fe <_svfprintf_r+0x1186>
8000b756:	82 0f       	mov %d15,0
8000b758:	82 02       	mov %d2,0
8000b75a:	e9 af 01 10 	st.b [%sp]65,%d15
8000b75e:	d9 c2 01 00 	lea %a2,[%a12]1
8000b762:	82 0f       	mov %d15,0
8000b764:	82 fe       	mov %d14,-1
8000b766:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b76a:	82 0a       	mov %d10,0
8000b76c:	79 22 00 00 	ld.b %d2,[%a2]0
8000b770:	d9 23 01 00 	lea %a3,[%a2]1
8000b774:	b5 a3 18 00 	st.a [%sp]24,%a3
8000b778:	59 a2 10 00 	st.w [%sp]16,%d2
8000b77c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b780:	1b 02 fe 3f 	addi %d3,%d2,-32
8000b784:	8b 93 a5 42 	ge.u %d4,%d3,89
8000b788:	df 04 19 84 	jne %d4,0,8000bfba <_svfprintf_r+0x942>
8000b78c:	91 10 00 28 	movh.a %a2,32769
8000b790:	d9 22 5c eb 	lea %a2,[%a2]-18532 <8000b79c <_svfprintf_r+0x124>>
8000b794:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000b798:	dc 07       	ji %a7
8000b79a:	00 00       	nop 
8000b79c:	1d 00 c3 00 	j 8000b922 <_svfprintf_r+0x2aa>
8000b7a0:	1d 00 0d 04 	j 8000bfba <_svfprintf_r+0x942>
8000b7a4:	1d 00 0b 04 	j 8000bfba <_svfprintf_r+0x942>
8000b7a8:	1d 00 c0 00 	j 8000b928 <_svfprintf_r+0x2b0>
8000b7ac:	1d 00 07 04 	j 8000bfba <_svfprintf_r+0x942>
8000b7b0:	1d 00 05 04 	j 8000bfba <_svfprintf_r+0x942>
8000b7b4:	1d 00 03 04 	j 8000bfba <_svfprintf_r+0x942>
8000b7b8:	1d 00 01 04 	j 8000bfba <_svfprintf_r+0x942>
8000b7bc:	1d 00 ff 03 	j 8000bfba <_svfprintf_r+0x942>
8000b7c0:	1d 00 fd 03 	j 8000bfba <_svfprintf_r+0x942>
8000b7c4:	1d 00 b5 00 	j 8000b92e <_svfprintf_r+0x2b6>
8000b7c8:	1d 00 9c 00 	j 8000b900 <_svfprintf_r+0x288>
8000b7cc:	1d 00 f7 03 	j 8000bfba <_svfprintf_r+0x942>
8000b7d0:	1d 00 b8 00 	j 8000b940 <_svfprintf_r+0x2c8>
8000b7d4:	1d 00 b9 00 	j 8000b946 <_svfprintf_r+0x2ce>
8000b7d8:	1d 00 f1 03 	j 8000bfba <_svfprintf_r+0x942>
8000b7dc:	1d 00 de 00 	j 8000b998 <_svfprintf_r+0x320>
8000b7e0:	1d 00 df 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7e4:	1d 00 dd 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7e8:	1d 00 db 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7ec:	1d 00 d9 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7f0:	1d 00 d7 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7f4:	1d 00 d5 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7f8:	1d 00 d3 00 	j 8000b99e <_svfprintf_r+0x326>
8000b7fc:	1d 00 d1 00 	j 8000b99e <_svfprintf_r+0x326>
8000b800:	1d 00 cf 00 	j 8000b99e <_svfprintf_r+0x326>
8000b804:	1d 00 db 03 	j 8000bfba <_svfprintf_r+0x942>
8000b808:	1d 00 d9 03 	j 8000bfba <_svfprintf_r+0x942>
8000b80c:	1d 00 d7 03 	j 8000bfba <_svfprintf_r+0x942>
8000b810:	1d 00 d5 03 	j 8000bfba <_svfprintf_r+0x942>
8000b814:	1d 00 d3 03 	j 8000bfba <_svfprintf_r+0x942>
8000b818:	1d 00 d1 03 	j 8000bfba <_svfprintf_r+0x942>
8000b81c:	1d 00 cf 03 	j 8000bfba <_svfprintf_r+0x942>
8000b820:	1d 00 cd 03 	j 8000bfba <_svfprintf_r+0x942>
8000b824:	1d 00 cb 03 	j 8000bfba <_svfprintf_r+0x942>
8000b828:	1d 00 c9 03 	j 8000bfba <_svfprintf_r+0x942>
8000b82c:	1d 00 f9 00 	j 8000ba1e <_svfprintf_r+0x3a6>
8000b830:	1d 00 21 01 	j 8000ba72 <_svfprintf_r+0x3fa>
8000b834:	1d 00 c3 03 	j 8000bfba <_svfprintf_r+0x942>
8000b838:	1d 00 1d 01 	j 8000ba72 <_svfprintf_r+0x3fa>
8000b83c:	1d 00 bf 03 	j 8000bfba <_svfprintf_r+0x942>
8000b840:	1d 00 bd 03 	j 8000bfba <_svfprintf_r+0x942>
8000b844:	1d 00 bb 03 	j 8000bfba <_svfprintf_r+0x942>
8000b848:	1d 00 b9 03 	j 8000bfba <_svfprintf_r+0x942>
8000b84c:	1d 00 c6 00 	j 8000b9d8 <_svfprintf_r+0x360>
8000b850:	1d 00 b5 03 	j 8000bfba <_svfprintf_r+0x942>
8000b854:	1d 00 b3 03 	j 8000bfba <_svfprintf_r+0x942>
8000b858:	1d 00 92 02 	j 8000bd7c <_svfprintf_r+0x704>
8000b85c:	1d 00 af 03 	j 8000bfba <_svfprintf_r+0x942>
8000b860:	1d 00 ad 03 	j 8000bfba <_svfprintf_r+0x942>
8000b864:	1d 00 ab 03 	j 8000bfba <_svfprintf_r+0x942>
8000b868:	1d 00 a9 03 	j 8000bfba <_svfprintf_r+0x942>
8000b86c:	1d 00 a7 03 	j 8000bfba <_svfprintf_r+0x942>
8000b870:	1d 00 d0 02 	j 8000be10 <_svfprintf_r+0x798>
8000b874:	1d 00 a3 03 	j 8000bfba <_svfprintf_r+0x942>
8000b878:	1d 00 a1 03 	j 8000bfba <_svfprintf_r+0x942>
8000b87c:	1d 00 4b 00 	j 8000b912 <_svfprintf_r+0x29a>
8000b880:	1d 00 9d 03 	j 8000bfba <_svfprintf_r+0x942>
8000b884:	1d 00 9b 03 	j 8000bfba <_svfprintf_r+0x942>
8000b888:	1d 00 99 03 	j 8000bfba <_svfprintf_r+0x942>
8000b88c:	1d 00 97 03 	j 8000bfba <_svfprintf_r+0x942>
8000b890:	1d 00 95 03 	j 8000bfba <_svfprintf_r+0x942>
8000b894:	1d 00 93 03 	j 8000bfba <_svfprintf_r+0x942>
8000b898:	1d 00 91 03 	j 8000bfba <_svfprintf_r+0x942>
8000b89c:	1d 00 8f 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8a0:	1d 00 8d 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8a4:	1d 00 8b 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8a8:	1d 00 b0 00 	j 8000ba08 <_svfprintf_r+0x390>
8000b8ac:	1d 00 2f 00 	j 8000b90a <_svfprintf_r+0x292>
8000b8b0:	1d 00 e1 00 	j 8000ba72 <_svfprintf_r+0x3fa>
8000b8b4:	1d 00 df 00 	j 8000ba72 <_svfprintf_r+0x3fa>
8000b8b8:	1d 00 dd 00 	j 8000ba72 <_svfprintf_r+0x3fa>
8000b8bc:	1d 00 91 00 	j 8000b9de <_svfprintf_r+0x366>
8000b8c0:	1d 00 25 00 	j 8000b90a <_svfprintf_r+0x292>
8000b8c4:	1d 00 7b 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8c8:	1d 00 79 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8cc:	1d 00 8c 00 	j 8000b9e4 <_svfprintf_r+0x36c>
8000b8d0:	1d 00 75 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8d4:	1d 00 39 02 	j 8000bd46 <_svfprintf_r+0x6ce>
8000b8d8:	1d 00 54 02 	j 8000bd80 <_svfprintf_r+0x708>
8000b8dc:	1d 00 66 02 	j 8000bda8 <_svfprintf_r+0x730>
8000b8e0:	1d 00 90 00 	j 8000ba00 <_svfprintf_r+0x388>
8000b8e4:	1d 00 6b 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8e8:	1d 00 77 02 	j 8000bdd6 <_svfprintf_r+0x75e>
8000b8ec:	1d 00 67 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8f0:	1d 00 92 02 	j 8000be14 <_svfprintf_r+0x79c>
8000b8f4:	1d 00 63 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8f8:	1d 00 61 03 	j 8000bfba <_svfprintf_r+0x942>
8000b8fc:	1d 00 a0 02 	j 8000be3c <_svfprintf_r+0x7c4>
8000b900:	da 2b       	mov %d15,43
8000b902:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b906:	1d ff 33 ff 	j 8000b76c <_svfprintf_r+0xf4>
8000b90a:	e9 af 01 10 	st.b [%sp]65,%d15
8000b90e:	1d 00 8c 00 	j 8000ba26 <_svfprintf_r+0x3ae>
8000b912:	e9 af 01 10 	st.b [%sp]65,%d15
8000b916:	7b 00 00 f8 	movh %d15,32768
8000b91a:	1b cf e7 f0 	addi %d15,%d15,3708
8000b91e:	1d 00 95 02 	j 8000be48 <_svfprintf_r+0x7d0>
8000b922:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000b926:	3c ee       	j 8000b902 <_svfprintf_r+0x28a>
8000b928:	8f 1a 40 a1 	or %d10,%d10,1
8000b92c:	3c eb       	j 8000b902 <_svfprintf_r+0x28a>
8000b92e:	48 02       	ld.w %d2,[%a15]0
8000b930:	b0 4f       	add.a %a15,4
8000b932:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b936:	ff 02 e6 7f 	jge %d2,0,8000b902 <_svfprintf_r+0x28a>
8000b93a:	32 52       	rsub %d2
8000b93c:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b940:	8f 4a 40 a1 	or %d10,%d10,4
8000b944:	3c df       	j 8000b902 <_svfprintf_r+0x28a>
8000b946:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b94a:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b94e:	79 32 00 00 	ld.b %d2,[%a3]0
8000b952:	b0 12       	add.a %a2,1
8000b954:	59 a2 10 00 	st.w [%sp]16,%d2
8000b958:	8b a2 02 32 	eq %d3,%d2,42
8000b95c:	f6 33       	jnz %d3,8000b962 <_svfprintf_r+0x2ea>
8000b95e:	82 05       	mov %d5,0
8000b960:	3c 08       	j 8000b970 <_svfprintf_r+0x2f8>
8000b962:	48 0e       	ld.w %d14,[%a15]0
8000b964:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b968:	b0 4f       	add.a %a15,4
8000b96a:	8b fe 5f e3 	max %d14,%d14,-1
8000b96e:	3c ca       	j 8000b902 <_svfprintf_r+0x28a>
8000b970:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b974:	1b 02 fd 3f 	addi %d3,%d2,-48
8000b978:	ff a3 0a 80 	jge.u %d3,10,8000b98c <_svfprintf_r+0x314>
8000b97c:	79 22 00 00 	ld.b %d2,[%a2]0
8000b980:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000b984:	59 a2 10 00 	st.w [%sp]16,%d2
8000b988:	b0 12       	add.a %a2,1
8000b98a:	3c f3       	j 8000b970 <_svfprintf_r+0x2f8>
8000b98c:	8b f5 5f e3 	max %d14,%d5,-1
8000b990:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b994:	1d ff f4 fe 	j 8000b77c <_svfprintf_r+0x104>
8000b998:	8f 0a 48 a1 	or %d10,%d10,128
8000b99c:	3c b3       	j 8000b902 <_svfprintf_r+0x28a>
8000b99e:	82 02       	mov %d2,0
8000b9a0:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b9a4:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b9a8:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b9ac:	1b 02 fd 4f 	addi %d4,%d2,-48
8000b9b0:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000b9b4:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b9b8:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000b9bc:	b0 12       	add.a %a2,1
8000b9be:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b9c2:	79 32 00 00 	ld.b %d2,[%a3]0
8000b9c6:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b9ca:	59 a2 10 00 	st.w [%sp]16,%d2
8000b9ce:	1b 02 fd 4f 	addi %d4,%d2,-48
8000b9d2:	bf a4 e9 ff 	jlt.u %d4,10,8000b9a4 <_svfprintf_r+0x32c>
8000b9d6:	3c dd       	j 8000b990 <_svfprintf_r+0x318>
8000b9d8:	8f 8a 40 a1 	or %d10,%d10,8
8000b9dc:	3c 93       	j 8000b902 <_svfprintf_r+0x28a>
8000b9de:	8f 0a 44 a1 	or %d10,%d10,64
8000b9e2:	3c 90       	j 8000b902 <_svfprintf_r+0x28a>
8000b9e4:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b9e8:	79 33 00 00 	ld.b %d3,[%a3]0
8000b9ec:	8b c3 26 32 	ne %d3,%d3,108
8000b9f0:	f6 35       	jnz %d3,8000b9fa <_svfprintf_r+0x382>
8000b9f2:	b0 13       	add.a %a3,1
8000b9f4:	b5 a3 18 00 	st.a [%sp]24,%a3
8000b9f8:	3c 04       	j 8000ba00 <_svfprintf_r+0x388>
8000b9fa:	8f 0a 41 a1 	or %d10,%d10,16
8000b9fe:	3c 82       	j 8000b902 <_svfprintf_r+0x28a>
8000ba00:	8f 0a 42 a1 	or %d10,%d10,32
8000ba04:	1d ff 7f ff 	j 8000b902 <_svfprintf_r+0x28a>
8000ba08:	48 03       	ld.w %d3,[%a15]0
8000ba0a:	d9 fc 04 00 	lea %a12,[%a15]4
8000ba0e:	e9 a3 28 10 	st.b [%sp]104,%d3
8000ba12:	82 03       	mov %d3,0
8000ba14:	e9 a3 01 10 	st.b [%sp]65,%d3
8000ba18:	60 ad       	mov.a %a13,%d10
8000ba1a:	1d 00 dc 02 	j 8000bfd2 <_svfprintf_r+0x95a>
8000ba1e:	e9 af 01 10 	st.b [%sp]65,%d15
8000ba22:	8f 0a 41 a1 	or %d10,%d10,16
8000ba26:	60 ad       	mov.a %a13,%d10
8000ba28:	6f 5a 07 00 	jz.t %d10,5,8000ba36 <_svfprintf_r+0x3be>
8000ba2c:	d9 fc 08 00 	lea %a12,[%a15]8
8000ba30:	09 f8 40 09 	ld.d %e8,[%a15]
8000ba34:	3c 12       	j 8000ba58 <_svfprintf_r+0x3e0>
8000ba36:	d9 f2 04 00 	lea %a2,[%a15]4
8000ba3a:	6f 4a 05 00 	jz.t %d10,4,8000ba44 <_svfprintf_r+0x3cc>
8000ba3e:	40 2c       	mov.aa %a12,%a2
8000ba40:	48 08       	ld.w %d8,[%a15]0
8000ba42:	3c 09       	j 8000ba54 <_svfprintf_r+0x3dc>
8000ba44:	48 03       	ld.w %d3,[%a15]0
8000ba46:	40 2c       	mov.aa %a12,%a2
8000ba48:	0b 30 00 88 	mov %e8,%d3
8000ba4c:	6f 6a 06 00 	jz.t %d10,6,8000ba58 <_svfprintf_r+0x3e0>
8000ba50:	37 03 50 80 	extr %d8,%d3,0,16
8000ba54:	0b 80 00 88 	mov %e8,%d8
8000ba58:	82 13       	mov %d3,1
8000ba5a:	ff 09 1d 02 	jge %d9,0,8000be94 <_svfprintf_r+0x81c>
8000ba5e:	32 59       	rsub %d9
8000ba60:	32 58       	rsub %d8
8000ba62:	3b d0 02 70 	mov %d7,45
8000ba66:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000ba6a:	e9 a7 01 10 	st.b [%sp]65,%d7
8000ba6e:	1d 00 13 02 	j 8000be94 <_svfprintf_r+0x81c>
8000ba72:	e9 af 01 10 	st.b [%sp]65,%d15
8000ba76:	4c f0       	ld.w %d15,[%a15]0
8000ba78:	d9 fc 08 00 	lea %a12,[%a15]8
8000ba7c:	78 0b       	st.w [%sp]44,%d15
8000ba7e:	4c f1       	ld.w %d15,[%a15]4
8000ba80:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000ba84:	78 0c       	st.w [%sp]48,%d15
8000ba86:	19 a5 30 00 	ld.w %d5,[%sp]48
8000ba8a:	6d 00 b3 10 	call 8000dbf0 <__fpclassifyd>
8000ba8e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000ba92:	19 a5 30 00 	ld.w %d5,[%sp]48
8000ba96:	df 12 18 80 	jne %d2,1,8000bac6 <_svfprintf_r+0x44e>
8000ba9a:	d2 06       	mov %e6,0
8000ba9c:	6d 00 50 14 	call 8000e33c <__ltdf2>
8000baa0:	ce 25       	jgez %d2,8000baaa <_svfprintf_r+0x432>
8000baa2:	3b d0 02 30 	mov %d3,45
8000baa6:	e9 a3 01 10 	st.b [%sp]65,%d3
8000baaa:	58 04       	ld.w %d15,[%sp]16
8000baac:	7b 00 00 78 	movh %d7,32768
8000bab0:	8b 8f 84 32 	ge %d3,%d15,72
8000bab4:	1b 07 e7 d0 	addi %d13,%d7,3696
8000bab8:	df 03 17 80 	jne %d3,0,8000bae6 <_svfprintf_r+0x46e>
8000babc:	7b 00 00 78 	movh %d7,32768
8000bac0:	1b c7 e6 d0 	addi %d13,%d7,3692
8000bac4:	3c 11       	j 8000bae6 <_svfprintf_r+0x46e>
8000bac6:	6d 00 95 10 	call 8000dbf0 <__fpclassifyd>
8000baca:	58 04       	ld.w %d15,[%sp]16
8000bacc:	df 02 13 80 	jne %d2,0,8000baf2 <_svfprintf_r+0x47a>
8000bad0:	7b 00 00 78 	movh %d7,32768
8000bad4:	8b 8f 84 32 	ge %d3,%d15,72
8000bad8:	1b 87 e7 d0 	addi %d13,%d7,3704
8000badc:	f6 35       	jnz %d3,8000bae6 <_svfprintf_r+0x46e>
8000bade:	7b 00 00 78 	movh %d7,32768
8000bae2:	1b 47 e7 d0 	addi %d13,%d7,3700
8000bae6:	8f 0a c8 a1 	andn %d10,%d10,128
8000baea:	60 ad       	mov.a %a13,%d10
8000baec:	82 39       	mov %d9,3
8000baee:	1d 00 78 02 	j 8000bfde <_svfprintf_r+0x966>
8000baf2:	8f 0f c2 f1 	andn %d15,%d15,32
8000baf6:	78 01       	st.w [%sp]4,%d15
8000baf8:	df fe 09 00 	jeq %d14,-1,8000bb0a <_svfprintf_r+0x492>
8000bafc:	8b 0e 00 72 	eq %d7,%d14,0
8000bb00:	8b 7f 04 74 	and.eq %d7,%d15,71
8000bb04:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000bb08:	3c 02       	j 8000bb0c <_svfprintf_r+0x494>
8000bb0a:	82 6e       	mov %d14,6
8000bb0c:	19 a3 30 00 	ld.w %d3,[%sp]48
8000bb10:	8f 0a 50 21 	or %d2,%d10,256
8000bb14:	60 2d       	mov.a %a13,%d2
8000bb16:	d8 0b       	ld.a %a15,[%sp]44
8000bb18:	82 0f       	mov %d15,0
8000bb1a:	ce 34       	jgez %d3,8000bb22 <_svfprintf_r+0x4aa>
8000bb1c:	9b 03 00 38 	addih %d3,%d3,32768
8000bb20:	da 2d       	mov %d15,45
8000bb22:	78 09       	st.w [%sp]36,%d15
8000bb24:	58 01       	ld.w %d15,[%sp]4
8000bb26:	02 e9       	mov %d9,%d14
8000bb28:	8b 6f 04 22 	eq %d2,%d15,70
8000bb2c:	82 36       	mov %d6,3
8000bb2e:	f6 28       	jnz %d2,8000bb3e <_svfprintf_r+0x4c6>
8000bb30:	8b 5f 24 12 	ne %d1,%d15,69
8000bb34:	1b 1e 00 50 	addi %d5,%d14,1
8000bb38:	82 26       	mov %d6,2
8000bb3a:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000bb3e:	60 c4       	mov.a %a4,%d12
8000bb40:	80 f4       	mov.d %d4,%a15
8000bb42:	02 35       	mov %d5,%d3
8000bb44:	02 97       	mov %d7,%d9
8000bb46:	d9 a5 04 10 	lea %a5,[%sp]68
8000bb4a:	d9 a6 08 10 	lea %a6,[%sp]72
8000bb4e:	d9 a7 14 10 	lea %a7,[%sp]84
8000bb52:	59 a2 0c 00 	st.w [%sp]12,%d2
8000bb56:	59 a3 08 00 	st.w [%sp]8,%d3
8000bb5a:	6d 00 ef 06 	call 8000c938 <_dtoa_r>
8000bb5e:	58 01       	ld.w %d15,[%sp]4
8000bb60:	80 2d       	mov.d %d13,%a2
8000bb62:	8b 7f 24 12 	ne %d1,%d15,71
8000bb66:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000bb6a:	19 a3 08 00 	ld.w %d3,[%sp]8
8000bb6e:	df 01 11 80 	jne %d1,0,8000bb90 <_svfprintf_r+0x518>
8000bb72:	6f 0a 0f 80 	jnz.t %d10,0,8000bb90 <_svfprintf_r+0x518>
8000bb76:	19 a2 14 10 	ld.w %d2,[%sp]84
8000bb7a:	58 01       	ld.w %d15,[%sp]4
8000bb7c:	a2 d2       	sub %d2,%d13
8000bb7e:	59 a2 14 00 	st.w [%sp]20,%d2
8000bb82:	8b 7f 04 42 	eq %d4,%d15,71
8000bb86:	19 a5 04 10 	ld.w %d5,[%sp]68
8000bb8a:	df 04 36 80 	jne %d4,0,8000bbf6 <_svfprintf_r+0x57e>
8000bb8e:	3c 3e       	j 8000bc0a <_svfprintf_r+0x592>
8000bb90:	0b 9d 00 80 	add %d8,%d13,%d9
8000bb94:	df 02 1c 00 	jeq %d2,0,8000bbcc <_svfprintf_r+0x554>
8000bb98:	60 d2       	mov.a %a2,%d13
8000bb9a:	80 f4       	mov.d %d4,%a15
8000bb9c:	79 20 00 00 	ld.b %d0,[%a2]0
8000bba0:	d2 06       	mov %e6,0
8000bba2:	02 35       	mov %d5,%d3
8000bba4:	8b 00 03 f2 	eq %d15,%d0,48
8000bba8:	59 a3 08 00 	st.w [%sp]8,%d3
8000bbac:	6d 00 68 13 	call 8000e27c <__nedf2>
8000bbb0:	8b 02 20 22 	ne %d2,%d2,0
8000bbb4:	0f 2f 80 00 	and %d0,%d15,%d2
8000bbb8:	19 a3 08 00 	ld.w %d3,[%sp]8
8000bbbc:	76 05       	jz %d0,8000bbc6 <_svfprintf_r+0x54e>
8000bbbe:	8b 19 00 01 	rsub %d0,%d9,1
8000bbc2:	59 a0 04 10 	st.w [%sp]68,%d0
8000bbc6:	19 a2 04 10 	ld.w %d2,[%sp]68
8000bbca:	42 28       	add %d8,%d2
8000bbcc:	80 f4       	mov.d %d4,%a15
8000bbce:	d2 06       	mov %e6,0
8000bbd0:	02 35       	mov %d5,%d3
8000bbd2:	6d 00 35 13 	call 8000e23c <__eqdf2>
8000bbd6:	f6 23       	jnz %d2,8000bbdc <_svfprintf_r+0x564>
8000bbd8:	59 a8 14 10 	st.w [%sp]84,%d8
8000bbdc:	3b 00 03 00 	mov %d0,48
8000bbe0:	19 a3 14 10 	ld.w %d3,[%sp]84
8000bbe4:	7f 83 c9 ff 	jge.u %d3,%d8,8000bb76 <_svfprintf_r+0x4fe>
8000bbe8:	1b 13 00 10 	addi %d1,%d3,1
8000bbec:	60 32       	mov.a %a2,%d3
8000bbee:	59 a1 14 10 	st.w [%sp]84,%d1
8000bbf2:	34 20       	st.b [%a2],%d0
8000bbf4:	3c f6       	j 8000bbe0 <_svfprintf_r+0x568>
8000bbf6:	0b 5e 20 31 	lt %d3,%d14,%d5
8000bbfa:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000bbfe:	df 03 88 00 	jeq %d3,0,8000bd0e <_svfprintf_r+0x696>
8000bc02:	58 04       	ld.w %d15,[%sp]16
8000bc04:	c2 ef       	add %d15,-2
8000bc06:	78 04       	st.w [%sp]16,%d15
8000bc08:	3c 06       	j 8000bc14 <_svfprintf_r+0x59c>
8000bc0a:	58 04       	ld.w %d15,[%sp]16
8000bc0c:	8b 6f 86 32 	ge %d3,%d15,102
8000bc10:	df 03 69 80 	jne %d3,0,8000bce2 <_svfprintf_r+0x66a>
8000bc14:	19 a2 10 00 	ld.w %d2,[%sp]16
8000bc18:	9a f5       	add %d15,%d5,-1
8000bc1a:	78 11       	st.w [%sp]68,%d15
8000bc1c:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000bc20:	3b b0 02 30 	mov %d3,43
8000bc24:	ce f4       	jgez %d15,8000bc2c <_svfprintf_r+0x5b4>
8000bc26:	32 5f       	rsub %d15
8000bc28:	3b d0 02 30 	mov %d3,45
8000bc2c:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000bc30:	8b af 40 32 	lt %d3,%d15,10
8000bc34:	df 03 3e 80 	jne %d3,0,8000bcb0 <_svfprintf_r+0x638>
8000bc38:	82 06       	mov %d6,0
8000bc3a:	3b a0 00 00 	mov %d0,10
8000bc3e:	4b 0f 01 42 	div %e4,%d15,%d0
8000bc42:	8b 66 00 71 	rsub %d7,%d6,6
8000bc46:	60 72       	mov.a %a2,%d7
8000bc48:	d9 af 14 10 	lea %a15,[%sp]84
8000bc4c:	1b 05 03 30 	addi %d3,%d5,48
8000bc50:	30 2f       	add.a %a15,%a2
8000bc52:	28 03       	st.b [%a15]0,%d3
8000bc54:	8b a4 80 32 	ge %d3,%d4,10
8000bc58:	02 4f       	mov %d15,%d4
8000bc5a:	c2 16       	add %d6,1
8000bc5c:	df 03 f1 ff 	jne %d3,0,8000bc3e <_svfprintf_r+0x5c6>
8000bc60:	60 74       	mov.a %a4,%d7
8000bc62:	d9 a2 10 30 	lea %a2,[%sp]208
8000bc66:	1b 04 03 f0 	addi %d15,%d4,48
8000bc6a:	30 42       	add.a %a2,%a4
8000bc6c:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000bc70:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000bc74:	80 22       	mov.d %d2,%a2
8000bc76:	d9 af 1b 10 	lea %a15,[%sp]91
8000bc7a:	80 ff       	mov.d %d15,%a15
8000bc7c:	1b 32 f8 4f 	addi %d4,%d2,-125
8000bc80:	82 03       	mov %d3,0
8000bc82:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000bc86:	3f 4f 08 80 	jlt.u %d15,%d4,8000bc96 <_svfprintf_r+0x61e>
8000bc8a:	80 a2       	mov.d %d2,%sp
8000bc8c:	1b 02 0d 20 	addi %d2,%d2,208
8000bc90:	8b 52 07 42 	eq %d4,%d2,117
8000bc94:	76 46       	jz %d4,8000bca0 <_svfprintf_r+0x628>
8000bc96:	a0 03       	mov.a %a3,0
8000bc98:	3c 04       	j 8000bca0 <_svfprintf_r+0x628>
8000bc9a:	0c 70       	ld.bu %d15,[%a7]0
8000bc9c:	b0 17       	add.a %a7,1
8000bc9e:	28 0f       	st.b [%a15]0,%d15
8000bca0:	60 3f       	mov.a %a15,%d3
8000bca2:	d9 a2 0d 10 	lea %a2,[%sp]77
8000bca6:	b0 2f       	add.a %a15,2
8000bca8:	30 2f       	add.a %a15,%a2
8000bcaa:	c2 13       	add %d3,1
8000bcac:	fc 37       	loop %a3,8000bc9a <_svfprintf_r+0x622>
8000bcae:	3c 0b       	j 8000bcc4 <_svfprintf_r+0x64c>
8000bcb0:	3b 00 03 30 	mov %d3,48
8000bcb4:	1b 0f 03 f0 	addi %d15,%d15,48
8000bcb8:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000bcbc:	e9 af 10 10 	st.b [%sp]80,%d15
8000bcc0:	d9 af 11 10 	lea %a15,[%sp]81
8000bcc4:	d9 a7 0d 10 	lea %a7,[%sp]77
8000bcc8:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000bccc:	80 79       	mov.d %d9,%a7
8000bcce:	58 05       	ld.w %d15,[%sp]20
8000bcd0:	b5 a7 38 00 	st.a [%sp]56,%a7
8000bcd4:	42 f9       	add %d9,%d15
8000bcd6:	ff 2f 04 00 	jge %d15,2,8000bcde <_svfprintf_r+0x666>
8000bcda:	6f 0a 2c 00 	jz.t %d10,0,8000bd32 <_svfprintf_r+0x6ba>
8000bcde:	c2 19       	add %d9,1
8000bce0:	3c 29       	j 8000bd32 <_svfprintf_r+0x6ba>
8000bce2:	58 04       	ld.w %d15,[%sp]16
8000bce4:	8b 6f 26 42 	ne %d4,%d15,102
8000bce8:	df 04 15 80 	jne %d4,0,8000bd12 <_svfprintf_r+0x69a>
8000bcec:	02 59       	mov %d9,%d5
8000bcee:	8e 59       	jlez %d5,8000bd00 <_svfprintf_r+0x688>
8000bcf0:	f6 e3       	jnz %d14,8000bcf6 <_svfprintf_r+0x67e>
8000bcf2:	6f 0a 20 00 	jz.t %d10,0,8000bd32 <_svfprintf_r+0x6ba>
8000bcf6:	1b 1e 00 30 	addi %d3,%d14,1
8000bcfa:	0b 35 00 90 	add %d9,%d5,%d3
8000bcfe:	3c 1a       	j 8000bd32 <_svfprintf_r+0x6ba>
8000bd00:	f6 e4       	jnz %d14,8000bd08 <_svfprintf_r+0x690>
8000bd02:	82 19       	mov %d9,1
8000bd04:	6f 0a 17 00 	jz.t %d10,0,8000bd32 <_svfprintf_r+0x6ba>
8000bd08:	1b 2e 00 90 	addi %d9,%d14,2
8000bd0c:	3c 13       	j 8000bd32 <_svfprintf_r+0x6ba>
8000bd0e:	da 67       	mov %d15,103
8000bd10:	78 04       	st.w [%sp]16,%d15
8000bd12:	58 05       	ld.w %d15,[%sp]20
8000bd14:	8f 1a 00 a1 	and %d10,%d10,1
8000bd18:	0b a5 00 90 	add %d9,%d5,%d10
8000bd1c:	7f f5 0b 00 	jge %d5,%d15,8000bd32 <_svfprintf_r+0x6ba>
8000bd20:	8b 15 40 92 	lt %d9,%d5,1
8000bd24:	8b 25 00 31 	rsub %d3,%d5,2
8000bd28:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000bd2c:	19 a9 14 00 	ld.w %d9,[%sp]20
8000bd30:	42 39       	add %d9,%d3
8000bd32:	58 09       	ld.w %d15,[%sp]36
8000bd34:	82 0e       	mov %d14,0
8000bd36:	df 0f 55 01 	jeq %d15,0,8000bfe0 <_svfprintf_r+0x968>
8000bd3a:	3b d0 02 70 	mov %d7,45
8000bd3e:	e9 a7 01 10 	st.b [%sp]65,%d7
8000bd42:	1d 00 4f 01 	j 8000bfe0 <_svfprintf_r+0x968>
8000bd46:	e9 af 01 10 	st.b [%sp]65,%d15
8000bd4a:	d9 f2 04 00 	lea %a2,[%a15]4
8000bd4e:	6f 5a 09 00 	jz.t %d10,5,8000bd60 <_svfprintf_r+0x6e8>
8000bd52:	58 0a       	ld.w %d15,[%sp]40
8000bd54:	c8 03       	ld.a %a3,[%a15]0
8000bd56:	0b f0 00 48 	mov %e4,%d15
8000bd5a:	89 34 40 09 	st.d [%a3],%e4
8000bd5e:	3c 0c       	j 8000bd76 <_svfprintf_r+0x6fe>
8000bd60:	6f 4a 08 80 	jnz.t %d10,4,8000bd70 <_svfprintf_r+0x6f8>
8000bd64:	6f 6a 06 00 	jz.t %d10,6,8000bd70 <_svfprintf_r+0x6f8>
8000bd68:	c8 03       	ld.a %a3,[%a15]0
8000bd6a:	58 0a       	ld.w %d15,[%sp]40
8000bd6c:	ac 30       	st.h [%a3]0,%d15
8000bd6e:	3c 04       	j 8000bd76 <_svfprintf_r+0x6fe>
8000bd70:	c8 03       	ld.a %a3,[%a15]0
8000bd72:	58 0a       	ld.w %d15,[%sp]40
8000bd74:	6c 30       	st.w [%a3]0,%d15
8000bd76:	40 2f       	mov.aa %a15,%a2
8000bd78:	1d ff b8 fc 	j 8000b6e8 <_svfprintf_r+0x70>
8000bd7c:	8f 0a 41 a1 	or %d10,%d10,16
8000bd80:	6f 5a 07 00 	jz.t %d10,5,8000bd8e <_svfprintf_r+0x716>
8000bd84:	d9 fc 08 00 	lea %a12,[%a15]8
8000bd88:	09 f8 40 09 	ld.d %e8,[%a15]
8000bd8c:	3c 0c       	j 8000bda4 <_svfprintf_r+0x72c>
8000bd8e:	d9 fc 04 00 	lea %a12,[%a15]4
8000bd92:	6f 4a 07 80 	jnz.t %d10,4,8000bda0 <_svfprintf_r+0x728>
8000bd96:	6f 6a 05 00 	jz.t %d10,6,8000bda0 <_svfprintf_r+0x728>
8000bd9a:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000bd9e:	3c 02       	j 8000bda2 <_svfprintf_r+0x72a>
8000bda0:	48 08       	ld.w %d8,[%a15]0
8000bda2:	82 09       	mov %d9,0
8000bda4:	82 03       	mov %d3,0
8000bda6:	3c 73       	j 8000be8c <_svfprintf_r+0x814>
8000bda8:	3b 00 03 40 	mov %d4,48
8000bdac:	7b 00 00 f8 	movh %d15,32768
8000bdb0:	1b df e8 f0 	addi %d15,%d15,3725
8000bdb4:	e9 a4 02 10 	st.b [%sp]66,%d4
8000bdb8:	3b 80 07 40 	mov %d4,120
8000bdbc:	78 0f       	st.w [%sp]60,%d15
8000bdbe:	02 4f       	mov %d15,%d4
8000bdc0:	d9 fc 04 00 	lea %a12,[%a15]4
8000bdc4:	48 08       	ld.w %d8,[%a15]0
8000bdc6:	82 09       	mov %d9,0
8000bdc8:	8f 2a 40 a1 	or %d10,%d10,2
8000bdcc:	e9 a4 03 10 	st.b [%sp]67,%d4
8000bdd0:	82 23       	mov %d3,2
8000bdd2:	78 04       	st.w [%sp]16,%d15
8000bdd4:	3c 5c       	j 8000be8c <_svfprintf_r+0x814>
8000bdd6:	82 07       	mov %d7,0
8000bdd8:	48 0d       	ld.w %d13,[%a15]0
8000bdda:	e9 a7 01 10 	st.b [%sp]65,%d7
8000bdde:	02 e9       	mov %d9,%d14
8000bde0:	60 ad       	mov.a %a13,%d10
8000bde2:	d9 fc 04 00 	lea %a12,[%a15]4
8000bde6:	60 d4       	mov.a %a4,%d13
8000bde8:	0e ef       	jltz %d14,8000be06 <_svfprintf_r+0x78e>
8000bdea:	82 04       	mov %d4,0
8000bdec:	02 e5       	mov %d5,%d14
8000bdee:	6d 00 14 0c 	call 8000d616 <memchr>
8000bdf2:	bd 02 f6 00 	jz.a %a2,8000bfde <_svfprintf_r+0x966>
8000bdf6:	60 d4       	mov.a %a4,%d13
8000bdf8:	01 42 20 30 	sub.a %a3,%a2,%a4
8000bdfc:	80 32       	mov.d %d2,%a3
8000bdfe:	0b e2 80 91 	min %d9,%d2,%d14
8000be02:	1d 00 ee 00 	j 8000bfde <_svfprintf_r+0x966>
8000be06:	6d ff cc fa 	call 8000b39e <strlen>
8000be0a:	02 29       	mov %d9,%d2
8000be0c:	1d 00 e9 00 	j 8000bfde <_svfprintf_r+0x966>
8000be10:	8f 0a 41 a1 	or %d10,%d10,16
8000be14:	6f 5a 07 00 	jz.t %d10,5,8000be22 <_svfprintf_r+0x7aa>
8000be18:	d9 fc 08 00 	lea %a12,[%a15]8
8000be1c:	09 f8 40 09 	ld.d %e8,[%a15]
8000be20:	3c 0c       	j 8000be38 <_svfprintf_r+0x7c0>
8000be22:	d9 fc 04 00 	lea %a12,[%a15]4
8000be26:	6f 4a 07 80 	jnz.t %d10,4,8000be34 <_svfprintf_r+0x7bc>
8000be2a:	6f 6a 05 00 	jz.t %d10,6,8000be34 <_svfprintf_r+0x7bc>
8000be2e:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000be32:	3c 02       	j 8000be36 <_svfprintf_r+0x7be>
8000be34:	48 08       	ld.w %d8,[%a15]0
8000be36:	82 09       	mov %d9,0
8000be38:	82 13       	mov %d3,1
8000be3a:	3c 29       	j 8000be8c <_svfprintf_r+0x814>
8000be3c:	e9 af 01 10 	st.b [%sp]65,%d15
8000be40:	7b 00 00 f8 	movh %d15,32768
8000be44:	1b df e8 f0 	addi %d15,%d15,3725
8000be48:	78 0f       	st.w [%sp]60,%d15
8000be4a:	6f 5a 07 00 	jz.t %d10,5,8000be58 <_svfprintf_r+0x7e0>
8000be4e:	d9 fc 08 00 	lea %a12,[%a15]8
8000be52:	09 f8 40 09 	ld.d %e8,[%a15]
8000be56:	3c 0c       	j 8000be6e <_svfprintf_r+0x7f6>
8000be58:	d9 fc 04 00 	lea %a12,[%a15]4
8000be5c:	6f 4a 07 80 	jnz.t %d10,4,8000be6a <_svfprintf_r+0x7f2>
8000be60:	6f 6a 05 00 	jz.t %d10,6,8000be6a <_svfprintf_r+0x7f2>
8000be64:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000be68:	3c 02       	j 8000be6c <_svfprintf_r+0x7f4>
8000be6a:	48 08       	ld.w %d8,[%a15]0
8000be6c:	82 09       	mov %d9,0
8000be6e:	82 23       	mov %d3,2
8000be70:	6f 0a 0e 00 	jz.t %d10,0,8000be8c <_svfprintf_r+0x814>
8000be74:	0f 89 a0 40 	or %d4,%d9,%d8
8000be78:	76 4a       	jz %d4,8000be8c <_svfprintf_r+0x814>
8000be7a:	58 04       	ld.w %d15,[%sp]16
8000be7c:	3b 00 03 70 	mov %d7,48
8000be80:	e9 a7 02 10 	st.b [%sp]66,%d7
8000be84:	e9 af 03 10 	st.b [%sp]67,%d15
8000be88:	8f 2a 40 a1 	or %d10,%d10,2
8000be8c:	82 07       	mov %d7,0
8000be8e:	60 ad       	mov.a %a13,%d10
8000be90:	e9 a7 01 10 	st.b [%sp]65,%d7
8000be94:	80 d2       	mov.d %d2,%a13
8000be96:	8b 0e 80 72 	ge %d7,%d14,0
8000be9a:	8f 02 c8 41 	andn %d4,%d2,128
8000be9e:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000bea2:	0f 98 a0 60 	or %d6,%d8,%d9
8000bea6:	8b 0e 20 42 	ne %d4,%d14,0
8000beaa:	8b 06 00 45 	or.ne %d4,%d6,0
8000beae:	60 2d       	mov.a %a13,%d2
8000beb0:	df 04 72 00 	jeq %d4,0,8000bf94 <_svfprintf_r+0x91c>
8000beb4:	df 13 06 00 	jeq %d3,1,8000bec0 <_svfprintf_r+0x848>
8000beb8:	df 23 57 00 	jeq %d3,2,8000bf66 <_svfprintf_r+0x8ee>
8000bebc:	82 03       	mov %d3,0
8000bebe:	3c 03       	j 8000bec4 <_svfprintf_r+0x84c>
8000bec0:	82 04       	mov %d4,0
8000bec2:	3c 22       	j 8000bf06 <_svfprintf_r+0x88e>
8000bec4:	8b 73 02 71 	rsub %d7,%d3,39
8000bec8:	60 72       	mov.a %a2,%d7
8000beca:	8f 78 00 41 	and %d4,%d8,7
8000bece:	d9 a3 28 10 	lea %a3,[%sp]104
8000bed2:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000bed6:	30 23       	add.a %a3,%a2
8000bed8:	1b 04 03 40 	addi %d4,%d4,48
8000bedc:	06 d9       	sh %d9,-3
8000bede:	34 34       	st.b [%a3],%d4
8000bee0:	0f 89 a0 60 	or %d6,%d9,%d8
8000bee4:	c2 13       	add %d3,1
8000bee6:	df 06 ef ff 	jne %d6,0,8000bec4 <_svfprintf_r+0x84c>
8000beea:	80 d2       	mov.d %d2,%a13
8000beec:	80 3d       	mov.d %d13,%a3
8000beee:	6f 02 61 00 	jz.t %d2,0,8000bfb0 <_svfprintf_r+0x938>
8000bef2:	8b 04 03 42 	eq %d4,%d4,48
8000bef6:	df 04 5d 80 	jne %d4,0,8000bfb0 <_svfprintf_r+0x938>
8000befa:	3b 00 03 70 	mov %d7,48
8000befe:	c2 fd       	add %d13,-1
8000bf00:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000bf04:	3c 56       	j 8000bfb0 <_svfprintf_r+0x938>
8000bf06:	8b 84 02 71 	rsub %d7,%d4,40
8000bf0a:	8b 09 00 32 	eq %d3,%d9,0
8000bf0e:	60 73       	mov.a %a3,%d7
8000bf10:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000bf14:	d9 a7 28 10 	lea %a7,[%sp]104
8000bf18:	8b 09 00 35 	or.ne %d3,%d9,0
8000bf1c:	30 37       	add.a %a7,%a3
8000bf1e:	1b 14 00 d0 	addi %d13,%d4,1
8000bf22:	df 03 1b 00 	jeq %d3,0,8000bf58 <_svfprintf_r+0x8e0>
8000bf26:	8b 74 02 41 	rsub %d4,%d4,39
8000bf2a:	60 42       	mov.a %a2,%d4
8000bf2c:	fb a0 00 60 	mov %e6,10
8000bf30:	0b 89 10 48 	mov %e4,%d9,%d8
8000bf34:	d9 af 28 10 	lea %a15,[%sp]104
8000bf38:	30 2f       	add.a %a15,%a2
8000bf3a:	6d 00 98 12 	call 8000e46a <__umoddi3>
8000bf3e:	0b 89 10 48 	mov %e4,%d9,%d8
8000bf42:	1b 02 03 20 	addi %d2,%d2,48
8000bf46:	fb a0 00 60 	mov %e6,10
8000bf4a:	28 02       	st.b [%a15]0,%d2
8000bf4c:	6d 00 3f 12 	call 8000e3ca <__udivdi3>
8000bf50:	02 d4       	mov %d4,%d13
8000bf52:	0b 23 10 88 	mov %e8,%d3,%d2
8000bf56:	3c d8       	j 8000bf06 <_svfprintf_r+0x88e>
8000bf58:	80 7d       	mov.d %d13,%a7
8000bf5a:	1b 08 03 80 	addi %d8,%d8,48
8000bf5e:	c2 fd       	add %d13,-1
8000bf60:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000bf64:	3c 26       	j 8000bfb0 <_svfprintf_r+0x938>
8000bf66:	82 03       	mov %d3,0
8000bf68:	d8 0f       	ld.a %a15,[%sp]60
8000bf6a:	80 ad       	mov.d %d13,%sp
8000bf6c:	8f f8 00 f1 	and %d15,%d8,15
8000bf70:	8b 73 02 71 	rsub %d7,%d3,39
8000bf74:	1b 8d 06 d0 	addi %d13,%d13,104
8000bf78:	10 f7       	addsc.a %a7,%a15,%d15,0
8000bf7a:	42 7d       	add %d13,%d7
8000bf7c:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000bf80:	0c 70       	ld.bu %d15,[%a7]0
8000bf82:	60 d2       	mov.a %a2,%d13
8000bf84:	06 c9       	sh %d9,-4
8000bf86:	2c 20       	st.b [%a2]0,%d15
8000bf88:	0f 89 a0 40 	or %d4,%d9,%d8
8000bf8c:	c2 13       	add %d3,1
8000bf8e:	df 04 ed ff 	jne %d4,0,8000bf68 <_svfprintf_r+0x8f0>
8000bf92:	3c 0f       	j 8000bfb0 <_svfprintf_r+0x938>
8000bf94:	80 a2       	mov.d %d2,%sp
8000bf96:	1b 02 09 d0 	addi %d13,%d2,144
8000bf9a:	f6 3b       	jnz %d3,8000bfb0 <_svfprintf_r+0x938>
8000bf9c:	80 df       	mov.d %d15,%a13
8000bf9e:	2e 09       	jz.t %d15,0,8000bfb0 <_svfprintf_r+0x938>
8000bfa0:	1b 02 0d d0 	addi %d13,%d2,208
8000bfa4:	60 d2       	mov.a %a2,%d13
8000bfa6:	3b 00 03 70 	mov %d7,48
8000bfaa:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000bfae:	80 2d       	mov.d %d13,%a2
8000bfb0:	d9 a3 10 20 	lea %a3,[%sp]144
8000bfb4:	80 39       	mov.d %d9,%a3
8000bfb6:	a2 d9       	sub %d9,%d13
8000bfb8:	3c 14       	j 8000bfe0 <_svfprintf_r+0x968>
8000bfba:	e9 af 01 10 	st.b [%sp]65,%d15
8000bfbe:	58 04       	ld.w %d15,[%sp]16
8000bfc0:	df 0f 1f 04 	jeq %d15,0,8000c7fe <_svfprintf_r+0x1186>
8000bfc4:	82 03       	mov %d3,0
8000bfc6:	60 ad       	mov.a %a13,%d10
8000bfc8:	e9 af 28 10 	st.b [%sp]104,%d15
8000bfcc:	e9 a3 01 10 	st.b [%sp]65,%d3
8000bfd0:	40 fc       	mov.aa %a12,%a15
8000bfd2:	80 a2       	mov.d %d2,%sp
8000bfd4:	82 19       	mov %d9,1
8000bfd6:	82 0e       	mov %d14,0
8000bfd8:	1b 82 06 d0 	addi %d13,%d2,104
8000bfdc:	3c 02       	j 8000bfe0 <_svfprintf_r+0x968>
8000bfde:	82 0e       	mov %d14,0
8000bfe0:	79 a7 01 10 	ld.b %d7,[%sp]65
8000bfe4:	80 df       	mov.d %d15,%a13
8000bfe6:	0b e9 a0 a1 	max %d10,%d9,%d14
8000bfea:	80 d2       	mov.d %d2,%a13
8000bfec:	16 02       	and %d15,2
8000bfee:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000bff2:	60 ff       	mov.a %a15,%d15
8000bff4:	8a 2a       	cadd %d10,%d15,2
8000bff6:	8f 42 08 f1 	and %d15,%d2,132
8000bffa:	ee 48       	jnz %d15,8000c08a <_svfprintf_r+0xa12>
8000bffc:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000c000:	a2 a8       	sub %d8,%d10
8000c002:	bf 18 44 00 	jlt %d8,1,8000c08a <_svfprintf_r+0xa12>
8000c006:	91 00 00 28 	movh.a %a2,32768
8000c00a:	d9 22 f0 a0 	lea %a2,[%a2]3760 <80000eb0 <blanks.4035>>
8000c00e:	19 a1 24 10 	ld.w %d1,[%sp]100 <80000eb0 <blanks.4035>>
8000c012:	19 a4 20 10 	ld.w %d4,[%sp]96 <80000eb0 <blanks.4035>>
8000c016:	8b 18 81 72 	ge %d7,%d8,17
8000c01a:	f4 e2       	st.a [%a14],%a2
8000c01c:	df 07 20 00 	jeq %d7,0,8000c05c <_svfprintf_r+0x9e4>
8000c020:	1b 14 00 00 	addi %d0,%d4,1
8000c024:	3b 00 01 20 	mov %d2,16
8000c028:	1b 01 01 10 	addi %d1,%d1,16
8000c02c:	59 e2 04 00 	st.w [%a14]4,%d2
8000c030:	59 a0 20 10 	st.w [%sp]96,%d0
8000c034:	59 a1 24 10 	st.w [%sp]100,%d1
8000c038:	8b 80 80 02 	ge %d0,%d0,8
8000c03c:	d9 ee 08 00 	lea %a14,[%a14]8
8000c040:	76 0b       	jz %d0,8000c056 <_svfprintf_r+0x9de>
8000c042:	60 c4       	mov.a %a4,%d12
8000c044:	60 b5       	mov.a %a5,%d11
8000c046:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c04a:	6d 00 f4 0d 	call 8000dc32 <__ssprint_r>
8000c04e:	df 02 e0 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c052:	d9 ae 10 20 	lea %a14,[%sp]144
8000c056:	1b 08 ff 8f 	addi %d8,%d8,-16
8000c05a:	3c d6       	j 8000c006 <_svfprintf_r+0x98e>
8000c05c:	c2 14       	add %d4,1
8000c05e:	42 81       	add %d1,%d8
8000c060:	59 e8 04 00 	st.w [%a14]4,%d8
8000c064:	59 a4 20 10 	st.w [%sp]96,%d4
8000c068:	59 a1 24 10 	st.w [%sp]100,%d1
8000c06c:	8b 84 80 42 	ge %d4,%d4,8
8000c070:	d9 ee 08 00 	lea %a14,[%a14]8
8000c074:	76 4b       	jz %d4,8000c08a <_svfprintf_r+0xa12>
8000c076:	60 c4       	mov.a %a4,%d12
8000c078:	60 b5       	mov.a %a5,%d11
8000c07a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c07e:	6d 00 da 0d 	call 8000dc32 <__ssprint_r>
8000c082:	df 02 c6 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c086:	d9 ae 10 20 	lea %a14,[%sp]144
8000c08a:	79 a4 01 10 	ld.b %d4,[%sp]65
8000c08e:	df 04 21 00 	jeq %d4,0,8000c0d0 <_svfprintf_r+0xa58>
8000c092:	19 a4 24 10 	ld.w %d4,[%sp]100
8000c096:	d9 a7 01 10 	lea %a7,[%sp]65
8000c09a:	c2 14       	add %d4,1
8000c09c:	59 a4 24 10 	st.w [%sp]100,%d4
8000c0a0:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c0a4:	82 17       	mov %d7,1
8000c0a6:	c2 14       	add %d4,1
8000c0a8:	f4 e7       	st.a [%a14],%a7
8000c0aa:	59 e7 04 00 	st.w [%a14]4,%d7
8000c0ae:	59 a4 20 10 	st.w [%sp]96,%d4
8000c0b2:	8b 84 80 42 	ge %d4,%d4,8
8000c0b6:	d9 ee 08 00 	lea %a14,[%a14]8
8000c0ba:	76 4b       	jz %d4,8000c0d0 <_svfprintf_r+0xa58>
8000c0bc:	60 c4       	mov.a %a4,%d12
8000c0be:	60 b5       	mov.a %a5,%d11
8000c0c0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c0c4:	6d 00 b7 0d 	call 8000dc32 <__ssprint_r>
8000c0c8:	df 02 a3 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c0cc:	d9 ae 10 20 	lea %a14,[%sp]144
8000c0d0:	bd 0f 21 00 	jz.a %a15,8000c112 <_svfprintf_r+0xa9a>
8000c0d4:	19 a4 24 10 	ld.w %d4,[%sp]100
8000c0d8:	d9 a7 02 10 	lea %a7,[%sp]66
8000c0dc:	c2 24       	add %d4,2
8000c0de:	59 a4 24 10 	st.w [%sp]100,%d4
8000c0e2:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c0e6:	82 27       	mov %d7,2
8000c0e8:	c2 14       	add %d4,1
8000c0ea:	f4 e7       	st.a [%a14],%a7
8000c0ec:	59 e7 04 00 	st.w [%a14]4,%d7
8000c0f0:	59 a4 20 10 	st.w [%sp]96,%d4
8000c0f4:	8b 84 80 42 	ge %d4,%d4,8
8000c0f8:	d9 ee 08 00 	lea %a14,[%a14]8
8000c0fc:	76 4b       	jz %d4,8000c112 <_svfprintf_r+0xa9a>
8000c0fe:	60 c4       	mov.a %a4,%d12
8000c100:	60 b5       	mov.a %a5,%d11
8000c102:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c106:	6d 00 96 0d 	call 8000dc32 <__ssprint_r>
8000c10a:	df 02 82 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c10e:	d9 ae 10 20 	lea %a14,[%sp]144
8000c112:	8b 0f 28 42 	ne %d4,%d15,128
8000c116:	df 04 48 80 	jne %d4,0,8000c1a6 <_svfprintf_r+0xb2e>
8000c11a:	58 07       	ld.w %d15,[%sp]28
8000c11c:	7b 00 00 28 	movh %d2,32768
8000c120:	60 23       	mov.a %a3,%d2
8000c122:	a2 af       	sub %d15,%d10
8000c124:	d9 3f e0 a0 	lea %a15,[%a3]3744
8000c128:	bf 1f 3f 00 	jlt %d15,1,8000c1a6 <_svfprintf_r+0xb2e>
8000c12c:	19 a7 24 10 	ld.w %d7,[%sp]100
8000c130:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c134:	8b 1f 81 82 	ge %d8,%d15,17
8000c138:	ec e0       	st.a [%a14]0,%a15
8000c13a:	df 08 20 00 	jeq %d8,0,8000c17a <_svfprintf_r+0xb02>
8000c13e:	1b 14 00 00 	addi %d0,%d4,1
8000c142:	3b 00 01 20 	mov %d2,16
8000c146:	1b 07 01 10 	addi %d1,%d7,16
8000c14a:	59 e2 04 00 	st.w [%a14]4,%d2
8000c14e:	59 a0 20 10 	st.w [%sp]96,%d0
8000c152:	59 a1 24 10 	st.w [%sp]100,%d1
8000c156:	8b 80 80 02 	ge %d0,%d0,8
8000c15a:	d9 ee 08 00 	lea %a14,[%a14]8
8000c15e:	76 0b       	jz %d0,8000c174 <_svfprintf_r+0xafc>
8000c160:	60 c4       	mov.a %a4,%d12
8000c162:	60 b5       	mov.a %a5,%d11
8000c164:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c168:	6d 00 65 0d 	call 8000dc32 <__ssprint_r>
8000c16c:	df 02 51 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c170:	d9 ae 10 20 	lea %a14,[%sp]144
8000c174:	1b 0f ff ff 	addi %d15,%d15,-16
8000c178:	3c da       	j 8000c12c <_svfprintf_r+0xab4>
8000c17a:	c2 14       	add %d4,1
8000c17c:	42 f7       	add %d7,%d15
8000c17e:	6c e1       	st.w [%a14]4,%d15
8000c180:	59 a4 20 10 	st.w [%sp]96,%d4
8000c184:	59 a7 24 10 	st.w [%sp]100,%d7
8000c188:	8b 84 80 42 	ge %d4,%d4,8
8000c18c:	d9 ee 08 00 	lea %a14,[%a14]8
8000c190:	76 4b       	jz %d4,8000c1a6 <_svfprintf_r+0xb2e>
8000c192:	60 c4       	mov.a %a4,%d12
8000c194:	60 b5       	mov.a %a5,%d11
8000c196:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c19a:	6d 00 4c 0d 	call 8000dc32 <__ssprint_r>
8000c19e:	df 02 38 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c1a2:	d9 ae 10 20 	lea %a14,[%sp]144
8000c1a6:	7b 00 00 88 	movh %d8,32768
8000c1aa:	a2 9e       	sub %d14,%d9
8000c1ac:	1b 08 ea 80 	addi %d8,%d8,3744
8000c1b0:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000c1b4:	bf 1e 3c 00 	jlt %d14,1,8000c22c <_svfprintf_r+0xbb4>
8000c1b8:	19 a6 24 10 	ld.w %d6,[%sp]100
8000c1bc:	19 a4 20 10 	ld.w %d4,[%sp]96
8000c1c0:	8b 1e 81 02 	ge %d0,%d14,17
8000c1c4:	74 e8       	st.w [%a14],%d8
8000c1c6:	df 00 1c 00 	jeq %d0,0,8000c1fe <_svfprintf_r+0xb86>
8000c1ca:	c2 14       	add %d4,1
8000c1cc:	1b 06 01 00 	addi %d0,%d6,16
8000c1d0:	ec e1       	st.a [%a14]4,%a15
8000c1d2:	59 a4 20 10 	st.w [%sp]96,%d4
8000c1d6:	59 a0 24 10 	st.w [%sp]100,%d0
8000c1da:	8b 84 80 42 	ge %d4,%d4,8
8000c1de:	d9 ee 08 00 	lea %a14,[%a14]8
8000c1e2:	76 4b       	jz %d4,8000c1f8 <_svfprintf_r+0xb80>
8000c1e4:	60 c4       	mov.a %a4,%d12
8000c1e6:	60 b5       	mov.a %a5,%d11
8000c1e8:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c1ec:	6d 00 23 0d 	call 8000dc32 <__ssprint_r>
8000c1f0:	df 02 0f 83 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c1f4:	d9 ae 10 20 	lea %a14,[%sp]144
8000c1f8:	1b 0e ff ef 	addi %d14,%d14,-16
8000c1fc:	3c de       	j 8000c1b8 <_svfprintf_r+0xb40>
8000c1fe:	c2 14       	add %d4,1
8000c200:	42 e6       	add %d6,%d14
8000c202:	59 ee 04 00 	st.w [%a14]4,%d14
8000c206:	59 a4 20 10 	st.w [%sp]96,%d4
8000c20a:	59 a6 24 10 	st.w [%sp]100,%d6
8000c20e:	8b 84 80 42 	ge %d4,%d4,8
8000c212:	d9 ee 08 00 	lea %a14,[%a14]8
8000c216:	76 4b       	jz %d4,8000c22c <_svfprintf_r+0xbb4>
8000c218:	60 c4       	mov.a %a4,%d12
8000c21a:	60 b5       	mov.a %a5,%d11
8000c21c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c220:	6d 00 09 0d 	call 8000dc32 <__ssprint_r>
8000c224:	df 02 f5 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c228:	d9 ae 10 20 	lea %a14,[%sp]144
8000c22c:	80 df       	mov.d %d15,%a13
8000c22e:	19 ae 24 10 	ld.w %d14,[%sp]100
8000c232:	19 a8 20 10 	ld.w %d8,[%sp]96
8000c236:	6f 8f 1d 80 	jnz.t %d15,8,8000c270 <_svfprintf_r+0xbf8>
8000c23a:	c2 18       	add %d8,1
8000c23c:	59 e9 04 00 	st.w [%a14]4,%d9
8000c240:	42 e9       	add %d9,%d14
8000c242:	59 a8 20 10 	st.w [%sp]96,%d8
8000c246:	74 ed       	st.w [%a14],%d13
8000c248:	59 a9 24 10 	st.w [%sp]100,%d9
8000c24c:	8b 88 80 82 	ge %d8,%d8,8
8000c250:	d9 ef 08 00 	lea %a15,[%a14]8
8000c254:	df 08 79 02 	jeq %d8,0,8000c746 <_svfprintf_r+0x10ce>
8000c258:	60 c4       	mov.a %a4,%d12
8000c25a:	60 b5       	mov.a %a5,%d11
8000c25c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c260:	6d 00 e9 0c 	call 8000dc32 <__ssprint_r>
8000c264:	df 02 d5 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c268:	d9 af 10 20 	lea %a15,[%sp]144
8000c26c:	1d 00 6d 02 	j 8000c746 <_svfprintf_r+0x10ce>
8000c270:	19 a2 10 00 	ld.w %d2,[%sp]16
8000c274:	8b 62 46 f2 	lt %d15,%d2,102
8000c278:	df 0f be 81 	jne %d15,0,8000c5f4 <_svfprintf_r+0xf7c>
8000c27c:	d2 06       	mov %e6,0
8000c27e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000c282:	19 a5 30 00 	ld.w %d5,[%sp]48
8000c286:	6d 00 db 0f 	call 8000e23c <__eqdf2>
8000c28a:	df 02 78 80 	jne %d2,0,8000c37a <_svfprintf_r+0xd02>
8000c28e:	7b 00 00 38 	movh %d3,32768
8000c292:	1b e3 e9 30 	addi %d3,%d3,3742
8000c296:	c2 18       	add %d8,1
8000c298:	74 e3       	st.w [%a14],%d3
8000c29a:	1b 1e 00 90 	addi %d9,%d14,1
8000c29e:	82 13       	mov %d3,1
8000c2a0:	59 a8 20 10 	st.w [%sp]96,%d8
8000c2a4:	59 e3 04 00 	st.w [%a14]4,%d3
8000c2a8:	59 a9 24 10 	st.w [%sp]100,%d9
8000c2ac:	8b 88 80 82 	ge %d8,%d8,8
8000c2b0:	d9 ef 08 00 	lea %a15,[%a14]8
8000c2b4:	76 8b       	jz %d8,8000c2ca <_svfprintf_r+0xc52>
8000c2b6:	60 c4       	mov.a %a4,%d12
8000c2b8:	60 b5       	mov.a %a5,%d11
8000c2ba:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c2be:	6d 00 ba 0c 	call 8000dc32 <__ssprint_r>
8000c2c2:	df 02 a6 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c2c6:	d9 af 10 20 	lea %a15,[%sp]144
8000c2ca:	58 11       	ld.w %d15,[%sp]68
8000c2cc:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c2d0:	3f 2f 05 00 	jlt %d15,%d2,8000c2da <_svfprintf_r+0xc62>
8000c2d4:	80 df       	mov.d %d15,%a13
8000c2d6:	6f 0f 38 02 	jz.t %d15,0,8000c746 <_svfprintf_r+0x10ce>
8000c2da:	58 08       	ld.w %d15,[%sp]32
8000c2dc:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c2e0:	68 1f       	st.w [%a15]4,%d15
8000c2e2:	58 19       	ld.w %d15,[%sp]100
8000c2e4:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c2e8:	42 2f       	add %d15,%d2
8000c2ea:	78 19       	st.w [%sp]100,%d15
8000c2ec:	58 18       	ld.w %d15,[%sp]96
8000c2ee:	e8 03       	st.a [%a15]0,%a3
8000c2f0:	c2 1f       	add %d15,1
8000c2f2:	78 18       	st.w [%sp]96,%d15
8000c2f4:	8b 8f 80 f2 	ge %d15,%d15,8
8000c2f8:	d9 ff 08 00 	lea %a15,[%a15]8
8000c2fc:	6e 0b       	jz %d15,8000c312 <_svfprintf_r+0xc9a>
8000c2fe:	60 c4       	mov.a %a4,%d12
8000c300:	60 b5       	mov.a %a5,%d11
8000c302:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c306:	6d 00 96 0c 	call 8000dc32 <__ssprint_r>
8000c30a:	df 02 82 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c30e:	d9 af 10 20 	lea %a15,[%sp]144
8000c312:	58 05       	ld.w %d15,[%sp]20
8000c314:	7b 00 00 88 	movh %d8,32768
8000c318:	c2 ff       	add %d15,-1
8000c31a:	1b 08 ea 80 	addi %d8,%d8,3744
8000c31e:	3b 00 01 90 	mov %d9,16
8000c322:	bf 1f 12 02 	jlt %d15,1,8000c746 <_svfprintf_r+0x10ce>
8000c326:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c32a:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c32e:	8b 1f 81 42 	ge %d4,%d15,17
8000c332:	68 08       	st.w [%a15]0,%d8
8000c334:	df 04 1c 00 	jeq %d4,0,8000c36c <_svfprintf_r+0xcf4>
8000c338:	c2 13       	add %d3,1
8000c33a:	1b 05 01 40 	addi %d4,%d5,16
8000c33e:	68 19       	st.w [%a15]4,%d9
8000c340:	59 a3 20 10 	st.w [%sp]96,%d3
8000c344:	59 a4 24 10 	st.w [%sp]100,%d4
8000c348:	8b 83 80 32 	ge %d3,%d3,8
8000c34c:	d9 ff 08 00 	lea %a15,[%a15]8
8000c350:	76 3b       	jz %d3,8000c366 <_svfprintf_r+0xcee>
8000c352:	60 c4       	mov.a %a4,%d12
8000c354:	60 b5       	mov.a %a5,%d11
8000c356:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c35a:	6d 00 6c 0c 	call 8000dc32 <__ssprint_r>
8000c35e:	df 02 58 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c362:	d9 af 10 20 	lea %a15,[%sp]144
8000c366:	1b 0f ff ff 	addi %d15,%d15,-16
8000c36a:	3c de       	j 8000c326 <_svfprintf_r+0xcae>
8000c36c:	12 54       	add %d4,%d15,%d5
8000c36e:	68 1f       	st.w [%a15]4,%d15
8000c370:	59 a4 24 10 	st.w [%sp]100,%d4
8000c374:	9a 13       	add %d15,%d3,1
8000c376:	1d 00 e1 01 	j 8000c738 <_svfprintf_r+0x10c0>
8000c37a:	19 a3 04 10 	ld.w %d3,[%sp]68
8000c37e:	ff 13 8e 00 	jge %d3,1,8000c49a <_svfprintf_r+0xe22>
8000c382:	7b 00 00 38 	movh %d3,32768
8000c386:	1b e3 e9 30 	addi %d3,%d3,3742
8000c38a:	c2 18       	add %d8,1
8000c38c:	74 e3       	st.w [%a14],%d3
8000c38e:	1b 1e 00 90 	addi %d9,%d14,1
8000c392:	82 13       	mov %d3,1
8000c394:	59 a8 20 10 	st.w [%sp]96,%d8
8000c398:	59 e3 04 00 	st.w [%a14]4,%d3
8000c39c:	59 a9 24 10 	st.w [%sp]100,%d9
8000c3a0:	8b 88 80 82 	ge %d8,%d8,8
8000c3a4:	d9 ef 08 00 	lea %a15,[%a14]8
8000c3a8:	76 8b       	jz %d8,8000c3be <_svfprintf_r+0xd46>
8000c3aa:	60 c4       	mov.a %a4,%d12
8000c3ac:	60 b5       	mov.a %a5,%d11
8000c3ae:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c3b2:	6d 00 40 0c 	call 8000dc32 <__ssprint_r>
8000c3b6:	df 02 2c 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c3ba:	d9 af 10 20 	lea %a15,[%sp]144
8000c3be:	58 11       	ld.w %d15,[%sp]68
8000c3c0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c3c4:	a6 2f       	or %d15,%d2
8000c3c6:	ee 04       	jnz %d15,8000c3ce <_svfprintf_r+0xd56>
8000c3c8:	80 df       	mov.d %d15,%a13
8000c3ca:	6f 0f be 01 	jz.t %d15,0,8000c746 <_svfprintf_r+0x10ce>
8000c3ce:	58 08       	ld.w %d15,[%sp]32
8000c3d0:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c3d4:	68 1f       	st.w [%a15]4,%d15
8000c3d6:	58 19       	ld.w %d15,[%sp]100
8000c3d8:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c3dc:	42 2f       	add %d15,%d2
8000c3de:	78 19       	st.w [%sp]100,%d15
8000c3e0:	58 18       	ld.w %d15,[%sp]96
8000c3e2:	e8 03       	st.a [%a15]0,%a3
8000c3e4:	c2 1f       	add %d15,1
8000c3e6:	78 18       	st.w [%sp]96,%d15
8000c3e8:	8b 8f 80 f2 	ge %d15,%d15,8
8000c3ec:	d9 ff 08 00 	lea %a15,[%a15]8
8000c3f0:	6e 0b       	jz %d15,8000c406 <_svfprintf_r+0xd8e>
8000c3f2:	60 c4       	mov.a %a4,%d12
8000c3f4:	60 b5       	mov.a %a5,%d11
8000c3f6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c3fa:	6d 00 1c 0c 	call 8000dc32 <__ssprint_r>
8000c3fe:	df 02 08 82 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c402:	d9 af 10 20 	lea %a15,[%sp]144
8000c406:	58 11       	ld.w %d15,[%sp]68
8000c408:	7b 00 00 88 	movh %d8,32768
8000c40c:	32 5f       	rsub %d15
8000c40e:	1b 08 ea 80 	addi %d8,%d8,3744
8000c412:	3b 00 01 90 	mov %d9,16
8000c416:	bf 1f 3a 00 	jlt %d15,1,8000c48a <_svfprintf_r+0xe12>
8000c41a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c41e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c422:	8b 1f 81 42 	ge %d4,%d15,17
8000c426:	68 08       	st.w [%a15]0,%d8
8000c428:	df 04 1c 00 	jeq %d4,0,8000c460 <_svfprintf_r+0xde8>
8000c42c:	c2 13       	add %d3,1
8000c42e:	1b 05 01 40 	addi %d4,%d5,16
8000c432:	68 19       	st.w [%a15]4,%d9
8000c434:	59 a3 20 10 	st.w [%sp]96,%d3
8000c438:	59 a4 24 10 	st.w [%sp]100,%d4
8000c43c:	8b 83 80 32 	ge %d3,%d3,8
8000c440:	d9 ff 08 00 	lea %a15,[%a15]8
8000c444:	76 3b       	jz %d3,8000c45a <_svfprintf_r+0xde2>
8000c446:	60 c4       	mov.a %a4,%d12
8000c448:	60 b5       	mov.a %a5,%d11
8000c44a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c44e:	6d 00 f2 0b 	call 8000dc32 <__ssprint_r>
8000c452:	df 02 de 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c456:	d9 af 10 20 	lea %a15,[%sp]144
8000c45a:	1b 0f ff ff 	addi %d15,%d15,-16
8000c45e:	3c de       	j 8000c41a <_svfprintf_r+0xda2>
8000c460:	68 1f       	st.w [%a15]4,%d15
8000c462:	12 54       	add %d4,%d15,%d5
8000c464:	9a 13       	add %d15,%d3,1
8000c466:	78 18       	st.w [%sp]96,%d15
8000c468:	59 a4 24 10 	st.w [%sp]100,%d4
8000c46c:	8b 8f 80 f2 	ge %d15,%d15,8
8000c470:	d9 ff 08 00 	lea %a15,[%a15]8
8000c474:	6e 0b       	jz %d15,8000c48a <_svfprintf_r+0xe12>
8000c476:	60 c4       	mov.a %a4,%d12
8000c478:	60 b5       	mov.a %a5,%d11
8000c47a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c47e:	6d 00 da 0b 	call 8000dc32 <__ssprint_r>
8000c482:	df 02 c6 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c486:	d9 af 10 20 	lea %a15,[%sp]144
8000c48a:	58 05       	ld.w %d15,[%sp]20
8000c48c:	68 0d       	st.w [%a15]0,%d13
8000c48e:	68 1f       	st.w [%a15]4,%d15
8000c490:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c494:	58 19       	ld.w %d15,[%sp]100
8000c496:	1d 00 4d 01 	j 8000c730 <_svfprintf_r+0x10b8>
8000c49a:	58 05       	ld.w %d15,[%sp]20
8000c49c:	74 ed       	st.w [%a14],%d13
8000c49e:	3f f3 6a 00 	jlt %d3,%d15,8000c572 <_svfprintf_r+0xefa>
8000c4a2:	02 f9       	mov %d9,%d15
8000c4a4:	c2 18       	add %d8,1
8000c4a6:	42 e9       	add %d9,%d14
8000c4a8:	59 a8 20 10 	st.w [%sp]96,%d8
8000c4ac:	6c e1       	st.w [%a14]4,%d15
8000c4ae:	59 a9 24 10 	st.w [%sp]100,%d9
8000c4b2:	8b 88 80 82 	ge %d8,%d8,8
8000c4b6:	d9 ef 08 00 	lea %a15,[%a14]8
8000c4ba:	76 8b       	jz %d8,8000c4d0 <_svfprintf_r+0xe58>
8000c4bc:	60 c4       	mov.a %a4,%d12
8000c4be:	60 b5       	mov.a %a5,%d11
8000c4c0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c4c4:	6d 00 b7 0b 	call 8000dc32 <__ssprint_r>
8000c4c8:	df 02 a3 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c4cc:	d9 af 10 20 	lea %a15,[%sp]144
8000c4d0:	58 11       	ld.w %d15,[%sp]68
8000c4d2:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c4d6:	7b 00 00 88 	movh %d8,32768
8000c4da:	a2 2f       	sub %d15,%d2
8000c4dc:	1b 08 ea 80 	addi %d8,%d8,3744
8000c4e0:	3b 00 01 90 	mov %d9,16
8000c4e4:	bf 1f 3a 00 	jlt %d15,1,8000c558 <_svfprintf_r+0xee0>
8000c4e8:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c4ec:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c4f0:	8b 1f 81 42 	ge %d4,%d15,17
8000c4f4:	68 08       	st.w [%a15]0,%d8
8000c4f6:	df 04 1c 00 	jeq %d4,0,8000c52e <_svfprintf_r+0xeb6>
8000c4fa:	c2 13       	add %d3,1
8000c4fc:	1b 05 01 40 	addi %d4,%d5,16
8000c500:	68 19       	st.w [%a15]4,%d9
8000c502:	59 a3 20 10 	st.w [%sp]96,%d3
8000c506:	59 a4 24 10 	st.w [%sp]100,%d4
8000c50a:	8b 83 80 32 	ge %d3,%d3,8
8000c50e:	d9 ff 08 00 	lea %a15,[%a15]8
8000c512:	76 3b       	jz %d3,8000c528 <_svfprintf_r+0xeb0>
8000c514:	60 c4       	mov.a %a4,%d12
8000c516:	60 b5       	mov.a %a5,%d11
8000c518:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c51c:	6d 00 8b 0b 	call 8000dc32 <__ssprint_r>
8000c520:	df 02 77 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c524:	d9 af 10 20 	lea %a15,[%sp]144
8000c528:	1b 0f ff ff 	addi %d15,%d15,-16
8000c52c:	3c de       	j 8000c4e8 <_svfprintf_r+0xe70>
8000c52e:	68 1f       	st.w [%a15]4,%d15
8000c530:	12 54       	add %d4,%d15,%d5
8000c532:	9a 13       	add %d15,%d3,1
8000c534:	78 18       	st.w [%sp]96,%d15
8000c536:	59 a4 24 10 	st.w [%sp]100,%d4
8000c53a:	8b 8f 80 f2 	ge %d15,%d15,8
8000c53e:	d9 ff 08 00 	lea %a15,[%a15]8
8000c542:	6e 0b       	jz %d15,8000c558 <_svfprintf_r+0xee0>
8000c544:	60 c4       	mov.a %a4,%d12
8000c546:	60 b5       	mov.a %a5,%d11
8000c548:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c54c:	6d 00 73 0b 	call 8000dc32 <__ssprint_r>
8000c550:	df 02 5f 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c554:	d9 af 10 20 	lea %a15,[%sp]144
8000c558:	80 df       	mov.d %d15,%a13
8000c55a:	6f 0f f6 00 	jz.t %d15,0,8000c746 <_svfprintf_r+0x10ce>
8000c55e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c562:	58 08       	ld.w %d15,[%sp]32
8000c564:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c568:	68 1f       	st.w [%a15]4,%d15
8000c56a:	e8 03       	st.a [%a15]0,%a3
8000c56c:	58 19       	ld.w %d15,[%sp]100
8000c56e:	1d 00 e1 00 	j 8000c730 <_svfprintf_r+0x10b8>
8000c572:	c2 18       	add %d8,1
8000c574:	59 e3 04 00 	st.w [%a14]4,%d3
8000c578:	42 e3       	add %d3,%d14
8000c57a:	59 a8 20 10 	st.w [%sp]96,%d8
8000c57e:	59 a3 24 10 	st.w [%sp]100,%d3
8000c582:	8b 88 80 82 	ge %d8,%d8,8
8000c586:	d9 ef 08 00 	lea %a15,[%a14]8
8000c58a:	76 8b       	jz %d8,8000c5a0 <_svfprintf_r+0xf28>
8000c58c:	60 c4       	mov.a %a4,%d12
8000c58e:	60 b5       	mov.a %a5,%d11
8000c590:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c594:	6d 00 4f 0b 	call 8000dc32 <__ssprint_r>
8000c598:	df 02 3b 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c59c:	d9 af 10 20 	lea %a15,[%sp]144
8000c5a0:	58 08       	ld.w %d15,[%sp]32
8000c5a2:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c5a6:	68 1f       	st.w [%a15]4,%d15
8000c5a8:	58 19       	ld.w %d15,[%sp]100
8000c5aa:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c5ae:	42 2f       	add %d15,%d2
8000c5b0:	78 19       	st.w [%sp]100,%d15
8000c5b2:	58 18       	ld.w %d15,[%sp]96
8000c5b4:	99 ae 04 10 	ld.a %a14,[%sp]68
8000c5b8:	c2 1f       	add %d15,1
8000c5ba:	60 d2       	mov.a %a2,%d13
8000c5bc:	e8 03       	st.a [%a15]0,%a3
8000c5be:	78 18       	st.w [%sp]96,%d15
8000c5c0:	8b 8f 80 f2 	ge %d15,%d15,8
8000c5c4:	30 2e       	add.a %a14,%a2
8000c5c6:	d9 ff 08 00 	lea %a15,[%a15]8
8000c5ca:	6e 0b       	jz %d15,8000c5e0 <_svfprintf_r+0xf68>
8000c5cc:	60 c4       	mov.a %a4,%d12
8000c5ce:	60 b5       	mov.a %a5,%d11
8000c5d0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c5d4:	6d 00 2f 0b 	call 8000dc32 <__ssprint_r>
8000c5d8:	df 02 1b 81 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c5dc:	d9 af 10 20 	lea %a15,[%sp]144
8000c5e0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c5e4:	58 11       	ld.w %d15,[%sp]68
8000c5e6:	e8 0e       	st.a [%a15]0,%a14
8000c5e8:	5a f2       	sub %d15,%d2,%d15
8000c5ea:	68 1f       	st.w [%a15]4,%d15
8000c5ec:	19 a2 24 10 	ld.w %d2,[%sp]100
8000c5f0:	1d 00 a0 00 	j 8000c730 <_svfprintf_r+0x10b8>
8000c5f4:	c2 18       	add %d8,1
8000c5f6:	82 13       	mov %d3,1
8000c5f8:	1b 1e 00 90 	addi %d9,%d14,1
8000c5fc:	58 05       	ld.w %d15,[%sp]20
8000c5fe:	59 a8 20 10 	st.w [%sp]96,%d8
8000c602:	74 ed       	st.w [%a14],%d13
8000c604:	59 e3 04 00 	st.w [%a14]4,%d3
8000c608:	59 a9 24 10 	st.w [%sp]100,%d9
8000c60c:	8b 88 80 82 	ge %d8,%d8,8
8000c610:	ff 2f 05 00 	jge %d15,2,8000c61a <_svfprintf_r+0xfa2>
8000c614:	80 d2       	mov.d %d2,%a13
8000c616:	6f 02 81 00 	jz.t %d2,0,8000c718 <_svfprintf_r+0x10a0>
8000c61a:	d9 ef 08 00 	lea %a15,[%a14]8
8000c61e:	76 8b       	jz %d8,8000c634 <_svfprintf_r+0xfbc>
8000c620:	60 c4       	mov.a %a4,%d12
8000c622:	60 b5       	mov.a %a5,%d11
8000c624:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c628:	6d 00 05 0b 	call 8000dc32 <__ssprint_r>
8000c62c:	df 02 f1 80 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c630:	d9 af 10 20 	lea %a15,[%sp]144
8000c634:	58 08       	ld.w %d15,[%sp]32
8000c636:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c63a:	68 1f       	st.w [%a15]4,%d15
8000c63c:	58 19       	ld.w %d15,[%sp]100
8000c63e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c642:	42 2f       	add %d15,%d2
8000c644:	78 19       	st.w [%sp]100,%d15
8000c646:	58 18       	ld.w %d15,[%sp]96
8000c648:	e8 03       	st.a [%a15]0,%a3
8000c64a:	c2 1f       	add %d15,1
8000c64c:	78 18       	st.w [%sp]96,%d15
8000c64e:	8b 8f 80 f2 	ge %d15,%d15,8
8000c652:	d9 ff 08 00 	lea %a15,[%a15]8
8000c656:	6e 0b       	jz %d15,8000c66c <_svfprintf_r+0xff4>
8000c658:	60 c4       	mov.a %a4,%d12
8000c65a:	60 b5       	mov.a %a5,%d11
8000c65c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c660:	6d 00 e9 0a 	call 8000dc32 <__ssprint_r>
8000c664:	df 02 d5 80 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c668:	d9 af 10 20 	lea %a15,[%sp]144
8000c66c:	d2 06       	mov %e6,0
8000c66e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000c672:	19 a5 30 00 	ld.w %d5,[%sp]48
8000c676:	6d 00 03 0e 	call 8000e27c <__nedf2>
8000c67a:	58 05       	ld.w %d15,[%sp]20
8000c67c:	c2 ff       	add %d15,-1
8000c67e:	76 2c       	jz %d2,8000c696 <_svfprintf_r+0x101e>
8000c680:	19 a2 24 10 	ld.w %d2,[%sp]100
8000c684:	60 de       	mov.a %a14,%d13
8000c686:	68 1f       	st.w [%a15]4,%d15
8000c688:	42 2f       	add %d15,%d2
8000c68a:	78 19       	st.w [%sp]100,%d15
8000c68c:	58 18       	ld.w %d15,[%sp]96
8000c68e:	b0 1e       	add.a %a14,1
8000c690:	e8 0e       	st.a [%a15]0,%a14
8000c692:	c2 1f       	add %d15,1
8000c694:	3c 31       	j 8000c6f6 <_svfprintf_r+0x107e>
8000c696:	7b 00 00 88 	movh %d8,32768
8000c69a:	1b 08 ea 80 	addi %d8,%d8,3744
8000c69e:	3b 00 01 90 	mov %d9,16
8000c6a2:	bf 1f 3f 00 	jlt %d15,1,8000c720 <_svfprintf_r+0x10a8>
8000c6a6:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c6aa:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c6ae:	8b 1f 81 42 	ge %d4,%d15,17
8000c6b2:	68 08       	st.w [%a15]0,%d8
8000c6b4:	df 04 1c 00 	jeq %d4,0,8000c6ec <_svfprintf_r+0x1074>
8000c6b8:	c2 13       	add %d3,1
8000c6ba:	1b 05 01 40 	addi %d4,%d5,16
8000c6be:	68 19       	st.w [%a15]4,%d9
8000c6c0:	59 a3 20 10 	st.w [%sp]96,%d3
8000c6c4:	59 a4 24 10 	st.w [%sp]100,%d4
8000c6c8:	8b 83 80 32 	ge %d3,%d3,8
8000c6cc:	d9 ff 08 00 	lea %a15,[%a15]8
8000c6d0:	76 3b       	jz %d3,8000c6e6 <_svfprintf_r+0x106e>
8000c6d2:	60 c4       	mov.a %a4,%d12
8000c6d4:	60 b5       	mov.a %a5,%d11
8000c6d6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c6da:	6d 00 ac 0a 	call 8000dc32 <__ssprint_r>
8000c6de:	df 02 98 80 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c6e2:	d9 af 10 20 	lea %a15,[%sp]144
8000c6e6:	1b 0f ff ff 	addi %d15,%d15,-16
8000c6ea:	3c de       	j 8000c6a6 <_svfprintf_r+0x102e>
8000c6ec:	12 54       	add %d4,%d15,%d5
8000c6ee:	68 1f       	st.w [%a15]4,%d15
8000c6f0:	59 a4 24 10 	st.w [%sp]100,%d4
8000c6f4:	9a 13       	add %d15,%d3,1
8000c6f6:	78 18       	st.w [%sp]96,%d15
8000c6f8:	8b 8f 80 f2 	ge %d15,%d15,8
8000c6fc:	d9 ff 08 00 	lea %a15,[%a15]8
8000c700:	6e 10       	jz %d15,8000c720 <_svfprintf_r+0x10a8>
8000c702:	60 c4       	mov.a %a4,%d12
8000c704:	60 b5       	mov.a %a5,%d11
8000c706:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c70a:	6d 00 94 0a 	call 8000dc32 <__ssprint_r>
8000c70e:	df 02 80 80 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c712:	d9 af 10 20 	lea %a15,[%sp]144
8000c716:	3c 05       	j 8000c720 <_svfprintf_r+0x10a8>
8000c718:	df 08 f5 ff 	jne %d8,0,8000c702 <_svfprintf_r+0x108a>
8000c71c:	d9 ef 08 00 	lea %a15,[%a14]8
8000c720:	58 0e       	ld.w %d15,[%sp]56
8000c722:	d9 a3 0d 10 	lea %a3,[%sp]77
8000c726:	68 1f       	st.w [%a15]4,%d15
8000c728:	19 a2 38 00 	ld.w %d2,[%sp]56
8000c72c:	58 19       	ld.w %d15,[%sp]100
8000c72e:	e8 03       	st.a [%a15]0,%a3
8000c730:	42 2f       	add %d15,%d2
8000c732:	78 19       	st.w [%sp]100,%d15
8000c734:	58 18       	ld.w %d15,[%sp]96
8000c736:	c2 1f       	add %d15,1
8000c738:	78 18       	st.w [%sp]96,%d15
8000c73a:	8b 8f 80 f2 	ge %d15,%d15,8
8000c73e:	df 0f 8d fd 	jne %d15,0,8000c258 <_svfprintf_r+0xbe0>
8000c742:	d9 ff 08 00 	lea %a15,[%a15]8
8000c746:	80 df       	mov.d %d15,%a13
8000c748:	ae 2d       	jnz.t %d15,2,8000c762 <_svfprintf_r+0x10ea>
8000c74a:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000c74e:	0b 2a a0 f1 	max %d15,%d10,%d2
8000c752:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c756:	42 f2       	add %d2,%d15
8000c758:	58 19       	ld.w %d15,[%sp]100
8000c75a:	59 a2 28 00 	st.w [%sp]40,%d2
8000c75e:	6e 49       	jz %d15,8000c7f0 <_svfprintf_r+0x1178>
8000c760:	3c 40       	j 8000c7e0 <_svfprintf_r+0x1168>
8000c762:	58 07       	ld.w %d15,[%sp]28
8000c764:	3b 00 01 80 	mov %d8,16
8000c768:	a2 af       	sub %d15,%d10
8000c76a:	bf 1f f0 7f 	jlt %d15,1,8000c74a <_svfprintf_r+0x10d2>
8000c76e:	91 00 00 28 	movh.a %a2,32768
8000c772:	d9 22 f0 a0 	lea %a2,[%a2]3760 <80000eb0 <blanks.4035>>
8000c776:	19 a5 24 10 	ld.w %d5,[%sp]100 <80000eb0 <blanks.4035>>
8000c77a:	19 a3 20 10 	ld.w %d3,[%sp]96 <80000eb0 <blanks.4035>>
8000c77e:	8b 1f 81 42 	ge %d4,%d15,17
8000c782:	e8 02       	st.a [%a15]0,%a2
8000c784:	df 04 1c 00 	jeq %d4,0,8000c7bc <_svfprintf_r+0x1144>
8000c788:	c2 13       	add %d3,1
8000c78a:	1b 05 01 40 	addi %d4,%d5,16
8000c78e:	68 18       	st.w [%a15]4,%d8
8000c790:	59 a3 20 10 	st.w [%sp]96,%d3
8000c794:	59 a4 24 10 	st.w [%sp]100,%d4
8000c798:	8b 83 80 32 	ge %d3,%d3,8
8000c79c:	d9 ff 08 00 	lea %a15,[%a15]8
8000c7a0:	76 3b       	jz %d3,8000c7b6 <_svfprintf_r+0x113e>
8000c7a2:	60 c4       	mov.a %a4,%d12
8000c7a4:	60 b5       	mov.a %a5,%d11
8000c7a6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c7aa:	6d 00 44 0a 	call 8000dc32 <__ssprint_r>
8000c7ae:	df 02 30 80 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c7b2:	d9 af 10 20 	lea %a15,[%sp]144
8000c7b6:	1b 0f ff ff 	addi %d15,%d15,-16
8000c7ba:	3c da       	j 8000c76e <_svfprintf_r+0x10f6>
8000c7bc:	12 54       	add %d4,%d15,%d5
8000c7be:	68 1f       	st.w [%a15]4,%d15
8000c7c0:	9a 13       	add %d15,%d3,1
8000c7c2:	78 18       	st.w [%sp]96,%d15
8000c7c4:	59 a4 24 10 	st.w [%sp]100,%d4
8000c7c8:	8b 8f 40 f2 	lt %d15,%d15,8
8000c7cc:	ee bf       	jnz %d15,8000c74a <_svfprintf_r+0x10d2>
8000c7ce:	60 c4       	mov.a %a4,%d12
8000c7d0:	60 b5       	mov.a %a5,%d11
8000c7d2:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c7d6:	6d 00 2e 0a 	call 8000dc32 <__ssprint_r>
8000c7da:	df 02 b8 7f 	jeq %d2,0,8000c74a <_svfprintf_r+0x10d2>
8000c7de:	3c 18       	j 8000c80e <_svfprintf_r+0x1196>
8000c7e0:	60 c4       	mov.a %a4,%d12
8000c7e2:	60 b5       	mov.a %a5,%d11
8000c7e4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c7e8:	6d 00 25 0a 	call 8000dc32 <__ssprint_r>
8000c7ec:	df 02 11 80 	jne %d2,0,8000c80e <_svfprintf_r+0x1196>
8000c7f0:	82 0f       	mov %d15,0
8000c7f2:	78 18       	st.w [%sp]96,%d15
8000c7f4:	40 cf       	mov.aa %a15,%a12
8000c7f6:	d9 ae 10 20 	lea %a14,[%sp]144
8000c7fa:	1d ff 77 f7 	j 8000b6e8 <_svfprintf_r+0x70>
8000c7fe:	58 19       	ld.w %d15,[%sp]100
8000c800:	6e 07       	jz %d15,8000c80e <_svfprintf_r+0x1196>
8000c802:	60 c4       	mov.a %a4,%d12
8000c804:	60 b5       	mov.a %a5,%d11
8000c806:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c80a:	6d 00 14 0a 	call 8000dc32 <__ssprint_r>
8000c80e:	60 b3       	mov.a %a3,%d11
8000c810:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c814:	8c 36       	ld.h %d15,[%a3]12
8000c816:	16 40       	and %d15,64
8000c818:	aa f2       	cmov %d2,%d15,-1
8000c81a:	00 90       	ret 

8000c81c <quorem>:
8000c81c:	19 58 10 00 	ld.w %d8,[%a5]16
8000c820:	4c 44       	ld.w %d15,[%a4]16
8000c822:	82 02       	mov %d2,0
8000c824:	3f 8f 88 00 	jlt %d15,%d8,8000c934 <quorem+0x118>
8000c828:	c2 f8       	add %d8,-1
8000c82a:	80 4f       	mov.d %d15,%a4
8000c82c:	8f 28 00 20 	sh %d2,%d8,2
8000c830:	60 2f       	mov.a %a15,%d2
8000c832:	1b 4f 01 90 	addi %d9,%d15,20
8000c836:	d9 5c 14 00 	lea %a12,[%a5]20
8000c83a:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000c83e:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000c842:	54 dc       	ld.w %d12,[%a13]
8000c844:	4c f0       	ld.w %d15,[%a15]0
8000c846:	c2 1c       	add %d12,1
8000c848:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000c84c:	02 ca       	mov %d10,%d12
8000c84e:	df 0c 3d 00 	jeq %d12,0,8000c8c8 <quorem+0xac>
8000c852:	60 96       	mov.a %a6,%d9
8000c854:	40 c2       	mov.aa %a2,%a12
8000c856:	82 05       	mov %d5,0
8000c858:	82 06       	mov %d6,0
8000c85a:	54 22       	ld.w %d2,[%a2]
8000c85c:	40 63       	mov.aa %a3,%a6
8000c85e:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000c862:	8f 02 1f 20 	sh %d2,%d2,-16
8000c866:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000c86a:	b0 42       	add.a %a2,4
8000c86c:	8f 03 1f 40 	sh %d4,%d3,-16
8000c870:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000c874:	44 34       	ld.w %d4,[%a3+]
8000c876:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000c87a:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000c87e:	8f 02 1f 50 	sh %d5,%d2,-16
8000c882:	42 f6       	add %d6,%d15
8000c884:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000c888:	0b 36 80 30 	sub %d3,%d6,%d3
8000c88c:	8f 04 1f 40 	sh %d4,%d4,-16
8000c890:	8f 03 3f f0 	sha %d15,%d3,-16
8000c894:	0b 24 80 20 	sub %d2,%d4,%d2
8000c898:	42 f2       	add %d2,%d15
8000c89a:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000c89e:	8f 02 3f 60 	sha %d6,%d2,-16
8000c8a2:	80 2f       	mov.d %d15,%a2
8000c8a4:	80 d2       	mov.d %d2,%a13
8000c8a6:	74 63       	st.w [%a6],%d3
8000c8a8:	40 36       	mov.aa %a6,%a3
8000c8aa:	7f f2 d8 ff 	jge.u %d2,%d15,8000c85a <quorem+0x3e>
8000c8ae:	4c f0       	ld.w %d15,[%a15]0
8000c8b0:	ee 0c       	jnz %d15,8000c8c8 <quorem+0xac>
8000c8b2:	b0 cf       	add.a %a15,-4
8000c8b4:	80 f2       	mov.d %d2,%a15
8000c8b6:	3f 29 05 80 	jlt.u %d9,%d2,8000c8c0 <quorem+0xa4>
8000c8ba:	59 48 10 00 	st.w [%a4]16,%d8
8000c8be:	3c 05       	j 8000c8c8 <quorem+0xac>
8000c8c0:	4c f0       	ld.w %d15,[%a15]0
8000c8c2:	ee fc       	jnz %d15,8000c8ba <quorem+0x9e>
8000c8c4:	c2 f8       	add %d8,-1
8000c8c6:	3c f6       	j 8000c8b2 <quorem+0x96>
8000c8c8:	40 4e       	mov.aa %a14,%a4
8000c8ca:	6d 00 b9 08 	call 8000da3c <__mcmp>
8000c8ce:	bf 02 32 00 	jlt %d2,0,8000c932 <quorem+0x116>
8000c8d2:	60 92       	mov.a %a2,%d9
8000c8d4:	1b 1c 00 a0 	addi %d10,%d12,1
8000c8d8:	82 04       	mov %d4,0
8000c8da:	40 2f       	mov.aa %a15,%a2
8000c8dc:	44 f3       	ld.w %d3,[%a15+]
8000c8de:	54 c5       	ld.w %d5,[%a12]
8000c8e0:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000c8e4:	8f 05 1f f0 	sh %d15,%d5,-16
8000c8e8:	42 42       	add %d2,%d4
8000c8ea:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000c8ee:	8f 03 1f 30 	sh %d3,%d3,-16
8000c8f2:	a2 42       	sub %d2,%d4
8000c8f4:	8f 02 3f 40 	sha %d4,%d2,-16
8000c8f8:	a2 f3       	sub %d3,%d15
8000c8fa:	42 43       	add %d3,%d4
8000c8fc:	8f 03 3f 40 	sha %d4,%d3,-16
8000c900:	b0 4c       	add.a %a12,4
8000c902:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000c906:	80 df       	mov.d %d15,%a13
8000c908:	80 c2       	mov.d %d2,%a12
8000c90a:	74 23       	st.w [%a2],%d3
8000c90c:	40 f2       	mov.aa %a2,%a15
8000c90e:	7f 2f e6 ff 	jge.u %d15,%d2,8000c8da <quorem+0xbe>
8000c912:	60 92       	mov.a %a2,%d9
8000c914:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000c918:	4c f0       	ld.w %d15,[%a15]0
8000c91a:	ee 0c       	jnz %d15,8000c932 <quorem+0x116>
8000c91c:	b0 cf       	add.a %a15,-4
8000c91e:	80 f2       	mov.d %d2,%a15
8000c920:	3f 29 05 80 	jlt.u %d9,%d2,8000c92a <quorem+0x10e>
8000c924:	59 e8 10 00 	st.w [%a14]16,%d8
8000c928:	3c 05       	j 8000c932 <quorem+0x116>
8000c92a:	4c f0       	ld.w %d15,[%a15]0
8000c92c:	ee fc       	jnz %d15,8000c924 <quorem+0x108>
8000c92e:	c2 f8       	add %d8,-1
8000c930:	3c f6       	j 8000c91c <quorem+0x100>
8000c932:	02 a2       	mov %d2,%d10
8000c934:	00 90       	ret 
	...

8000c938 <_dtoa_r>:
8000c938:	20 58       	sub.a %sp,88
8000c93a:	b5 a5 08 10 	st.a [%sp]72,%a5
8000c93e:	99 45 00 10 	ld.a %a5,[%a4]64
8000c942:	59 a6 1c 00 	st.w [%sp]28,%d6
8000c946:	59 a7 28 00 	st.w [%sp]40,%d7
8000c94a:	b5 a7 38 00 	st.a [%sp]56,%a7
8000c94e:	40 4d       	mov.aa %a13,%a4
8000c950:	0b 45 10 88 	mov %e8,%d5,%d4
8000c954:	40 6c       	mov.aa %a12,%a6
8000c956:	0b 45 10 c8 	mov %e12,%d5,%d4
8000c95a:	bc 5e       	jz.a %a5,8000c976 <_dtoa_r+0x3e>
8000c95c:	19 4f 04 10 	ld.w %d15,[%a4]68
8000c960:	82 12       	mov %d2,1
8000c962:	0f f2 00 20 	sh %d2,%d2,%d15
8000c966:	6c 51       	st.w [%a5]4,%d15
8000c968:	59 52 08 00 	st.w [%a5]8,%d2
8000c96c:	82 0f       	mov %d15,0
8000c96e:	6d 00 99 06 	call 8000d6a0 <_Bfree>
8000c972:	59 df 00 10 	st.w [%a13]64,%d15
8000c976:	ce 96       	jgez %d9,8000c982 <_dtoa_r+0x4a>
8000c978:	82 1f       	mov %d15,1
8000c97a:	6c c0       	st.w [%a12]0,%d15
8000c97c:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000c980:	3c 03       	j 8000c986 <_dtoa_r+0x4e>
8000c982:	82 0f       	mov %d15,0
8000c984:	6c c0       	st.w [%a12]0,%d15
8000c986:	7b 00 ff 27 	movh %d2,32752
8000c98a:	26 d2       	and %d2,%d13
8000c98c:	7b 00 ff 37 	movh %d3,32752
8000c990:	5f 32 22 80 	jne %d2,%d3,8000c9d4 <_dtoa_r+0x9c>
8000c994:	99 a3 08 10 	ld.a %a3,[%sp]72
8000c998:	3b f0 70 22 	mov %d2,9999
8000c99c:	91 00 00 f8 	movh.a %a15,32768
8000c9a0:	74 32       	st.w [%a3],%d2
8000c9a2:	d9 ff c9 b0 	lea %a15,[%a15]3785 <80000ec9 <blanks.4035+0x19>>
8000c9a6:	f6 c8       	jnz %d12,8000c9b6 <_dtoa_r+0x7e>
8000c9a8:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000c9ac:	ee 05       	jnz %d15,8000c9b6 <_dtoa_r+0x7e>
8000c9ae:	91 00 00 f8 	movh.a %a15,32768
8000c9b2:	d9 ff c0 b0 	lea %a15,[%a15]3776 <80000ec0 <blanks.4035+0x10>>
8000c9b6:	99 a3 38 00 	ld.a %a3,[%sp]56 <80000ec0 <blanks.4035+0x10>>
8000c9ba:	40 f2       	mov.aa %a2,%a15
8000c9bc:	bd 03 26 06 	jz.a %a3,8000d608 <_dtoa_r+0xcd0>
8000c9c0:	80 ff       	mov.d %d15,%a15
8000c9c2:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000c9c6:	1b 8f 00 20 	addi %d2,%d15,8
8000c9ca:	c2 3f       	add %d15,3
8000c9cc:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000c9d0:	6c 30       	st.w [%a3]0,%d15
8000c9d2:	00 90       	ret 
8000c9d4:	0b cd 10 48 	mov %e4,%d13,%d12
8000c9d8:	d2 06       	mov %e6,0
8000c9da:	0b cd 10 88 	mov %e8,%d13,%d12
8000c9de:	6d 00 2f 0c 	call 8000e23c <__eqdf2>
8000c9e2:	df 02 13 80 	jne %d2,0,8000ca08 <_dtoa_r+0xd0>
8000c9e6:	99 a3 08 10 	ld.a %a3,[%sp]72
8000c9ea:	d8 0e       	ld.a %a15,[%sp]56
8000c9ec:	82 1f       	mov %d15,1
8000c9ee:	91 00 00 28 	movh.a %a2,32768
8000c9f2:	6c 30       	st.w [%a3]0,%d15
8000c9f4:	d9 22 cd b0 	lea %a2,[%a2]3789 <80000ecd <blanks.4035+0x1d>>
8000c9f8:	bd 0f 08 06 	jz.a %a15,8000d608 <_dtoa_r+0xcd0>
8000c9fc:	7b 00 00 f8 	movh %d15,32768
8000ca00:	1b ef ec f0 	addi %d15,%d15,3790
8000ca04:	68 0f       	st.w [%a15]0,%d15
8000ca06:	00 90       	ret 
8000ca08:	0b cd 10 48 	mov %e4,%d13,%d12
8000ca0c:	40 d4       	mov.aa %a4,%a13
8000ca0e:	d9 a5 14 10 	lea %a5,[%sp]84
8000ca12:	d9 a6 10 10 	lea %a6,[%sp]80
8000ca16:	6d 00 99 08 	call 8000db48 <__d2b>
8000ca1a:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000ca1e:	40 2e       	mov.aa %a14,%a2
8000ca20:	19 aa 10 10 	ld.w %d10,[%sp]80
8000ca24:	76 bd       	jz %d11,8000ca3e <_dtoa_r+0x106>
8000ca26:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000ca2a:	0b cd 10 48 	mov %e4,%d13,%d12
8000ca2e:	7b 00 ff 23 	movh %d2,16368
8000ca32:	0f 2f a0 50 	or %d5,%d15,%d2
8000ca36:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000ca3a:	82 0f       	mov %d15,0
8000ca3c:	3c 22       	j 8000ca80 <_dtoa_r+0x148>
8000ca3e:	19 ab 14 10 	ld.w %d11,[%sp]84
8000ca42:	3b e0 be 4f 	mov %d4,-1042
8000ca46:	42 ab       	add %d11,%d10
8000ca48:	a2 b4       	sub %d4,%d11
8000ca4a:	3b f0 be 2f 	mov %d2,-1041
8000ca4e:	0f 4c 00 40 	sh %d4,%d12,%d4
8000ca52:	3f 2b 0f 00 	jlt %d11,%d2,8000ca70 <_dtoa_r+0x138>
8000ca56:	1b 2b 41 30 	addi %d3,%d11,1042
8000ca5a:	3b e0 c0 4f 	mov %d4,-1010
8000ca5e:	a2 b4       	sub %d4,%d11
8000ca60:	8b 03 00 21 	rsub %d2,%d3,0
8000ca64:	0f 2c 00 20 	sh %d2,%d12,%d2
8000ca68:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000ca6c:	0f f2 a0 40 	or %d4,%d2,%d15
8000ca70:	6d ff 7c f0 	call 8000ab68 <__floatunsidf>
8000ca74:	0b 23 10 48 	mov %e4,%d3,%d2
8000ca78:	9b 03 e1 5f 	addih %d5,%d3,65040
8000ca7c:	c2 fb       	add %d11,-1
8000ca7e:	82 1f       	mov %d15,1
8000ca80:	b7 00 ab 69 	imask %e6,0,19,11
8000ca84:	78 13       	st.w [%sp]76,%d15
8000ca86:	6d ff a2 ee 	call 8000a7ca <__subdf3>
8000ca8a:	7b 30 fd 73 	movh %d7,16339
8000ca8e:	0b 23 10 48 	mov %e4,%d3,%d2
8000ca92:	7b f0 36 66 	movh %d6,25455
8000ca96:	1b 77 7a 78 	addi %d7,%d7,-30809
8000ca9a:	1b 16 36 64 	addi %d6,%d6,17249
8000ca9e:	6d ff b6 ee 	call 8000a80a <__muldf3>
8000caa2:	7b 70 fc 73 	movh %d7,16327
8000caa6:	0b 23 10 48 	mov %e4,%d3,%d2
8000caaa:	7b 10 b6 68 	movh %d6,35681
8000caae:	1b 87 a2 78 	addi %d7,%d7,-30168
8000cab2:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000cab6:	6d ff 6e ee 	call 8000a792 <__adddf3>
8000caba:	02 b4       	mov %d4,%d11
8000cabc:	0b 23 10 88 	mov %e8,%d3,%d2
8000cac0:	6d ff 03 f0 	call 8000aac6 <__floatsidf>
8000cac4:	7b 30 fd 73 	movh %d7,16339
8000cac8:	0b 23 10 48 	mov %e4,%d3,%d2
8000cacc:	7b f0 09 65 	movh %d6,20639
8000cad0:	1b 37 41 74 	addi %d7,%d7,17427
8000cad4:	1b b6 9f 67 	addi %d6,%d6,31227
8000cad8:	6d ff 99 ee 	call 8000a80a <__muldf3>
8000cadc:	0b 89 10 48 	mov %e4,%d9,%d8
8000cae0:	0b 23 10 68 	mov %e6,%d3,%d2
8000cae4:	6d ff 57 ee 	call 8000a792 <__adddf3>
8000cae8:	0b 23 10 48 	mov %e4,%d3,%d2
8000caec:	0b 23 10 88 	mov %e8,%d3,%d2
8000caf0:	6d 00 46 0c 	call 8000e37c <__fixdfsi>
8000caf4:	0b 89 10 48 	mov %e4,%d9,%d8
8000caf8:	d2 06       	mov %e6,0
8000cafa:	59 a2 08 00 	st.w [%sp]8,%d2
8000cafe:	6d 00 1f 0c 	call 8000e33c <__ltdf2>
8000cb02:	ff 02 12 00 	jge %d2,0,8000cb26 <_dtoa_r+0x1ee>
8000cb06:	19 a4 08 00 	ld.w %d4,[%sp]8
8000cb0a:	6d ff de ef 	call 8000aac6 <__floatsidf>
8000cb0e:	0b 89 10 48 	mov %e4,%d9,%d8
8000cb12:	0b 23 10 68 	mov %e6,%d3,%d2
8000cb16:	6d 00 b3 0b 	call 8000e27c <__nedf2>
8000cb1a:	19 a3 08 00 	ld.w %d3,[%sp]8
8000cb1e:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000cb22:	59 a3 08 00 	st.w [%sp]8,%d3
8000cb26:	19 a2 08 00 	ld.w %d2,[%sp]8
8000cb2a:	82 13       	mov %d3,1
8000cb2c:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000cb30:	59 a3 3c 00 	st.w [%sp]60,%d3
8000cb34:	ee 18       	jnz %d15,8000cb64 <_dtoa_r+0x22c>
8000cb36:	91 00 00 f8 	movh.a %a15,32768
8000cb3a:	d9 ff f0 d0 	lea %a15,[%a15]3952 <80000f70 <__mprec_tens>>
8000cb3e:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000cb42:	0b cd 10 68 	mov %e6,%d13,%d12
8000cb46:	09 f4 40 09 	ld.d %e4,[%a15]
8000cb4a:	6d 00 b9 0b 	call 8000e2bc <__gtdf2>
8000cb4e:	8e 28       	jlez %d2,8000cb5e <_dtoa_r+0x226>
8000cb50:	58 02       	ld.w %d15,[%sp]8
8000cb52:	82 02       	mov %d2,0
8000cb54:	c2 ff       	add %d15,-1
8000cb56:	78 02       	st.w [%sp]8,%d15
8000cb58:	59 a2 3c 00 	st.w [%sp]60,%d2
8000cb5c:	3c 04       	j 8000cb64 <_dtoa_r+0x22c>
8000cb5e:	82 03       	mov %d3,0
8000cb60:	59 a3 3c 00 	st.w [%sp]60,%d3
8000cb64:	0b ba 80 b0 	sub %d11,%d10,%d11
8000cb68:	9a fb       	add %d15,%d11,-1
8000cb6a:	82 02       	mov %d2,0
8000cb6c:	78 06       	st.w [%sp]24,%d15
8000cb6e:	59 a2 14 00 	st.w [%sp]20,%d2
8000cb72:	ce f6       	jgez %d15,8000cb7e <_dtoa_r+0x246>
8000cb74:	32 5f       	rsub %d15
8000cb76:	82 03       	mov %d3,0
8000cb78:	78 05       	st.w [%sp]20,%d15
8000cb7a:	59 a3 18 00 	st.w [%sp]24,%d3
8000cb7e:	58 02       	ld.w %d15,[%sp]8
8000cb80:	0e fa       	jltz %d15,8000cb94 <_dtoa_r+0x25c>
8000cb82:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cb86:	78 0d       	st.w [%sp]52,%d15
8000cb88:	42 f2       	add %d2,%d15
8000cb8a:	82 0f       	mov %d15,0
8000cb8c:	59 a2 18 00 	st.w [%sp]24,%d2
8000cb90:	78 08       	st.w [%sp]32,%d15
8000cb92:	3c 0d       	j 8000cbac <_dtoa_r+0x274>
8000cb94:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cb98:	19 a3 08 00 	ld.w %d3,[%sp]8
8000cb9c:	82 0f       	mov %d15,0
8000cb9e:	a2 32       	sub %d2,%d3
8000cba0:	32 53       	rsub %d3
8000cba2:	59 a2 14 00 	st.w [%sp]20,%d2
8000cba6:	59 a3 20 00 	st.w [%sp]32,%d3
8000cbaa:	78 0d       	st.w [%sp]52,%d15
8000cbac:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cbb0:	82 18       	mov %d8,1
8000cbb2:	ff a2 46 80 	jge.u %d2,10,8000cc3e <_dtoa_r+0x306>
8000cbb6:	bf 62 06 00 	jlt %d2,6,8000cbc2 <_dtoa_r+0x28a>
8000cbba:	c2 c2       	add %d2,-4
8000cbbc:	59 a2 1c 00 	st.w [%sp]28,%d2
8000cbc0:	82 08       	mov %d8,0
8000cbc2:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000cbc6:	c2 e3       	add %d3,-2
8000cbc8:	ff 43 4b 80 	jge.u %d3,4,8000cc5e <_dtoa_r+0x326>
8000cbcc:	91 10 00 f8 	movh.a %a15,32769
8000cbd0:	d9 ff 9c fc 	lea %a15,[%a15]-13348 <8000cbdc <_dtoa_r+0x2a4>>
8000cbd4:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000cbd8:	dc 0f       	ji %a15
8000cbda:	00 00       	nop 
8000cbdc:	1d 00 08 00 	j 8000cbec <_dtoa_r+0x2b4>
8000cbe0:	1d 00 1c 00 	j 8000cc18 <_dtoa_r+0x2e0>
8000cbe4:	1d 00 08 00 	j 8000cbf4 <_dtoa_r+0x2bc>
8000cbe8:	1d 00 1c 00 	j 8000cc20 <_dtoa_r+0x2e8>
8000cbec:	82 03       	mov %d3,0
8000cbee:	59 a3 24 00 	st.w [%sp]36,%d3
8000cbf2:	3c 03       	j 8000cbf8 <_dtoa_r+0x2c0>
8000cbf4:	82 1f       	mov %d15,1
8000cbf6:	78 09       	st.w [%sp]36,%d15
8000cbf8:	19 a2 28 00 	ld.w %d2,[%sp]40
8000cbfc:	59 a2 2c 00 	st.w [%sp]44,%d2
8000cc00:	59 a2 10 00 	st.w [%sp]16,%d2
8000cc04:	02 23       	mov %d3,%d2
8000cc06:	ff 12 38 00 	jge %d2,1,8000cc76 <_dtoa_r+0x33e>
8000cc0a:	82 13       	mov %d3,1
8000cc0c:	82 1f       	mov %d15,1
8000cc0e:	59 a3 2c 00 	st.w [%sp]44,%d3
8000cc12:	78 04       	st.w [%sp]16,%d15
8000cc14:	82 12       	mov %d2,1
8000cc16:	3c 21       	j 8000cc58 <_dtoa_r+0x320>
8000cc18:	82 03       	mov %d3,0
8000cc1a:	59 a3 24 00 	st.w [%sp]36,%d3
8000cc1e:	3c 03       	j 8000cc24 <_dtoa_r+0x2ec>
8000cc20:	82 1f       	mov %d15,1
8000cc22:	78 09       	st.w [%sp]36,%d15
8000cc24:	19 a3 08 00 	ld.w %d3,[%sp]8
8000cc28:	19 a2 28 00 	ld.w %d2,[%sp]40
8000cc2c:	42 32       	add %d2,%d3
8000cc2e:	59 a2 2c 00 	st.w [%sp]44,%d2
8000cc32:	c2 12       	add %d2,1
8000cc34:	59 a2 10 00 	st.w [%sp]16,%d2
8000cc38:	8b 12 40 33 	max %d3,%d2,1
8000cc3c:	3c 1d       	j 8000cc76 <_dtoa_r+0x33e>
8000cc3e:	82 0f       	mov %d15,0
8000cc40:	82 12       	mov %d2,1
8000cc42:	82 f3       	mov %d3,-1
8000cc44:	78 07       	st.w [%sp]28,%d15
8000cc46:	82 ff       	mov %d15,-1
8000cc48:	59 a2 24 00 	st.w [%sp]36,%d2
8000cc4c:	59 a3 2c 00 	st.w [%sp]44,%d3
8000cc50:	78 04       	st.w [%sp]16,%d15
8000cc52:	3b 20 01 30 	mov %d3,18
8000cc56:	82 02       	mov %d2,0
8000cc58:	59 a2 28 00 	st.w [%sp]40,%d2
8000cc5c:	3c 0d       	j 8000cc76 <_dtoa_r+0x33e>
8000cc5e:	82 ff       	mov %d15,-1
8000cc60:	82 13       	mov %d3,1
8000cc62:	78 0b       	st.w [%sp]44,%d15
8000cc64:	82 f2       	mov %d2,-1
8000cc66:	82 0f       	mov %d15,0
8000cc68:	59 a3 24 00 	st.w [%sp]36,%d3
8000cc6c:	59 a2 10 00 	st.w [%sp]16,%d2
8000cc70:	3b 20 01 30 	mov %d3,18
8000cc74:	78 0a       	st.w [%sp]40,%d15
8000cc76:	82 05       	mov %d5,0
8000cc78:	59 d5 04 10 	st.w [%a13]68,%d5
8000cc7c:	82 45       	mov %d5,4
8000cc7e:	1b 45 01 00 	addi %d0,%d5,20
8000cc82:	3f 03 09 80 	jlt.u %d3,%d0,8000cc94 <_dtoa_r+0x35c>
8000cc86:	19 d0 04 10 	ld.w %d0,[%a13]68
8000cc8a:	06 15       	sh %d5,1
8000cc8c:	c2 10       	add %d0,1
8000cc8e:	59 d0 04 10 	st.w [%a13]68,%d0
8000cc92:	3c f6       	j 8000cc7e <_dtoa_r+0x346>
8000cc94:	40 d4       	mov.aa %a4,%a13
8000cc96:	19 d4 04 10 	ld.w %d4,[%a13]68
8000cc9a:	6d 00 d8 04 	call 8000d64a <_Balloc>
8000cc9e:	19 a2 10 00 	ld.w %d2,[%sp]16
8000cca2:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000cca6:	8b f2 60 32 	lt.u %d3,%d2,15
8000ccaa:	b5 d2 00 10 	st.a [%a13]64,%a2
8000ccae:	26 38       	and %d8,%d3
8000ccb0:	df 08 97 01 	jeq %d8,0,8000cfde <_dtoa_r+0x6a6>
8000ccb4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000ccb8:	89 ac 40 19 	st.d [%sp]64,%e12
8000ccbc:	bf 13 3f 00 	jlt %d3,1,8000cd3a <_dtoa_r+0x402>
8000ccc0:	91 00 00 f8 	movh.a %a15,32768
8000ccc4:	8f f3 00 31 	and %d3,%d3,15
8000ccc8:	d9 ff f0 d0 	lea %a15,[%a15]3952 <80000f70 <__mprec_tens>>
8000cccc:	19 ae 08 00 	ld.w %d14,[%sp]8 <80000f70 <__mprec_tens>>
8000ccd0:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000ccd4:	86 ce       	sha %d14,-4
8000ccd6:	09 f8 40 09 	ld.d %e8,[%a15]
8000ccda:	82 2a       	mov %d10,2
8000ccdc:	6f 4e 11 00 	jz.t %d14,4,8000ccfe <_dtoa_r+0x3c6>
8000cce0:	91 00 00 f8 	movh.a %a15,32768
8000cce4:	0b cd 10 48 	mov %e4,%d13,%d12
8000cce8:	d9 ff c8 d0 	lea %a15,[%a15]3912 <80000f48 <__mprec_bigtens>>
8000ccec:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000ccf0:	6d ff 5f ee 	call 8000a9ae <__divdf3>
8000ccf4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000ccf8:	8f fe 00 e1 	and %d14,%d14,15
8000ccfc:	82 3a       	mov %d10,3
8000ccfe:	7b 00 00 b8 	movh %d11,32768
8000cd02:	82 0f       	mov %d15,0
8000cd04:	1b 8b f4 b0 	addi %d11,%d11,3912
8000cd08:	df 0e 12 00 	jeq %d14,0,8000cd2c <_dtoa_r+0x3f4>
8000cd0c:	6f 0e 0d 00 	jz.t %d14,0,8000cd26 <_dtoa_r+0x3ee>
8000cd10:	60 b2       	mov.a %a2,%d11
8000cd12:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000cd14:	0b 89 10 48 	mov %e4,%d9,%d8
8000cd18:	09 f6 40 09 	ld.d %e6,[%a15]
8000cd1c:	6d ff 77 ed 	call 8000a80a <__muldf3>
8000cd20:	0b 23 10 88 	mov %e8,%d3,%d2
8000cd24:	c2 1a       	add %d10,1
8000cd26:	86 fe       	sha %d14,-1
8000cd28:	c2 1f       	add %d15,1
8000cd2a:	3c ef       	j 8000cd08 <_dtoa_r+0x3d0>
8000cd2c:	0b cd 10 48 	mov %e4,%d13,%d12
8000cd30:	0b 89 10 68 	mov %e6,%d9,%d8
8000cd34:	6d ff 3d ee 	call 8000a9ae <__divdf3>
8000cd38:	3c 2c       	j 8000cd90 <_dtoa_r+0x458>
8000cd3a:	19 a8 08 00 	ld.w %d8,[%sp]8
8000cd3e:	82 2a       	mov %d10,2
8000cd40:	32 58       	rsub %d8
8000cd42:	df 08 29 00 	jeq %d8,0,8000cd94 <_dtoa_r+0x45c>
8000cd46:	91 00 00 f8 	movh.a %a15,32768
8000cd4a:	8f f8 00 31 	and %d3,%d8,15
8000cd4e:	d9 ff f0 d0 	lea %a15,[%a15]3952 <80000f70 <__mprec_tens>>
8000cd52:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000cd56:	09 a4 40 19 	ld.d %e4,[%sp]64
8000cd5a:	09 f6 40 09 	ld.d %e6,[%a15]
8000cd5e:	7b 00 00 c8 	movh %d12,32768
8000cd62:	6d ff 54 ed 	call 8000a80a <__muldf3>
8000cd66:	82 09       	mov %d9,0
8000cd68:	86 c8       	sha %d8,-4
8000cd6a:	1b 8c f4 c0 	addi %d12,%d12,3912
8000cd6e:	df 08 11 00 	jeq %d8,0,8000cd90 <_dtoa_r+0x458>
8000cd72:	6f 08 0c 00 	jz.t %d8,0,8000cd8a <_dtoa_r+0x452>
8000cd76:	60 c3       	mov.a %a3,%d12
8000cd78:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000cd7c:	0b 23 10 48 	mov %e4,%d3,%d2
8000cd80:	09 f6 40 09 	ld.d %e6,[%a15]
8000cd84:	c2 1a       	add %d10,1
8000cd86:	6d ff 42 ed 	call 8000a80a <__muldf3>
8000cd8a:	86 f8       	sha %d8,-1
8000cd8c:	c2 19       	add %d9,1
8000cd8e:	3c f0       	j 8000cd6e <_dtoa_r+0x436>
8000cd90:	0b 23 10 c8 	mov %e12,%d3,%d2
8000cd94:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000cd98:	df 02 23 00 	jeq %d2,0,8000cdde <_dtoa_r+0x4a6>
8000cd9c:	0b cd 10 48 	mov %e4,%d13,%d12
8000cda0:	b7 00 2a 6a 	imask %e6,0,20,10
8000cda4:	6d 00 cc 0a 	call 8000e33c <__ltdf2>
8000cda8:	ff 02 20 00 	jge %d2,0,8000cde8 <_dtoa_r+0x4b0>
8000cdac:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cdb0:	df 03 21 00 	jeq %d3,0,8000cdf2 <_dtoa_r+0x4ba>
8000cdb4:	58 0b       	ld.w %d15,[%sp]44
8000cdb6:	bf 1f 12 01 	jlt %d15,1,8000cfda <_dtoa_r+0x6a2>
8000cdba:	19 a2 08 00 	ld.w %d2,[%sp]8
8000cdbe:	0b cd 10 48 	mov %e4,%d13,%d12
8000cdc2:	c2 f2       	add %d2,-1
8000cdc4:	82 06       	mov %d6,0
8000cdc6:	7b 40 02 74 	movh %d7,16420
8000cdca:	59 a2 30 00 	st.w [%sp]48,%d2
8000cdce:	6d ff 1e ed 	call 8000a80a <__muldf3>
8000cdd2:	c2 1a       	add %d10,1
8000cdd4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000cdd8:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000cddc:	3c 10       	j 8000cdfc <_dtoa_r+0x4c4>
8000cdde:	19 a3 08 00 	ld.w %d3,[%sp]8
8000cde2:	59 a3 30 00 	st.w [%sp]48,%d3
8000cde6:	3c 03       	j 8000cdec <_dtoa_r+0x4b4>
8000cde8:	58 02       	ld.w %d15,[%sp]8
8000cdea:	78 0c       	st.w [%sp]48,%d15
8000cdec:	99 ac 10 00 	ld.a %a12,[%sp]16
8000cdf0:	3c 06       	j 8000cdfc <_dtoa_r+0x4c4>
8000cdf2:	19 a2 08 00 	ld.w %d2,[%sp]8
8000cdf6:	a0 0c       	mov.a %a12,0
8000cdf8:	59 a2 30 00 	st.w [%sp]48,%d2
8000cdfc:	02 a4       	mov %d4,%d10
8000cdfe:	6d ff 64 ee 	call 8000aac6 <__floatsidf>
8000ce02:	0b cd 10 68 	mov %e6,%d13,%d12
8000ce06:	0b 23 10 48 	mov %e4,%d3,%d2
8000ce0a:	6d ff 00 ed 	call 8000a80a <__muldf3>
8000ce0e:	0b 23 10 48 	mov %e4,%d3,%d2
8000ce12:	82 06       	mov %d6,0
8000ce14:	7b c0 01 74 	movh %d7,16412
8000ce18:	6d ff bd ec 	call 8000a792 <__adddf3>
8000ce1c:	0b 23 10 a8 	mov %e10,%d3,%d2
8000ce20:	0b 23 10 e8 	mov %e14,%d3,%d2
8000ce24:	60 b2       	mov.a %a2,%d11
8000ce26:	11 02 cc ff 	addih.a %a15,%a2,64704
8000ce2a:	80 ff       	mov.d %d15,%a15
8000ce2c:	bd 0c 1e 80 	jnz.a %a12,8000ce68 <_dtoa_r+0x530>
8000ce30:	0b cd 10 48 	mov %e4,%d13,%d12
8000ce34:	82 06       	mov %d6,0
8000ce36:	7b 40 01 74 	movh %d7,16404
8000ce3a:	6d ff c8 ec 	call 8000a7ca <__subdf3>
8000ce3e:	80 f7       	mov.d %d7,%a15
8000ce40:	0b 23 10 48 	mov %e4,%d3,%d2
8000ce44:	02 e6       	mov %d6,%d14
8000ce46:	0b 23 10 88 	mov %e8,%d3,%d2
8000ce4a:	6d 00 39 0a 	call 8000e2bc <__gtdf2>
8000ce4e:	ff 12 8e 02 	jge %d2,1,8000d36a <_dtoa_r+0xa32>
8000ce52:	0b 89 10 48 	mov %e4,%d9,%d8
8000ce56:	02 e6       	mov %d6,%d14
8000ce58:	9b 0b cc 77 	addih %d7,%d11,31936
8000ce5c:	6d 00 70 0a 	call 8000e33c <__ltdf2>
8000ce60:	bf 02 7d 02 	jlt %d2,0,8000d35a <_dtoa_r+0xa22>
8000ce64:	1d 00 bb 00 	j 8000cfda <_dtoa_r+0x6a2>
8000ce68:	80 c5       	mov.d %d5,%a12
8000ce6a:	91 00 00 f8 	movh.a %a15,32768
8000ce6e:	19 a2 24 00 	ld.w %d2,[%sp]36
8000ce72:	d9 ff f0 d0 	lea %a15,[%a15]3952 <80000f70 <__mprec_tens>>
8000ce76:	c2 f5       	add %d5,-1
8000ce78:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000ce7c:	df 02 57 00 	jeq %d2,0,8000cf2a <_dtoa_r+0x5f2>
8000ce80:	b7 00 a9 4a 	imask %e4,0,21,9
8000ce84:	09 f6 40 09 	ld.d %e6,[%a15]
8000ce88:	6d ff 93 ed 	call 8000a9ae <__divdf3>
8000ce8c:	0b ef 10 68 	mov %e6,%d15,%d14
8000ce90:	0b 23 10 48 	mov %e4,%d3,%d2
8000ce94:	6d ff 9b ec 	call 8000a7ca <__subdf3>
8000ce98:	d8 03       	ld.a %a15,[%sp]12
8000ce9a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000ce9e:	0b cd 10 48 	mov %e4,%d13,%d12
8000cea2:	80 fe       	mov.d %d14,%a15
8000cea4:	6d 00 6c 0a 	call 8000e37c <__fixdfsi>
8000cea8:	02 24       	mov %d4,%d2
8000ceaa:	02 2f       	mov %d15,%d2
8000ceac:	6d ff 0d ee 	call 8000aac6 <__floatsidf>
8000ceb0:	0b cd 10 48 	mov %e4,%d13,%d12
8000ceb4:	0b 23 10 68 	mov %e6,%d3,%d2
8000ceb8:	c2 1e       	add %d14,1
8000ceba:	6d ff 88 ec 	call 8000a7ca <__subdf3>
8000cebe:	1b 0f 03 50 	addi %d5,%d15,48
8000cec2:	28 05       	st.b [%a15]0,%d5
8000cec4:	0b ab 10 68 	mov %e6,%d11,%d10
8000cec8:	0b 23 10 48 	mov %e4,%d3,%d2
8000cecc:	0b 23 10 88 	mov %e8,%d3,%d2
8000ced0:	6d 00 36 0a 	call 8000e33c <__ltdf2>
8000ced4:	bf 02 86 03 	jlt %d2,0,8000d5e0 <_dtoa_r+0xca8>
8000ced8:	b7 00 2a 4a 	imask %e4,0,20,10
8000cedc:	0b 89 10 68 	mov %e6,%d9,%d8
8000cee0:	6d ff 75 ec 	call 8000a7ca <__subdf3>
8000cee4:	0b ab 10 68 	mov %e6,%d11,%d10
8000cee8:	0b 23 10 48 	mov %e4,%d3,%d2
8000ceec:	6d 00 28 0a 	call 8000e33c <__ltdf2>
8000cef0:	bf 02 ea 00 	jlt %d2,0,8000d0c4 <_dtoa_r+0x78c>
8000cef4:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000cef8:	02 e5       	mov %d5,%d14
8000cefa:	80 cf       	mov.d %d15,%a12
8000cefc:	a2 35       	sub %d5,%d3
8000cefe:	7f f5 6e 00 	jge %d5,%d15,8000cfda <_dtoa_r+0x6a2>
8000cf02:	0b ab 10 48 	mov %e4,%d11,%d10
8000cf06:	82 06       	mov %d6,0
8000cf08:	7b 40 02 74 	movh %d7,16420
8000cf0c:	6d ff 7f ec 	call 8000a80a <__muldf3>
8000cf10:	0b 89 10 48 	mov %e4,%d9,%d8
8000cf14:	82 06       	mov %d6,0
8000cf16:	7b 40 02 74 	movh %d7,16420
8000cf1a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000cf1e:	6d ff 76 ec 	call 8000a80a <__muldf3>
8000cf22:	60 ef       	mov.a %a15,%d14
8000cf24:	0b 23 10 c8 	mov %e12,%d3,%d2
8000cf28:	3c bb       	j 8000ce9e <_dtoa_r+0x566>
8000cf2a:	0b ef 10 68 	mov %e6,%d15,%d14
8000cf2e:	09 f4 40 09 	ld.d %e4,[%a15]
8000cf32:	6d ff 6c ec 	call 8000a80a <__muldf3>
8000cf36:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000cf3a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000cf3e:	30 c3       	add.a %a3,%a12
8000cf40:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000cf44:	80 3e       	mov.d %d14,%a3
8000cf46:	0b cd 10 48 	mov %e4,%d13,%d12
8000cf4a:	d9 cf 01 00 	lea %a15,[%a12]1
8000cf4e:	6d 00 17 0a 	call 8000e37c <__fixdfsi>
8000cf52:	02 24       	mov %d4,%d2
8000cf54:	02 2f       	mov %d15,%d2
8000cf56:	6d ff b8 ed 	call 8000aac6 <__floatsidf>
8000cf5a:	0b cd 10 48 	mov %e4,%d13,%d12
8000cf5e:	0b 23 10 68 	mov %e6,%d3,%d2
8000cf62:	6d ff 34 ec 	call 8000a7ca <__subdf3>
8000cf66:	1b 0f 03 50 	addi %d5,%d15,48
8000cf6a:	0b 23 10 88 	mov %e8,%d3,%d2
8000cf6e:	80 f2       	mov.d %d2,%a15
8000cf70:	34 c5       	st.b [%a12],%d5
8000cf72:	5f e2 29 80 	jne %d2,%d14,8000cfc4 <_dtoa_r+0x68c>
8000cf76:	0b ab 10 48 	mov %e4,%d11,%d10
8000cf7a:	b7 00 a9 6a 	imask %e6,0,21,9
8000cf7e:	6d ff 0a ec 	call 8000a792 <__adddf3>
8000cf82:	0b 89 10 48 	mov %e4,%d9,%d8
8000cf86:	0b 23 10 68 	mov %e6,%d3,%d2
8000cf8a:	6d 00 99 09 	call 8000e2bc <__gtdf2>
8000cf8e:	ff 12 9b 00 	jge %d2,1,8000d0c4 <_dtoa_r+0x78c>
8000cf92:	b7 00 a9 4a 	imask %e4,0,21,9
8000cf96:	0b ab 10 68 	mov %e6,%d11,%d10
8000cf9a:	6d ff 18 ec 	call 8000a7ca <__subdf3>
8000cf9e:	0b 89 10 48 	mov %e4,%d9,%d8
8000cfa2:	0b 23 10 68 	mov %e6,%d3,%d2
8000cfa6:	6d 00 cb 09 	call 8000e33c <__ltdf2>
8000cfaa:	ff 02 18 00 	jge %d2,0,8000cfda <_dtoa_r+0x6a2>
8000cfae:	60 e2       	mov.a %a2,%d14
8000cfb0:	60 ef       	mov.a %a15,%d14
8000cfb2:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000cfb6:	b0 ff       	add.a %a15,-1
8000cfb8:	8b 0f 03 f2 	eq %d15,%d15,48
8000cfbc:	df 0f 12 03 	jeq %d15,0,8000d5e0 <_dtoa_r+0xca8>
8000cfc0:	80 fe       	mov.d %d14,%a15
8000cfc2:	3c f6       	j 8000cfae <_dtoa_r+0x676>
8000cfc4:	0b 89 10 48 	mov %e4,%d9,%d8
8000cfc8:	82 06       	mov %d6,0
8000cfca:	7b 40 02 74 	movh %d7,16420
8000cfce:	6d ff 1e ec 	call 8000a80a <__muldf3>
8000cfd2:	40 fc       	mov.aa %a12,%a15
8000cfd4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000cfd8:	3c b7       	j 8000cf46 <_dtoa_r+0x60e>
8000cfda:	09 ac 40 19 	ld.d %e12,[%sp]64
8000cfde:	19 a3 14 10 	ld.w %d3,[%sp]84
8000cfe2:	19 a2 08 00 	ld.w %d2,[%sp]8
8000cfe6:	8b 03 80 52 	ge %d5,%d3,0
8000cfea:	8b f2 40 54 	and.lt %d5,%d2,15
8000cfee:	df 05 9e 00 	jeq %d5,0,8000d12a <_dtoa_r+0x7f2>
8000cff2:	91 00 00 f8 	movh.a %a15,32768
8000cff6:	d9 ff f0 d0 	lea %a15,[%a15]3952 <80000f70 <__mprec_tens>>
8000cffa:	19 a3 10 00 	ld.w %d3,[%sp]16 <80000f70 <__mprec_tens>>
8000cffe:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000d002:	19 a2 28 00 	ld.w %d2,[%sp]40
8000d006:	fa 13       	lt %d15,%d3,1
8000d008:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000d00c:	09 f8 40 09 	ld.d %e8,[%a15]
8000d010:	6e 16       	jz %d15,8000d03c <_dtoa_r+0x704>
8000d012:	df 03 a4 81 	jne %d3,0,8000d35a <_dtoa_r+0xa22>
8000d016:	0b 89 10 48 	mov %e4,%d9,%d8
8000d01a:	82 06       	mov %d6,0
8000d01c:	7b 40 01 74 	movh %d7,16404
8000d020:	6d ff f5 eb 	call 8000a80a <__muldf3>
8000d024:	0b cd 10 68 	mov %e6,%d13,%d12
8000d028:	0b 23 10 48 	mov %e4,%d3,%d2
8000d02c:	a0 0c       	mov.a %a12,0
8000d02e:	6d 00 67 09 	call 8000e2fc <__gedf2>
8000d032:	a0 0f       	mov.a %a15,0
8000d034:	ff 02 95 01 	jge %d2,0,8000d35e <_dtoa_r+0xa26>
8000d038:	1d 00 9d 01 	j 8000d372 <_dtoa_r+0xa3a>
8000d03c:	d8 03       	ld.a %a15,[%sp]12
8000d03e:	0b cd 10 a8 	mov %e10,%d13,%d12
8000d042:	0b 89 10 68 	mov %e6,%d9,%d8
8000d046:	0b ab 10 48 	mov %e4,%d11,%d10
8000d04a:	80 fe       	mov.d %d14,%a15
8000d04c:	6d ff b1 ec 	call 8000a9ae <__divdf3>
8000d050:	0b 23 10 48 	mov %e4,%d3,%d2
8000d054:	c2 1e       	add %d14,1
8000d056:	6d 00 93 09 	call 8000e37c <__fixdfsi>
8000d05a:	02 24       	mov %d4,%d2
8000d05c:	02 2f       	mov %d15,%d2
8000d05e:	6d ff 34 ed 	call 8000aac6 <__floatsidf>
8000d062:	0b 89 10 68 	mov %e6,%d9,%d8
8000d066:	0b 23 10 48 	mov %e4,%d3,%d2
8000d06a:	6d ff d0 eb 	call 8000a80a <__muldf3>
8000d06e:	0b ab 10 48 	mov %e4,%d11,%d10
8000d072:	0b 23 10 68 	mov %e6,%d3,%d2
8000d076:	6d ff aa eb 	call 8000a7ca <__subdf3>
8000d07a:	0b 23 10 48 	mov %e4,%d3,%d2
8000d07e:	1b 0f 03 30 	addi %d3,%d15,48
8000d082:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000d086:	28 03       	st.b [%a15]0,%d3
8000d088:	02 e3       	mov %d3,%d14
8000d08a:	a2 23       	sub %d3,%d2
8000d08c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000d090:	5f 23 3c 80 	jne %d3,%d2,8000d108 <_dtoa_r+0x7d0>
8000d094:	0b 45 10 68 	mov %e6,%d5,%d4
8000d098:	6d ff 7d eb 	call 8000a792 <__adddf3>
8000d09c:	0b 89 10 68 	mov %e6,%d9,%d8
8000d0a0:	0b 23 10 48 	mov %e4,%d3,%d2
8000d0a4:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d0a8:	6d 00 0a 09 	call 8000e2bc <__gtdf2>
8000d0ac:	4e 2e       	jgtz %d2,8000d0c8 <_dtoa_r+0x790>
8000d0ae:	0b ab 10 48 	mov %e4,%d11,%d10
8000d0b2:	0b 89 10 68 	mov %e6,%d9,%d8
8000d0b6:	6d 00 c3 08 	call 8000e23c <__eqdf2>
8000d0ba:	df 02 95 82 	jne %d2,0,8000d5e4 <_dtoa_r+0xcac>
8000d0be:	ae 05       	jnz.t %d15,0,8000d0c8 <_dtoa_r+0x790>
8000d0c0:	1d 00 92 02 	j 8000d5e4 <_dtoa_r+0xcac>
8000d0c4:	58 0c       	ld.w %d15,[%sp]48
8000d0c6:	78 02       	st.w [%sp]8,%d15
8000d0c8:	58 03       	ld.w %d15,[%sp]12
8000d0ca:	a2 ef       	sub %d15,%d14
8000d0cc:	46 0f       	not %d15
8000d0ce:	60 e2       	mov.a %a2,%d14
8000d0d0:	60 ef       	mov.a %a15,%d14
8000d0d2:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000d0d6:	b0 ff       	add.a %a15,-1
8000d0d8:	8b 93 03 32 	eq %d3,%d3,57
8000d0dc:	df 03 11 00 	jeq %d3,0,8000d0fe <_dtoa_r+0x7c6>
8000d0e0:	9f 0f 0d 80 	jned %d15,0,8000d0fa <_dtoa_r+0x7c2>
8000d0e4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d0e8:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d0ec:	c2 13       	add %d3,1
8000d0ee:	da 30       	mov %d15,48
8000d0f0:	59 a3 08 00 	st.w [%sp]8,%d3
8000d0f4:	2c 30       	st.b [%a3]0,%d15
8000d0f6:	40 3f       	mov.aa %a15,%a3
8000d0f8:	3c 03       	j 8000d0fe <_dtoa_r+0x7c6>
8000d0fa:	80 fe       	mov.d %d14,%a15
8000d0fc:	3c e9       	j 8000d0ce <_dtoa_r+0x796>
8000d0fe:	0c f0       	ld.bu %d15,[%a15]0
8000d100:	c2 1f       	add %d15,1
8000d102:	28 0f       	st.b [%a15]0,%d15
8000d104:	1d 00 70 02 	j 8000d5e4 <_dtoa_r+0xcac>
8000d108:	82 06       	mov %d6,0
8000d10a:	7b 40 02 74 	movh %d7,16420
8000d10e:	6d ff 7e eb 	call 8000a80a <__muldf3>
8000d112:	d2 06       	mov %e6,0
8000d114:	0b 23 10 48 	mov %e4,%d3,%d2
8000d118:	0b 23 10 a8 	mov %e10,%d3,%d2
8000d11c:	60 ef       	mov.a %a15,%d14
8000d11e:	6d 00 8f 08 	call 8000e23c <__eqdf2>
8000d122:	df 02 90 ff 	jne %d2,0,8000d042 <_dtoa_r+0x70a>
8000d126:	1d 00 5f 02 	j 8000d5e4 <_dtoa_r+0xcac>
8000d12a:	19 a2 24 00 	ld.w %d2,[%sp]36
8000d12e:	58 08       	ld.w %d15,[%sp]32
8000d130:	19 a8 14 00 	ld.w %d8,[%sp]20
8000d134:	a0 0f       	mov.a %a15,0
8000d136:	df 02 3b 00 	jeq %d2,0,8000d1ac <_dtoa_r+0x874>
8000d13a:	58 07       	ld.w %d15,[%sp]28
8000d13c:	ff 2f 10 00 	jge %d15,2,8000d15c <_dtoa_r+0x824>
8000d140:	58 13       	ld.w %d15,[%sp]76
8000d142:	6e 05       	jz %d15,8000d14c <_dtoa_r+0x814>
8000d144:	1b 33 43 30 	addi %d3,%d3,1075
8000d148:	58 08       	ld.w %d15,[%sp]32
8000d14a:	3c 22       	j 8000d18e <_dtoa_r+0x856>
8000d14c:	19 a3 10 10 	ld.w %d3,[%sp]80
8000d150:	58 08       	ld.w %d15,[%sp]32
8000d152:	8b 63 03 31 	rsub %d3,%d3,54
8000d156:	19 a8 14 00 	ld.w %d8,[%sp]20
8000d15a:	3c 1a       	j 8000d18e <_dtoa_r+0x856>
8000d15c:	58 04       	ld.w %d15,[%sp]16
8000d15e:	19 a2 20 00 	ld.w %d2,[%sp]32
8000d162:	c2 ff       	add %d15,-1
8000d164:	3f f2 04 00 	jlt %d2,%d15,8000d16c <_dtoa_r+0x834>
8000d168:	5a f2       	sub %d15,%d2,%d15
8000d16a:	3c 0b       	j 8000d180 <_dtoa_r+0x848>
8000d16c:	19 a3 20 00 	ld.w %d3,[%sp]32
8000d170:	78 08       	st.w [%sp]32,%d15
8000d172:	52 32       	sub %d2,%d15,%d3
8000d174:	19 a3 34 00 	ld.w %d3,[%sp]52
8000d178:	82 0f       	mov %d15,0
8000d17a:	42 23       	add %d3,%d2
8000d17c:	59 a3 34 00 	st.w [%sp]52,%d3
8000d180:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d184:	19 a8 14 00 	ld.w %d8,[%sp]20
8000d188:	ce 33       	jgez %d3,8000d18e <_dtoa_r+0x856>
8000d18a:	a2 38       	sub %d8,%d3
8000d18c:	82 03       	mov %d3,0
8000d18e:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d192:	40 d4       	mov.aa %a4,%a13
8000d194:	42 32       	add %d2,%d3
8000d196:	59 a2 14 00 	st.w [%sp]20,%d2
8000d19a:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d19e:	82 14       	mov %d4,1
8000d1a0:	42 32       	add %d2,%d3
8000d1a2:	59 a2 18 00 	st.w [%sp]24,%d2
8000d1a6:	6d 00 1b 03 	call 8000d7dc <__i2b>
8000d1aa:	40 2f       	mov.aa %a15,%a2
8000d1ac:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d1b0:	8b 18 80 32 	ge %d3,%d8,1
8000d1b4:	8b 12 80 34 	and.ge %d3,%d2,1
8000d1b8:	76 3e       	jz %d3,8000d1d4 <_dtoa_r+0x89c>
8000d1ba:	0b 82 80 31 	min %d3,%d2,%d8
8000d1be:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d1c2:	a2 38       	sub %d8,%d3
8000d1c4:	a2 32       	sub %d2,%d3
8000d1c6:	59 a2 14 00 	st.w [%sp]20,%d2
8000d1ca:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d1ce:	a2 32       	sub %d2,%d3
8000d1d0:	59 a2 18 00 	st.w [%sp]24,%d2
8000d1d4:	19 a3 20 00 	ld.w %d3,[%sp]32
8000d1d8:	bf 13 27 00 	jlt %d3,1,8000d226 <_dtoa_r+0x8ee>
8000d1dc:	19 a2 24 00 	ld.w %d2,[%sp]36
8000d1e0:	df 02 1c 00 	jeq %d2,0,8000d218 <_dtoa_r+0x8e0>
8000d1e4:	bf 1f 13 00 	jlt %d15,1,8000d20a <_dtoa_r+0x8d2>
8000d1e8:	40 f5       	mov.aa %a5,%a15
8000d1ea:	02 f4       	mov %d4,%d15
8000d1ec:	40 d4       	mov.aa %a4,%a13
8000d1ee:	6d 00 8c 03 	call 8000d906 <__pow5mult>
8000d1f2:	40 e6       	mov.aa %a6,%a14
8000d1f4:	40 d4       	mov.aa %a4,%a13
8000d1f6:	40 25       	mov.aa %a5,%a2
8000d1f8:	40 2f       	mov.aa %a15,%a2
8000d1fa:	6d 00 f9 02 	call 8000d7ec <__multiply>
8000d1fe:	40 e5       	mov.aa %a5,%a14
8000d200:	40 2c       	mov.aa %a12,%a2
8000d202:	40 d4       	mov.aa %a4,%a13
8000d204:	6d 00 4e 02 	call 8000d6a0 <_Bfree>
8000d208:	40 ce       	mov.aa %a14,%a12
8000d20a:	19 a4 20 00 	ld.w %d4,[%sp]32
8000d20e:	40 d4       	mov.aa %a4,%a13
8000d210:	a2 f4       	sub %d4,%d15
8000d212:	40 e5       	mov.aa %a5,%a14
8000d214:	76 49       	jz %d4,8000d226 <_dtoa_r+0x8ee>
8000d216:	3c 05       	j 8000d220 <_dtoa_r+0x8e8>
8000d218:	19 a4 20 00 	ld.w %d4,[%sp]32
8000d21c:	40 d4       	mov.aa %a4,%a13
8000d21e:	40 e5       	mov.aa %a5,%a14
8000d220:	6d 00 73 03 	call 8000d906 <__pow5mult>
8000d224:	40 2e       	mov.aa %a14,%a2
8000d226:	40 d4       	mov.aa %a4,%a13
8000d228:	82 14       	mov %d4,1
8000d22a:	6d 00 d9 02 	call 8000d7dc <__i2b>
8000d22e:	19 a3 34 00 	ld.w %d3,[%sp]52
8000d232:	40 2c       	mov.aa %a12,%a2
8000d234:	8e 3c       	jlez %d3,8000d24c <_dtoa_r+0x914>
8000d236:	40 d4       	mov.aa %a4,%a13
8000d238:	40 25       	mov.aa %a5,%a2
8000d23a:	02 34       	mov %d4,%d3
8000d23c:	6d 00 65 03 	call 8000d906 <__pow5mult>
8000d240:	58 07       	ld.w %d15,[%sp]28
8000d242:	40 2c       	mov.aa %a12,%a2
8000d244:	82 09       	mov %d9,0
8000d246:	ff 2f 1f 00 	jge %d15,2,8000d284 <_dtoa_r+0x94c>
8000d24a:	3c 06       	j 8000d256 <_dtoa_r+0x91e>
8000d24c:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d250:	82 09       	mov %d9,0
8000d252:	ff 22 15 00 	jge %d2,2,8000d27c <_dtoa_r+0x944>
8000d256:	82 09       	mov %d9,0
8000d258:	df 0c 12 80 	jne %d12,0,8000d27c <_dtoa_r+0x944>
8000d25c:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000d260:	ee 0e       	jnz %d15,8000d27c <_dtoa_r+0x944>
8000d262:	7b 00 ff f7 	movh %d15,32752
8000d266:	26 df       	and %d15,%d13
8000d268:	6e 0a       	jz %d15,8000d27c <_dtoa_r+0x944>
8000d26a:	19 a3 14 00 	ld.w %d3,[%sp]20
8000d26e:	58 06       	ld.w %d15,[%sp]24
8000d270:	c2 13       	add %d3,1
8000d272:	c2 1f       	add %d15,1
8000d274:	59 a3 14 00 	st.w [%sp]20,%d3
8000d278:	78 06       	st.w [%sp]24,%d15
8000d27a:	82 19       	mov %d9,1
8000d27c:	19 a3 34 00 	ld.w %d3,[%sp]52
8000d280:	82 12       	mov %d2,1
8000d282:	76 39       	jz %d3,8000d294 <_dtoa_r+0x95c>
8000d284:	4c c4       	ld.w %d15,[%a12]16
8000d286:	90 c3       	addsc.a %a3,%a12,%d15,2
8000d288:	19 34 10 00 	ld.w %d4,[%a3]16
8000d28c:	6d 00 54 02 	call 8000d734 <__hi0bits>
8000d290:	8b 02 02 21 	rsub %d2,%d2,32
8000d294:	58 06       	ld.w %d15,[%sp]24
8000d296:	42 2f       	add %d15,%d2
8000d298:	16 1f       	and %d15,31
8000d29a:	6e 0a       	jz %d15,8000d2ae <_dtoa_r+0x976>
8000d29c:	8b 0f 02 31 	rsub %d3,%d15,32
8000d2a0:	8b cf 01 f1 	rsub %d15,%d15,28
8000d2a4:	ff 53 07 00 	jge %d3,5,8000d2b2 <_dtoa_r+0x97a>
8000d2a8:	df 43 10 00 	jeq %d3,4,8000d2c8 <_dtoa_r+0x990>
8000d2ac:	02 3f       	mov %d15,%d3
8000d2ae:	1b cf 01 f0 	addi %d15,%d15,28
8000d2b2:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d2b6:	19 a3 18 00 	ld.w %d3,[%sp]24
8000d2ba:	42 f2       	add %d2,%d15
8000d2bc:	42 f3       	add %d3,%d15
8000d2be:	59 a2 14 00 	st.w [%sp]20,%d2
8000d2c2:	42 f8       	add %d8,%d15
8000d2c4:	59 a3 18 00 	st.w [%sp]24,%d3
8000d2c8:	58 05       	ld.w %d15,[%sp]20
8000d2ca:	8e f7       	jlez %d15,8000d2d8 <_dtoa_r+0x9a0>
8000d2cc:	40 e5       	mov.aa %a5,%a14
8000d2ce:	40 d4       	mov.aa %a4,%a13
8000d2d0:	02 f4       	mov %d4,%d15
8000d2d2:	6d 00 58 03 	call 8000d982 <__lshift>
8000d2d6:	40 2e       	mov.aa %a14,%a2
8000d2d8:	19 a2 18 00 	ld.w %d2,[%sp]24
8000d2dc:	8e 27       	jlez %d2,8000d2ea <_dtoa_r+0x9b2>
8000d2de:	40 c5       	mov.aa %a5,%a12
8000d2e0:	40 d4       	mov.aa %a4,%a13
8000d2e2:	02 24       	mov %d4,%d2
8000d2e4:	6d 00 4f 03 	call 8000d982 <__lshift>
8000d2e8:	40 2c       	mov.aa %a12,%a2
8000d2ea:	19 a3 3c 00 	ld.w %d3,[%sp]60
8000d2ee:	df 03 20 00 	jeq %d3,0,8000d32e <_dtoa_r+0x9f6>
8000d2f2:	40 e4       	mov.aa %a4,%a14
8000d2f4:	40 c5       	mov.aa %a5,%a12
8000d2f6:	6d 00 a3 03 	call 8000da3c <__mcmp>
8000d2fa:	ff 02 1a 00 	jge %d2,0,8000d32e <_dtoa_r+0x9f6>
8000d2fe:	58 02       	ld.w %d15,[%sp]8
8000d300:	40 e5       	mov.aa %a5,%a14
8000d302:	c2 ff       	add %d15,-1
8000d304:	40 d4       	mov.aa %a4,%a13
8000d306:	fb a0 00 40 	mov %e4,10
8000d30a:	78 02       	st.w [%sp]8,%d15
8000d30c:	6d 00 d3 01 	call 8000d6b2 <__multadd>
8000d310:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000d314:	19 a3 24 00 	ld.w %d3,[%sp]36
8000d318:	59 a2 10 00 	st.w [%sp]16,%d2
8000d31c:	40 2e       	mov.aa %a14,%a2
8000d31e:	76 38       	jz %d3,8000d32e <_dtoa_r+0x9f6>
8000d320:	40 f5       	mov.aa %a5,%a15
8000d322:	40 d4       	mov.aa %a4,%a13
8000d324:	fb a0 00 40 	mov %e4,10
8000d328:	6d 00 c5 01 	call 8000d6b2 <__multadd>
8000d32c:	40 2f       	mov.aa %a15,%a2
8000d32e:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d332:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d336:	8b 32 80 f2 	ge %d15,%d2,3
8000d33a:	8b 13 40 f4 	and.lt %d15,%d3,1
8000d33e:	6e 2a       	jz %d15,8000d392 <_dtoa_r+0xa5a>
8000d340:	f6 3f       	jnz %d3,8000d35e <_dtoa_r+0xa26>
8000d342:	40 c5       	mov.aa %a5,%a12
8000d344:	40 d4       	mov.aa %a4,%a13
8000d346:	d2 54       	mov %e4,5
8000d348:	6d 00 b5 01 	call 8000d6b2 <__multadd>
8000d34c:	40 e4       	mov.aa %a4,%a14
8000d34e:	40 25       	mov.aa %a5,%a2
8000d350:	40 2c       	mov.aa %a12,%a2
8000d352:	6d 00 75 03 	call 8000da3c <__mcmp>
8000d356:	4e 2e       	jgtz %d2,8000d372 <_dtoa_r+0xa3a>
8000d358:	3c 03       	j 8000d35e <_dtoa_r+0xa26>
8000d35a:	a0 0c       	mov.a %a12,0
8000d35c:	a0 0f       	mov.a %a15,0
8000d35e:	58 0a       	ld.w %d15,[%sp]40
8000d360:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000d364:	46 0f       	not %d15
8000d366:	78 02       	st.w [%sp]8,%d15
8000d368:	3c 11       	j 8000d38a <_dtoa_r+0xa52>
8000d36a:	58 0c       	ld.w %d15,[%sp]48
8000d36c:	a0 0c       	mov.a %a12,0
8000d36e:	78 02       	st.w [%sp]8,%d15
8000d370:	a0 0f       	mov.a %a15,0
8000d372:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d376:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d37a:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000d37e:	da 31       	mov %d15,49
8000d380:	c2 12       	add %d2,1
8000d382:	c2 1e       	add %d14,1
8000d384:	2c 30       	st.b [%a3]0,%d15
8000d386:	59 a2 08 00 	st.w [%sp]8,%d2
8000d38a:	80 f8       	mov.d %d8,%a15
8000d38c:	a0 0f       	mov.a %a15,0
8000d38e:	1d 00 14 01 	j 8000d5b6 <_dtoa_r+0xc7e>
8000d392:	19 a3 24 00 	ld.w %d3,[%sp]36
8000d396:	f6 35       	jnz %d3,8000d3a0 <_dtoa_r+0xa68>
8000d398:	19 a8 0c 00 	ld.w %d8,[%sp]12
8000d39c:	1d 00 c2 00 	j 8000d520 <_dtoa_r+0xbe8>
8000d3a0:	8e 87       	jlez %d8,8000d3ae <_dtoa_r+0xa76>
8000d3a2:	40 f5       	mov.aa %a5,%a15
8000d3a4:	40 d4       	mov.aa %a4,%a13
8000d3a6:	02 84       	mov %d4,%d8
8000d3a8:	6d 00 ed 02 	call 8000d982 <__lshift>
8000d3ac:	40 2f       	mov.aa %a15,%a2
8000d3ae:	80 f8       	mov.d %d8,%a15
8000d3b0:	df 09 16 00 	jeq %d9,0,8000d3dc <_dtoa_r+0xaa4>
8000d3b4:	40 d4       	mov.aa %a4,%a13
8000d3b6:	48 14       	ld.w %d4,[%a15]4
8000d3b8:	6d 00 49 01 	call 8000d64a <_Balloc>
8000d3bc:	48 44       	ld.w %d4,[%a15]16
8000d3be:	d9 24 0c 00 	lea %a4,[%a2]12
8000d3c2:	c2 24       	add %d4,2
8000d3c4:	d9 f5 0c 00 	lea %a5,[%a15]12
8000d3c8:	06 24       	sh %d4,2
8000d3ca:	80 2f       	mov.d %d15,%a2
8000d3cc:	6d 00 31 01 	call 8000d62e <memcpy>
8000d3d0:	60 f5       	mov.a %a5,%d15
8000d3d2:	40 d4       	mov.aa %a4,%a13
8000d3d4:	82 14       	mov %d4,1
8000d3d6:	6d 00 d6 02 	call 8000d982 <__lshift>
8000d3da:	80 28       	mov.d %d8,%a2
8000d3dc:	19 a9 0c 00 	ld.w %d9,[%sp]12
8000d3e0:	8f 1c 00 a1 	and %d10,%d12,1
8000d3e4:	40 e4       	mov.aa %a4,%a14
8000d3e6:	40 c5       	mov.aa %a5,%a12
8000d3e8:	6d ff 1a fa 	call 8000c81c <quorem>
8000d3ec:	40 e4       	mov.aa %a4,%a14
8000d3ee:	40 f5       	mov.aa %a5,%a15
8000d3f0:	02 2e       	mov %d14,%d2
8000d3f2:	1b 02 03 f0 	addi %d15,%d2,48
8000d3f6:	6d 00 23 03 	call 8000da3c <__mcmp>
8000d3fa:	60 86       	mov.a %a6,%d8
8000d3fc:	40 d4       	mov.aa %a4,%a13
8000d3fe:	40 c5       	mov.aa %a5,%a12
8000d400:	02 2b       	mov %d11,%d2
8000d402:	6d 00 3e 03 	call 8000da7e <__mdiff>
8000d406:	19 22 0c 00 	ld.w %d2,[%a2]12
8000d40a:	80 2d       	mov.d %d13,%a2
8000d40c:	82 1c       	mov %d12,1
8000d40e:	f6 26       	jnz %d2,8000d41a <_dtoa_r+0xae2>
8000d410:	40 e4       	mov.aa %a4,%a14
8000d412:	40 25       	mov.aa %a5,%a2
8000d414:	6d 00 14 03 	call 8000da3c <__mcmp>
8000d418:	02 2c       	mov %d12,%d2
8000d41a:	60 d5       	mov.a %a5,%d13
8000d41c:	40 d4       	mov.aa %a4,%a13
8000d41e:	6d 00 41 01 	call 8000d6a0 <_Bfree>
8000d422:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000d426:	1b 19 00 d0 	addi %d13,%d9,1
8000d42a:	a6 c3       	or %d3,%d12
8000d42c:	f6 3f       	jnz %d3,8000d44a <_dtoa_r+0xb12>
8000d42e:	f6 ae       	jnz %d10,8000d44a <_dtoa_r+0xb12>
8000d430:	8b 9f 03 32 	eq %d3,%d15,57
8000d434:	40 e2       	mov.aa %a2,%a14
8000d436:	df 03 3a 80 	jne %d3,0,8000d4aa <_dtoa_r+0xb72>
8000d43a:	1b 1e 03 20 	addi %d2,%d14,49
8000d43e:	8b 1b 80 b2 	ge %d11,%d11,1
8000d442:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
8000d446:	02 de       	mov %d14,%d13
8000d448:	3c 37       	j 8000d4b6 <_dtoa_r+0xb7e>
8000d44a:	ce b5       	jgez %d11,8000d454 <_dtoa_r+0xb1c>
8000d44c:	02 fa       	mov %d10,%d15
8000d44e:	40 e2       	mov.aa %a2,%a14
8000d450:	4e ca       	jgtz %d12,8000d464 <_dtoa_r+0xb2c>
8000d452:	3c 1e       	j 8000d48e <_dtoa_r+0xb56>
8000d454:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000d458:	a6 2b       	or %d11,%d2
8000d45a:	df 0b 20 80 	jne %d11,0,8000d49a <_dtoa_r+0xb62>
8000d45e:	df 0a 1e 80 	jne %d10,0,8000d49a <_dtoa_r+0xb62>
8000d462:	3c f5       	j 8000d44c <_dtoa_r+0xb14>
8000d464:	40 d4       	mov.aa %a4,%a13
8000d466:	40 e5       	mov.aa %a5,%a14
8000d468:	82 14       	mov %d4,1
8000d46a:	6d 00 8c 02 	call 8000d982 <__lshift>
8000d46e:	40 c5       	mov.aa %a5,%a12
8000d470:	40 24       	mov.aa %a4,%a2
8000d472:	b5 a2 04 00 	st.a [%sp]4,%a2
8000d476:	6d 00 e3 02 	call 8000da3c <__mcmp>
8000d47a:	99 a2 04 00 	ld.a %a2,[%sp]4
8000d47e:	4e 23       	jgtz %d2,8000d484 <_dtoa_r+0xb4c>
8000d480:	f6 27       	jnz %d2,8000d48e <_dtoa_r+0xb56>
8000d482:	2e 06       	jz.t %d15,0,8000d48e <_dtoa_r+0xb56>
8000d484:	8b 9f 03 32 	eq %d3,%d15,57
8000d488:	df 03 11 80 	jne %d3,0,8000d4aa <_dtoa_r+0xb72>
8000d48c:	92 1a       	add %d10,%d15,1
8000d48e:	60 93       	mov.a %a3,%d9
8000d490:	02 de       	mov %d14,%d13
8000d492:	34 3a       	st.b [%a3],%d10
8000d494:	40 2e       	mov.aa %a14,%a2
8000d496:	1d 00 90 00 	j 8000d5b6 <_dtoa_r+0xc7e>
8000d49a:	bf 1c 11 00 	jlt %d12,1,8000d4bc <_dtoa_r+0xb84>
8000d49e:	8b 9f 23 32 	ne %d3,%d15,57
8000d4a2:	40 e2       	mov.aa %a2,%a14
8000d4a4:	02 de       	mov %d14,%d13
8000d4a6:	c2 1f       	add %d15,1
8000d4a8:	f6 37       	jnz %d3,8000d4b6 <_dtoa_r+0xb7e>
8000d4aa:	60 93       	mov.a %a3,%d9
8000d4ac:	da 39       	mov %d15,57
8000d4ae:	02 de       	mov %d14,%d13
8000d4b0:	2c 30       	st.b [%a3]0,%d15
8000d4b2:	40 2e       	mov.aa %a14,%a2
8000d4b4:	3c 5d       	j 8000d56e <_dtoa_r+0xc36>
8000d4b6:	60 92       	mov.a %a2,%d9
8000d4b8:	2c 20       	st.b [%a2]0,%d15
8000d4ba:	3c 7e       	j 8000d5b6 <_dtoa_r+0xc7e>
8000d4bc:	60 93       	mov.a %a3,%d9
8000d4be:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000d4c2:	02 d5       	mov %d5,%d13
8000d4c4:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d4c8:	2c 30       	st.b [%a3]0,%d15
8000d4ca:	a2 25       	sub %d5,%d2
8000d4cc:	02 de       	mov %d14,%d13
8000d4ce:	5f 35 41 00 	jeq %d5,%d3,8000d550 <_dtoa_r+0xc18>
8000d4d2:	40 e5       	mov.aa %a5,%a14
8000d4d4:	40 d4       	mov.aa %a4,%a13
8000d4d6:	fb a0 00 40 	mov %e4,10
8000d4da:	6d 00 ec 00 	call 8000d6b2 <__multadd>
8000d4de:	80 ff       	mov.d %d15,%a15
8000d4e0:	40 2e       	mov.aa %a14,%a2
8000d4e2:	40 d4       	mov.aa %a4,%a13
8000d4e4:	40 f5       	mov.aa %a5,%a15
8000d4e6:	fb a0 00 40 	mov %e4,10
8000d4ea:	7e 86       	jne %d15,%d8,8000d4f6 <_dtoa_r+0xbbe>
8000d4ec:	6d 00 e3 00 	call 8000d6b2 <__multadd>
8000d4f0:	40 2f       	mov.aa %a15,%a2
8000d4f2:	80 28       	mov.d %d8,%a2
8000d4f4:	3c 0b       	j 8000d50a <_dtoa_r+0xbd2>
8000d4f6:	6d 00 de 00 	call 8000d6b2 <__multadd>
8000d4fa:	60 85       	mov.a %a5,%d8
8000d4fc:	40 d4       	mov.aa %a4,%a13
8000d4fe:	fb a0 00 40 	mov %e4,10
8000d502:	40 2f       	mov.aa %a15,%a2
8000d504:	6d 00 d7 00 	call 8000d6b2 <__multadd>
8000d508:	80 28       	mov.d %d8,%a2
8000d50a:	02 d9       	mov %d9,%d13
8000d50c:	1d ff 6c ff 	j 8000d3e4 <_dtoa_r+0xaac>
8000d510:	40 e5       	mov.aa %a5,%a14
8000d512:	40 d4       	mov.aa %a4,%a13
8000d514:	fb a0 00 40 	mov %e4,10
8000d518:	6d 00 cd 00 	call 8000d6b2 <__multadd>
8000d51c:	02 98       	mov %d8,%d9
8000d51e:	40 2e       	mov.aa %a14,%a2
8000d520:	40 e4       	mov.aa %a4,%a14
8000d522:	40 c5       	mov.aa %a5,%a12
8000d524:	6d ff 7c f9 	call 8000c81c <quorem>
8000d528:	1b 18 00 90 	addi %d9,%d8,1
8000d52c:	1b 02 03 f0 	addi %d15,%d2,48
8000d530:	60 82       	mov.a %a2,%d8
8000d532:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000d536:	02 95       	mov %d5,%d9
8000d538:	19 a3 10 00 	ld.w %d3,[%sp]16
8000d53c:	2c 20       	st.b [%a2]0,%d15
8000d53e:	a2 25       	sub %d5,%d2
8000d540:	3f 35 e8 7f 	jlt %d5,%d3,8000d510 <_dtoa_r+0xbd8>
8000d544:	8b 13 40 33 	max %d3,%d3,1
8000d548:	02 2e       	mov %d14,%d2
8000d54a:	80 f8       	mov.d %d8,%a15
8000d54c:	42 3e       	add %d14,%d3
8000d54e:	a0 0f       	mov.a %a15,0
8000d550:	40 e5       	mov.aa %a5,%a14
8000d552:	40 d4       	mov.aa %a4,%a13
8000d554:	82 14       	mov %d4,1
8000d556:	6d 00 16 02 	call 8000d982 <__lshift>
8000d55a:	40 c5       	mov.aa %a5,%a12
8000d55c:	40 2e       	mov.aa %a14,%a2
8000d55e:	40 24       	mov.aa %a4,%a2
8000d560:	6d 00 6e 02 	call 8000da3c <__mcmp>
8000d564:	4e 25       	jgtz %d2,8000d56e <_dtoa_r+0xc36>
8000d566:	df 02 1e 80 	jne %d2,0,8000d5a2 <_dtoa_r+0xc6a>
8000d56a:	6f 0f 1c 00 	jz.t %d15,0,8000d5a2 <_dtoa_r+0xc6a>
8000d56e:	58 03       	ld.w %d15,[%sp]12
8000d570:	a2 ef       	sub %d15,%d14
8000d572:	46 0f       	not %d15
8000d574:	60 e2       	mov.a %a2,%d14
8000d576:	60 e3       	mov.a %a3,%d14
8000d578:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000d57c:	b0 f3       	add.a %a3,-1
8000d57e:	8b 93 03 52 	eq %d5,%d3,57
8000d582:	76 5d       	jz %d5,8000d59c <_dtoa_r+0xc64>
8000d584:	9f 0f 0a 80 	jned %d15,0,8000d598 <_dtoa_r+0xc60>
8000d588:	58 02       	ld.w %d15,[%sp]8
8000d58a:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d58e:	c2 1f       	add %d15,1
8000d590:	78 02       	st.w [%sp]8,%d15
8000d592:	da 31       	mov %d15,49
8000d594:	2c 30       	st.b [%a3]0,%d15
8000d596:	3c 10       	j 8000d5b6 <_dtoa_r+0xc7e>
8000d598:	80 3e       	mov.d %d14,%a3
8000d59a:	3c ed       	j 8000d574 <_dtoa_r+0xc3c>
8000d59c:	c2 13       	add %d3,1
8000d59e:	34 33       	st.b [%a3],%d3
8000d5a0:	3c 0b       	j 8000d5b6 <_dtoa_r+0xc7e>
8000d5a2:	60 e2       	mov.a %a2,%d14
8000d5a4:	60 e3       	mov.a %a3,%d14
8000d5a6:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000d5aa:	b0 f3       	add.a %a3,-1
8000d5ac:	8b 0f 03 f2 	eq %d15,%d15,48
8000d5b0:	6e 03       	jz %d15,8000d5b6 <_dtoa_r+0xc7e>
8000d5b2:	80 3e       	mov.d %d14,%a3
8000d5b4:	3c f7       	j 8000d5a2 <_dtoa_r+0xc6a>
8000d5b6:	40 d4       	mov.aa %a4,%a13
8000d5b8:	40 c5       	mov.aa %a5,%a12
8000d5ba:	6d 00 73 00 	call 8000d6a0 <_Bfree>
8000d5be:	df 08 13 00 	jeq %d8,0,8000d5e4 <_dtoa_r+0xcac>
8000d5c2:	80 f2       	mov.d %d2,%a15
8000d5c4:	8b 02 20 f2 	ne %d15,%d2,0
8000d5c8:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8000d5cc:	6e 05       	jz %d15,8000d5d6 <_dtoa_r+0xc9e>
8000d5ce:	40 d4       	mov.aa %a4,%a13
8000d5d0:	40 f5       	mov.aa %a5,%a15
8000d5d2:	6d 00 67 00 	call 8000d6a0 <_Bfree>
8000d5d6:	60 85       	mov.a %a5,%d8
8000d5d8:	40 d4       	mov.aa %a4,%a13
8000d5da:	6d 00 63 00 	call 8000d6a0 <_Bfree>
8000d5de:	3c 03       	j 8000d5e4 <_dtoa_r+0xcac>
8000d5e0:	58 0c       	ld.w %d15,[%sp]48
8000d5e2:	78 02       	st.w [%sp]8,%d15
8000d5e4:	40 d4       	mov.aa %a4,%a13
8000d5e6:	40 e5       	mov.aa %a5,%a14
8000d5e8:	6d 00 5c 00 	call 8000d6a0 <_Bfree>
8000d5ec:	60 e2       	mov.a %a2,%d14
8000d5ee:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d5f2:	99 a3 08 10 	ld.a %a3,[%sp]72
8000d5f6:	82 0f       	mov %d15,0
8000d5f8:	d8 0e       	ld.a %a15,[%sp]56
8000d5fa:	2c 20       	st.b [%a2]0,%d15
8000d5fc:	c2 12       	add %d2,1
8000d5fe:	74 32       	st.w [%a3],%d2
8000d600:	99 a2 0c 00 	ld.a %a2,[%sp]12
8000d604:	bc f2       	jz.a %a15,8000d608 <_dtoa_r+0xcd0>
8000d606:	68 0e       	st.w [%a15]0,%d14
8000d608:	00 90       	ret 
	...

8000d60c <_localeconv_r>:
8000d60c:	91 00 00 28 	movh.a %a2,32768
8000d610:	d9 22 dc b0 	lea %a2,[%a2]3804 <80000edc <lconv>>
8000d614:	00 90       	ret 

8000d616 <memchr>:
8000d616:	8f f4 0f 41 	and %d4,%d4,255
8000d61a:	9f 05 04 80 	jned %d5,0,8000d622 <memchr+0xc>
8000d61e:	a0 02       	mov.a %a2,0
8000d620:	00 90       	ret 
8000d622:	0c 40       	ld.bu %d15,[%a4]0
8000d624:	3e 43       	jeq %d15,%d4,8000d62a <memchr+0x14>
8000d626:	b0 14       	add.a %a4,1
8000d628:	3c f9       	j 8000d61a <memchr+0x4>
8000d62a:	40 42       	mov.aa %a2,%a4
8000d62c:	00 90       	ret 

8000d62e <memcpy>:
8000d62e:	40 42       	mov.aa %a2,%a4
8000d630:	a0 0f       	mov.a %a15,0
8000d632:	01 f2 10 40 	add.a %a4,%a2,%a15
8000d636:	01 f5 10 30 	add.a %a3,%a5,%a15
8000d63a:	9f 04 03 80 	jned %d4,0,8000d640 <memcpy+0x12>
8000d63e:	00 90       	ret 
8000d640:	79 3f 00 00 	ld.b %d15,[%a3]0
8000d644:	b0 1f       	add.a %a15,1
8000d646:	2c 40       	st.b [%a4]0,%d15
8000d648:	3c f5       	j 8000d632 <memcpy+0x4>

8000d64a <_Balloc>:
8000d64a:	19 42 0c 10 	ld.w %d2,[%a4]76
8000d64e:	40 4f       	mov.aa %a15,%a4
8000d650:	02 4f       	mov %d15,%d4
8000d652:	76 29       	jz %d2,8000d664 <_Balloc+0x1a>
8000d654:	99 f3 0c 10 	ld.a %a3,[%a15]76
8000d658:	90 33       	addsc.a %a3,%a3,%d15,2
8000d65a:	d4 32       	ld.a %a2,[%a3]
8000d65c:	bc 2f       	jz.a %a2,8000d67a <_Balloc+0x30>
8000d65e:	4c 20       	ld.w %d15,[%a2]0
8000d660:	6c 30       	st.w [%a3]0,%d15
8000d662:	3c 1b       	j 8000d698 <_Balloc+0x4e>
8000d664:	82 44       	mov %d4,4
8000d666:	3b 10 02 50 	mov %d5,33
8000d66a:	6d 00 5c 03 	call 8000dd22 <_calloc_r>
8000d66e:	b5 f2 0c 10 	st.a [%a15]76,%a2
8000d672:	bd 02 f1 ff 	jnz.a %a2,8000d654 <_Balloc+0xa>
8000d676:	a0 02       	mov.a %a2,0
8000d678:	00 90       	ret 
8000d67a:	82 18       	mov %d8,1
8000d67c:	0f f8 00 80 	sh %d8,%d8,%d15
8000d680:	1b 58 00 50 	addi %d5,%d8,5
8000d684:	40 f4       	mov.aa %a4,%a15
8000d686:	82 14       	mov %d4,1
8000d688:	06 25       	sh %d5,2
8000d68a:	6d 00 4c 03 	call 8000dd22 <_calloc_r>
8000d68e:	bd 02 f4 7f 	jz.a %a2,8000d676 <_Balloc+0x2c>
8000d692:	6c 21       	st.w [%a2]4,%d15
8000d694:	59 28 08 00 	st.w [%a2]8,%d8
8000d698:	82 0f       	mov %d15,0
8000d69a:	6c 24       	st.w [%a2]16,%d15
8000d69c:	6c 23       	st.w [%a2]12,%d15
8000d69e:	00 90       	ret 

8000d6a0 <_Bfree>:
8000d6a0:	bc 58       	jz.a %a5,8000d6b0 <_Bfree+0x10>
8000d6a2:	99 4f 0c 10 	ld.a %a15,[%a4]76
8000d6a6:	4c 51       	ld.w %d15,[%a5]4
8000d6a8:	90 ff       	addsc.a %a15,%a15,%d15,2
8000d6aa:	4c f0       	ld.w %d15,[%a15]0
8000d6ac:	6c 50       	st.w [%a5]0,%d15
8000d6ae:	e8 05       	st.a [%a15]0,%a5
8000d6b0:	00 90       	ret 

8000d6b2 <__multadd>:
8000d6b2:	19 59 10 00 	ld.w %d9,[%a5]16
8000d6b6:	40 4c       	mov.aa %a12,%a4
8000d6b8:	9a f9       	add %d15,%d9,-1
8000d6ba:	8b 19 80 22 	ge %d2,%d9,1
8000d6be:	40 5f       	mov.aa %a15,%a5
8000d6c0:	02 58       	mov %d8,%d5
8000d6c2:	d9 53 14 00 	lea %a3,[%a5]20
8000d6c6:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000d6ca:	40 32       	mov.aa %a2,%a3
8000d6cc:	44 25       	ld.w %d5,[%a2+]
8000d6ce:	b7 05 10 38 	insert %d3,%d5,0,16,16
8000d6d2:	8f 05 1f f0 	sh %d15,%d5,-16
8000d6d6:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
8000d6da:	8f 03 1f 60 	sh %d6,%d3,-16
8000d6de:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
8000d6e2:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000d6e6:	8f 0f 1f 80 	sh %d8,%d15,-16
8000d6ea:	74 33       	st.w [%a3],%d3
8000d6ec:	40 23       	mov.aa %a3,%a2
8000d6ee:	9f 02 ee ff 	jned %d2,0,8000d6ca <__multadd+0x18>
8000d6f2:	df 08 1f 00 	jeq %d8,0,8000d730 <__multadd+0x7e>
8000d6f6:	4c f2       	ld.w %d15,[%a15]8
8000d6f8:	3f f9 16 00 	jlt %d9,%d15,8000d724 <__multadd+0x72>
8000d6fc:	48 14       	ld.w %d4,[%a15]4
8000d6fe:	40 c4       	mov.aa %a4,%a12
8000d700:	c2 14       	add %d4,1
8000d702:	6d ff a4 ff 	call 8000d64a <_Balloc>
8000d706:	48 44       	ld.w %d4,[%a15]16
8000d708:	d9 f5 0c 00 	lea %a5,[%a15]12
8000d70c:	c2 24       	add %d4,2
8000d70e:	d9 24 0c 00 	lea %a4,[%a2]12
8000d712:	06 24       	sh %d4,2
8000d714:	40 2d       	mov.aa %a13,%a2
8000d716:	6d ff 8c ff 	call 8000d62e <memcpy>
8000d71a:	40 f5       	mov.aa %a5,%a15
8000d71c:	40 c4       	mov.aa %a4,%a12
8000d71e:	6d ff c1 ff 	call 8000d6a0 <_Bfree>
8000d722:	40 df       	mov.aa %a15,%a13
8000d724:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
8000d728:	c2 19       	add %d9,1
8000d72a:	59 28 14 00 	st.w [%a2]20,%d8
8000d72e:	68 49       	st.w [%a15]16,%d9
8000d730:	40 f2       	mov.aa %a2,%a15
8000d732:	00 90       	ret 

8000d734 <__hi0bits>:
8000d734:	b7 04 10 f0 	insert %d15,%d4,0,0,16
8000d738:	82 02       	mov %d2,0
8000d73a:	ee 05       	jnz %d15,8000d744 <__hi0bits+0x10>
8000d73c:	8f 04 01 40 	sh %d4,%d4,16
8000d740:	3b 00 01 20 	mov %d2,16
8000d744:	b7 04 18 f0 	insert %d15,%d4,0,0,24
8000d748:	ee 05       	jnz %d15,8000d752 <__hi0bits+0x1e>
8000d74a:	1b 82 00 20 	addi %d2,%d2,8
8000d74e:	8f 84 00 40 	sh %d4,%d4,8
8000d752:	b7 04 1c f0 	insert %d15,%d4,0,0,28
8000d756:	ee 03       	jnz %d15,8000d75c <__hi0bits+0x28>
8000d758:	c2 42       	add %d2,4
8000d75a:	06 44       	sh %d4,4
8000d75c:	b7 04 1e f0 	insert %d15,%d4,0,0,30
8000d760:	ee 03       	jnz %d15,8000d766 <__hi0bits+0x32>
8000d762:	c2 22       	add %d2,2
8000d764:	06 24       	sh %d4,2
8000d766:	0e 47       	jltz %d4,8000d774 <__hi0bits+0x40>
8000d768:	7b 00 00 f4 	movh %d15,16384
8000d76c:	26 f4       	and %d4,%d15
8000d76e:	c2 12       	add %d2,1
8000d770:	ab 02 82 24 	sel %d2,%d4,%d2,32
8000d774:	00 90       	ret 

8000d776 <__lo0bits>:
8000d776:	54 43       	ld.w %d3,[%a4]
8000d778:	8f 73 00 f1 	and %d15,%d3,7
8000d77c:	6e 0e       	jz %d15,8000d798 <__lo0bits+0x22>
8000d77e:	82 02       	mov %d2,0
8000d780:	6f 03 2d 80 	jnz.t %d3,0,8000d7da <__lo0bits+0x64>
8000d784:	6f 13 06 00 	jz.t %d3,1,8000d790 <__lo0bits+0x1a>
8000d788:	06 f3       	sh %d3,-1
8000d78a:	74 43       	st.w [%a4],%d3
8000d78c:	82 12       	mov %d2,1
8000d78e:	00 90       	ret 
8000d790:	06 e3       	sh %d3,-2
8000d792:	74 43       	st.w [%a4],%d3
8000d794:	82 22       	mov %d2,2
8000d796:	00 90       	ret 
8000d798:	b7 03 10 f8 	insert %d15,%d3,0,16,16
8000d79c:	82 04       	mov %d4,0
8000d79e:	ee 05       	jnz %d15,8000d7a8 <__lo0bits+0x32>
8000d7a0:	8f 03 1f 30 	sh %d3,%d3,-16
8000d7a4:	3b 00 01 40 	mov %d4,16
8000d7a8:	02 3f       	mov %d15,%d3
8000d7aa:	16 ff       	and %d15,255
8000d7ac:	ee 04       	jnz %d15,8000d7b4 <__lo0bits+0x3e>
8000d7ae:	1b 84 00 40 	addi %d4,%d4,8
8000d7b2:	06 83       	sh %d3,-8
8000d7b4:	8f f3 00 f1 	and %d15,%d3,15
8000d7b8:	ee 03       	jnz %d15,8000d7be <__lo0bits+0x48>
8000d7ba:	c2 44       	add %d4,4
8000d7bc:	06 c3       	sh %d3,-4
8000d7be:	8f 33 00 f1 	and %d15,%d3,3
8000d7c2:	ee 03       	jnz %d15,8000d7c8 <__lo0bits+0x52>
8000d7c4:	c2 24       	add %d4,2
8000d7c6:	06 e3       	sh %d3,-2
8000d7c8:	6f 03 07 80 	jnz.t %d3,0,8000d7d6 <__lo0bits+0x60>
8000d7cc:	06 f3       	sh %d3,-1
8000d7ce:	3b 00 02 20 	mov %d2,32
8000d7d2:	76 34       	jz %d3,8000d7da <__lo0bits+0x64>
8000d7d4:	c2 14       	add %d4,1
8000d7d6:	74 43       	st.w [%a4],%d3
8000d7d8:	02 42       	mov %d2,%d4
8000d7da:	00 90       	ret 

8000d7dc <__i2b>:
8000d7dc:	02 4f       	mov %d15,%d4
8000d7de:	82 14       	mov %d4,1
8000d7e0:	6d ff 35 ff 	call 8000d64a <_Balloc>
8000d7e4:	6c 25       	st.w [%a2]20,%d15
8000d7e6:	82 1f       	mov %d15,1
8000d7e8:	6c 24       	st.w [%a2]16,%d15
8000d7ea:	00 90       	ret 

8000d7ec <__multiply>:
8000d7ec:	19 52 10 00 	ld.w %d2,[%a5]16
8000d7f0:	4c 64       	ld.w %d15,[%a6]16
8000d7f2:	40 5f       	mov.aa %a15,%a5
8000d7f4:	40 6c       	mov.aa %a12,%a6
8000d7f6:	7f f2 04 00 	jge %d2,%d15,8000d7fe <__multiply+0x12>
8000d7fa:	40 6f       	mov.aa %a15,%a6
8000d7fc:	40 5c       	mov.aa %a12,%a5
8000d7fe:	48 4a       	ld.w %d10,[%a15]16
8000d800:	19 c9 10 00 	ld.w %d9,[%a12]16
8000d804:	4c f2       	ld.w %d15,[%a15]8
8000d806:	0b 9a 00 80 	add %d8,%d10,%d9
8000d80a:	48 12       	ld.w %d2,[%a15]4
8000d80c:	0b 8f 20 41 	lt %d4,%d15,%d8
8000d810:	42 24       	add %d4,%d2
8000d812:	6d ff 1c ff 	call 8000d64a <_Balloc>
8000d816:	d9 23 14 00 	lea %a3,[%a2]20
8000d81a:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
8000d81e:	40 34       	mov.aa %a4,%a3
8000d820:	82 0f       	mov %d15,0
8000d822:	80 43       	mov.d %d3,%a4
8000d824:	80 d2       	mov.d %d2,%a13
8000d826:	7f 23 04 80 	jge.u %d3,%d2,8000d82e <__multiply+0x42>
8000d82a:	64 4f       	st.w [%a4+],%d15
8000d82c:	3c fb       	j 8000d822 <__multiply+0x36>
8000d82e:	d9 ff 14 00 	lea %a15,[%a15]20
8000d832:	d9 cc 14 00 	lea %a12,[%a12]20
8000d836:	80 f3       	mov.d %d3,%a15
8000d838:	80 cf       	mov.d %d15,%a12
8000d83a:	13 4a 20 43 	madd %d4,%d3,%d10,4
8000d83e:	13 49 20 0f 	madd %d0,%d15,%d9,4
8000d842:	80 c2       	mov.d %d2,%a12
8000d844:	7f 02 54 80 	jge.u %d2,%d0,8000d8ec <__multiply+0x100>
8000d848:	b9 c2 00 00 	ld.hu %d2,[%a12]0
8000d84c:	40 34       	mov.aa %a4,%a3
8000d84e:	40 f6       	mov.aa %a6,%a15
8000d850:	82 03       	mov %d3,0
8000d852:	df 02 21 00 	jeq %d2,0,8000d894 <__multiply+0xa8>
8000d856:	40 45       	mov.aa %a5,%a4
8000d858:	44 67       	ld.w %d7,[%a6+]
8000d85a:	44 56       	ld.w %d6,[%a5+]
8000d85c:	b7 07 10 18 	insert %d1,%d7,0,16,16
8000d860:	b7 06 10 58 	insert %d5,%d6,0,16,16
8000d864:	8f 07 1f 70 	sh %d7,%d7,-16
8000d868:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
8000d86c:	8f 06 1f 60 	sh %d6,%d6,-16
8000d870:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
8000d874:	42 35       	add %d5,%d3
8000d876:	8f 05 1f 30 	sh %d3,%d5,-16
8000d87a:	1a 36       	add %d15,%d6,%d3
8000d87c:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
8000d880:	8f 0f 1f 30 	sh %d3,%d15,-16
8000d884:	80 6f       	mov.d %d15,%a6
8000d886:	74 45       	st.w [%a4],%d5
8000d888:	7f 4f 04 80 	jge.u %d15,%d4,8000d890 <__multiply+0xa4>
8000d88c:	40 54       	mov.aa %a4,%a5
8000d88e:	3c e4       	j 8000d856 <__multiply+0x6a>
8000d890:	59 43 04 00 	st.w [%a4]4,%d3
8000d894:	b9 c2 02 00 	ld.hu %d2,[%a12]2
8000d898:	df 02 27 00 	jeq %d2,0,8000d8e6 <__multiply+0xfa>
8000d89c:	54 33       	ld.w %d3,[%a3]
8000d89e:	40 34       	mov.aa %a4,%a3
8000d8a0:	40 f5       	mov.aa %a5,%a15
8000d8a2:	82 07       	mov %d7,0
8000d8a4:	40 56       	mov.aa %a6,%a5
8000d8a6:	44 66       	ld.w %d6,[%a6+]
8000d8a8:	40 47       	mov.aa %a7,%a4
8000d8aa:	44 75       	ld.w %d5,[%a7+]
8000d8ac:	b7 06 10 68 	insert %d6,%d6,0,16,16
8000d8b0:	8f 05 1f 50 	sh %d5,%d5,-16
8000d8b4:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
8000d8b8:	42 7f       	add %d15,%d7
8000d8ba:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000d8be:	8f 0f 1f f0 	sh %d15,%d15,-16
8000d8c2:	74 43       	st.w [%a4],%d3
8000d8c4:	b9 55 02 00 	ld.hu %d5,[%a5]2
8000d8c8:	b9 43 04 00 	ld.hu %d3,[%a4]4
8000d8cc:	40 65       	mov.aa %a5,%a6
8000d8ce:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
8000d8d2:	42 f3       	add %d3,%d15
8000d8d4:	80 6f       	mov.d %d15,%a6
8000d8d6:	8f 03 1f 70 	sh %d7,%d3,-16
8000d8da:	7f 4f 04 80 	jge.u %d15,%d4,8000d8e2 <__multiply+0xf6>
8000d8de:	40 74       	mov.aa %a4,%a7
8000d8e0:	3c e2       	j 8000d8a4 <__multiply+0xb8>
8000d8e2:	59 43 04 00 	st.w [%a4]4,%d3
8000d8e6:	b0 4c       	add.a %a12,4
8000d8e8:	b0 43       	add.a %a3,4
8000d8ea:	3c ac       	j 8000d842 <__multiply+0x56>
8000d8ec:	8b 08 40 f3 	max %d15,%d8,0
8000d8f0:	9f 0f 05 80 	jned %d15,0,8000d8fa <__multiply+0x10e>
8000d8f4:	59 28 10 00 	st.w [%a2]16,%d8
8000d8f8:	00 90       	ret 
8000d8fa:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
8000d8fe:	df 02 fb ff 	jne %d2,0,8000d8f4 <__multiply+0x108>
8000d902:	c2 f8       	add %d8,-1
8000d904:	3c f6       	j 8000d8f0 <__multiply+0x104>

8000d906 <__pow5mult>:
8000d906:	8f 34 00 21 	and %d2,%d4,3
8000d90a:	40 4c       	mov.aa %a12,%a4
8000d90c:	40 5d       	mov.aa %a13,%a5
8000d90e:	02 4f       	mov %d15,%d4
8000d910:	76 2d       	jz %d2,8000d92a <__pow5mult+0x24>
8000d912:	91 00 00 f8 	movh.a %a15,32768
8000d916:	d9 ff d4 c0 	lea %a15,[%a15]3860 <80000f14 <p05.2553>>
8000d91a:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
8000d91e:	82 05       	mov %d5,0
8000d920:	19 f4 fc ff 	ld.w %d4,[%a15]-4
8000d924:	6d ff c7 fe 	call 8000d6b2 <__multadd>
8000d928:	40 2d       	mov.aa %a13,%a2
8000d92a:	86 ef       	sha %d15,-2
8000d92c:	6e 29       	jz %d15,8000d97e <__pow5mult+0x78>
8000d92e:	99 cf 08 10 	ld.a %a15,[%a12]72
8000d932:	7c fb       	jnz.a %a15,8000d948 <__pow5mult+0x42>
8000d934:	40 c4       	mov.aa %a4,%a12
8000d936:	3b 10 27 40 	mov %d4,625
8000d93a:	6d ff 51 ff 	call 8000d7dc <__i2b>
8000d93e:	82 02       	mov %d2,0
8000d940:	b5 c2 08 10 	st.a [%a12]72,%a2
8000d944:	40 2f       	mov.aa %a15,%a2
8000d946:	74 22       	st.w [%a2],%d2
8000d948:	82 08       	mov %d8,0
8000d94a:	2e 0c       	jz.t %d15,0,8000d962 <__pow5mult+0x5c>
8000d94c:	40 d5       	mov.aa %a5,%a13
8000d94e:	40 c4       	mov.aa %a4,%a12
8000d950:	40 f6       	mov.aa %a6,%a15
8000d952:	6d ff 4d ff 	call 8000d7ec <__multiply>
8000d956:	40 d5       	mov.aa %a5,%a13
8000d958:	40 2e       	mov.aa %a14,%a2
8000d95a:	40 c4       	mov.aa %a4,%a12
8000d95c:	6d ff a2 fe 	call 8000d6a0 <_Bfree>
8000d960:	40 ed       	mov.aa %a13,%a14
8000d962:	86 ff       	sha %d15,-1
8000d964:	6e 0d       	jz %d15,8000d97e <__pow5mult+0x78>
8000d966:	c8 02       	ld.a %a2,[%a15]0
8000d968:	bc 23       	jz.a %a2,8000d96e <__pow5mult+0x68>
8000d96a:	40 2f       	mov.aa %a15,%a2
8000d96c:	3c ef       	j 8000d94a <__pow5mult+0x44>
8000d96e:	40 c4       	mov.aa %a4,%a12
8000d970:	40 f5       	mov.aa %a5,%a15
8000d972:	40 f6       	mov.aa %a6,%a15
8000d974:	6d ff 3c ff 	call 8000d7ec <__multiply>
8000d978:	e8 02       	st.a [%a15]0,%a2
8000d97a:	74 28       	st.w [%a2],%d8
8000d97c:	3c f7       	j 8000d96a <__pow5mult+0x64>
8000d97e:	40 d2       	mov.aa %a2,%a13
8000d980:	00 90       	ret 

8000d982 <__lshift>:
8000d982:	19 5b 10 00 	ld.w %d11,[%a5]16
8000d986:	8f b4 3f 80 	sha %d8,%d4,-5
8000d98a:	02 4a       	mov %d10,%d4
8000d98c:	42 8b       	add %d11,%d8
8000d98e:	19 54 04 00 	ld.w %d4,[%a5]4
8000d992:	4c 52       	ld.w %d15,[%a5]8
8000d994:	40 4e       	mov.aa %a14,%a4
8000d996:	40 5c       	mov.aa %a12,%a5
8000d998:	1b 1b 00 90 	addi %d9,%d11,1
8000d99c:	7f 9f 05 00 	jge %d15,%d9,8000d9a6 <__lshift+0x24>
8000d9a0:	c2 14       	add %d4,1
8000d9a2:	06 1f       	sh %d15,1
8000d9a4:	3c fc       	j 8000d99c <__lshift+0x1a>
8000d9a6:	40 e4       	mov.aa %a4,%a14
8000d9a8:	6d ff 51 fe 	call 8000d64a <_Balloc>
8000d9ac:	8b 08 40 f3 	max %d15,%d8,0
8000d9b0:	40 2d       	mov.aa %a13,%a2
8000d9b2:	d9 2f 14 00 	lea %a15,[%a2]20
8000d9b6:	d2 02       	mov %e2,0
8000d9b8:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
8000d9bc:	9f 0f 03 80 	jned %d15,0,8000d9c2 <__lshift+0x40>
8000d9c0:	3c 04       	j 8000d9c8 <__lshift+0x46>
8000d9c2:	74 23       	st.w [%a2],%d3
8000d9c4:	c2 12       	add %d2,1
8000d9c6:	3c f9       	j 8000d9b8 <__lshift+0x36>
8000d9c8:	8b 08 40 83 	max %d8,%d8,0
8000d9cc:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
8000d9d0:	d9 cf 14 00 	lea %a15,[%a12]20
8000d9d4:	19 c2 10 00 	ld.w %d2,[%a12]16
8000d9d8:	80 f3       	mov.d %d3,%a15
8000d9da:	8f fa 01 41 	and %d4,%d10,31
8000d9de:	13 42 20 23 	madd %d2,%d3,%d2,4
8000d9e2:	8b 04 02 51 	rsub %d5,%d4,32
8000d9e6:	82 0f       	mov %d15,0
8000d9e8:	df 04 1a 00 	jeq %d4,0,8000da1c <__lshift+0x9a>
8000d9ec:	40 f5       	mov.aa %a5,%a15
8000d9ee:	44 53       	ld.w %d3,[%a5+]
8000d9f0:	d9 32 04 00 	lea %a2,[%a3]4
8000d9f4:	0f 43 00 30 	sh %d3,%d3,%d4
8000d9f8:	a6 3f       	or %d15,%d3
8000d9fa:	6c 30       	st.w [%a3]0,%d15
8000d9fc:	4c f0       	ld.w %d15,[%a15]0
8000d9fe:	8b 05 00 31 	rsub %d3,%d5,0
8000da02:	0f 3f 00 30 	sh %d3,%d15,%d3
8000da06:	02 3f       	mov %d15,%d3
8000da08:	80 53       	mov.d %d3,%a5
8000da0a:	40 5f       	mov.aa %a15,%a5
8000da0c:	7f 23 04 80 	jge.u %d3,%d2,8000da14 <__lshift+0x92>
8000da10:	40 23       	mov.aa %a3,%a2
8000da12:	3c ed       	j 8000d9ec <__lshift+0x6a>
8000da14:	c2 2b       	add %d11,2
8000da16:	6c 31       	st.w [%a3]4,%d15
8000da18:	2a b9       	cmov %d9,%d15,%d11
8000da1a:	3c 08       	j 8000da2a <__lshift+0xa8>
8000da1c:	4c f0       	ld.w %d15,[%a15]0
8000da1e:	b0 4f       	add.a %a15,4
8000da20:	80 f3       	mov.d %d3,%a15
8000da22:	6c 30       	st.w [%a3]0,%d15
8000da24:	b0 43       	add.a %a3,4
8000da26:	3f 23 fb ff 	jlt.u %d3,%d2,8000da1c <__lshift+0x9a>
8000da2a:	c2 f9       	add %d9,-1
8000da2c:	59 d9 10 00 	st.w [%a13]16,%d9
8000da30:	40 e4       	mov.aa %a4,%a14
8000da32:	40 c5       	mov.aa %a5,%a12
8000da34:	6d ff 36 fe 	call 8000d6a0 <_Bfree>
8000da38:	40 d2       	mov.aa %a2,%a13
8000da3a:	00 90       	ret 

8000da3c <__mcmp>:
8000da3c:	4c 54       	ld.w %d15,[%a5]16
8000da3e:	19 42 10 00 	ld.w %d2,[%a4]16
8000da42:	a2 f2       	sub %d2,%d15
8000da44:	df 02 1c 80 	jne %d2,0,8000da7c <__mcmp+0x40>
8000da48:	80 42       	mov.d %d2,%a4
8000da4a:	06 2f       	sh %d15,2
8000da4c:	60 f2       	mov.a %a2,%d15
8000da4e:	1b 42 01 30 	addi %d3,%d2,20
8000da52:	d9 55 14 00 	lea %a5,[%a5]20
8000da56:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
8000da5a:	30 25       	add.a %a5,%a2
8000da5c:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
8000da60:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
8000da64:	5f f2 08 00 	jeq %d2,%d15,8000da74 <__mcmp+0x38>
8000da68:	0b f2 30 21 	lt.u %d2,%d2,%d15
8000da6c:	82 f3       	mov %d3,-1
8000da6e:	ab 13 80 22 	sel %d2,%d2,%d3,1
8000da72:	00 90       	ret 
8000da74:	80 ff       	mov.d %d15,%a15
8000da76:	3f f3 f3 ff 	jlt.u %d3,%d15,8000da5c <__mcmp+0x20>
8000da7a:	82 02       	mov %d2,0
8000da7c:	00 90       	ret 

8000da7e <__mdiff>:
8000da7e:	40 4d       	mov.aa %a13,%a4
8000da80:	40 5f       	mov.aa %a15,%a5
8000da82:	40 54       	mov.aa %a4,%a5
8000da84:	40 65       	mov.aa %a5,%a6
8000da86:	40 6c       	mov.aa %a12,%a6
8000da88:	6d ff da ff 	call 8000da3c <__mcmp>
8000da8c:	02 2f       	mov %d15,%d2
8000da8e:	f6 2a       	jnz %d2,8000daa2 <__mdiff+0x24>
8000da90:	40 d4       	mov.aa %a4,%a13
8000da92:	82 04       	mov %d4,0
8000da94:	6d ff db fd 	call 8000d64a <_Balloc>
8000da98:	82 12       	mov %d2,1
8000da9a:	59 22 10 00 	st.w [%a2]16,%d2
8000da9e:	6c 25       	st.w [%a2]20,%d15
8000daa0:	00 90       	ret 
8000daa2:	82 08       	mov %d8,0
8000daa4:	ce 25       	jgez %d2,8000daae <__mdiff+0x30>
8000daa6:	40 f2       	mov.aa %a2,%a15
8000daa8:	82 18       	mov %d8,1
8000daaa:	40 cf       	mov.aa %a15,%a12
8000daac:	40 2c       	mov.aa %a12,%a2
8000daae:	40 d4       	mov.aa %a4,%a13
8000dab0:	48 14       	ld.w %d4,[%a15]4
8000dab2:	6d ff cc fd 	call 8000d64a <_Balloc>
8000dab6:	48 42       	ld.w %d2,[%a15]16
8000dab8:	d9 ff 14 00 	lea %a15,[%a15]20
8000dabc:	80 ff       	mov.d %d15,%a15
8000dabe:	d9 c4 14 00 	lea %a4,[%a12]20
8000dac2:	13 42 20 7f 	madd %d7,%d15,%d2,4
8000dac6:	19 c0 10 00 	ld.w %d0,[%a12]16
8000daca:	80 4f       	mov.d %d15,%a4
8000dacc:	59 28 0c 00 	st.w [%a2]12,%d8
8000dad0:	13 40 20 0f 	madd %d0,%d15,%d0,4
8000dad4:	d9 25 14 00 	lea %a5,[%a2]20
8000dad8:	82 03       	mov %d3,0
8000dada:	44 f6       	ld.w %d6,[%a15+]
8000dadc:	44 45       	ld.w %d5,[%a4+]
8000dade:	b7 06 10 48 	insert %d4,%d6,0,16,16
8000dae2:	b7 05 10 18 	insert %d1,%d5,0,16,16
8000dae6:	42 34       	add %d4,%d3
8000dae8:	a2 14       	sub %d4,%d1
8000daea:	8f 06 1f 60 	sh %d6,%d6,-16
8000daee:	8f 05 1f 50 	sh %d5,%d5,-16
8000daf2:	8f 04 3f 30 	sha %d3,%d4,-16
8000daf6:	0b 56 80 50 	sub %d5,%d6,%d5
8000dafa:	1a 35       	add %d15,%d5,%d3
8000dafc:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000db00:	8f 0f 3f 30 	sha %d3,%d15,-16
8000db04:	80 4f       	mov.d %d15,%a4
8000db06:	d9 53 04 00 	lea %a3,[%a5]4
8000db0a:	74 54       	st.w [%a5],%d4
8000db0c:	40 35       	mov.aa %a5,%a3
8000db0e:	3f 0f e6 ff 	jlt.u %d15,%d0,8000dada <__mdiff+0x5c>
8000db12:	80 ff       	mov.d %d15,%a15
8000db14:	7f 7f 12 80 	jge.u %d15,%d7,8000db38 <__mdiff+0xba>
8000db18:	44 f5       	ld.w %d5,[%a15+]
8000db1a:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000db1e:	8f 05 1f 50 	sh %d5,%d5,-16
8000db22:	42 34       	add %d4,%d3
8000db24:	8f 04 3f f0 	sha %d15,%d4,-16
8000db28:	42 5f       	add %d15,%d5
8000db2a:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000db2e:	8f 0f 3f 30 	sha %d3,%d15,-16
8000db32:	74 34       	st.w [%a3],%d4
8000db34:	b0 43       	add.a %a3,4
8000db36:	3c ee       	j 8000db12 <__mdiff+0x94>
8000db38:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
8000db3c:	ee 03       	jnz %d15,8000db42 <__mdiff+0xc4>
8000db3e:	c2 f2       	add %d2,-1
8000db40:	3c fc       	j 8000db38 <__mdiff+0xba>
8000db42:	59 22 10 00 	st.w [%a2]16,%d2
8000db46:	00 90       	ret 

8000db48 <__d2b>:
8000db48:	20 08       	sub.a %sp,8
8000db4a:	02 48       	mov %d8,%d4
8000db4c:	82 14       	mov %d4,1
8000db4e:	02 59       	mov %d9,%d5
8000db50:	40 5d       	mov.aa %a13,%a5
8000db52:	40 6c       	mov.aa %a12,%a6
8000db54:	6d ff 7b fd 	call 8000d64a <_Balloc>
8000db58:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
8000db5c:	37 09 6b 9a 	extr.u %d9,%d9,20,11
8000db60:	40 2f       	mov.aa %a15,%a2
8000db62:	76 93       	jz %d9,8000db68 <__d2b+0x20>
8000db64:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
8000db68:	59 a2 04 00 	st.w [%sp]4,%d2
8000db6c:	df 08 20 00 	jeq %d8,0,8000dbac <__d2b+0x64>
8000db70:	d9 a4 08 00 	lea %a4,[%sp]8
8000db74:	89 48 38 f5 	st.w [+%a4]-8,%d8
8000db78:	40 a4       	mov.aa %a4,%sp
8000db7a:	6d ff fe fd 	call 8000d776 <__lo0bits>
8000db7e:	58 00       	ld.w %d15,[%sp]0
8000db80:	76 2f       	jz %d2,8000db9e <__d2b+0x56>
8000db82:	19 a4 04 00 	ld.w %d4,[%sp]4
8000db86:	8b 02 02 31 	rsub %d3,%d2,32
8000db8a:	0f 34 00 30 	sh %d3,%d4,%d3
8000db8e:	a6 3f       	or %d15,%d3
8000db90:	68 5f       	st.w [%a15]20,%d15
8000db92:	8b 02 00 f1 	rsub %d15,%d2,0
8000db96:	0f f4 00 f0 	sh %d15,%d4,%d15
8000db9a:	78 01       	st.w [%sp]4,%d15
8000db9c:	3c 02       	j 8000dba0 <__d2b+0x58>
8000db9e:	68 5f       	st.w [%a15]20,%d15
8000dba0:	58 01       	ld.w %d15,[%sp]4
8000dba2:	82 28       	mov %d8,2
8000dba4:	ea 18       	cmovn %d8,%d15,1
8000dba6:	68 6f       	st.w [%a15]24,%d15
8000dba8:	68 48       	st.w [%a15]16,%d8
8000dbaa:	3c 0c       	j 8000dbc2 <__d2b+0x7a>
8000dbac:	d9 a4 04 00 	lea %a4,[%sp]4
8000dbb0:	6d ff e3 fd 	call 8000d776 <__lo0bits>
8000dbb4:	58 01       	ld.w %d15,[%sp]4
8000dbb6:	1b 02 02 20 	addi %d2,%d2,32
8000dbba:	68 5f       	st.w [%a15]20,%d15
8000dbbc:	82 1f       	mov %d15,1
8000dbbe:	68 4f       	st.w [%a15]16,%d15
8000dbc0:	82 18       	mov %d8,1
8000dbc2:	76 98       	jz %d9,8000dbd2 <__d2b+0x8a>
8000dbc4:	1b d9 bc 9f 	addi %d9,%d9,-1075
8000dbc8:	42 29       	add %d9,%d2
8000dbca:	74 d9       	st.w [%a13],%d9
8000dbcc:	8b 52 03 21 	rsub %d2,%d2,53
8000dbd0:	3c 0d       	j 8000dbea <__d2b+0xa2>
8000dbd2:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
8000dbd6:	1b e2 bc 2f 	addi %d2,%d2,-1074
8000dbda:	74 d2       	st.w [%a13],%d2
8000dbdc:	19 24 10 00 	ld.w %d4,[%a2]16
8000dbe0:	6d ff aa fd 	call 8000d734 <__hi0bits>
8000dbe4:	06 58       	sh %d8,5
8000dbe6:	0b 28 80 20 	sub %d2,%d8,%d2
8000dbea:	74 c2       	st.w [%a12],%d2
8000dbec:	40 f2       	mov.aa %a2,%a15
8000dbee:	00 90       	ret 

8000dbf0 <__fpclassifyd>:
8000dbf0:	0f 45 a0 f0 	or %d15,%d5,%d4
8000dbf4:	82 22       	mov %d2,2
8000dbf6:	6e 1d       	jz %d15,8000dc30 <__fpclassifyd+0x40>
8000dbf8:	7b 00 00 38 	movh %d3,32768
8000dbfc:	3a 53       	eq %d15,%d3,%d5
8000dbfe:	8b 04 00 f4 	and.eq %d15,%d4,0
8000dc02:	8b 04 00 62 	eq %d6,%d4,0
8000dc06:	ee 15       	jnz %d15,8000dc30 <__fpclassifyd+0x40>
8000dc08:	b7 05 81 5f 	insert %d5,%d5,0,31,1
8000dc0c:	7b 00 fe f7 	movh %d15,32736
8000dc10:	9b 05 ff 3f 	addih %d3,%d5,65520
8000dc14:	82 42       	mov %d2,4
8000dc16:	3f f3 0d 80 	jlt.u %d3,%d15,8000dc30 <__fpclassifyd+0x40>
8000dc1a:	7b 00 01 f0 	movh %d15,16
8000dc1e:	82 32       	mov %d2,3
8000dc20:	3f f5 08 80 	jlt.u %d5,%d15,8000dc30 <__fpclassifyd+0x40>
8000dc24:	7b 00 ff 27 	movh %d2,32752
8000dc28:	0b 25 00 51 	eq %d5,%d5,%d2
8000dc2c:	0f 56 80 20 	and %d2,%d6,%d5
8000dc30:	00 90       	ret 

8000dc32 <__ssprint_r>:
8000dc32:	4c 62       	ld.w %d15,[%a6]8
8000dc34:	20 08       	sub.a %sp,8
8000dc36:	40 4e       	mov.aa %a14,%a4
8000dc38:	40 5f       	mov.aa %a15,%a5
8000dc3a:	40 6c       	mov.aa %a12,%a6
8000dc3c:	54 6c       	ld.w %d12,[%a6]
8000dc3e:	6e 30       	jz %d15,8000dc9e <__ssprint_r+0x6c>
8000dc40:	a0 02       	mov.a %a2,0
8000dc42:	b5 a2 04 00 	st.a [%sp]4,%a2
8000dc46:	82 09       	mov %d9,0
8000dc48:	3b 00 48 e0 	mov %d14,1152
8000dc4c:	3b f0 b7 df 	mov %d13,-1153
8000dc50:	3c 0a       	j 8000dc64 <__ssprint_r+0x32>
8000dc52:	60 c2       	mov.a %a2,%d12
8000dc54:	d4 22       	ld.a %a2,[%a2]
8000dc56:	b5 a2 04 00 	st.a [%sp]4,%a2
8000dc5a:	60 c2       	mov.a %a2,%d12
8000dc5c:	1b 8c 00 c0 	addi %d12,%d12,8
8000dc60:	19 29 04 00 	ld.w %d9,[%a2]4
8000dc64:	df 09 f7 7f 	jeq %d9,0,8000dc52 <__ssprint_r+0x20>
8000dc68:	48 28       	ld.w %d8,[%a15]8
8000dc6a:	3f 89 5a 80 	jlt.u %d9,%d8,8000dd1e <__ssprint_r+0xec>
8000dc6e:	88 62       	ld.h %d2,[%a15]12
8000dc70:	0f e2 80 f0 	and %d15,%d2,%d14
8000dc74:	ee 19       	jnz %d15,8000dca6 <__ssprint_r+0x74>
8000dc76:	3f 89 54 80 	jlt.u %d9,%d8,8000dd1e <__ssprint_r+0xec>
8000dc7a:	c8 04       	ld.a %a4,[%a15]0
8000dc7c:	99 a5 04 00 	ld.a %a5,[%sp]4 <0 <NULL>>
8000dc80:	02 84       	mov %d4,%d8
8000dc82:	6d 00 81 00 	call 8000dd84 <memmove>
8000dc86:	4c f2       	ld.w %d15,[%a15]8
8000dc88:	a2 8f       	sub %d15,%d8
8000dc8a:	68 2f       	st.w [%a15]8,%d15
8000dc8c:	4c f0       	ld.w %d15,[%a15]0
8000dc8e:	42 f8       	add %d8,%d15
8000dc90:	4c c2       	ld.w %d15,[%a12]8
8000dc92:	68 08       	st.w [%a15]0,%d8
8000dc94:	52 99       	sub %d9,%d15,%d9
8000dc96:	59 c9 08 00 	st.w [%a12]8,%d9
8000dc9a:	df 09 dc ff 	jne %d9,0,8000dc52 <__ssprint_r+0x20>
8000dc9e:	82 0f       	mov %d15,0
8000dca0:	6c c1       	st.w [%a12]4,%d15
8000dca2:	82 02       	mov %d2,0
8000dca4:	00 90       	ret 
8000dca6:	c8 45       	ld.a %a5,[%a15]16
8000dca8:	48 5a       	ld.w %d10,[%a15]20
8000dcaa:	4c f0       	ld.w %d15,[%a15]0
8000dcac:	80 53       	mov.d %d3,%a5
8000dcae:	53 3a 20 a0 	mul %d10,%d10,3
8000dcb2:	a2 3f       	sub %d15,%d3
8000dcb4:	82 23       	mov %d3,2
8000dcb6:	4b 3a 01 a2 	div %e10,%d10,%d3
8000dcba:	92 13       	add %d3,%d15,1
8000dcbc:	42 93       	add %d3,%d9
8000dcbe:	0b 3a b0 a1 	max.u %d10,%d10,%d3
8000dcc2:	40 e4       	mov.aa %a4,%a14
8000dcc4:	02 a4       	mov %d4,%d10
8000dcc6:	6f a2 12 00 	jz.t %d2,10,8000dcea <__ssprint_r+0xb8>
8000dcca:	6d ff 0c e9 	call 8000aee2 <_malloc_r>
8000dcce:	40 2d       	mov.aa %a13,%a2
8000dcd0:	bd 02 15 00 	jz.a %a2,8000dcfa <__ssprint_r+0xc8>
8000dcd4:	c8 45       	ld.a %a5,[%a15]16
8000dcd6:	40 24       	mov.aa %a4,%a2
8000dcd8:	02 f4       	mov %d4,%d15
8000dcda:	6d ff aa fc 	call 8000d62e <memcpy>
8000dcde:	88 62       	ld.h %d2,[%a15]12
8000dce0:	26 d2       	and %d2,%d13
8000dce2:	8f 02 48 21 	or %d2,%d2,128
8000dce6:	a8 62       	st.h [%a15]12,%d2
8000dce8:	3c 13       	j 8000dd0e <__ssprint_r+0xdc>
8000dcea:	6d 00 7d 00 	call 8000dde4 <_realloc_r>
8000dcee:	40 2d       	mov.aa %a13,%a2
8000dcf0:	7c 2f       	jnz.a %a2,8000dd0e <__ssprint_r+0xdc>
8000dcf2:	c8 45       	ld.a %a5,[%a15]16
8000dcf4:	40 e4       	mov.aa %a4,%a14
8000dcf6:	6d ff eb eb 	call 8000b4cc <_free_r>
8000dcfa:	da 0c       	mov %d15,12
8000dcfc:	6c e0       	st.w [%a14]0,%d15
8000dcfe:	8c f6       	ld.h %d15,[%a15]12
8000dd00:	82 f2       	mov %d2,-1
8000dd02:	96 40       	or %d15,64
8000dd04:	a8 6f       	st.h [%a15]12,%d15
8000dd06:	82 0f       	mov %d15,0
8000dd08:	6c c2       	st.w [%a12]8,%d15
8000dd0a:	6c c1       	st.w [%a12]4,%d15
8000dd0c:	00 90       	ret 
8000dd0e:	e8 4d       	st.a [%a15]16,%a13
8000dd10:	10 dd       	addsc.a %a13,%a13,%d15,0
8000dd12:	68 5a       	st.w [%a15]20,%d10
8000dd14:	a2 fa       	sub %d10,%d15
8000dd16:	e8 0d       	st.a [%a15]0,%a13
8000dd18:	02 98       	mov %d8,%d9
8000dd1a:	68 2a       	st.w [%a15]8,%d10
8000dd1c:	3c ad       	j 8000dc76 <__ssprint_r+0x44>
8000dd1e:	02 98       	mov %d8,%d9
8000dd20:	3c ad       	j 8000dc7a <__ssprint_r+0x48>

8000dd22 <_calloc_r>:
8000dd22:	e2 54       	mul %d4,%d5
8000dd24:	6d ff df e8 	call 8000aee2 <_malloc_r>
8000dd28:	40 2f       	mov.aa %a15,%a2
8000dd2a:	a0 02       	mov.a %a2,0
8000dd2c:	bd 0f 2b 00 	jz.a %a15,8000dd82 <_calloc_r+0x60>
8000dd30:	19 f5 fc ff 	ld.w %d5,[%a15]-4
8000dd34:	8f 35 c0 51 	andn %d5,%d5,3
8000dd38:	c2 c5       	add %d5,-4
8000dd3a:	8b 55 a2 f2 	ge.u %d15,%d5,37
8000dd3e:	ee 1d       	jnz %d15,8000dd78 <_calloc_r+0x56>
8000dd40:	8b 45 61 f2 	lt.u %d15,%d5,20
8000dd44:	40 f2       	mov.aa %a2,%a15
8000dd46:	ee 14       	jnz %d15,8000dd6e <_calloc_r+0x4c>
8000dd48:	82 0f       	mov %d15,0
8000dd4a:	68 0f       	st.w [%a15]0,%d15
8000dd4c:	68 1f       	st.w [%a15]4,%d15
8000dd4e:	8b c5 a1 22 	ge.u %d2,%d5,28
8000dd52:	d9 f2 08 00 	lea %a2,[%a15]8
8000dd56:	76 2c       	jz %d2,8000dd6e <_calloc_r+0x4c>
8000dd58:	68 2f       	st.w [%a15]8,%d15
8000dd5a:	68 3f       	st.w [%a15]12,%d15
8000dd5c:	8b 45 02 52 	eq %d5,%d5,36
8000dd60:	d9 f2 10 00 	lea %a2,[%a15]16
8000dd64:	76 55       	jz %d5,8000dd6e <_calloc_r+0x4c>
8000dd66:	68 4f       	st.w [%a15]16,%d15
8000dd68:	d9 f2 18 00 	lea %a2,[%a15]24
8000dd6c:	68 5f       	st.w [%a15]20,%d15
8000dd6e:	82 0f       	mov %d15,0
8000dd70:	6c 20       	st.w [%a2]0,%d15
8000dd72:	6c 21       	st.w [%a2]4,%d15
8000dd74:	6c 22       	st.w [%a2]8,%d15
8000dd76:	3c 05       	j 8000dd80 <_calloc_r+0x5e>
8000dd78:	40 f4       	mov.aa %a4,%a15
8000dd7a:	82 04       	mov %d4,0
8000dd7c:	6d 00 2c 00 	call 8000ddd4 <memset>
8000dd80:	40 f2       	mov.aa %a2,%a15
8000dd82:	00 90       	ret 

8000dd84 <memmove>:
8000dd84:	80 46       	mov.d %d6,%a4
8000dd86:	80 52       	mov.d %d2,%a5
8000dd88:	7f 62 16 80 	jge.u %d2,%d6,8000ddb4 <memmove+0x30>
8000dd8c:	0b 42 00 50 	add %d5,%d2,%d4
8000dd90:	7f 56 12 80 	jge.u %d6,%d5,8000ddb4 <memmove+0x30>
8000dd94:	60 4f       	mov.a %a15,%d4
8000dd96:	02 42       	mov %d2,%d4
8000dd98:	c2 f2       	add %d2,-1
8000dd9a:	fd f0 03 00 	loop %a15,8000dda0 <memmove+0x1c>
8000dd9e:	3c 19       	j 8000ddd0 <memmove+0x4c>
8000dda0:	5a 42       	sub %d15,%d2,%d4
8000dda2:	60 f2       	mov.a %a2,%d15
8000dda4:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
8000dda8:	1a 62       	add %d15,%d2,%d6
8000ddaa:	79 23 00 00 	ld.b %d3,[%a2]0
8000ddae:	60 f2       	mov.a %a2,%d15
8000ddb0:	34 23       	st.b [%a2],%d3
8000ddb2:	3c f3       	j 8000dd98 <memmove+0x14>
8000ddb4:	60 4f       	mov.a %a15,%d4
8000ddb6:	a0 02       	mov.a %a2,0
8000ddb8:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
8000ddbc:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
8000ddc0:	fd f0 03 00 	loop %a15,8000ddc6 <memmove+0x42>
8000ddc4:	3c 06       	j 8000ddd0 <memmove+0x4c>
8000ddc6:	79 33 00 00 	ld.b %d3,[%a3]0
8000ddca:	b0 12       	add.a %a2,1
8000ddcc:	34 43       	st.b [%a4],%d3
8000ddce:	3c f5       	j 8000ddb8 <memmove+0x34>
8000ddd0:	60 62       	mov.a %a2,%d6
8000ddd2:	00 90       	ret 

8000ddd4 <memset>:
8000ddd4:	40 42       	mov.aa %a2,%a4
8000ddd6:	40 4f       	mov.aa %a15,%a4
8000ddd8:	9f 05 03 80 	jned %d5,0,8000ddde <memset+0xa>
8000dddc:	00 90       	ret 
8000ddde:	28 04       	st.b [%a15]0,%d4
8000dde0:	b0 1f       	add.a %a15,1
8000dde2:	3c fb       	j 8000ddd8 <memset+0x4>

8000dde4 <_realloc_r>:
8000dde4:	40 4d       	mov.aa %a13,%a4
8000dde6:	40 5f       	mov.aa %a15,%a5
8000dde8:	02 49       	mov %d9,%d4
8000ddea:	7c 53       	jnz.a %a5,8000ddf0 <_realloc_r+0xc>
8000ddec:	1d ff 7b e8 	j 8000aee2 <_malloc_r>
8000ddf0:	6d ff c6 ea 	call 8000b37c <__malloc_lock>
8000ddf4:	1b b9 00 20 	addi %d2,%d9,11
8000ddf8:	8b 72 61 f2 	lt.u %d15,%d2,23
8000ddfc:	8f 72 c0 21 	andn %d2,%d2,7
8000de00:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
8000de04:	19 f3 fc ff 	ld.w %d3,[%a15]-4
8000de08:	0b 9f 30 21 	lt.u %d2,%d15,%d9
8000de0c:	8b 0f 20 25 	or.lt %d2,%d15,0
8000de10:	d9 fe f8 ff 	lea %a14,[%a15]-8
8000de14:	8f 33 c0 81 	andn %d8,%d3,3
8000de18:	76 25       	jz %d2,8000de22 <_realloc_r+0x3e>
8000de1a:	da 0c       	mov %d15,12
8000de1c:	6c d0       	st.w [%a13]0,%d15
8000de1e:	1d 00 56 01 	j 8000e0ca <_realloc_r+0x2e6>
8000de22:	7f f8 ac 01 	jge %d8,%d15,8000e17a <_realloc_r+0x396>
8000de26:	7b 00 00 c7 	movh %d12,28672
8000de2a:	60 c3       	mov.a %a3,%d12
8000de2c:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
8000de30:	d9 34 00 40 	lea %a4,[%a3]256
8000de34:	99 43 08 00 	ld.a %a3,[%a4]8
8000de38:	80 4c       	mov.d %d12,%a4
8000de3a:	19 2b 04 00 	ld.w %d11,[%a2]4
8000de3e:	7d 32 0a 00 	jeq.a %a2,%a3,8000de52 <_realloc_r+0x6e>
8000de42:	8f 1b c0 21 	andn %d2,%d11,1
8000de46:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
8000de4a:	19 42 04 00 	ld.w %d2,[%a4]4
8000de4e:	6f 02 2b 80 	jnz.t %d2,0,8000dea4 <_realloc_r+0xc0>
8000de52:	8f 3b c0 b1 	andn %d11,%d11,3
8000de56:	0b 8b 00 20 	add %d2,%d11,%d8
8000de5a:	7d 32 1b 80 	jne.a %a2,%a3,8000de90 <_realloc_r+0xac>
8000de5e:	1b 0f 01 40 	addi %d4,%d15,16
8000de62:	3f 42 23 00 	jlt %d2,%d4,8000dea8 <_realloc_r+0xc4>
8000de66:	10 ee       	addsc.a %a14,%a14,%d15,0
8000de68:	60 c2       	mov.a %a2,%d12
8000de6a:	a2 f2       	sub %d2,%d15
8000de6c:	b5 2e 08 00 	st.a [%a2]8,%a14
8000de70:	8f 12 40 21 	or %d2,%d2,1
8000de74:	59 e2 04 00 	st.w [%a14]4,%d2
8000de78:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000de7c:	40 d4       	mov.aa %a4,%a13
8000de7e:	8f 12 00 21 	and %d2,%d2,1
8000de82:	a6 2f       	or %d15,%d2
8000de84:	59 ff fc ff 	st.w [%a15]-4,%d15
8000de88:	6d ff 7b ea 	call 8000b37e <__malloc_unlock>
8000de8c:	40 f2       	mov.aa %a2,%a15
8000de8e:	00 90       	ret 
8000de90:	3f f2 0c 00 	jlt %d2,%d15,8000dea8 <_realloc_r+0xc4>
8000de94:	cc 23       	ld.a %a15,[%a2]12
8000de96:	99 22 08 00 	ld.a %a2,[%a2]8
8000de9a:	02 28       	mov %d8,%d2
8000de9c:	ec 23       	st.a [%a2]12,%a15
8000de9e:	e8 22       	st.a [%a15]8,%a2
8000dea0:	1d 00 6d 01 	j 8000e17a <_realloc_r+0x396>
8000dea4:	82 0b       	mov %d11,0
8000dea6:	a0 02       	mov.a %a2,0
8000dea8:	6f 03 08 81 	jnz.t %d3,0,8000e0b8 <_realloc_r+0x2d4>
8000deac:	99 fc f8 ff 	ld.a %a12,[%a15]-8
8000deb0:	01 ce 20 c0 	sub.a %a12,%a14,%a12
8000deb4:	19 ca 04 00 	ld.w %d10,[%a12]4
8000deb8:	8f 3a c0 a1 	andn %d10,%d10,3
8000debc:	42 8a       	add %d10,%d8
8000debe:	bd 02 b3 00 	jz.a %a2,8000e024 <_realloc_r+0x240>
8000dec2:	42 ab       	add %d11,%d10
8000dec4:	7d 32 5f 80 	jne.a %a2,%a3,8000df82 <_realloc_r+0x19e>
8000dec8:	1b 0f 01 20 	addi %d2,%d15,16
8000decc:	3f 2b ac 00 	jlt %d11,%d2,8000e024 <_realloc_r+0x240>
8000ded0:	40 ce       	mov.aa %a14,%a12
8000ded2:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000ded6:	09 e3 88 05 	ld.a %a3,[+%a14]8
8000deda:	1b c8 ff 4f 	addi %d4,%d8,-4
8000dede:	8b 54 a2 22 	ge.u %d2,%d4,37
8000dee2:	b5 32 0c 00 	st.a [%a3]12,%a2
8000dee6:	b5 23 08 00 	st.a [%a2]8,%a3
8000deea:	df 02 36 80 	jne %d2,0,8000df56 <_realloc_r+0x172>
8000deee:	8b 44 61 22 	lt.u %d2,%d4,20
8000def2:	40 e3       	mov.aa %a3,%a14
8000def4:	df 02 28 80 	jne %d2,0,8000df44 <_realloc_r+0x160>
8000def8:	48 02       	ld.w %d2,[%a15]0
8000defa:	59 c2 08 00 	st.w [%a12]8,%d2
8000defe:	48 13       	ld.w %d3,[%a15]4
8000df00:	8b c4 a1 22 	ge.u %d2,%d4,28
8000df04:	59 c3 0c 00 	st.w [%a12]12,%d3
8000df08:	f6 26       	jnz %d2,8000df14 <_realloc_r+0x130>
8000df0a:	d9 c3 10 00 	lea %a3,[%a12]16
8000df0e:	d9 ff 08 00 	lea %a15,[%a15]8
8000df12:	3c 19       	j 8000df44 <_realloc_r+0x160>
8000df14:	48 22       	ld.w %d2,[%a15]8
8000df16:	8b 44 02 82 	eq %d8,%d4,36
8000df1a:	59 c2 10 00 	st.w [%a12]16,%d2
8000df1e:	48 33       	ld.w %d3,[%a15]12
8000df20:	59 c3 14 00 	st.w [%a12]20,%d3
8000df24:	f6 86       	jnz %d8,8000df30 <_realloc_r+0x14c>
8000df26:	d9 c3 18 00 	lea %a3,[%a12]24
8000df2a:	d9 ff 10 00 	lea %a15,[%a15]16
8000df2e:	3c 0b       	j 8000df44 <_realloc_r+0x160>
8000df30:	48 42       	ld.w %d2,[%a15]16
8000df32:	d9 c3 20 00 	lea %a3,[%a12]32
8000df36:	59 c2 18 00 	st.w [%a12]24,%d2
8000df3a:	48 53       	ld.w %d3,[%a15]20
8000df3c:	d9 ff 18 00 	lea %a15,[%a15]24
8000df40:	59 c3 1c 00 	st.w [%a12]28,%d3
8000df44:	48 02       	ld.w %d2,[%a15]0
8000df46:	74 32       	st.w [%a3],%d2
8000df48:	48 13       	ld.w %d3,[%a15]4
8000df4a:	59 33 04 00 	st.w [%a3]4,%d3
8000df4e:	48 22       	ld.w %d2,[%a15]8
8000df50:	59 32 08 00 	st.w [%a3]8,%d2
8000df54:	3c 05       	j 8000df5e <_realloc_r+0x17a>
8000df56:	40 e4       	mov.aa %a4,%a14
8000df58:	40 f5       	mov.aa %a5,%a15
8000df5a:	6d ff 15 ff 	call 8000dd84 <memmove>
8000df5e:	10 cf       	addsc.a %a15,%a12,%d15,0
8000df60:	60 c2       	mov.a %a2,%d12
8000df62:	a2 fb       	sub %d11,%d15
8000df64:	ec 22       	st.a [%a2]8,%a15
8000df66:	8f 1b 40 b1 	or %d11,%d11,1
8000df6a:	68 1b       	st.w [%a15]4,%d11
8000df6c:	19 c2 04 00 	ld.w %d2,[%a12]4
8000df70:	40 d4       	mov.aa %a4,%a13
8000df72:	8f 12 00 21 	and %d2,%d2,1
8000df76:	a6 2f       	or %d15,%d2
8000df78:	6c c1       	st.w [%a12]4,%d15
8000df7a:	6d ff 02 ea 	call 8000b37e <__malloc_unlock>
8000df7e:	40 e2       	mov.aa %a2,%a14
8000df80:	00 90       	ret 
8000df82:	3f fb 51 00 	jlt %d11,%d15,8000e024 <_realloc_r+0x240>
8000df86:	99 23 0c 00 	ld.a %a3,[%a2]12
8000df8a:	99 22 08 00 	ld.a %a2,[%a2]8
8000df8e:	40 c4       	mov.aa %a4,%a12
8000df90:	1b c8 ff 4f 	addi %d4,%d8,-4
8000df94:	b5 23 0c 00 	st.a [%a2]12,%a3
8000df98:	b5 32 08 00 	st.a [%a3]8,%a2
8000df9c:	09 43 88 05 	ld.a %a3,[+%a4]8
8000dfa0:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000dfa4:	8b 54 a2 22 	ge.u %d2,%d4,37
8000dfa8:	b5 32 0c 00 	st.a [%a3]12,%a2
8000dfac:	b5 23 08 00 	st.a [%a2]8,%a3
8000dfb0:	df 02 35 80 	jne %d2,0,8000e01a <_realloc_r+0x236>
8000dfb4:	8b 44 61 22 	lt.u %d2,%d4,20
8000dfb8:	df 02 28 80 	jne %d2,0,8000e008 <_realloc_r+0x224>
8000dfbc:	48 02       	ld.w %d2,[%a15]0
8000dfbe:	59 c2 08 00 	st.w [%a12]8,%d2
8000dfc2:	48 13       	ld.w %d3,[%a15]4
8000dfc4:	8b c4 a1 22 	ge.u %d2,%d4,28
8000dfc8:	59 c3 0c 00 	st.w [%a12]12,%d3
8000dfcc:	f6 26       	jnz %d2,8000dfd8 <_realloc_r+0x1f4>
8000dfce:	d9 c4 10 00 	lea %a4,[%a12]16
8000dfd2:	d9 ff 08 00 	lea %a15,[%a15]8
8000dfd6:	3c 19       	j 8000e008 <_realloc_r+0x224>
8000dfd8:	48 22       	ld.w %d2,[%a15]8
8000dfda:	8b 44 02 82 	eq %d8,%d4,36
8000dfde:	59 c2 10 00 	st.w [%a12]16,%d2
8000dfe2:	48 33       	ld.w %d3,[%a15]12
8000dfe4:	59 c3 14 00 	st.w [%a12]20,%d3
8000dfe8:	f6 86       	jnz %d8,8000dff4 <_realloc_r+0x210>
8000dfea:	d9 c4 18 00 	lea %a4,[%a12]24
8000dfee:	d9 ff 10 00 	lea %a15,[%a15]16
8000dff2:	3c 0b       	j 8000e008 <_realloc_r+0x224>
8000dff4:	48 42       	ld.w %d2,[%a15]16
8000dff6:	d9 c4 20 00 	lea %a4,[%a12]32
8000dffa:	59 c2 18 00 	st.w [%a12]24,%d2
8000dffe:	48 53       	ld.w %d3,[%a15]20
8000e000:	d9 ff 18 00 	lea %a15,[%a15]24
8000e004:	59 c3 1c 00 	st.w [%a12]28,%d3
8000e008:	48 02       	ld.w %d2,[%a15]0
8000e00a:	74 42       	st.w [%a4],%d2
8000e00c:	48 13       	ld.w %d3,[%a15]4
8000e00e:	59 43 04 00 	st.w [%a4]4,%d3
8000e012:	48 22       	ld.w %d2,[%a15]8
8000e014:	59 42 08 00 	st.w [%a4]8,%d2
8000e018:	3c 04       	j 8000e020 <_realloc_r+0x23c>
8000e01a:	40 f5       	mov.aa %a5,%a15
8000e01c:	6d ff b4 fe 	call 8000dd84 <memmove>
8000e020:	02 b8       	mov %d8,%d11
8000e022:	3c 45       	j 8000e0ac <_realloc_r+0x2c8>
8000e024:	3f fa 4a 00 	jlt %d10,%d15,8000e0b8 <_realloc_r+0x2d4>
8000e028:	40 c4       	mov.aa %a4,%a12
8000e02a:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000e02e:	09 43 88 05 	ld.a %a3,[+%a4]8
8000e032:	1b c8 ff 4f 	addi %d4,%d8,-4
8000e036:	8b 54 a2 22 	ge.u %d2,%d4,37
8000e03a:	b5 32 0c 00 	st.a [%a3]12,%a2
8000e03e:	b5 23 08 00 	st.a [%a2]8,%a3
8000e042:	df 02 37 80 	jne %d2,0,8000e0b0 <_realloc_r+0x2cc>
8000e046:	8b 44 61 22 	lt.u %d2,%d4,20
8000e04a:	df 02 28 80 	jne %d2,0,8000e09a <_realloc_r+0x2b6>
8000e04e:	48 03       	ld.w %d3,[%a15]0
8000e050:	59 c3 08 00 	st.w [%a12]8,%d3
8000e054:	48 12       	ld.w %d2,[%a15]4
8000e056:	59 c2 0c 00 	st.w [%a12]12,%d2
8000e05a:	8b c4 a1 22 	ge.u %d2,%d4,28
8000e05e:	f6 26       	jnz %d2,8000e06a <_realloc_r+0x286>
8000e060:	d9 c4 10 00 	lea %a4,[%a12]16
8000e064:	d9 ff 08 00 	lea %a15,[%a15]8
8000e068:	3c 19       	j 8000e09a <_realloc_r+0x2b6>
8000e06a:	48 23       	ld.w %d3,[%a15]8
8000e06c:	8b 44 02 82 	eq %d8,%d4,36
8000e070:	59 c3 10 00 	st.w [%a12]16,%d3
8000e074:	48 32       	ld.w %d2,[%a15]12
8000e076:	59 c2 14 00 	st.w [%a12]20,%d2
8000e07a:	f6 86       	jnz %d8,8000e086 <_realloc_r+0x2a2>
8000e07c:	d9 c4 18 00 	lea %a4,[%a12]24
8000e080:	d9 ff 10 00 	lea %a15,[%a15]16
8000e084:	3c 0b       	j 8000e09a <_realloc_r+0x2b6>
8000e086:	48 43       	ld.w %d3,[%a15]16
8000e088:	d9 c4 20 00 	lea %a4,[%a12]32
8000e08c:	59 c3 18 00 	st.w [%a12]24,%d3
8000e090:	48 52       	ld.w %d2,[%a15]20
8000e092:	d9 ff 18 00 	lea %a15,[%a15]24
8000e096:	59 c2 1c 00 	st.w [%a12]28,%d2
8000e09a:	48 03       	ld.w %d3,[%a15]0
8000e09c:	74 43       	st.w [%a4],%d3
8000e09e:	48 12       	ld.w %d2,[%a15]4
8000e0a0:	59 42 04 00 	st.w [%a4]4,%d2
8000e0a4:	48 23       	ld.w %d3,[%a15]8
8000e0a6:	59 43 08 00 	st.w [%a4]8,%d3
8000e0aa:	02 a8       	mov %d8,%d10
8000e0ac:	40 ce       	mov.aa %a14,%a12
8000e0ae:	3c 66       	j 8000e17a <_realloc_r+0x396>
8000e0b0:	40 f5       	mov.aa %a5,%a15
8000e0b2:	6d ff 69 fe 	call 8000dd84 <memmove>
8000e0b6:	3c fa       	j 8000e0aa <_realloc_r+0x2c6>
8000e0b8:	40 d4       	mov.aa %a4,%a13
8000e0ba:	02 94       	mov %d4,%d9
8000e0bc:	6d ff 13 e7 	call 8000aee2 <_malloc_r>
8000e0c0:	40 2c       	mov.aa %a12,%a2
8000e0c2:	7c 26       	jnz.a %a2,8000e0ce <_realloc_r+0x2ea>
8000e0c4:	40 d4       	mov.aa %a4,%a13
8000e0c6:	6d ff 5c e9 	call 8000b37e <__malloc_unlock>
8000e0ca:	a0 02       	mov.a %a2,0
8000e0cc:	00 90       	ret 
8000e0ce:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000e0d2:	d9 23 f8 ff 	lea %a3,[%a2]-8
8000e0d6:	8f 12 c0 21 	andn %d2,%d2,1
8000e0da:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
8000e0de:	80 32       	mov.d %d2,%a3
8000e0e0:	80 23       	mov.d %d3,%a2
8000e0e2:	5f 32 08 80 	jne %d2,%d3,8000e0f2 <_realloc_r+0x30e>
8000e0e6:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8000e0ea:	8f 32 c0 21 	andn %d2,%d2,3
8000e0ee:	42 28       	add %d8,%d2
8000e0f0:	3c 45       	j 8000e17a <_realloc_r+0x396>
8000e0f2:	1b c8 ff 4f 	addi %d4,%d8,-4
8000e0f6:	8b 54 a2 f2 	ge.u %d15,%d4,37
8000e0fa:	ee 33       	jnz %d15,8000e160 <_realloc_r+0x37c>
8000e0fc:	8b 44 61 f2 	lt.u %d15,%d4,20
8000e100:	40 c3       	mov.aa %a3,%a12
8000e102:	40 f2       	mov.aa %a2,%a15
8000e104:	ee 23       	jnz %d15,8000e14a <_realloc_r+0x366>
8000e106:	4c f0       	ld.w %d15,[%a15]0
8000e108:	d9 c3 08 00 	lea %a3,[%a12]8
8000e10c:	6c c0       	st.w [%a12]0,%d15
8000e10e:	48 12       	ld.w %d2,[%a15]4
8000e110:	8b c4 a1 f2 	ge.u %d15,%d4,28
8000e114:	59 c2 04 00 	st.w [%a12]4,%d2
8000e118:	d9 f2 08 00 	lea %a2,[%a15]8
8000e11c:	6e 17       	jz %d15,8000e14a <_realloc_r+0x366>
8000e11e:	48 23       	ld.w %d3,[%a15]8
8000e120:	8b 44 02 82 	eq %d8,%d4,36
8000e124:	59 c3 08 00 	st.w [%a12]8,%d3
8000e128:	4c f3       	ld.w %d15,[%a15]12
8000e12a:	d9 c3 10 00 	lea %a3,[%a12]16
8000e12e:	6c c3       	st.w [%a12]12,%d15
8000e130:	d9 f2 10 00 	lea %a2,[%a15]16
8000e134:	76 8b       	jz %d8,8000e14a <_realloc_r+0x366>
8000e136:	48 42       	ld.w %d2,[%a15]16
8000e138:	d9 c3 18 00 	lea %a3,[%a12]24
8000e13c:	59 c2 10 00 	st.w [%a12]16,%d2
8000e140:	48 53       	ld.w %d3,[%a15]20
8000e142:	d9 f2 18 00 	lea %a2,[%a15]24
8000e146:	59 c3 14 00 	st.w [%a12]20,%d3
8000e14a:	4c 20       	ld.w %d15,[%a2]0
8000e14c:	6c 30       	st.w [%a3]0,%d15
8000e14e:	19 22 04 00 	ld.w %d2,[%a2]4
8000e152:	59 32 04 00 	st.w [%a3]4,%d2
8000e156:	19 23 08 00 	ld.w %d3,[%a2]8
8000e15a:	59 33 08 00 	st.w [%a3]8,%d3
8000e15e:	3c 05       	j 8000e168 <_realloc_r+0x384>
8000e160:	40 c4       	mov.aa %a4,%a12
8000e162:	40 f5       	mov.aa %a5,%a15
8000e164:	6d ff 10 fe 	call 8000dd84 <memmove>
8000e168:	40 d4       	mov.aa %a4,%a13
8000e16a:	40 f5       	mov.aa %a5,%a15
8000e16c:	6d ff b0 e9 	call 8000b4cc <_free_r>
8000e170:	40 d4       	mov.aa %a4,%a13
8000e172:	6d ff 06 e9 	call 8000b37e <__malloc_unlock>
8000e176:	40 c2       	mov.aa %a2,%a12
8000e178:	00 90       	ret 
8000e17a:	0b f8 80 20 	sub %d2,%d8,%d15
8000e17e:	8b 02 61 42 	lt.u %d4,%d2,16
8000e182:	19 e3 04 00 	ld.w %d3,[%a14]4
8000e186:	df 04 16 80 	jne %d4,0,8000e1b2 <_realloc_r+0x3ce>
8000e18a:	8f 13 00 31 	and %d3,%d3,1
8000e18e:	10 e5       	addsc.a %a5,%a14,%d15,0
8000e190:	a6 3f       	or %d15,%d3
8000e192:	6c e1       	st.w [%a14]4,%d15
8000e194:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
8000e198:	8f 12 40 f1 	or %d15,%d2,1
8000e19c:	b7 10 21 20 	imask %e2,1,0,1
8000e1a0:	6c 51       	st.w [%a5]4,%d15
8000e1a2:	49 f2 44 08 	ldmst [%a15]4,%e2
8000e1a6:	40 d4       	mov.aa %a4,%a13
8000e1a8:	d9 55 08 00 	lea %a5,[%a5]8
8000e1ac:	6d ff 90 e9 	call 8000b4cc <_free_r>
8000e1b0:	3c 0c       	j 8000e1c8 <_realloc_r+0x3e4>
8000e1b2:	8f 13 00 31 	and %d3,%d3,1
8000e1b6:	a6 83       	or %d3,%d8
8000e1b8:	59 e3 04 00 	st.w [%a14]4,%d3
8000e1bc:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
8000e1c0:	b7 10 21 20 	imask %e2,1,0,1
8000e1c4:	49 f2 44 08 	ldmst [%a15]4,%e2
8000e1c8:	40 d4       	mov.aa %a4,%a13
8000e1ca:	6d ff da e8 	call 8000b37e <__malloc_unlock>
8000e1ce:	d9 e2 08 00 	lea %a2,[%a14]8
8000e1d2:	00 90       	ret 

8000e1d4 <_exit>:
8000e1d4:	76 43       	jz %d4,8000e1da <_exit+0x6>
8000e1d6:	60 4e       	mov.a %a14,%d4
8000e1d8:	3c 04       	j 8000e1e0 <_exit+0xc>
8000e1da:	bb d0 00 f9 	mov.u %d15,36877
8000e1de:	60 fe       	mov.a %a14,%d15
8000e1e0:	00 a0       	debug 
8000e1e2:	3c 00       	j 8000e1e2 <_exit+0xe>

8000e1e4 <sbrk>:
8000e1e4:	91 00 00 f7 	movh.a %a15,28672
8000e1e8:	19 ff b0 40 	ld.w %d15,[%a15]2352 <70000930 <heap_top.2289>>
8000e1ec:	7b 00 00 27 	movh %d2,28672
8000e1f0:	42 f4       	add %d4,%d15
8000e1f2:	1b 82 c9 20 	addi %d2,%d2,3224
8000e1f6:	7f 42 09 80 	jge.u %d2,%d4,8000e208 <sbrk+0x24>
8000e1fa:	6d 00 13 00 	call 8000e220 <__errno>
8000e1fe:	da 0c       	mov %d15,12
8000e200:	6c 20       	st.w [%a2]0,%d15
8000e202:	a0 02       	mov.a %a2,0
8000e204:	b0 f2       	add.a %a2,-1
8000e206:	00 90       	ret 
8000e208:	7b 00 00 27 	movh %d2,28672
8000e20c:	1b 82 c9 20 	addi %d2,%d2,3224
8000e210:	7f 24 04 80 	jge.u %d4,%d2,8000e218 <sbrk+0x34>
8000e214:	6d 00 0b 00 	call 8000e22a <abort>
8000e218:	59 f4 b0 40 	st.w [%a15]2352,%d4
8000e21c:	60 f2       	mov.a %a2,%d15
8000e21e:	00 90       	ret 

8000e220 <__errno>:
8000e220:	91 00 00 27 	movh.a %a2,28672
8000e224:	d9 22 d0 20 	lea %a2,[%a2]3216 <70000c90 <_my_errno>>
8000e228:	00 90       	ret 

8000e22a <abort>:
8000e22a:	00 a0       	debug 
8000e22c:	7b e0 ea fd 	movh %d15,57006
8000e230:	1b ff ee fb 	addi %d15,%d15,-16657
8000e234:	60 fe       	mov.a %a14,%d15
8000e236:	1d ff cf ff 	j 8000e1d4 <_exit>
8000e23a:	3c 00       	j 8000e23a <abort+0x10>

8000e23c <__eqdf2>:
8000e23c:	20 38       	sub.a %sp,56
8000e23e:	40 a4       	mov.aa %a4,%sp
8000e240:	d9 a5 10 00 	lea %a5,[%sp]16
8000e244:	89 a4 40 09 	st.d [%sp],%e4
8000e248:	89 a6 48 09 	st.d [%sp]8,%e6
8000e24c:	6d ff 85 e5 	call 8000ad56 <__unpack_d>
8000e250:	d9 a4 08 00 	lea %a4,[%sp]8
8000e254:	d9 a5 24 00 	lea %a5,[%sp]36
8000e258:	6d ff 7f e5 	call 8000ad56 <__unpack_d>
8000e25c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e260:	82 12       	mov %d2,1
8000e262:	bf 2f 0c 80 	jlt.u %d15,2,8000e27a <__eqdf2+0x3e>
8000e266:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e26a:	bf 2f 08 80 	jlt.u %d15,2,8000e27a <__eqdf2+0x3e>
8000e26e:	d9 a4 10 00 	lea %a4,[%sp]16
8000e272:	d9 a5 24 00 	lea %a5,[%sp]36
8000e276:	6d 00 0d 01 	call 8000e490 <__fpcmp_parts_d>
8000e27a:	00 90       	ret 

8000e27c <__nedf2>:
8000e27c:	20 38       	sub.a %sp,56
8000e27e:	40 a4       	mov.aa %a4,%sp
8000e280:	d9 a5 10 00 	lea %a5,[%sp]16
8000e284:	89 a4 40 09 	st.d [%sp],%e4
8000e288:	89 a6 48 09 	st.d [%sp]8,%e6
8000e28c:	6d ff 65 e5 	call 8000ad56 <__unpack_d>
8000e290:	d9 a4 08 00 	lea %a4,[%sp]8
8000e294:	d9 a5 24 00 	lea %a5,[%sp]36
8000e298:	6d ff 5f e5 	call 8000ad56 <__unpack_d>
8000e29c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e2a0:	82 12       	mov %d2,1
8000e2a2:	bf 2f 0c 80 	jlt.u %d15,2,8000e2ba <__nedf2+0x3e>
8000e2a6:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e2aa:	bf 2f 08 80 	jlt.u %d15,2,8000e2ba <__nedf2+0x3e>
8000e2ae:	d9 a4 10 00 	lea %a4,[%sp]16
8000e2b2:	d9 a5 24 00 	lea %a5,[%sp]36
8000e2b6:	6d 00 ed 00 	call 8000e490 <__fpcmp_parts_d>
8000e2ba:	00 90       	ret 

8000e2bc <__gtdf2>:
8000e2bc:	20 38       	sub.a %sp,56
8000e2be:	40 a4       	mov.aa %a4,%sp
8000e2c0:	d9 a5 10 00 	lea %a5,[%sp]16
8000e2c4:	89 a4 40 09 	st.d [%sp],%e4
8000e2c8:	89 a6 48 09 	st.d [%sp]8,%e6
8000e2cc:	6d ff 45 e5 	call 8000ad56 <__unpack_d>
8000e2d0:	d9 a4 08 00 	lea %a4,[%sp]8
8000e2d4:	d9 a5 24 00 	lea %a5,[%sp]36
8000e2d8:	6d ff 3f e5 	call 8000ad56 <__unpack_d>
8000e2dc:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e2e0:	82 f2       	mov %d2,-1
8000e2e2:	bf 2f 0c 80 	jlt.u %d15,2,8000e2fa <__gtdf2+0x3e>
8000e2e6:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e2ea:	bf 2f 08 80 	jlt.u %d15,2,8000e2fa <__gtdf2+0x3e>
8000e2ee:	d9 a4 10 00 	lea %a4,[%sp]16
8000e2f2:	d9 a5 24 00 	lea %a5,[%sp]36
8000e2f6:	6d 00 cd 00 	call 8000e490 <__fpcmp_parts_d>
8000e2fa:	00 90       	ret 

8000e2fc <__gedf2>:
8000e2fc:	20 38       	sub.a %sp,56
8000e2fe:	40 a4       	mov.aa %a4,%sp
8000e300:	d9 a5 10 00 	lea %a5,[%sp]16
8000e304:	89 a4 40 09 	st.d [%sp],%e4
8000e308:	89 a6 48 09 	st.d [%sp]8,%e6
8000e30c:	6d ff 25 e5 	call 8000ad56 <__unpack_d>
8000e310:	d9 a4 08 00 	lea %a4,[%sp]8
8000e314:	d9 a5 24 00 	lea %a5,[%sp]36
8000e318:	6d ff 1f e5 	call 8000ad56 <__unpack_d>
8000e31c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e320:	82 f2       	mov %d2,-1
8000e322:	bf 2f 0c 80 	jlt.u %d15,2,8000e33a <__gedf2+0x3e>
8000e326:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e32a:	bf 2f 08 80 	jlt.u %d15,2,8000e33a <__gedf2+0x3e>
8000e32e:	d9 a4 10 00 	lea %a4,[%sp]16
8000e332:	d9 a5 24 00 	lea %a5,[%sp]36
8000e336:	6d 00 ad 00 	call 8000e490 <__fpcmp_parts_d>
8000e33a:	00 90       	ret 

8000e33c <__ltdf2>:
8000e33c:	20 38       	sub.a %sp,56
8000e33e:	40 a4       	mov.aa %a4,%sp
8000e340:	d9 a5 10 00 	lea %a5,[%sp]16
8000e344:	89 a4 40 09 	st.d [%sp],%e4
8000e348:	89 a6 48 09 	st.d [%sp]8,%e6
8000e34c:	6d ff 05 e5 	call 8000ad56 <__unpack_d>
8000e350:	d9 a4 08 00 	lea %a4,[%sp]8
8000e354:	d9 a5 24 00 	lea %a5,[%sp]36
8000e358:	6d ff ff e4 	call 8000ad56 <__unpack_d>
8000e35c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e360:	82 12       	mov %d2,1
8000e362:	bf 2f 0c 80 	jlt.u %d15,2,8000e37a <__ltdf2+0x3e>
8000e366:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e36a:	bf 2f 08 80 	jlt.u %d15,2,8000e37a <__ltdf2+0x3e>
8000e36e:	d9 a4 10 00 	lea %a4,[%sp]16
8000e372:	d9 a5 24 00 	lea %a5,[%sp]36
8000e376:	6d 00 8d 00 	call 8000e490 <__fpcmp_parts_d>
8000e37a:	00 90       	ret 

8000e37c <__fixdfsi>:
8000e37c:	20 20       	sub.a %sp,32
8000e37e:	d9 a4 20 00 	lea %a4,[%sp]32
8000e382:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000e386:	d9 a5 0c 00 	lea %a5,[%sp]12
8000e38a:	6d ff e6 e4 	call 8000ad56 <__unpack_d>
8000e38e:	0c ac       	ld.bu %d15,[%sp]12
8000e390:	82 02       	mov %d2,0
8000e392:	bf 3f 1b 80 	jlt.u %d15,3,8000e3c8 <__fixdfsi+0x4c>
8000e396:	5e 48       	jne %d15,4,8000e3a6 <__fixdfsi+0x2a>
8000e398:	7b 00 00 28 	movh %d2,32768
8000e39c:	58 04       	ld.w %d15,[%sp]16
8000e39e:	1b f2 ff 3f 	addi %d3,%d2,-1
8000e3a2:	6a 32       	cmovn %d2,%d15,%d3
8000e3a4:	00 90       	ret 
8000e3a6:	19 a6 14 00 	ld.w %d6,[%sp]20
8000e3aa:	82 02       	mov %d2,0
8000e3ac:	0e 6e       	jltz %d6,8000e3c8 <__fixdfsi+0x4c>
8000e3ae:	8b f6 81 f2 	ge %d15,%d6,31
8000e3b2:	ee f3       	jnz %d15,8000e398 <__fixdfsi+0x1c>
8000e3b4:	09 a4 58 09 	ld.d %e4,[%sp]24
8000e3b8:	8b c6 03 61 	rsub %d6,%d6,60
8000e3bc:	6d ff cb e0 	call 8000a552 <__lshrdi3>
8000e3c0:	58 04       	ld.w %d15,[%sp]16
8000e3c2:	8b 02 00 41 	rsub %d4,%d2,0
8000e3c6:	2a 42       	cmov %d2,%d15,%d4
8000e3c8:	00 90       	ret 

8000e3ca <__udivdi3>:
8000e3ca:	0f 67 a0 20 	or %d2,%d7,%d6
8000e3ce:	0b 45 10 a8 	mov %e10,%d5,%d4
8000e3d2:	02 6f       	mov %d15,%d6
8000e3d4:	02 7c       	mov %d12,%d7
8000e3d6:	d2 f8       	mov %e8,-1
8000e3d8:	df 02 46 00 	jeq %d2,0,8000e464 <__udivdi3+0x9a>
8000e3dc:	8f 07 40 21 	or %d2,%d7,0
8000e3e0:	f6 2d       	jnz %d2,8000e3fa <__udivdi3+0x30>
8000e3e2:	4b 6b 11 82 	div.u %e8,%d11,%d6
8000e3e6:	d2 04       	mov %e4,0
8000e3e8:	02 a4       	mov %d4,%d10
8000e3ea:	42 95       	add %d5,%d9
8000e3ec:	6d 00 a5 00 	call 8000e536 <__udiv6432>
8000e3f0:	82 04       	mov %d4,0
8000e3f2:	02 85       	mov %d5,%d8
8000e3f4:	13 12 40 84 	madd.u %e8,%e4,%d2,1
8000e3f8:	3c 36       	j 8000e464 <__udivdi3+0x9a>
8000e3fa:	0b 7b 00 21 	eq %d2,%d11,%d7
8000e3fe:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
8000e402:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
8000e406:	d2 08       	mov %e8,0
8000e408:	df 02 2e 80 	jne %d2,0,8000e464 <__udivdi3+0x9a>
8000e40c:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
8000e410:	0f 07 b0 d1 	clz %d13,%d7
8000e414:	60 5f       	mov.a %a15,%d5
8000e416:	0b 67 10 48 	mov %e4,%d7,%d6
8000e41a:	02 d6       	mov %d6,%d13
8000e41c:	6d ff bf e3 	call 8000ab9a <__ashldi3>
8000e420:	8f fb 1f e0 	sh %d14,%d11,-1
8000e424:	80 f4       	mov.d %d4,%a15
8000e426:	02 36       	mov %d6,%d3
8000e428:	02 e5       	mov %d5,%d14
8000e42a:	6d 00 86 00 	call 8000e536 <__udiv6432>
8000e42e:	8b fd 01 d1 	rsub %d13,%d13,31
8000e432:	8b 0d 00 31 	rsub %d3,%d13,0
8000e436:	0f 32 00 30 	sh %d3,%d2,%d3
8000e43a:	02 32       	mov %d2,%d3
8000e43c:	8b f2 9f 80 	addx %d8,%d2,-1
8000e440:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
8000e444:	82 03       	mov %d3,0
8000e446:	8b f3 bf 90 	addc %d9,%d3,-1
8000e44a:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
8000e44e:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
8000e452:	0b cb 00 41 	eq %d4,%d11,%d12
8000e456:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
8000e45a:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
8000e45e:	f6 43       	jnz %d4,8000e464 <__udivdi3+0x9a>
8000e460:	0b 23 10 88 	mov %e8,%d3,%d2
8000e464:	0b 89 10 28 	mov %e2,%d9,%d8
8000e468:	00 90       	ret 

8000e46a <__umoddi3>:
8000e46a:	0f 67 a0 90 	or %d9,%d7,%d6
8000e46e:	02 6f       	mov %d15,%d6
8000e470:	d2 00       	mov %e0,0
8000e472:	76 9c       	jz %d9,8000e48a <__umoddi3+0x20>
8000e474:	02 7a       	mov %d10,%d7
8000e476:	0b 45 10 88 	mov %e8,%d5,%d4
8000e47a:	6d ff a8 ff 	call 8000e3ca <__udivdi3>
8000e47e:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
8000e482:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
8000e486:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
8000e48a:	0b 01 10 28 	mov %e2,%d1,%d0
8000e48e:	00 90       	ret 

8000e490 <__fpcmp_parts_d>:
8000e490:	14 43       	ld.bu %d3,[%a4]
8000e492:	82 12       	mov %d2,1
8000e494:	bf 23 50 80 	jlt.u %d3,2,8000e534 <__fpcmp_parts_d+0xa4>
8000e498:	0c 50       	ld.bu %d15,[%a5]0
8000e49a:	bf 2f 4d 80 	jlt.u %d15,2,8000e534 <__fpcmp_parts_d+0xa4>
8000e49e:	8b 43 00 42 	eq %d4,%d3,4
8000e4a2:	8b 4f 00 22 	eq %d2,%d15,4
8000e4a6:	0f 24 80 50 	and %d5,%d4,%d2
8000e4aa:	76 56       	jz %d5,8000e4b6 <__fpcmp_parts_d+0x26>
8000e4ac:	19 52 04 00 	ld.w %d2,[%a5]4
8000e4b0:	4c 41       	ld.w %d15,[%a4]4
8000e4b2:	a2 f2       	sub %d2,%d15
8000e4b4:	00 90       	ret 
8000e4b6:	76 47       	jz %d4,8000e4c4 <__fpcmp_parts_d+0x34>
8000e4b8:	19 42 04 00 	ld.w %d2,[%a4]4
8000e4bc:	82 1f       	mov %d15,1
8000e4be:	ab ff bf 22 	seln %d2,%d2,%d15,-1
8000e4c2:	00 90       	ret 
8000e4c4:	76 27       	jz %d2,8000e4d2 <__fpcmp_parts_d+0x42>
8000e4c6:	19 52 04 00 	ld.w %d2,[%a5]4
8000e4ca:	82 ff       	mov %d15,-1
8000e4cc:	ab 1f a0 22 	seln %d2,%d2,%d15,1
8000e4d0:	00 90       	ret 
8000e4d2:	df 23 06 80 	jne %d3,2,8000e4de <__fpcmp_parts_d+0x4e>
8000e4d6:	82 02       	mov %d2,0
8000e4d8:	df 2f f7 ff 	jne %d15,2,8000e4c6 <__fpcmp_parts_d+0x36>
8000e4dc:	00 90       	ret 
8000e4de:	df 2f ed 7f 	jeq %d15,2,8000e4b8 <__fpcmp_parts_d+0x28>
8000e4e2:	19 45 04 00 	ld.w %d5,[%a4]4
8000e4e6:	4c 51       	ld.w %d15,[%a5]4
8000e4e8:	5f f5 19 80 	jne %d5,%d15,8000e51a <__fpcmp_parts_d+0x8a>
8000e4ec:	19 42 08 00 	ld.w %d2,[%a4]8
8000e4f0:	4c 52       	ld.w %d15,[%a5]8
8000e4f2:	3f 2f 14 00 	jlt %d15,%d2,8000e51a <__fpcmp_parts_d+0x8a>
8000e4f6:	3f f2 1c 00 	jlt %d2,%d15,8000e52e <__fpcmp_parts_d+0x9e>
8000e4fa:	19 43 10 00 	ld.w %d3,[%a4]16
8000e4fe:	19 54 10 00 	ld.w %d4,[%a5]16
8000e502:	19 47 0c 00 	ld.w %d7,[%a4]12
8000e506:	19 56 0c 00 	ld.w %d6,[%a5]12
8000e50a:	0b 43 00 21 	eq %d2,%d3,%d4
8000e50e:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
8000e512:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
8000e516:	3a 43       	eq %d15,%d3,%d4
8000e518:	f6 25       	jnz %d2,8000e522 <__fpcmp_parts_d+0x92>
8000e51a:	82 12       	mov %d2,1
8000e51c:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
8000e520:	00 90       	ret 
8000e522:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
8000e526:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
8000e52a:	82 02       	mov %d2,0
8000e52c:	ee 04       	jnz %d15,8000e534 <__fpcmp_parts_d+0xa4>
8000e52e:	82 f2       	mov %d2,-1
8000e530:	ab 12 a0 25 	seln %d2,%d5,%d2,1
8000e534:	00 90       	ret 

8000e536 <__udiv6432>:
8000e536:	02 53       	mov %d3,%d5
8000e538:	82 f2       	mov %d2,-1
8000e53a:	7f 65 4b 80 	jge.u %d5,%d6,8000e5d0 <__udiv6432+0x9a>
8000e53e:	0f 06 b0 21 	clz %d2,%d6
8000e542:	0f 26 00 60 	sh %d6,%d6,%d2
8000e546:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
8000e54a:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
8000e54e:	8f 06 1f 70 	sh %d7,%d6,-16
8000e552:	4b 73 11 02 	div.u %e0,%d3,%d7
8000e556:	b7 06 10 88 	insert %d8,%d6,0,16,16
8000e55a:	0f 24 00 20 	sh %d2,%d4,%d2
8000e55e:	02 05       	mov %d5,%d0
8000e560:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
8000e564:	e2 80       	mul %d0,%d8
8000e566:	8f 02 1f b0 	sh %d11,%d2,-16
8000e56a:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000e56e:	82 0c       	mov %d12,0
8000e570:	7b 10 00 90 	movh %d9,1
8000e574:	7f 95 09 80 	jge.u %d5,%d9,8000e586 <__udiv6432+0x50>
8000e578:	8f 01 01 f0 	sh %d15,%d1,16
8000e57c:	0b 0c 00 a0 	add %d10,%d12,%d0
8000e580:	42 bf       	add %d15,%d11
8000e582:	7f af 07 80 	jge.u %d15,%d10,8000e590 <__udiv6432+0x5a>
8000e586:	42 71       	add %d1,%d7
8000e588:	c2 f5       	add %d5,-1
8000e58a:	a2 8c       	sub %d12,%d8
8000e58c:	3f 91 f4 ff 	jlt.u %d1,%d9,8000e574 <__udiv6432+0x3e>
8000e590:	8f 03 01 30 	sh %d3,%d3,16
8000e594:	42 3b       	add %d11,%d3
8000e596:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
8000e59a:	82 0a       	mov %d10,0
8000e59c:	4b 76 11 02 	div.u %e0,%d6,%d7
8000e5a0:	7b 10 00 10 	movh %d1,1
8000e5a4:	02 03       	mov %d3,%d0
8000e5a6:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
8000e5aa:	e2 80       	mul %d0,%d8
8000e5ac:	7f 13 09 80 	jge.u %d3,%d1,8000e5be <__udiv6432+0x88>
8000e5b0:	8f 06 01 f0 	sh %d15,%d6,16
8000e5b4:	0b 0a 00 90 	add %d9,%d10,%d0
8000e5b8:	42 2f       	add %d15,%d2
8000e5ba:	7f 9f 07 80 	jge.u %d15,%d9,8000e5c8 <__udiv6432+0x92>
8000e5be:	42 76       	add %d6,%d7
8000e5c0:	c2 f3       	add %d3,-1
8000e5c2:	a2 8a       	sub %d10,%d8
8000e5c4:	3f 16 f4 ff 	jlt.u %d6,%d1,8000e5ac <__udiv6432+0x76>
8000e5c8:	8f 05 01 50 	sh %d5,%d5,16
8000e5cc:	0b 53 00 20 	add %d2,%d3,%d5
8000e5d0:	00 90       	ret 
8000e5d2:	00 00       	nop 
8000e5d4:	00 00       	nop 
	...
