
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x0000e2a8 memsz 0x0000e2a8 flags r-x
    LOAD off    0x00014000 vaddr 0x70000000 paddr 0x8000e2c8 align 2**14
         filesz 0x00000918 memsz 0x00000918 flags rw-
    LOAD off    0x00016600 vaddr 0x5001a600 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x5001b700 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00016600 vaddr 0x6001a600 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x6001b700 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00014918 vaddr 0x70000918 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00000320 flags rw-
    LOAD off    0x00018600 vaddr 0x70018600 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00015700 vaddr 0x70019700 paddr 0x8000ebe0 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00017c00 vaddr 0x5001bc00 paddr 0x8000ec00 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00017c00 vaddr 0x6001bc00 paddr 0x8000ec00 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00015c00 vaddr 0x70019c00 paddr 0x8000ec00 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00004020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00001060  80000028  80000028  00004028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .bss          00000320  70000918  8000ebe0  00014918  2**3
                  ALLOC
  3 .data         00000918  70000000  8000e2c8  00014000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .traptab      00000100  80001100  80001100  00005100  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ctors        00000008  80001200  80001200  00005200  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .dtors        00000008  80001208  80001208  00005208  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .inttab_cpu0  00002000  80002000  80002000  00006000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text         0000a2c8  80004000  80004000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .CPU2.ustack  00001000  5001a600  8000ebe0  00016600  2**3
                  ALLOC, CPU2
 10 .CPU2.istack  00000400  5001b700  8000ebe0  00017700  2**3
                  ALLOC, CPU2
 11 .CPU2.csa     00002000  5001bc00  8000ec00  00017c00  2**6
                  ALLOC, CPU2
 12 .CPU1.ustack  00001000  6001a600  8000ebe0  00016600  2**3
                  ALLOC, CPU1
 13 .CPU1.istack  00000400  6001b700  8000ebe0  00017700  2**3
                  ALLOC, CPU1
 14 .CPU1.csa     00002000  6001bc00  8000ec00  00017c00  2**6
                  ALLOC, CPU1
 15 .CPU0.ustack  00001000  70018600  8000ebe0  00018600  2**3
                  ALLOC, CPU0
 16 .CPU0.istack  00000400  70019700  8000ebe0  00015700  2**3
                  ALLOC, CPU0
 17 .CPU0.csa     00002000  70019c00  8000ec00  00015c00  2**6
                  ALLOC, CPU0
 18 .comment      00000053  00000000  00000000  00014918  2**0
                  CONTENTS, READONLY
 19 .debug_aranges 00000d10  00000000  00000000  00014970  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_info   000c3385  00000000  00000000  00015680  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_abbrev 0000bf5c  00000000  00000000  000d8a05  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   0000e4d2  00000000  00000000  000e4961  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  000021f0  00000000  00000000  000f2e34  2**2
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_str    0000202c  00000000  00000000  000f5024  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_loc    00013f29  00000000  00000000  000f7050  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_ranges 00001478  00000000  00000000  0010af79  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .version_info 0004dce5  00000000  00000000  0010c3f1  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
70000918 l    d  .bss	00000000 .bss
70000000 l    d  .data	00000000 .data
80001100 l    d  .traptab	00000000 .traptab
80001200 l    d  .ctors	00000000 .ctors
80001208 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 asw.c
70000000 l     O .data	00000004 c.15762
00000000 l    df *ABS*	00000000 bsw.c
00000000 l    df *ABS*	00000000 ee_applcfg.c
800000e8 l     O .rodata	00000018 osEE_tdb_ptr_array
800000dc l     O .rodata	00000004 osEE_res_db_ptr_array
80000100 l     O .rodata	000000c0 osEE_tdb_array
70000030 l     O .data	00000028 osEE_sn_array
800000e0 l     O .rodata	00000008 osEE_res_db_array
70000bd4 l     O .bss	0000000c osEE_res_cb_array
800001c0 l     O .rodata	00000008 osEE_sdb_array
70000be0 l     O .bss	00000004 osEE_scb_array
70000058 l     O .data	00000078 osEE_tcb_array
00000000 l    df *ABS*	00000000 IfxVadc.c
800001c8 l     O .rodata	00000006 CSWTCH.25
00000000 l    df *ABS*	00000000 IfxVadc_cfg.c
00000000 l    df *ABS*	00000000 IfxAsclin_PinMap.c
00000000 l    df *ABS*	00000000 IfxAsclin_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
700000d0 l     O .data	00000004 IfxScuCcu_xtalFrequency
80006004 l     F .text	00000034 IfxScuCcu_wait
80000a9c l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 IfxScu_PinMap.c
00000000 l    df *ABS*	00000000 IfxVadc_Adc.c
80000d38 l     O .rodata	00000040 IfxVadc_Adc_masterIndex
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 vfprintf.c
80000dd0 l     O .rodata	00000010 blanks.4035
80000dc0 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000c2ac l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 impure.c
700004ec l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 locale.c
80000e04 l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80000e3c l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70000910 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
80009314 l     F .text	0000000e osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 Lcd_Driver.c
80004000 l     F .text	00000060 lcd_write4bits
80004060 l     F .text	00000020 lcd_command
00000000 l    df *ABS*	00000000 IfxAsclin.c
00000000 l    df *ABS*	00000000 IfxAsclin_Asc.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuEru.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 Ifx_CircularBuffer.c
00000000 l    df *ABS*	00000000 Ifx_Fifo.c
00000000 l    df *ABS*	00000000 ultrasonic_Driver.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
80008e44 l     F .text	00000054 osEE_tc_stm_us_ticks
70000be8 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
80009324 l     F .text	0000001e osEE_shutdown_os
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
80009be8 l     F .text	00000022 osEE_release_all_m
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
8000a0de l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
8000a2b6 l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 Bsp.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 IfxCpu.c
00000000 l    df *ABS*	00000000 IfxCpu_Irq.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc.c
00000000 l    df *ABS*	00000000 IfxStdIf_DPipe.c
00000000 l    df *ABS*	00000000 IfxStm.c
00000000 l    df *ABS*	00000000 IfxStm_cfg.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc_cfg.c
800003d0 g     O .rodata	00000010 IfxAsclin1_TX_P33_12_OUT
800031c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_142
80002d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_105
70000010 g     O .data	00000020 osEE_ccb_var
70000c38 g     O .text	00000001 __HEAP
80003980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_204
800057f8 g     F .text	00000062 IfxAsclin_Asc_write
800088ee g     F .text	000000b0 measureEchoTick
80005096 g     F .text	0000000a IfxAsclin_Asc_getWriteEvent
80007120 g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
80002c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_100
80007354 g     F .text	00000036 IfxScuWdt_setCpuEndinit
80000e48 g     O .rodata	00000028 __mprec_tinytens
80000ae0 g     O .rodata	00000010 IfxScu_WDT1LCK_P20_7_OUT
80004348 g     F .text	000000e8 mdelay
8000a85a g     F .text	0000001a .hidden __ashldi3
800070b6 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
800021e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_15
80009694 g     F .text	0000005a TerminateTask
80005112 g     F .text	00000006 IfxAsclin_Asc_resetSendCount
800001d0 g     O .rodata	000000a0 IfxVadc_cfg_srcAddresses
70000bd0 g     O .bss	00000004 osEE_kcb_var
80000380 g     O .rodata	00000010 IfxAsclin2_TX_P14_2_OUT
80002f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_123
800080fe g     F .text	00000020 Ifx_CircularBuffer_addDataIncr
80004bc2 g     F .text	00000014 IfxVadc_setScan
8000df32 g     F .text	00000040 .hidden __eqdf2
80005728 g     F .text	00000088 IfxAsclin_Asc_initModuleConfig
8000704a g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
80004834 g     F .text	00000010 IfxVadc_getQueueStatus
00000000 g       *ABS*	00000000 __HEAP_SIZE
800083b4 g     F .text	00000176 Ifx_Fifo_read
80004c1c g     F .text	0000001c IfxAsclin_disableModule
80000720 g     O .rodata	00000010 IfxAsclin3_RXC_P20_3_IN
80009cbe g     F .text	00000022 osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80003e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_242
80002300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_24
80003580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_172
800089d8 g     F .text	0000046c osEE_tc_core0_start
800024c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_38
8000827a g     F .text	00000004 Ifx_Fifo_destroy
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
8000758e g     F .text	00000108 IfxVadc_Adc_getChannelConfig
800047e4 g     F .text	00000018 IfxVadc_getAdcAnalogFrequency
70000000 g       *ABS*	00000000 __DSPR0_START
80002be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_95
80002740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_58
8000a13e g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80002c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_97
800068c0 g     F .text	00000012 IfxScuCcu_initErayPllConfig
8000a006 g     F .text	00000028 osEE_change_context_from_running
80005088 g     F .text	0000000e IfxAsclin_Asc_getWriteCount
80000740 g     O .rodata	00000010 IfxAsclin3_RXA_P15_7_IN
80006fe0 g     F .text	00000032 IfxScuEru_setInterruptGatingPattern
800051d4 g     F .text	00000014 IfxAsclin_Asc_clearTx
80005876 g     F .text	000000c6 IfxAsclin_Asc_stdIfDPipeInit
80002560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_43
8000b03e g     F .text	00000002 __malloc_unlock
80005072 g     F .text	0000000a IfxAsclin_Asc_getReadEvent
80004220 g     F .text	00000048 TimerISR
80008560 g     F .text	000000f0 Ifx_Fifo_canWriteCount
80007ec6 g     F .text	000000e8 IfxVadc_Adc_initModule
800032e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_151
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_118
80002c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_99
800046fe g     F .text	0000003c IfxVadc_disablePostCalibration
80002680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_52
800048e2 g     F .text	00000028 IfxVadc_getSrcAddress
8000492e g     F .text	00000024 IfxVadc_initialiseAdcConverterClock
80004d46 g     F .text	00000024 IfxAsclin_getOvsFrequency
80009aae g     F .text	00000096 SetEvent
80007696 g     F .text	00000038 IfxVadc_Adc_getChannelConversionTime
80003e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_244
80002380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_28
80006fa2 g     F .text	00000012 IfxScuEru_setEventFlag
80003920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_201
80009c0a g     F .text	0000000a osEE_scheduler_task_wrapper_restore
80000ce8 g     O .rodata	00000010 IfxScu_EVRWUPA_P14_1_IN
800004f0 g     O .rodata	00000010 IfxAsclin3_SLSO_P12_1_OUT
70019600 g     O .CPU0.ustack	00000000 __USTACK0
80003720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_185
8000da7a g     F .text	00000050 memmove
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
8000d340 g     F .text	00000056 _Balloc
80000cc8 g     O .rodata	00000010 IfxScu_EXTCLK0_P23_1_OUT
80003b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_216
800007e0 g     O .rodata	00000010 IfxAsclin1_RXE_P11_10_IN
800005c0 g     O .rodata	00000010 IfxAsclin3_SCLK_P15_8_OUT
800061da g     F .text	0000004a IfxScuCcu_getModuleFrequency
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_213
800028e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_71
8000634c g     F .text	000003be IfxScuCcu_init
8000dfb2 g     F .text	00000040 .hidden __gtdf2
8000df16  w    F .text	0000000a __errno
800037e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_191
80003380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_156
80009374 g     F .text	00000042 SuspendAllInterrupts
80002140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_10
80005118 g     F .text	00000008 IfxAsclin_Asc_canReadCount
80003180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_140
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_103
00001000 g       *ABS*	00000000 __USTACK0_SIZE
800007c0 g     O .rodata	00000010 IfxAsclin1_RXG_P02_3_IN
8000a1ac g     F .text	00000066 osEE_hal_terminate_ctx
80000270 g     O .rodata	00000010 IfxAsclin3_TX_P32_3_OUT
80009d50 g     F .text	00000048 osEE_sn_priority_insert
80003480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_164
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_215
800099bc g     F .text	00000078 GetTaskState
800080bc g     F .text	00000020 Ifx_CircularBuffer_get32
80009e02 g     F .text	00000022 osEE_task_event_set_mask
80000300 g     O .rodata	00000010 IfxAsclin3_TX_P11_1_OUT
80000730 g     O .rodata	00000010 IfxAsclin3_RXB_P11_0_IN
8000738a g     F .text	0000009e IfxScuWdt_initCpuWatchdog
80005adc g     F .text	00000092 IfxPort_setGroupModeOutput
80002080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_4
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80005f2a g     F .text	00000072 IfxScuCcu_getPllFrequency
80002a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_82
70000c28 g     O .bss	00000004 errno
8000a7ce g     F .text	0000001e .hidden __make_dp
80002e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_114
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
800022a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_21
80001160 g       .traptab	00000000 osEE_tc_trap_context
8000750c g     F .text	00000040 IfxScuWdt_enableWatchdogWithDebugger
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_117
800006d0 g     O .rodata	00000010 IfxAsclin3_RXG_P21_3_IN
80000870 g     O .rodata	00000010 IfxAsclin2_RTS_P33_4_OUT
80000530 g     O .rodata	00000010 IfxAsclin2_SLSO_P02_3_OUT
800027e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_63
8000a8ee g     F .text	00000016 .hidden __make_fp
80003560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_171
80004480 g     F .text	0000007e initVADCChannels
800023c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_30
800002a0 g     O .rodata	00000010 IfxAsclin3_TX_P22_0_OUT
800020c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_6
80003780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_188
80000bc8 g     O .rodata	00000014 IfxScu_REQ15_P14_1_IN
80000c40 g     O .rodata	00000014 IfxScu_REQ0_P15_4_IN
80002260 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_19
80007012 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
80009b76 g     F .text	00000058 ClearEvent
8000629e g     F .text	00000042 IfxScuCcu_getCpuFrequency
80003d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_232
800028a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_69
80009c14 g     F .text	000000aa osEE_scheduler_task_wrapper_run
80003f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_251
800035c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_174
80000610 g     O .rodata	00000010 IfxAsclin3_SCLK_P00_0_OUT
80003700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_184
80000940 g     O .rodata	00000080 IfxPort_cfg_indexMap
8000537a g     F .text	000003ae IfxAsclin_Asc_initModule
80009fa2 g     F .text	00000026 osEE_scheduler_task_preemption_point
8000420c g     F .text	00000014 FuncTaskUltrasonic
8000d324 g     F .text	0000001c memcpy
800021c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_14
8000419e g     F .text	00000024 FuncTask1
8000b0a8 g     F .text	000011a4 _svfprintf_r
8000a786 g     F .text	00000048 .hidden __floatsidf
800076ce g     F .text	0000023e IfxVadc_Adc_getGroupConfig
80006e74 g     F .text	00000026 IfxScuEru_enablePatternDetectionTrigger
80009d98 g     F .text	0000000e osEE_scheduler_rq_insert
80002940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_74
8000e032 g     F .text	00000040 .hidden __ltdf2
800048d8 g     F .text	0000000a IfxVadc_getScanStatus
80001210 g       .dtors	00000000 __DTOR_END__
800068d2 g     F .text	00000076 IfxScuCcu_setCpuFrequency
80006fb4 g     F .text	0000002c IfxScuEru_setFlagPatternDetection
8000a04e g     F .text	00000026 osEE_idle_task_terminate
80000c2c g     O .rodata	00000014 IfxScu_REQ10_P14_3_IN
80003c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_228
80000860 g     O .rodata	00000010 IfxAsclin3_RTS_P00_9_OUT
80000690 g     O .rodata	00000010 IfxAsclin1_SCLK_P20_10_OUT
8000d8e6 g     F .text	00000042 __fpclassifyd
800023a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_29
80007082 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
80003a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_211
80002340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_26
8000721c g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
80002540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_42
80009edc g     F .text	0000003c osEE_scheduler_task_unblocked
80002960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_75
80003820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_193
800033c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_158
8000ab88 g     F .text	0000000c malloc
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_102
80006ce4 g     F .text	00000028 IfxScuEru_clearInputChannelConfiguration
00000000 g       *ABS*	00000000 NULL
800006f0 g     O .rodata	00000010 IfxAsclin3_RXF_P21_6_IN
80009222 g     F .text	0000001e osEE_tc_stm_set_sr0_next_match
80001140 g       .traptab	00000000 osEE_tc_trap_instruction
80000e98 g     O .rodata	000000c8 __mprec_tens
70000008 g     O .data	00000004 g_vadcChannelIDs
800051bc g     F .text	00000008 IfxAsclin_Asc_canWriteCount
80009762 g     F .text	000000b2 GetResource
80000390 g     O .rodata	00000010 IfxAsclin2_TX_P10_5_OUT
80000480 g     O .rodata	00000010 IfxAsclin0_TX_P15_2_OUT
8000c296 g     F .text	00000016 vsnprintf
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_214
800029a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_77
800008c0 g     O .rodata	00000010 IfxAsclin3_CTSA_P00_12_IN
800038a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_197
70000c20 g     O .bss	00000004 __malloc_top_pad
80004520 g     F .text	00000026 readADCValue
80006948 g     F .text	0000008e IfxScuCcu_setGtmFrequency
80005c68 g     F .text	00000064 IfxPort_setPinModeLvdsHigh
8000a162 g     F .text	0000002c osEE_hal_ready2stacked
80002660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_51
80000ba0 g     O .rodata	00000014 IfxScu_REQ1_P15_8_IN
8000822a g     F .text	00000050 Ifx_CircularBuffer_write32
8000d302 g     F .text	0000000a _localeconv_r
80003460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_163
80004d0c g     F .text	00000022 IfxAsclin_getIndex
8000d4d2 g     F .text	00000010 __i2b
800096ee g     F .text	00000074 Schedule
80004d6a g     F .text	00000016 IfxAsclin_getShiftFrequency
8000790c g     F .text	000001ec IfxVadc_Adc_initChannel
80003f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_250
80000290 g     O .rodata	00000010 IfxAsclin3_TX_P22_1_OUT
80006baa g     F .text	00000112 IfxScuCcu_switchToBackupClock
80003100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_136
800006b0 g     O .rodata	00000010 IfxAsclin0_SCLK_P15_2_OUT
80007278 g     F .text	00000072 IfxScuWdt_enableSafetyWatchdog
80002060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_3
80003e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_240
8000b040 g     F .text	0000001e _sbrk_r
80000440 g     O .rodata	00000010 IfxAsclin1_TX_P11_12_OUT
80000c60 g     O .rodata	0000000c IfxScu_HWCFG5_P10_6_IN
80000450 g     O .rodata	00000010 IfxAsclin1_TX_P02_2_OUT
80003040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_130
80002b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_89
800025c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_46
70000938 g     O .bss	0000000c g_vadcGroup
80006e28 g     F .text	00000026 IfxScuEru_enableAutoClear
800006a0 g     O .rodata	00000010 IfxAsclin1_SCLK_P15_0_OUT
800027a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_61
80002800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_64
8000aa16 g     F .text	000000ac .hidden __unpack_d
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
80005d0e g     F .text	0000003c IfxPort_setPinPadDriver
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_246
80002480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_36
80000400 g     O .rodata	00000010 IfxAsclin1_TX_P15_4_OUT
70000c1c g     O .bss	00000004 __malloc_max_sbrked_mem
80002a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_81
800011a0 g       .traptab	00000000 osEE_tc_trap_assertion
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_93
80008000 g       *ABS*	00000000 __A1_MEM
8000a284 g     F .text	00000032 .hidden __extendsfdf2
80002700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_56
80004c82 g     F .text	00000016 IfxAsclin_getAddress
8000a452 g     F .text	00000038 .hidden __adddf3
8000415a g     F .text	0000000e lcd_goto
80009520 g     F .text	0000001a GetActiveApplicationMode
80006224 g     F .text	0000007a IfxScuCcu_getSriFrequency
800088d2 g     F .text	0000001c sendTrigger
800030c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_134
800093b6 g     F .text	00000026 ResumeAllInterrupts
800036c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_182
800038e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_199
80006b2a g     F .text	00000080 IfxScuCcu_setSriFrequency
8000e160 g     F .text	00000026 .hidden __umoddi3
80003740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_186
70019c00 g     O .CPU0.csa	00000000 __CSA0
80003840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_194
800033e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_159
80003280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_148
80002180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_12
80000890 g     O .rodata	00000010 IfxAsclin1_RTS_P23_1_OUT
80000df0 g     O .rodata	00000004 _global_impure_ptr
80006d34 g     F .text	00000036 IfxScuEru_connectTrigger
70000918 g     O .bss	00000020 g_vadcChannel
800062e0 g     F .text	00000036 IfxScuCcu_getFsi2Frequency
8000dada g     F .text	000003f0 _realloc_r
80000670 g     O .rodata	00000010 IfxAsclin1_SCLK_P33_12_OUT
80004dbc g     F .text	00000012 IfxAsclin_read16
80005a10 g     F .text	0000003c IfxPort_enableEmergencyStop
800002c0 g     O .rodata	00000010 IfxAsclin3_TX_P20_3_OUT
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_254
8000e0c0 g     F .text	000000a0 .hidden __udivdi3
80000840 g     O .rodata	00000010 IfxAsclin0_RXB_P15_3_IN
800002d0 g     O .rodata	00000010 IfxAsclin3_TX_P20_0_OUT
70008000 g       *ABS*	00000000 __A0_MEM
80009ce0 g     F .text	00000070 osEE_scheduler_core_rq_preempt_stk
80000490 g     O .rodata	00000010 IfxAsclin0_TX_P14_1_OUT
80004080 g     F .text	0000000a lcd_clear
80000e70 g     O .rodata	00000028 __mprec_bigtens
8000df20 g     F .text	00000012 abort
8000a828 g     F .text	00000032 .hidden __floatunsidf
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_85
8000d732 g     F .text	00000042 __mcmp
800038c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_198
800051e8 g     F .text	0000001c IfxAsclin_Asc_read
8000953a g     F .text	00000084 ActivateTask
80000bdc g     O .rodata	00000014 IfxScu_REQ14_P02_1_IN
80003300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_152
80006d90 g     F .text	00000026 IfxScuEru_disableFallingEdgeDetection
80002040 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_2
80002de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_111
8000827e g     F .text	0000003a Ifx_Fifo_init
80002420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_33
70000c30  w    O .bss	00000004 _my_errno
800004d0 g     O .rodata	00000010 IfxAsclin3_SLSO_P21_2_OUT
8000593c g     F .text	00000030 IfxPort_getAddress
80003760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_187
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
800008f0 g     O .rodata	00000010 IfxAsclin1_CTSB_P32_4_IN
80009964 g     F .text	00000058 GetTaskID
8000671e g     F .text	000001a2 IfxScuCcu_initErayPll
80000370 g     O .rodata	00000010 IfxAsclin2_TX_P14_3_OUT
80003de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_239
80000310 g     O .rodata	00000010 IfxAsclin3_TX_P11_0_OUT
80000a48 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
80006ee6 g     F .text	0000000e IfxScuEru_getAllEventFlagsStatus
80000c84 g     O .rodata	0000000c IfxScu_HWCFG2EVR13_P14_2_IN
800093dc g     F .text	0000005c SuspendOSInterrupts
80003a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_210
80007152 g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
8000a874 g     F .text	0000007a .hidden __unpack_f
8000916a g     F .text	00000034 osEE_tc_stm_set_clockpersec
80003a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_208
800044fe g     F .text	00000022 initADC
800031e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_143
80002d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_106
80009fc8 g     F .text	0000003e osEE_scheduler_task_set_running
b0008000 g     O *ABS*	00000000 _SMALL_DATA4_
80009240 g     F .text	0000008e osEE_tc_stm_set_sr1
80000710 g     O .rodata	00000010 IfxAsclin3_RXD_P32_2_IN
800045e8 g     F .text	0000000c asclin0TxISR
800005f0 g     O .rodata	00000010 IfxAsclin3_SCLK_P11_1_OUT
800071ac g     F .text	00000070 IfxScuWdt_disableSafetyWatchdog
80002c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_96
80007508 g     F .text	00000004 IfxScuWdt_serviceSafetyWatchdog
80000770 g     O .rodata	00000010 IfxAsclin2_RXE_P33_8_IN
80000620 g     O .rodata	00000010 IfxAsclin2_SCLK_P33_9_OUT
8000d42a g     F .text	00000042 __hi0bits
80002760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_59
80000810 g     O .rodata	00000010 IfxAsclin1_RXB_P15_5_IN
80002e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_115
800003e0 g     O .rodata	00000010 IfxAsclin1_TX_P20_10_OUT
800003f0 g     O .rodata	00000010 IfxAsclin1_TX_P15_5_OUT
8000e072 g     F .text	0000004e .hidden __fixdfsi
80003160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_139
80009e46 g     F .text	00000068 osEE_scheduler_task_activated
80006038 g     F .text	00000078 IfxScuCcu_getBbbFrequency
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
80000320 g     O .rodata	00000010 IfxAsclin3_TX_P00_1_OUT
800004a0 g     O .rodata	00000010 IfxAsclin0_TX_P14_0_OUT
80002f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_121
80006316 g     F .text	00000036 IfxScuCcu_getFsiFrequency
80000af0 g     O .rodata	00000010 IfxScu_WDT0LCK_P20_8_OUT
80002100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_8
80002580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_44
80003d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_234
800032a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_149
800070ea g     F .text	00000036 IfxScuWdt_clearCpuEndinit
8000899e g     F .text	00000024 getUltrasonic
80002e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_113
80003320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_153
800025e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_47
800022e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_23
80000640 g     O .rodata	00000010 IfxAsclin2_SCLK_P14_2_OUT
80004eb2 g     F .text	00000182 IfxAsclin_setBitTiming
80000ca8 g     O .rodata	00000010 IfxScu_EXTCLK1_P32_4_OUT
800004b0 g     O .rodata	00000010 IfxAsclin3_SLSO_P33_1_OUT
800002e0 g     O .rodata	00000010 IfxAsclin3_TX_P15_7_OUT
800007f0 g     O .rodata	00000010 IfxAsclin1_RXD_P14_8_IN
80000c6c g     O .rodata	0000000c IfxScu_HWCFG4_P10_5_IN
8000754c g     F .text	00000026 IfxVadc_Adc_deInitGroup
8000a212 g     F .text	00000026 .hidden __lshrdi3
80000700 g     O .rodata	00000010 IfxAsclin3_RXE_P00_1_IN
800039a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_205
80000830 g     O .rodata	00000010 IfxAsclin0_RXD_P34_2_IN
80000590 g     O .rodata	00000010 IfxAsclin3_SCLK_P21_7_OUT
80007b0e g     F .text	0000038a IfxVadc_Adc_initGroup
8000d5fc g     F .text	0000007c __pow5mult
70000948 g     O .bss	0000000c g_ERUconfig
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_255
80002860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_67
80002e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_112
80006ddc g     F .text	00000026 IfxScuEru_disableRisingEdgeDetection
80000550 g     O .rodata	00000010 IfxAsclin1_SLSO_P20_8_OUT
80009f18 g     F .text	0000008a osEE_scheduler_task_terminated
80000330 g     O .rodata	00000010 IfxAsclin3_TX_P00_0_OUT
80002460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_35
800036a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_181
8000aac2 g     F .text	000000c6 .hidden __pack_f
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_245
8000811e g     F .text	0000005e Ifx_CircularBuffer_read8
80000880 g     O .rodata	00000010 IfxAsclin2_RTS_P10_8_OUT
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
80003b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_219
80002360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_27
800037a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_189
8000733a g     F .text	0000001a IfxScuWdt_initConfig
80001200 g       .ctors	00000000 __CTOR_LIST__
800090c6 g     F .text	000000a4 osEE_tc_get_fsource
80004dce g     F .text	00000012 IfxAsclin_read32
80000c04 g     O .rodata	00000014 IfxScu_REQ12_P11_10_IN
80007428 g     F .text	00000004 IfxScuWdt_serviceCpuWatchdog
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_247
800008b0 g     O .rodata	00000010 IfxAsclin0_RTS_P14_7_OUT
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_86
80000780 g     O .rodata	00000010 IfxAsclin2_RXD_P10_6_IN
8000919e g     F .text	00000084 osEE_tc_stm_set_sr0
80000b00 g     O .rodata	00000014 IfxScu_REQ9_P20_0_IN
80000650 g     O .rodata	00000010 IfxAsclin2_SCLK_P10_6_OUT
80002e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_116
8000a18e g     F .text	0000001e osEE_tc_change_context_from_isr2_end
80002a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_83
8000d30c g     F .text	00000018 memchr
80003400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_160
8000d156 g     F .text	000001ac _free_r
800057b0 g     F .text	00000048 IfxAsclin_Asc_initiateTransmission
80002220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_17
800023e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_31
80009bce g     F .text	00000018 GetISRID
8000a100 g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
80001180 g       .traptab	00000000 osEE_tc_trap_bus
80005d4c g     F .text	000000f8 IfxScuCcu_calculateSysPllDividers
800008d0 g     O .rodata	00000010 IfxAsclin2_CTSB_P33_5_IN
700000d8 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80003520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_169
800082b8 g     F .text	00000022 Ifx_Fifo_create
80003f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_249
8000730a g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800011e0 g       .traptab	00000000 osEE_tc_trap_nmi
800020a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_5
8000d678 g     F .text	000000ba __lshift
80003600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_176
80000630 g     O .rodata	00000010 IfxAsclin2_SCLK_P33_7_OUT
80007572 g     F .text	0000001c IfxVadc_Adc_disableModule
00002000 g       *ABS*	00000000 __CSA_SIZE
8000d928 g     F .text	000000f0 __ssprint_r
800047fc g     F .text	0000001a IfxVadc_getAdcDigitalFrequency
5001bc00 g       .CPU2.csa	00000000 __CSA2
800034a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_165
80003c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_227
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
80004680 g     F .text	00000038 IfxVadc_enableAccess
800027c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_62
8000d4e2 g     F .text	0000011a __multiply
00000001 g       *ABS*	00000000 _.
80006ef4 g     F .text	00000012 IfxScuEru_getEventFlagStatus
80004168 g     F .text	00000036 lcd_print
80000510 g     O .rodata	00000010 IfxAsclin2_SLSO_P33_6_OUT
80000360 g     O .rodata	00000010 IfxAsclin2_TX_P32_5_OUT
80004b48 g     F .text	00000024 IfxVadc_selectPowerSupplyVoltage
80006db6 g     F .text	00000026 IfxScuEru_disablePatternDetectionTrigger
70000bf0 g     O .bss	00000028 __malloc_current_mallinfo
8000d83e g     F .text	000000a8 __d2b
80003c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_226
800037c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_190
80003360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_155
800026c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_54
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_125
80002b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_91
80000b3c g     O .rodata	00000014 IfxScu_REQ6_P02_0_IN
800080dc g     F .text	00000022 Ifx_CircularBuffer_get16
80000430 g     O .rodata	00000010 IfxAsclin1_TX_P14_10_OUT
80003680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_180
80005ee6 g     F .text	00000044 IfxScuCcu_getPllErayVcoFrequency
80001200 g       .ctors	00000000 __EH_FRAME_END__
80006d6a g     F .text	00000026 IfxScuEru_disableAutoClear
800069d6 g     F .text	00000050 IfxScuCcu_setPll2ErayFrequency
6001bb00 g       .CPU1.istack	00000000 __ISTACK1
80003800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_192
800033a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_157
80006140 g     F .text	00000022 IfxScuCcu_getBaud2Frequency
80003240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_146
80002da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_109
800005d0 g     O .rodata	00000010 IfxAsclin3_SCLK_P15_6_OUT
8000e186 g     F .text	000000a6 .hidden __fpcmp_parts_d
80004c66 g     F .text	0000001c IfxAsclin_enableModule
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
80009da6 g     F .text	00000026 osEE_scheduler_core_pop_running
800021a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_13
80003f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_252
8000a074 g     F .text	0000006a osEE_cpu_startos
80003b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_218
70000004 g     O .data	00000002 rpm
80006e9a g     F .text	00000026 IfxScuEru_enableRisingEdgeDetection
800007b0 g     O .rodata	00000010 IfxAsclin2_RXA_P14_3_IN
80003e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_241
800029c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_78
8000596c g     F .text	00000022 IfxPort_getIndex
800030a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_133
80009b44 g     F .text	00000032 GetEvent
8000535e g     F .text	0000001c IfxAsclin_Asc_disableModule
8000a238 g     F .text	0000004c .hidden __floatundisf
6001b600 g       .CPU1.ustack	00000000 __USTACK1
80004de0 g     F .text	00000012 IfxAsclin_read8
80009eae g     F .text	0000002e osEE_scheduler_task_insert
80003be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_223
80002620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_49
8000a66e g     F .text	00000118 .hidden __divdf3
80000d08 g     O .rodata	00000010 IfxScu_EMGSTOPA_P33_8_IN
80000cb8 g     O .rodata	00000010 IfxScu_EXTCLK1_P11_12_OUT
8000585a g     F .text	0000001c IfxAsclin_Asc_blockingWrite
80007fae g     F .text	0000003a IfxVadc_Adc_initModuleConfig
700000e0 g     O .data	00000408 __malloc_av_
80002f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_120
80009900 g     F .text	00000064 ShutdownOS
80003060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_131
8000c24c g     F .text	0000004a _vsnprintf_r
800035e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_175
70018600 g     O .CPU0.ustack	00000000 __USTACK0_END
80003900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_200
80002120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_9
8000a4ca g     F .text	000001a4 .hidden __muldf3
80002500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_40
800006c0 g     O .rodata	00000010 IfxAsclin0_SCLK_P14_0_OUT
80002520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_41
80008864 g     F .text	0000006e delay_us
80000cf8 g     O .rodata	00000010 IfxScu_EMGSTOPB_P21_2_IN
8000b03c g     F .text	00000002 __malloc_lock
8000deda g     F .text	0000003c sbrk
80005e44 g     F .text	0000000e IfxScuCcu_getOsc0Frequency
80004648 g     F .text	00000038 IfxVadc_disableAccess
80000000 g       .startup	00000000 BootModeHeader0
800011c0 g       .traptab	00000000 osEE_tc_trap_system
80000c78 g     O .rodata	0000000c IfxScu_HWCFG3_BMI_P14_3_IN
80004da8 g     F .text	00000014 IfxAsclin_getSrcPointerTx
80004844 g     F .text	00000094 IfxVadc_getResultBasedOnRequestSource
8000da18 g     F .text	00000062 _calloc_r
00002000 g       *ABS*	00000000 __CSA0_SIZE
80006162 g     F .text	00000078 IfxScuCcu_getSpbFrequency
80002820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_65
800007a0 g     O .rodata	00000010 IfxAsclin2_RXB_P02_1_IN
8000473a g     F .text	000000aa IfxVadc_enableGroupSync
80006f4e g     F .text	00000012 IfxScuEru_getPatternDetectionResult
800024a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_37
80005204 g     F .text	0000009e IfxAsclin_Asc_isrTransmit
80000350 g     O .rodata	00000010 IfxAsclin2_TX_P33_8_OUT
80003d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_233
80003960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_203
8000daca g     F .text	00000010 memset
800034e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_167
80002640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_50
8000408a g     F .text	000000d0 lcd_init
800045f4 g     F .text	00000054 main
800072ea g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
800087fa g     F .text	0000006a delay_ms
80006ec0 g     F .text	00000026 IfxScuEru_enableTriggerPulse
80002200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_16
70000c18 g     O .bss	00000004 __malloc_max_total_mem
80003540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_170
80004c38 g     F .text	0000002e IfxAsclin_enableAscErrorFlags
8000e22c g     F .text	0000009c .hidden __udiv6432
00000400 g       *ABS*	00000000 __ISTACK_SIZE
80006120 g     F .text	00000020 IfxScuCcu_getBaud1Frequency
800025a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_45
8000802a g     F .text	00000092 IfxVadc_Adc_initExternalMultiplexerMode
80000bb4 g     O .rodata	00000014 IfxScu_REQ16_P15_1_IN
70000954 g     O .bss	0000027c g_AsclinAsc
80002b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_88
80000c54 g     O .rodata	0000000c IfxScu_HWCFG6_P14_4_IN
80009dcc g     F .text	00000018 osEE_task_activated
5001bb00 g       .CPU2.istack	00000000 __ISTACK2
800000c0 g     O .rodata	00000014 osEE_kdb_var
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
80007326 g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
8000a7ec g     F .text	0000003c .hidden __truncdfsf2
80003b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_220
80003020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_129
8000c3c8 g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000aba2 g     F .text	0000049a _malloc_r
800004c0 g     O .rodata	00000010 IfxAsclin3_SLSO_P21_6_OUT
80005ccc g     F .text	00000042 IfxPort_setPinModeLvdsMedium
80000790 g     O .rodata	00000010 IfxAsclin2_RXC_P02_10_IN
800039e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_207
80005338 g     F .text	00000026 IfxAsclin_Asc_blockingRead
80003d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_235
800024e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_39
80002020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_1
80000580 g     O .rodata	00000010 IfxAsclin3_SCLK_P32_3_OUT
8000506c g     F .text	00000006 IfxAsclin_Asc_getReadCount
80002a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_80
80008000 g       *ABS*	00000000 __A8_MEM
80000570 g     O .rodata	00000010 IfxAsclin3_SCLK_P33_2_OUT
b0008000 g       *ABS*	00000000 __A9_MEM
80005048 g     F .text	00000012 IfxAsclin_write32
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_231
80003340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_154
80002c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_98
800042da g     F .text	0000006e printfSerial
80000d78 g     O .rodata	00000014 .hidden __thenan_df
8000d09c g     F .text	000000ba _malloc_trim_r
80001208 g       .ctors	00000000 __CTOR_END__
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
800003a0 g     O .rodata	00000010 IfxAsclin2_TX_P02_9_OUT
80004a4c g     F .text	000000aa IfxVadc_getChannelConversionTime
50000000 g       *ABS*	00000000 __DSPR2_START
800028c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_70
800046b8 g     F .text	00000046 IfxVadc_configExternalMultiplexerMode
800041c2 g     F .text	0000004a FuncTaskLCD
80009814 g     F .text	000000ec ReleaseResource
80007fe8 g     F .text	00000042 IfxVadc_Adc_initExternalMultiplexerModeConfig
80004d2e g     F .text	00000018 IfxAsclin_getPdFrequency
8000481a g     F .text	0000001a IfxVadc_getBackgroundScanStatus
80003da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_237
80001208 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
80003c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_224
800026a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_53
00001000 g       *ABS*	00000000 __USTACK1_SIZE
80002b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_90
80004af6 g     F .text	00000052 IfxVadc_resetKernel
800008a0 g     O .rodata	00000010 IfxAsclin1_RTS_P20_6_OUT
80000c9c g     O .rodata	0000000c IfxScu_HWCFG0DCLDO_P14_6_IN
8000df72 g     F .text	00000040 .hidden __nedf2
80004e60 g     F .text	00000052 IfxAsclin_setBaudrateBitFields
80003a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_209
80003880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_196
80005f9c g     F .text	00000044 IfxScuCcu_getPllVcoFrequency
80006a76 g     F .text	000000b4 IfxScuCcu_setSpbFrequency
80003220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_145
80002d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_108
80006f2a g     F .text	00000024 IfxScuEru_getOutputChannelConfiguration
80000ad0 g     O .rodata	00000010 IfxScu_WDT2LCK_P20_6_OUT
800009c0 g     O .rodata	00000080 IfxPort_cfg_esrMasks
80002a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_84
800006e0 g     O .rodata	00000010 IfxAsclin3_RXG_P21_2_IN
8000b05e g     F .text	00000036 sprintf
80003500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_168
800051c4 g     F .text	00000010 IfxAsclin_Asc_clearRx
80000910 g     O .rodata	00000010 IfxAsclin0_CTSA_P14_9_IN
80002400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_32
80003000 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_128
80000d28 g     O .rodata	00000010 IfxScu_DCDCSYNC_P32_2_OUT
800059e6 g     F .text	0000002a IfxPort_setESR
800004e0 g     O .rodata	00000010 IfxAsclin3_SLSO_P14_3_OUT
80003620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_177
80000420 g     O .rodata	00000010 IfxAsclin1_TX_P15_0_OUT
80003120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_137
80002900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_72
80000900 g     O .rodata	00000010 IfxAsclin1_CTSA_P20_7_IN
80002600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_48
80000b78 g     O .rodata	00000014 IfxScu_REQ3_P10_3_IN
80000410 g     O .rodata	00000010 IfxAsclin1_TX_P15_1_OUT
700004e8 g     O .data	00000004 _impure_ptr
80003660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_179
8000598e g     F .text	00000028 IfxPort_resetESR
800050a0 g     F .text	00000072 IfxAsclin_Asc_isrError
8000490a g     F .text	00000024 IfxVadc_initialiseAdcArbiterClock
80004d94 g     F .text	00000014 IfxAsclin_getSrcPointerRx
800036e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_183
80000470 g     O .rodata	00000010 IfxAsclin0_TX_P15_3_OUT
800087d6 g     F .text	00000024 initUltrasonic
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_230
80004d80 g     F .text	00000014 IfxAsclin_getSrcPointerEr
00002000 g       *ABS*	00000000 __CSA1_SIZE
800022c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_22
800003c0 g     O .rodata	00000010 IfxAsclin1_TX_P33_13_OUT
80000800 g     O .rodata	00000010 IfxAsclin1_RXC_P20_9_IN
80009342 g     F .text	00000016 DisableAllInterrupts
800081cc g     F .text	0000005e Ifx_CircularBuffer_write8
800052a2 g     F .text	00000096 IfxAsclin_Asc_isrReceive
80005a4c g     F .text	00000090 IfxPort_setGroupModeInput
800082da g     F .text	000000da Ifx_Fifo_canReadCount
00001000 g       *ABS*	00000000 __USTACK_SIZE
800095be g     F .text	000000d6 ChainTask
80006f6e g     F .text	00000034 IfxScuEru_selectExternalInput
80006e4e g     F .text	00000026 IfxScuEru_enableFallingEdgeDetection
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_101
800008e0 g     O .rodata	00000010 IfxAsclin2_CTSA_P10_7_IN
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
80000760 g     O .rodata	00000010 IfxAsclin2_RXF_P32_6_IN
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_126
800005e0 g     O .rodata	00000010 IfxAsclin3_SCLK_P11_4_OUT
8000670a g     F .text	00000014 IfxScuCcu_initConfig
80003b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_217
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_221
800002b0 g     O .rodata	00000010 IfxAsclin3_TX_P21_7_OUT
8000497c g     F .text	00000066 IfxVadc_initializeFAdcI
80000520 g     O .rodata	00000010 IfxAsclin2_SLSO_P10_5_OUT
80000b14 g     O .rodata	00000014 IfxScu_REQ8_P33_7_IN
80000280 g     O .rodata	00000010 IfxAsclin3_TX_P32_2_OUT
80001100 g       .traptab	00000000 osEE_tc_trap_mmu
8000817c g     F .text	00000050 Ifx_CircularBuffer_read32
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_87
80005120 g     F .text	0000009c IfxAsclin_Asc_flushTx
800092ec g     F .text	00000028 osEE_tc_delay
80000600 g     O .rodata	00000010 IfxAsclin3_SCLK_P00_2_OUT
80000f60 g     O .rodata	00000000 __clear_table
80005e82 g     F .text	00000064 IfxScuCcu_getPllErayFrequency
800007d0 g     O .rodata	00000010 IfxAsclin1_RXF_P33_13_IN
80009de4 g     F .text	0000001e osEE_task_end
800005b0 g     O .rodata	00000010 IfxAsclin3_SCLK_P20_0_OUT
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_110
80002f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_124
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_222
80002240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_18
80002440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_34
80000820 g     O .rodata	00000010 IfxAsclin1_RXA_P15_1_IN
80001200 g       .ctors	00000000 __EH_FRAME_BEGIN__
80000500 g     O .rodata	00000010 IfxAsclin3_SLSO_P00_3_OUT
80002840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_66
80003140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_138
80003e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_243
80005fe0 g     F .text	00000024 IfxScuCcu_getSourceFrequency
80000460 g     O .rodata	00000010 IfxAsclin0_TX_P34_1_OUT
80000d18 g     O .rodata	00000010 IfxScu_DCDCSYNC_P33_13_OUT
80000bf0 g     O .rodata	00000014 IfxScu_REQ13_P15_5_IN
8000a02e g     F .text	00000020 osEE_change_context_from_task_end
80009a34 g     F .text	0000007a WaitEvent
800059b6 g     F .text	00000030 IfxPort_disableEmergencyStop
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_253
80003c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_225
800089c2 g     F .text	00000016 calculateDistanceCm
800002f0 g     O .rodata	00000010 IfxAsclin3_TX_P15_6_OUT
80002880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_68
80007e98 g     F .text	0000002e IfxVadc_Adc_initGroupConfig
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
80002980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_76
5001b600 g       .CPU2.ustack	00000000 __USTACK2
80003940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_202
800092ce g     F .text	0000001e osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80003260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_147
80000020 g       .startup	00000000 BootModeIndex
800032c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_150
80003d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_236
700000dc g     O .data	00000004 __malloc_trim_threshold
800031a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_141
80002d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_104
80004816 g     F .text	00000004 IfxVadc_getAdcModuleFrequency
80008650 g     F .text	00000186 Ifx_Fifo_write
8000d774 g     F .text	000000ca __mdiff
800020e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_7
80002920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_73
80009e24 g     F .text	00000022 osEE_activate_isr2
80007af8 g     F .text	00000016 IfxVadc_Adc_initChannelConfig
80004c98 g     F .text	00000074 IfxAsclin_getFaFrequency
80006a26 g     F .text	00000050 IfxScuCcu_setPll2Frequency
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_238
80020000 g       .startup	00000000 BootModeHeader1
80008e98 g     F .text	0000022e osEE_tc_set_pll_fsource
80004952 g     F .text	0000002a IfxVadc_initializeFAdcD
80004268 g     F .text	00000072 UART_init
80005b6e g     F .text	000000a4 IfxPort_setGroupPadDriver
800026e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_55
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_127
80002b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_92
80000cd8 g     O .rodata	00000010 IfxScu_EVRWUPB_P15_1_IN
80000850 g     O .rodata	00000010 IfxAsclin0_RXA_P14_1_IN
8000505a g     F .text	00000012 IfxAsclin_write8
80006f60 g     F .text	0000000e IfxScuEru_getWholePatternDetectionResult
80002320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_25
800039c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_206
800029e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_79
80000fc8 g     O .rodata	00000000 __copy_table
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
80005034 g     F .text	00000014 IfxAsclin_write16
8000852a g     F .text	00000036 Ifx_Fifo_clear
80000b8c g     O .rodata	00000014 IfxScu_REQ2_P10_2_IN
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_119
8000deca g     F .text	00000010 _exit
80002280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_20
80001120 g       .traptab	00000000 osEE_tc_trap_protection
80001100 g     F .traptab	00000000 __TRAPTAB
80000c18 g     O .rodata	00000014 IfxScu_REQ11_P20_9_IN
00002000 g       *ABS*	00000000 __CSA2_SIZE
80006d0c g     F .text	00000028 IfxScuEru_clearOutputChannelConfiguration
800035a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_173
80006e02 g     F .text	00000026 IfxScuEru_disableTriggerPulse
8000745e g     F .text	000000aa IfxScuWdt_initSafetyWatchdog
8000507c g     F .text	00000006 IfxAsclin_Asc_getSendCount
8000b094 g     F .text	00000014 strlen
80003860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_195
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
80004e3e g     F .text	00000022 IfxAsclin_setClockSource
8000dff2 g     F .text	00000040 .hidden __gedf2
80000a40 g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
80004546 g     F .text	000000a2 initPeripheralsAndERU
80000750 g     O .rodata	00000010 IfxAsclin2_RXG_P02_0_IN
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_94
80002720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_57
80003420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_161
800003b0 g     O .rodata	00000010 IfxAsclin2_TX_P02_0_OUT
80002f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_122
80000b50 g     O .rodata	00000014 IfxScu_REQ5_P10_8_IN
80004b6c g     F .text	00000056 IfxVadc_setArbiterPriority
70000c38 g     O .text	00000001 __HEAP_END
80000540 g     O .rodata	00000010 IfxAsclin1_SLSO_P33_10_OUT
6001bc00 g       .CPU1.csa	00000000 __CSA1
800060b0 g     F .text	00000070 IfxScuCcu_getMaxFrequency
80009358 g     F .text	0000001c EnableAllInterrupts
80000560 g     O .rodata	00000010 IfxAsclin1_SLSO_P14_3_OUT
80004bd6 g     F .text	00000044 IfxVadc_startupCalibration
70000944 g     O .bss	00000004 g_vadc
80005c12 g     F .text	00000056 IfxPort_setPinMode
80003640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_178
80002780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_60
80000b28 g     O .rodata	00000014 IfxScu_REQ7_P00_4_IN
8000a124 g     F .text	0000001a osEE_hal_restore_ctx
8000444e g     F .text	00000032 initVADCGroup
800005a0 g     O .rodata	00000010 IfxAsclin3_SCLK_P21_5_OUT
8000a48a g     F .text	00000040 .hidden __subdf3
70008000 g     O *ABS*	00000000 _SMALL_DATA_
80005082 g     F .text	00000006 IfxAsclin_Asc_getTxTimeStamp
800049e2 g     F .text	0000006a IfxVadc_isPostCalibration
80004430 g     F .text	0000001e initVADCModule
80003f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_248
80006cce g     F .text	00000016 IfxScuEru_clearEventFlag
8000742c g     F .text	00000032 IfxScuWdt_setSafetyEndinit
8000d46c g     F .text	00000066 __lo0bits
800034c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_166
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
80000340 g     O .rodata	00000010 IfxAsclin2_TX_P33_9_OUT
80003080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_132
80005e52 g     F .text	00000030 IfxScuCcu_getOscFrequency
80009438 g     F .text	0000003c ResumeOSInterrupts
800030e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_135
80004df2 g     F .text	0000004c IfxAsclin_resetModule
80006f06 g     F .text	00000024 IfxScuEru_getInputChannelConfiguration
80000660 g     O .rodata	00000010 IfxAsclin2_SCLK_P02_4_OUT
80006cbc g     F .text	00000012 IfxScuEru_clearAllEventFlags
80003200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_144
80002d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_107
80002160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_11
800000d4 g     O .rodata	00000008 osEE_cdb_var
8000a904 g     F .text	00000112 .hidden __pack_d
80000920 g     O .rodata	00000020 IfxAsclin_cfg_indexMap
80009474 g     F .text	000000ac StartOS
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_229
80000c90 g     O .rodata	0000000c IfxScu_HWCFG1EVR33_P14_5_IN
80000b64 g     O .rodata	00000014 IfxScu_REQ4_P10_7_IN
80003440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_162
8000ab94 g     F .text	0000000e free
80000ac0 g     O .rodata	00000010 IfxScu_WDTSLCK_P20_9_OUT
8000d3a8 g     F .text	00000082 __multadd
8000d396 g     F .text	00000012 _Bfree
80000680 g     O .rodata	00000010 IfxAsclin1_SCLK_P33_11_OUT
80008000 g     O *ABS*	00000000 _SMALL_DATA3_
80003a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_212



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 ec 44 	ja 800089d8 <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80001100 <__TRAPTAB>:
80001100:	00 a0       	debug 
80001102:	1d ff ff ff 	j 80001100 <__TRAPTAB>
	...

80001120 <osEE_tc_trap_protection>:
80001120:	00 a0       	debug 
80001122:	1d ff ff ff 	j 80001120 <osEE_tc_trap_protection>
	...

80001140 <osEE_tc_trap_instruction>:
80001140:	00 a0       	debug 
80001142:	1d ff ff ff 	j 80001140 <osEE_tc_trap_instruction>
	...

80001160 <osEE_tc_trap_context>:
80001160:	00 a0       	debug 
80001162:	1d ff ff ff 	j 80001160 <osEE_tc_trap_context>
	...

80001180 <osEE_tc_trap_bus>:
80001180:	00 a0       	debug 
80001182:	1d ff ff ff 	j 80001180 <osEE_tc_trap_bus>
	...

800011a0 <osEE_tc_trap_assertion>:
800011a0:	00 a0       	debug 
800011a2:	1d ff ff ff 	j 800011a0 <osEE_tc_trap_assertion>
	...

800011c0 <osEE_tc_trap_system>:
800011c0:	00 a0       	debug 
800011c2:	1d ff ff ff 	j 800011c0 <osEE_tc_trap_system>
	...

800011e0 <osEE_tc_trap_nmi>:
800011e0:	00 a0       	debug 
800011e2:	1d ff ff ff 	j 800011e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001200 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001208 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_isr_dummy_entry_1>:
80002020:	3c 00       	j 80002020 <osEE_tc_isr_dummy_entry_1>
	...

80002040 <osEE_tc_isr2_entry_2>:
80002040:	0d 00 00 02 	svlcx 
80002044:	82 14       	mov %d4,1
80002046:	1d 00 67 39 	j 80009314 <osEE_tc_isr2_wrapper>
	...

80002060 <osEE_tc_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_isr_dummy_entry_3>
	...

80002080 <osEE_tc_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_isr_dummy_entry_7>
	...

80002100 <osEE_tc_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_isr_dummy_entry_8>
	...

80002120 <osEE_tc_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_isr_dummy_entry_9>
	...

80002140 <osEE_tc_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_isr_dummy_entry_10>
	...

80002160 <osEE_tc_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_isr_dummy_entry_11>
	...

80002180 <osEE_tc_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_isr_dummy_entry_15>
	...

80002200 <osEE_tc_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_isr_dummy_entry_16>
	...

80002220 <osEE_tc_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_isr_dummy_entry_17>
	...

80002240 <osEE_tc_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_isr_dummy_entry_18>
	...

80002260 <osEE_tc_isr2_entry_19>:
80002260:	0d 00 00 02 	svlcx 
80002264:	82 04       	mov %d4,0
80002266:	1d 00 57 38 	j 80009314 <osEE_tc_isr2_wrapper>
	...

80002280 <osEE_tc_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_isr_dummy_entry_23>
	...

80002300 <osEE_tc_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_isr_dummy_entry_24>
	...

80002320 <osEE_tc_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_isr_dummy_entry_25>
	...

80002340 <osEE_tc_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_isr_dummy_entry_26>
	...

80002360 <osEE_tc_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_isr_dummy_entry_27>
	...

80002380 <osEE_tc_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_isr_dummy_entry_31>
	...

80002400 <osEE_tc_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_isr_dummy_entry_32>
	...

80002420 <osEE_tc_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_isr_dummy_entry_33>
	...

80002440 <osEE_tc_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_isr_dummy_entry_34>
	...

80002460 <osEE_tc_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_isr_dummy_entry_35>
	...

80002480 <osEE_tc_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_isr_dummy_entry_39>
	...

80002500 <osEE_tc_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_isr_dummy_entry_40>
	...

80002520 <osEE_tc_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_isr_dummy_entry_41>
	...

80002540 <osEE_tc_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_isr_dummy_entry_42>
	...

80002560 <osEE_tc_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_isr_dummy_entry_43>
	...

80002580 <osEE_tc_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_isr_dummy_entry_47>
	...

80002600 <osEE_tc_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_isr_dummy_entry_48>
	...

80002620 <osEE_tc_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_isr_dummy_entry_49>
	...

80002640 <osEE_tc_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_isr_dummy_entry_50>
	...

80002660 <osEE_tc_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_isr_dummy_entry_51>
	...

80002680 <osEE_tc_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_isr_dummy_entry_55>
	...

80002700 <osEE_tc_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_isr_dummy_entry_56>
	...

80002720 <osEE_tc_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_isr_dummy_entry_57>
	...

80002740 <osEE_tc_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_isr_dummy_entry_58>
	...

80002760 <osEE_tc_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_isr_dummy_entry_59>
	...

80002780 <osEE_tc_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_isr_dummy_entry_63>
	...

80002800 <osEE_tc_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_isr_dummy_entry_64>
	...

80002820 <osEE_tc_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_isr_dummy_entry_65>
	...

80002840 <osEE_tc_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_isr_dummy_entry_66>
	...

80002860 <osEE_tc_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_isr_dummy_entry_67>
	...

80002880 <osEE_tc_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_isr_dummy_entry_71>
	...

80002900 <osEE_tc_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_isr_dummy_entry_72>
	...

80002920 <osEE_tc_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_isr_dummy_entry_73>
	...

80002940 <osEE_tc_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_isr_dummy_entry_74>
	...

80002960 <osEE_tc_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_isr_dummy_entry_75>
	...

80002980 <osEE_tc_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_isr_dummy_entry_127>
	...

80003000 <osEE_tc_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_isr_dummy_entry_128>
	...

80003020 <osEE_tc_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_isr_dummy_entry_129>
	...

80003040 <osEE_tc_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_isr_dummy_entry_130>
	...

80003060 <osEE_tc_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_isr_dummy_entry_131>
	...

80003080 <osEE_tc_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_isr_dummy_entry_135>
	...

80003100 <osEE_tc_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_isr_dummy_entry_136>
	...

80003120 <osEE_tc_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_isr_dummy_entry_137>
	...

80003140 <osEE_tc_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_isr_dummy_entry_138>
	...

80003160 <osEE_tc_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_isr_dummy_entry_139>
	...

80003180 <osEE_tc_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_isr_dummy_entry_143>
	...

80003200 <osEE_tc_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_isr_dummy_entry_144>
	...

80003220 <osEE_tc_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_isr_dummy_entry_145>
	...

80003240 <osEE_tc_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_isr_dummy_entry_146>
	...

80003260 <osEE_tc_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_isr_dummy_entry_147>
	...

80003280 <osEE_tc_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_isr_dummy_entry_151>
	...

80003300 <osEE_tc_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_isr_dummy_entry_152>
	...

80003320 <osEE_tc_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_isr_dummy_entry_153>
	...

80003340 <osEE_tc_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_isr_dummy_entry_154>
	...

80003360 <osEE_tc_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_isr_dummy_entry_155>
	...

80003380 <osEE_tc_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_isr_dummy_entry_159>
	...

80003400 <osEE_tc_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_isr_dummy_entry_160>
	...

80003420 <osEE_tc_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_isr_dummy_entry_161>
	...

80003440 <osEE_tc_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_isr_dummy_entry_162>
	...

80003460 <osEE_tc_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_isr_dummy_entry_163>
	...

80003480 <osEE_tc_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_isr_dummy_entry_167>
	...

80003500 <osEE_tc_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_isr_dummy_entry_168>
	...

80003520 <osEE_tc_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_isr_dummy_entry_169>
	...

80003540 <osEE_tc_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_isr_dummy_entry_170>
	...

80003560 <osEE_tc_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_isr_dummy_entry_171>
	...

80003580 <osEE_tc_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_isr_dummy_entry_175>
	...

80003600 <osEE_tc_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_isr_dummy_entry_176>
	...

80003620 <osEE_tc_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_isr_dummy_entry_177>
	...

80003640 <osEE_tc_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_isr_dummy_entry_178>
	...

80003660 <osEE_tc_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_isr_dummy_entry_179>
	...

80003680 <osEE_tc_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_isr_dummy_entry_183>
	...

80003700 <osEE_tc_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_isr_dummy_entry_184>
	...

80003720 <osEE_tc_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_isr_dummy_entry_185>
	...

80003740 <osEE_tc_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_isr_dummy_entry_186>
	...

80003760 <osEE_tc_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_isr_dummy_entry_187>
	...

80003780 <osEE_tc_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_isr_dummy_entry_191>
	...

80003800 <osEE_tc_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_isr_dummy_entry_192>
	...

80003820 <osEE_tc_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_isr_dummy_entry_193>
	...

80003840 <osEE_tc_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_isr_dummy_entry_194>
	...

80003860 <osEE_tc_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_isr_dummy_entry_195>
	...

80003880 <osEE_tc_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_isr_dummy_entry_199>
	...

80003900 <osEE_tc_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_isr_dummy_entry_200>
	...

80003920 <osEE_tc_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_isr_dummy_entry_201>
	...

80003940 <osEE_tc_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_isr_dummy_entry_202>
	...

80003960 <osEE_tc_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_isr_dummy_entry_203>
	...

80003980 <osEE_tc_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <lcd_write4bits>:
}


static void lcd_write4bits(uint8 data)
{
    IfxPort_setPinState(LCD_D4, (data & 0x01) ? IfxPort_State_high : IfxPort_State_low);
80004000:	8f 14 00 21 	and %d2,%d4,1
80004004:	7b 10 00 f0 	movh %d15,1
80004008:	ab 1f a0 f2 	seln %d15,%d2,%d15,1
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000400c:	91 40 00 ff 	movh.a %a15,61444
80004010:	06 4f       	sh %d15,4
80004012:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80004016:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D5, (data & 0x02) ? IfxPort_State_high : IfxPort_State_low);
80004018:	8f 24 00 21 	and %d2,%d4,2
8000401c:	7b 80 00 f0 	movh %d15,8
80004020:	91 40 00 ff 	movh.a %a15,61444
80004024:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004028:	ab 8f a0 f2 	seln %d15,%d2,%d15,8
8000402c:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D6, (data & 0x04) ? IfxPort_State_high : IfxPort_State_low);
8000402e:	8f 44 00 21 	and %d2,%d4,4
80004032:	7b 00 01 f0 	movh %d15,16
80004036:	ab 0f a1 f2 	seln %d15,%d2,%d15,16
8000403a:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinState(LCD_D7, (data & 0x08) ? IfxPort_State_high : IfxPort_State_low);
8000403c:	8f 84 00 41 	and %d4,%d4,8
80004040:	7b 00 02 f0 	movh %d15,32
80004044:	ab 0f a2 44 	seln %d4,%d4,%d15,32
80004048:	68 14       	st.w [%a15]4,%d4
8000404a:	da 80       	mov %d15,128
8000404c:	68 1f       	st.w [%a15]4,%d15


static void lcd_pulse_enable(void)
{
    IfxPort_setPinHigh(LCD_E);
    delay_ms(2);       
8000404e:	82 24       	mov %d4,2
80004050:	6d 00 d5 23 	call 800087fa <delay_ms>
80004054:	7b 00 08 f0 	movh %d15,128
80004058:	68 1f       	st.w [%a15]4,%d15
    IfxPort_setPinLow(LCD_E);
    delay_ms(2);       
8000405a:	82 24       	mov %d4,2
8000405c:	1d 00 cf 23 	j 800087fa <delay_ms>

80004060 <lcd_command>:
80004060:	91 40 00 ff 	movh.a %a15,61444
80004064:	7b 00 04 20 	movh %d2,64
80004068:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
    lcd_pulse_enable();
}


static void lcd_command(uint8 cmd)
{
8000406c:	02 4f       	mov %d15,%d4
8000406e:	68 12       	st.w [%a15]4,%d2
    IfxPort_setPinLow(LCD_RS);
    lcd_write4bits(cmd >> 4);
80004070:	06 c4       	sh %d4,-4
80004072:	5c c7       	call 80004000 <lcd_write4bits>
    lcd_write4bits(cmd & 0x0F);
80004074:	8f ff 00 41 	and %d4,%d15,15
80004078:	5c c4       	call 80004000 <lcd_write4bits>
    delay_ms(5);       
8000407a:	82 54       	mov %d4,5
8000407c:	1d 00 bf 23 	j 800087fa <delay_ms>

80004080 <lcd_clear>:
}


void lcd_clear(void)
{
    lcd_command(0x01);
80004080:	82 14       	mov %d4,1
80004082:	5c ef       	call 80004060 <lcd_command>
    delay_ms(5);       
80004084:	82 54       	mov %d4,5
80004086:	1d 00 ba 23 	j 800087fa <delay_ms>

8000408a <lcd_init>:
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000408a:	91 40 00 4f 	movh.a %a4,61444
8000408e:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004092:	82 64       	mov %d4,6
80004094:	3b 00 08 50 	mov %d5,128
80004098:	6d 00 bd 0d 	call 80005c12 <IfxPort_setPinMode>
8000409c:	91 40 00 4f 	movh.a %a4,61444
800040a0:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040a4:	82 74       	mov %d4,7
800040a6:	3b 00 08 50 	mov %d5,128
800040aa:	6d 00 b4 0d 	call 80005c12 <IfxPort_setPinMode>
800040ae:	91 40 00 4f 	movh.a %a4,61444
800040b2:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
800040b6:	82 44       	mov %d4,4
800040b8:	3b 00 08 50 	mov %d5,128
800040bc:	6d 00 ab 0d 	call 80005c12 <IfxPort_setPinMode>
800040c0:	91 40 00 4f 	movh.a %a4,61444
800040c4:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040c8:	82 34       	mov %d4,3
800040ca:	3b 00 08 50 	mov %d5,128
800040ce:	6d 00 a2 0d 	call 80005c12 <IfxPort_setPinMode>
800040d2:	91 40 00 4f 	movh.a %a4,61444
800040d6:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040da:	82 44       	mov %d4,4
800040dc:	3b 00 08 50 	mov %d5,128
800040e0:	6d 00 99 0d 	call 80005c12 <IfxPort_setPinMode>
800040e4:	91 40 00 4f 	movh.a %a4,61444
800040e8:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
800040ec:	3b 00 08 50 	mov %d5,128
800040f0:	82 54       	mov %d4,5
800040f2:	6d 00 90 0d 	call 80005c12 <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(LCD_D4, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D5, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D6, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LCD_D7, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    delay_ms(100);  
800040f6:	3b 40 06 40 	mov %d4,100
800040fa:	6d 00 80 23 	call 800087fa <delay_ms>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800040fe:	91 40 00 ff 	movh.a %a15,61444
80004102:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004106:	7b 00 04 f0 	movh %d15,64
8000410a:	68 1f       	st.w [%a15]4,%d15
8000410c:	7b 00 08 f0 	movh %d15,128
80004110:	68 1f       	st.w [%a15]4,%d15

    IfxPort_setPinLow(LCD_RS);
    IfxPort_setPinLow(LCD_E);

    lcd_write4bits(0x03); delay_ms(10);  
80004112:	82 34       	mov %d4,3
80004114:	6d ff 76 ff 	call 80004000 <lcd_write4bits>
80004118:	3b a0 00 40 	mov %d4,10
8000411c:	6d 00 6f 23 	call 800087fa <delay_ms>
    lcd_write4bits(0x03); delay_ms(10);  
80004120:	82 34       	mov %d4,3
80004122:	6d ff 6f ff 	call 80004000 <lcd_write4bits>
80004126:	3b a0 00 40 	mov %d4,10
8000412a:	6d 00 68 23 	call 800087fa <delay_ms>
    lcd_write4bits(0x03); delay_ms(5);   
8000412e:	82 34       	mov %d4,3
80004130:	6d ff 68 ff 	call 80004000 <lcd_write4bits>
80004134:	82 54       	mov %d4,5
80004136:	6d 00 62 23 	call 800087fa <delay_ms>
    lcd_write4bits(0x02); delay_ms(5);   
8000413a:	82 24       	mov %d4,2
8000413c:	6d ff 62 ff 	call 80004000 <lcd_write4bits>
80004140:	82 54       	mov %d4,5
80004142:	6d 00 5c 23 	call 800087fa <delay_ms>

    lcd_command(0x28);
80004146:	3b 80 02 40 	mov %d4,40
8000414a:	5c 8b       	call 80004060 <lcd_command>
    lcd_command(0x0C);
8000414c:	3b c0 00 40 	mov %d4,12
80004150:	5c 88       	call 80004060 <lcd_command>
    lcd_command(0x06);
80004152:	82 64       	mov %d4,6
80004154:	5c 86       	call 80004060 <lcd_command>
    lcd_clear();
80004156:	1d ff 95 ff 	j 80004080 <lcd_clear>

8000415a <lcd_goto>:
}


void lcd_goto(uint8 row, uint8 col)
{
    uint8 address = (row == 0) ? 0x00 : 0x40;
8000415a:	ab 04 a4 44 	seln %d4,%d4,%d4,64
    address += col;
8000415e:	42 54       	add %d4,%d5
    lcd_command(0x80 | address);
80004160:	b7 14 99 43 	insert %d4,%d4,1,7,25
80004164:	1d ff 7e ff 	j 80004060 <lcd_command>

80004168 <lcd_print>:
80004168:	91 40 00 cf 	movh.a %a12,61444
}


void lcd_print(const char *str)
{
8000416c:	40 4f       	mov.aa %a15,%a4
8000416e:	d9 cc 00 8a 	lea %a12,[%a12]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
80004172:	3b 00 04 80 	mov %d8,64
    while (*str)
80004176:	79 ff 00 00 	ld.b %d15,[%a15]0
8000417a:	6e 11       	jz %d15,8000419c <lcd_print+0x34>
        lcd_data(*str++);
8000417c:	16 ff       	and %d15,255


static void lcd_data(uint8 data)
{
    IfxPort_setPinHigh(LCD_RS);
    lcd_write4bits(data >> 4);
8000417e:	8f cf 1f 40 	sh %d4,%d15,-4
80004182:	59 c8 04 00 	st.w [%a12]4 <f0040004 <_SMALL_DATA4_+0x40038004>>,%d8
80004186:	6d ff 3d ff 	call 80004000 <lcd_write4bits>
    lcd_write4bits(data & 0x0F);
8000418a:	8f ff 00 41 	and %d4,%d15,15
8000418e:	6d ff 39 ff 	call 80004000 <lcd_write4bits>
    delay_ms(5);       
80004192:	82 54       	mov %d4,5


void lcd_print(const char *str)
{
    while (*str)
        lcd_data(*str++);
80004194:	b0 1f       	add.a %a15,1
static void lcd_data(uint8 data)
{
    IfxPort_setPinHigh(LCD_RS);
    lcd_write4bits(data >> 4);
    lcd_write4bits(data & 0x0F);
    delay_ms(5);       
80004196:	6d 00 32 23 	call 800087fa <delay_ms>
8000419a:	3c ee       	j 80004176 <lcd_print+0xe>

void lcd_print(const char *str)
{
    while (*str)
        lcd_data(*str++);
}
8000419c:	00 90       	ret 

8000419e <FuncTask1>:

uint16_t rpm = 1000; // LCD에 출력한 전역변수 선언

TASK(Task1)
{
    printfSerial("Task1 Begins...");
8000419e:	91 00 00 48 	movh.a %a4,32768
800041a2:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <_start+0x8>>
800041a6:	6d 00 9a 00 	call 800042da <printfSerial>
    mdelay(3000);
800041aa:	3b 80 bb 40 	mov %d4,3000
800041ae:	6d 00 cd 00 	call 80004348 <mdelay>
    printfSerial("Task1 Finishes...");
800041b2:	91 00 00 48 	movh.a %a4,32768
800041b6:	d9 44 38 00 	lea %a4,[%a4]56 <80000038 <_start+0x18>>
800041ba:	6d 00 90 00 	call 800042da <printfSerial>

    TerminateTask();
800041be:	1d 00 6b 2a 	j 80009694 <TerminateTask>

800041c2 <FuncTaskLCD>:
}

TASK(TaskLCD)
{   
    rpm += 100;
800041c2:	91 00 00 f7 	movh.a %a15,28672
800041c6:	c9 ff 04 00 	ld.h %d15,[%a15]4 <70000004 <rpm>>

    TerminateTask();
}

TASK(TaskLCD)
{   
800041ca:	20 28       	sub.a %sp,40
    rpm += 100;
800041cc:	1b 4f 06 f0 	addi %d15,%d15,100
800041d0:	f9 ff 04 00 	st.h [%a15]4,%d15
    lcd_clear(); // LCD 출력 내용 초기화 함수
800041d4:	6d ff 56 ff 	call 80004080 <lcd_clear>

    char buf[32];  
    sprintf(buf, "RPM = %u", rpm); 
800041d8:	b9 ff 04 00 	ld.hu %d15,[%a15]4
800041dc:	91 00 00 58 	movh.a %a5,32768
800041e0:	d9 55 0a 10 	lea %a5,[%a5]74 <8000004a <_start+0x2a>>
800041e4:	d9 a4 08 00 	lea %a4,[%sp]8 <8000004a <_start+0x2a>>
800041e8:	78 00       	st.w [%sp]0,%d15
800041ea:	6d 00 3a 37 	call 8000b05e <sprintf>
    lcd_print(buf);  // 출력할 내용을 문자열로 만들어 LCD에게 전송
800041ee:	d9 a4 08 00 	lea %a4,[%sp]8
800041f2:	6d ff bb ff 	call 80004168 <lcd_print>

    lcd_goto(1,0); // LCD 커서 위치 이동 함수
800041f6:	d2 14       	mov %e4,1
800041f8:	6d ff b1 ff 	call 8000415a <lcd_goto>
    lcd_print("Hello World!");
800041fc:	91 00 00 48 	movh.a %a4,32768
80004200:	d9 44 13 10 	lea %a4,[%a4]83 <80000053 <_start+0x33>>
80004204:	6d ff b2 ff 	call 80004168 <lcd_print>

    TerminateTask();
80004208:	1d 00 46 2a 	j 80009694 <TerminateTask>

8000420c <FuncTaskUltrasonic>:
}

TASK(TaskUltrasonic)
{   
8000420c:	20 08       	sub.a %sp,8
    printfSerial("%d",getUltrasonic());
8000420e:	6d 00 c8 23 	call 8000899e <getUltrasonic>
80004212:	91 00 00 48 	movh.a %a4,32768
80004216:	74 a2       	st.w [%sp],%d2
80004218:	d9 44 20 10 	lea %a4,[%a4]96 <80000060 <_start+0x40>>
8000421c:	1d 00 5f 00 	j 800042da <printfSerial>

80004220 <TimerISR>:


ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004220:	7b f0 00 40 	movh %d4,15
    printfSerial("%d",getUltrasonic());
}


ISR2(TimerISR)
{
80004224:	20 08       	sub.a %sp,8
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004226:	1b 04 24 44 	addi %d4,%d4,16960
    if (c == 0)
8000422a:	91 00 00 f7 	movh.a %a15,28672


ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
8000422e:	6d 00 fa 27 	call 80009222 <osEE_tc_stm_set_sr0_next_match>
    if (c == 0)
80004232:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004236:	ee 04       	jnz %d15,8000423e <TimerISR+0x1e>
        ActivateTask(Task1);
80004238:	82 24       	mov %d4,2
8000423a:	6d 00 80 29 	call 8000953a <ActivateTask>
    if (c % 2 == 0)
8000423e:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004242:	ae 04       	jnz.t %d15,0,8000424a <TimerISR+0x2a>
        ActivateTask(TaskLCD);
80004244:	82 34       	mov %d4,3
80004246:	6d 00 7a 29 	call 8000953a <ActivateTask>
    ActivateTask(TaskUltrasonic);
8000424a:	82 44       	mov %d4,4
8000424c:	6d 00 77 29 	call 8000953a <ActivateTask>
    printfSerial("\n%4ld: ", c++);
80004250:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004254:	91 00 00 48 	movh.a %a4,32768
80004258:	78 00       	st.w [%sp]0,%d15
8000425a:	d9 44 23 10 	lea %a4,[%a4]99 <80000063 <_start+0x43>>
8000425e:	c2 1f       	add %d15,1
80004260:	59 ff 00 00 	st.w [%a15]0 <70000000 <__DSPR0_START>>,%d15
80004264:	1d 00 3b 00 	j 800042da <printfSerial>

80004268 <UART_init>:
                                        IfxVadc_ChannelId_6,  /* AN38: channel 6 of group 4                         */
                                        IfxVadc_ChannelId_7}; /* AN39: channel 7 of group 4                         */


void UART_init(void)
{
80004268:	20 60       	sub.a %sp,96

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
8000426a:	d9 a4 24 00 	lea %a4,[%sp]36
8000426e:	c5 f5 80 40 	lea %a5,f0000900 <_SMALL_DATA4_+0x3fff8900>
    ascConfig.baudrate.prescaler    = 1;
80004272:	82 1f       	mov %d15,1

void UART_init(void)
{

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
80004274:	6d 00 5a 0a 	call 80005728 <IfxAsclin_Asc_initModuleConfig>
    ascConfig.baudrate.prescaler    = 1;
80004278:	f9 af 2c 00 	st.h [%sp]44,%d15
    ascConfig.baudrate.baudrate     = 115200;
8000427c:	7b 10 7e f4 	movh %d15,18401
80004280:	78 0a       	st.w [%sp]40,%d15
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
80004282:	82 3f       	mov %d15,3
80004284:	e9 af 2e 00 	st.b [%sp]46,%d15

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;
80004288:	da 13       	mov %d15,19
8000428a:	f9 af 00 10 	st.h [%sp]64,%d15


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000428e:	4d c0 e1 ff 	mfcr %d15,$core_id
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
80004292:	7b 00 00 28 	movh %d2,32768
80004296:	60 23       	mov.a %a3,%d2
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80004298:	37 0f 63 f0 	extr.u %d15,%d15,0,3
8000429c:	d9 af 04 00 	lea %a15,[%sp]4
800042a0:	40 f4       	mov.aa %a4,%a15
800042a2:	d9 32 2c 10 	lea %a2,[%a3]108
    ascConfig.baudrate.baudrate     = 115200;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
800042a6:	e9 af 06 10 	st.b [%sp]70,%d15
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
800042aa:	a0 33       	mov.a %a3,3
800042ac:	09 22 48 01 	ld.d %e2,[%a2+]8
800042b0:	89 42 48 01 	st.d [%a4+]8,%e2
800042b4:	fc 3c       	loop %a3,800042ac <UART_init+0x44>

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
800042b6:	7b 00 00 f7 	movh %d15,28672
800042ba:	1b 4f 95 f0 	addi %d15,%d15,2388
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800042be:	91 00 00 47 	movh.a %a4,28672

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
800042c2:	78 14       	st.w [%sp]80,%d15
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800042c4:	d9 44 a8 e0 	lea %a4,[%a4]2984 <70000ba8 <g_AsclinAsc+0x254>>
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
800042c8:	3b 20 10 f0 	mov %d15,258
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800042cc:	d9 a5 24 00 	lea %a5,[%sp]36
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
800042d0:	f9 af 0e 10 	st.h [%sp]78,%d15
        &IfxAsclin3_RXD_P32_2_IN, IfxPort_InputMode_pullUp,        /* Rx pin */
        NULL_PTR,                     IfxPort_OutputMode_pushPull,     /* RTS pin not used */
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
800042d4:	f8 12       	st.a [%sp]72,%a15
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800042d6:	1d 00 52 08 	j 8000537a <IfxAsclin_Asc_initModule>

800042da <printfSerial>:
    //printf("Asclin Asc is initialised\n");
}


void printfSerial(const char *fmt,...)
{
800042da:	20 e8       	sub.a %sp,232
800042dc:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
800042de:	6d 00 3d 28 	call 80009358 <EnableAllInterrupts>
    char buf[LEN_BUF];
    va_list args;
    va_start (args, fmt );
    vsnprintf(buf, LEN_BUF, fmt, args);
800042e2:	40 f5       	mov.aa %a5,%a15
800042e4:	d9 a4 28 10 	lea %a4,[%sp]104
800042e8:	3b 00 08 40 	mov %d4,128
800042ec:	d9 a6 28 30 	lea %a6,[%sp]232
800042f0:	6d 00 d3 3f 	call 8000c296 <vsnprintf>
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
800042f4:	d9 a4 28 10 	lea %a4,[%sp]104
800042f8:	6d 00 ce 36 	call 8000b094 <strlen>
800042fc:	91 00 00 f7 	movh.a %a15,28672
80004300:	d9 ff 94 50 	lea %a15,[%a15]2388 <70000954 <g_AsclinAsc>>
80004304:	f9 f2 3a 90 	st.h [%a15]634 <7000027a <__malloc_av_+0x19a>>,%d2
    unsigned int i =0;
80004308:	82 0f       	mov %d15,0
    for(; i<strlen(buf);i++) {
8000430a:	d9 a4 28 10 	lea %a4,[%sp]104
8000430e:	6d 00 c3 36 	call 8000b094 <strlen>
80004312:	7f 2f 0c 80 	jge.u %d15,%d2,8000432a <printfSerial+0x50>
        txData[i] = buf[i];
80004316:	d9 a3 04 00 	lea %a3,[%sp]4
8000431a:	10 32       	addsc.a %a2,%a3,%d15,0
8000431c:	d9 a3 28 10 	lea %a3,[%sp]104
80004320:	10 3f       	addsc.a %a15,%a3,%d15,0
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
    unsigned int i =0;
    for(; i<strlen(buf);i++) {
80004322:	c2 1f       	add %d15,1
        txData[i] = buf[i];
80004324:	08 02       	ld.bu %d2,[%a15]0
80004326:	34 22       	st.b [%a2],%d2
80004328:	3c f1       	j 8000430a <printfSerial+0x30>
    }
    /* Transmit data */
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
8000432a:	91 00 00 47 	movh.a %a4,28672
8000432e:	91 00 00 67 	movh.a %a6,28672
80004332:	82 f4       	mov %d4,-1
80004334:	d9 44 a8 e0 	lea %a4,[%a4]2984 <70000ba8 <g_AsclinAsc+0x254>>
80004338:	d9 a5 04 00 	lea %a5,[%sp]4 <70000ba8 <g_AsclinAsc+0x254>>
8000433c:	d9 66 8e f0 	lea %a6,[%a6]3022 <70000bce <g_AsclinAsc+0x27a>>
80004340:	9b 04 00 58 	addih %d5,%d4,32768
80004344:	1d 00 5a 0a 	j 800057f8 <IfxAsclin_Asc_write>

80004348 <mdelay>:

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004348:	85 fa 10 00 	ld.w %d10,f0000010 <_SMALL_DATA4_+0x3fff8010>
}

void mdelay(unsigned long delay_ms)
{
8000434c:	02 4b       	mov %d11,%d4
    result |= ((uint64)stm->CAP.U) << 32;
8000434e:	85 fc 2c 00 	ld.w %d12,f000002c <_SMALL_DATA4_+0x3fff802c>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80004352:	6d 00 47 0e 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
80004356:	91 30 00 ff 	movh.a %a15,61443
8000435a:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000435e:	4c f0       	ld.w %d15,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004360:	53 1a 40 80 	mul.u %e8,%d10,1
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004364:	0b ac 10 48 	mov %e4,%d12,%d10
80004368:	37 0f 64 f4 	extr.u %d15,%d15,8,4
8000436c:	a6 95       	or %d5,%d9
8000436e:	02 28       	mov %d8,%d2
80004370:	6d 00 64 2f 	call 8000a238 <__floatundisf>
80004374:	4b 0f 41 f1 	itof %d15,%d15
80004378:	7b a0 47 a4 	movh %d10,17530
8000437c:	4b f8 51 f0 	div.f %d15,%d8,%d15
80004380:	40 fc       	mov.aa %a12,%a15
80004382:	40 fd       	mov.aa %a13,%a15
80004384:	4b af 51 f0 	div.f %d15,%d15,%d10
80004388:	4b f2 51 20 	div.f %d2,%d2,%d15
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
8000438c:	02 ae       	mov %d14,%d10
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
8000438e:	4b 02 71 f1 	ftouz %d15,%d2
80004392:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80004396:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
8000439a:	6d 00 23 0e 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
8000439e:	3b 40 01 40 	mov %d4,20
800043a2:	4b 4b 11 42 	div.u %e4,%d11,%d4
800043a6:	48 02       	ld.w %d2,[%a15]0
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
800043a8:	82 0b       	mov %d11,0
    while (cnt < (delay_ms / period_ms)) {
800043aa:	02 4d       	mov %d13,%d4
800043ac:	5f db 41 00 	jeq %d11,%d13,8000442e <mdelay+0xe6>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800043b0:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800043b4:	85 fe 2c 08 	ld.a %a14,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800043b8:	53 1c 40 80 	mul.u %e8,%d12,1
800043bc:	6d 00 12 0e 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
800043c0:	54 c3       	ld.w %d3,[%a12]
    result |= ((uint64)stm->CAP.U) << 32;
800043c2:	80 e5       	mov.d %d5,%a14
800043c4:	37 03 64 34 	extr.u %d3,%d3,8,4
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800043c8:	02 c4       	mov %d4,%d12
800043ca:	a6 95       	or %d5,%d9
800043cc:	60 3f       	mov.a %a15,%d3
800043ce:	02 28       	mov %d8,%d2
800043d0:	6d 00 34 2f 	call 8000a238 <__floatundisf>
800043d4:	80 f4       	mov.d %d4,%a15
800043d6:	4b 04 41 31 	itof %d3,%d4
800043da:	4b 38 51 80 	div.f %d8,%d8,%d3
800043de:	4b a8 51 80 	div.f %d8,%d8,%d10
800043e2:	4b 82 51 20 	div.f %d2,%d2,%d8
800043e6:	4b 02 71 21 	ftouz %d2,%d2
        if (current_ms - prev_ms >= period_ms) {
800043ea:	a2 f2       	sub %d2,%d15
800043ec:	8b 42 61 22 	lt.u %d2,%d2,20
800043f0:	df 02 de ff 	jne %d2,0,800043ac <mdelay+0x64>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800043f4:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800043f8:	85 ff 2c 08 	ld.a %a15,f000002c <_SMALL_DATA4_+0x3fff802c>
800043fc:	6d 00 f2 0d 	call 80005fe0 <IfxScuCcu_getSourceFrequency>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004400:	53 1c 40 80 	mul.u %e8,%d12,1
80004404:	4c d0       	ld.w %d15,[%a13]0
    result |= ((uint64)stm->CAP.U) << 32;
80004406:	80 f5       	mov.d %d5,%a15
80004408:	37 0f 64 f4 	extr.u %d15,%d15,8,4
            cnt++;
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
8000440c:	02 c4       	mov %d4,%d12
8000440e:	a6 95       	or %d5,%d9
80004410:	02 28       	mov %d8,%d2
80004412:	6d 00 13 2f 	call 8000a238 <__floatundisf>
80004416:	4b 0f 41 f1 	itof %d15,%d15
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
        if (current_ms - prev_ms >= period_ms) {
            cnt++;
8000441a:	c2 1b       	add %d11,1
8000441c:	4b f8 51 f0 	div.f %d15,%d8,%d15
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004420:	4b ef 51 f0 	div.f %d15,%d15,%d14
80004424:	4b f2 51 20 	div.f %d2,%d2,%d15
80004428:	4b 02 71 f1 	ftouz %d15,%d2
8000442c:	3c c0       	j 800043ac <mdelay+0x64>
        }
    }
}
8000442e:	00 90       	ret 

80004430 <initVADCModule>:
    IfxVadc_Adc_startBackgroundScan(&g_vadc);
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
80004430:	20 28       	sub.a %sp,40
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
80004432:	d9 a4 04 00 	lea %a4,[%sp]4
80004436:	91 20 00 5f 	movh.a %a5,61442
8000443a:	6d 00 ba 1d 	call 80007fae <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the configuration                  */
8000443e:	91 00 00 47 	movh.a %a4,28672
80004442:	d9 44 84 50 	lea %a4,[%a4]2372 <70000944 <g_vadc>>
80004446:	d9 a5 04 00 	lea %a5,[%sp]4 <70000944 <g_vadc>>
8000444a:	1d 00 3e 1d 	j 80007ec6 <IfxVadc_Adc_initModule>

8000444e <initVADCGroup>:
}

/* Function to initialize the VADC group */
void initVADCGroup(void)
{
8000444e:	20 38       	sub.a %sp,56
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */
80004450:	91 00 00 57 	movh.a %a5,28672
80004454:	40 a4       	mov.aa %a4,%sp
80004456:	d9 55 84 50 	lea %a5,[%a5]2372 <70000944 <g_vadc>>
8000445a:	6d 00 1f 1d 	call 80007e98 <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
8000445e:	82 4f       	mov %d15,4
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004460:	91 00 00 47 	movh.a %a4,28672
void initVADCGroup(void)
{
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
80004464:	2c a4       	st.b [%sp]4,%d15
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */
80004466:	2c a5       	st.b [%sp]5,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004468:	d9 44 b8 40 	lea %a4,[%a4]2360 <70000938 <g_vadcGroup>>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
8000446c:	82 1f       	mov %d15,1
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
8000446e:	40 a5       	mov.aa %a5,%sp

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
80004470:	e9 af 35 00 	st.b [%sp]53,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;
80004474:	e9 af 28 00 	st.b [%sp]40,%d15

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80004478:	e9 af 2c 00 	st.b [%sp]44,%d15

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
8000447c:	1d 00 49 1b 	j 80007b0e <IfxVadc_Adc_initGroup>

80004480 <initVADCChannels>:
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004480:	91 00 00 e7 	movh.a %a14,28672

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004484:	7b 00 00 b7 	movh %d11,28672
80004488:	7b 00 00 a7 	movh %d10,28672
}


IFX_INLINE void IfxVadc_Adc_setBackgroundScan(IfxVadc_Adc *vadc, IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setBackgroundScan(vadc->vadc, group->groupId, channels, mask);
8000448c:	91 00 00 d7 	movh.a %a13,28672
    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
}

/* Function to initialize the VADC used channels */
void initVADCChannels(void)
{
80004490:	20 60       	sub.a %sp,96
80004492:	82 0f       	mov %d15,0
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004494:	d9 ee b8 40 	lea %a14,[%a14]2360 <70000938 <g_vadcGroup>>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004498:	1b 8b 00 b0 	addi %d11,%d11,8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
8000449c:	82 19       	mov %d9,1
8000449e:	1b 8a 91 a0 	addi %d10,%d10,2328
800044a2:	d9 dd 84 50 	lea %a13,[%a13]2372
800044a6:	53 8f 21 80 	mul %d8,%d15,24
800044aa:	40 ac       	mov.aa %a12,%sp
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
800044ac:	40 e5       	mov.aa %a5,%a14
800044ae:	60 82       	mov.a %a2,%d8

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044b0:	d9 af 20 10 	lea %a15,[%sp]96
800044b4:	30 2c       	add.a %a12,%a2
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
800044b6:	40 c4       	mov.aa %a4,%a12
800044b8:	6d 00 20 1b 	call 80007af8 <IfxVadc_Adc_initChannelConfig>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044bc:	60 83       	mov.a %a3,%d8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
800044be:	40 c5       	mov.aa %a5,%a12
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044c0:	30 3f       	add.a %a15,%a3
800044c2:	60 b3       	mov.a %a3,%d11
800044c4:	10 32       	addsc.a %a2,%a3,%d15,0
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
800044c6:	e9 ff ef ef 	st.b [%a15]-81,%d15
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044ca:	14 22       	ld.bu %d2,[%a2]
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
800044cc:	60 a2       	mov.a %a2,%d10
800044ce:	d0 24       	addsc.a %a4,%a2,%d15,3
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800044d0:	e9 f2 ec ef 	st.b [%a15]-84,%d2
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
800044d4:	e9 f9 e2 ef 	st.b [%a15]-94,%d9


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
800044d8:	6d 00 1a 1a 	call 8000790c <IfxVadc_Adc_initChannel>
800044dc:	d4 d2       	ld.a %a2,[%a13]
800044de:	39 e2 08 00 	ld.bu %d2,[%a14]8 <70000008 <g_vadcChannelIDs>>
800044e2:	c2 1f       	add %d15,1
800044e4:	01 22 02 26 	addsc.a %a2,%a2,%d2,2

        /* Add the channel to background scan */
        unsigned chnEnableBit = (1 << adcChannelConf[chn].channelId);   /* Set the the corresponding input channel  */
800044e8:	79 f2 ec ef 	ld.b %d2,[%a15]-84
}


IFX_INLINE void IfxVadc_setBackgroundScan(Ifx_VADC *vadc, IfxVadc_GroupId groupId, uint32 channels, uint32 mask)
{
    channels                = (vadc->BRSSEL[groupId].U & ~mask) | channels;
800044ec:	19 23 00 60 	ld.w %d3,[%a2]384
800044f0:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
    vadc->BRSSEL[groupId].U = channels;
800044f4:	59 22 00 60 	st.w [%a2]384,%d2
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
800044f8:	df 4f d7 ff 	jne %d15,4,800044a6 <initVADCChannels+0x26>
        unsigned mask = chnEnableBit;                                   /* of the respective group to be added in   */
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup, chnEnableBit, mask); /* the background scan sequence.  */

    }

}
800044fc:	00 90       	ret 

800044fe <initADC>:
}


IFX_INLINE void IfxVadc_Adc_startBackgroundScan(IfxVadc_Adc *vadc)
{
    IfxVadc_startBackgroundScan(vadc->vadc);
800044fe:	91 00 00 f7 	movh.a %a15,28672
}

/* Function to initialize the VADC module */
void initADC(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
80004502:	6d ff 97 ff 	call 80004430 <initVADCModule>
    initVADCGroup();                                                    /* Initialize the VADC group                */
80004506:	6d ff a4 ff 	call 8000444e <initVADCGroup>
    initVADCChannels();                                                 /* Initialize the used channels             */
8000450a:	6d ff bb ff 	call 80004480 <initVADCChannels>
8000450e:	99 ff 84 50 	ld.a %a15,[%a15]2372 <70000944 <g_vadc>>
}


IFX_INLINE void IfxVadc_startBackgroundScan(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.LDEV = 1;     /* execute Load event to start the conversion */
80004512:	19 ff 04 80 	ld.w %d15,[%a15]516 <70000944 <g_vadc>>
80004516:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000451a:	59 ff 04 80 	st.w [%a15]516,%d15
8000451e:	00 90       	ret 

80004520 <readADCValue>:
}


IFX_INLINE Ifx_VADC_RES IfxVadc_Adc_getResult(IfxVadc_Adc_Channel *channel)
{
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
80004520:	91 00 00 f7 	movh.a %a15,28672
80004524:	d9 ff 98 40 	lea %a15,[%a15]2328 <70000918 <g_vadcChannel>>
80004528:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
8000452c:	c8 12       	ld.a %a2,[%a15]4
8000452e:	0c f1       	ld.bu %d15,[%a15]1
80004530:	99 22 04 00 	ld.a %a2,[%a2]4

IFX_INLINE Ifx_VADC_RES IfxVadc_getResult(Ifx_VADC_G *group, uint32 resultIdx)
{
    Ifx_VADC_RES tmpResult;

    tmpResult.U = group->RES[resultIdx].U;
80004534:	1b 0f 0a f0 	addi %d15,%d15,160
80004538:	90 2f       	addsc.a %a15,%a2,%d15,2
8000453a:	4c f0       	ld.w %d15,[%a15]0
8000453c:	37 0f 70 20 	extr.u %d2,%d15,0,16
{
    Ifx_VADC_RES conversionResult;
    do
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    } while(!conversionResult.B.VF);
80004540:	ff 0f fd 7f 	jge %d15,0,8000453a <readADCValue+0x1a>

    return conversionResult.B.RESULT;
}
80004544:	00 90       	ret 

80004546 <initPeripheralsAndERU>:

void initPeripheralsAndERU(void)
{
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */
80004546:	91 40 00 4f 	movh.a %a4,61444
8000454a:	d9 44 00 0e 	lea %a4,[%a4]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
8000454e:	82 74       	mov %d4,7
80004550:	3b 00 01 50 	mov %d5,16
80004554:	6d 00 5f 0b 	call 80005c12 <IfxPort_setPinMode>


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
80004558:	91 00 00 f8 	movh.a %a15,32768
8000455c:	d9 ff bc c0 	lea %a15,[%a15]2876 <80000b3c <IfxScu_REQ6_P02_0_IN>>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80004560:	c8 24       	ld.a %a4,[%a15]8
80004562:	91 00 00 d7 	movh.a %a13,28672
80004566:	08 c4       	ld.bu %d4,[%a15]12
80004568:	3b 80 00 50 	mov %d5,8
8000456c:	b5 df 88 50 	st.a [%a13]2376 <70000948 <g_ERUconfig>>,%a15
80004570:	6d 00 51 0b 	call 80005c12 <IfxPort_setPinMode>
/******************************************************************************/

IFX_INLINE void IfxScuEru_initReqPin(IfxScu_Req_In *req, IfxPort_InputMode inputMode)
{
    IfxPort_setPinModeInput(req->pin.port, req->pin.pinIndex, inputMode);
    IfxScuEru_selectExternalInput((IfxScuEru_InputChannel)req->channelId, (IfxScuEru_ExternalInputSelection)req->select);
80004574:	39 f5 10 00 	ld.bu %d5,[%a15]16 <80000010 <BootModeHeader0+0x10>>
80004578:	08 44       	ld.bu %d4,[%a15]4
8000457a:	6d 00 fa 14 	call 80006f6e <IfxScuEru_selectExternalInput>
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
8000457e:	99 df 88 50 	ld.a %a15,[%a13]2376 <70000948 <g_ERUconfig>>
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
80004582:	d9 dc 88 50 	lea %a12,[%a13]2376 <70000948 <g_ERUconfig>>
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
80004586:	82 0f       	mov %d15,0
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
80004588:	08 44       	ld.bu %d4,[%a15]4
8000458a:	e9 c4 04 00 	st.b [%a12]4 <70000004 <rpm>>,%d4

    /* Input channel configuration */
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */
8000458e:	6d 00 60 14 	call 80006e4e <IfxScuEru_enableFallingEdgeDetection>
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
80004592:	39 c4 04 00 	ld.bu %d4,[%a12]4
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
80004596:	2c c6       	st.b [%a12]6,%d15
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;
80004598:	2c c5       	st.b [%a12]5,%d15

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
8000459a:	6d 00 93 14 	call 80006ec0 <IfxScuEru_enableTriggerPulse>
    /* Determination of output channel for trigger event (Register INPx) */
    IfxScuEru_connectTrigger(g_ERUconfig.inputChannel, g_ERUconfig.triggerSelect);
8000459e:	39 c4 04 00 	ld.bu %d4,[%a12]4
800045a2:	39 c5 05 00 	ld.bu %d5,[%a12]5
800045a6:	6d 00 c7 13 	call 80006d34 <IfxScuEru_connectTrigger>

    /* Configure Output channels, OutputGating Unit OGU (Register IGPy) */
    IfxScuEru_setInterruptGatingPattern(g_ERUconfig.outputChannel, IfxScuEru_InterruptGatingPattern_alwaysActive);
800045aa:	39 c4 06 00 	ld.bu %d4,[%a12]6
800045ae:	82 15       	mov %d5,1
800045b0:	6d 00 18 15 	call 80006fe0 <IfxScuEru_setInterruptGatingPattern>

    /* Service request configuration */
    /* Get source pointer depending on outputChannel (SRC_SCUERU0 for outputChannel0) */
    g_ERUconfig.src = &MODULE_SRC.SCU.SCU.ERU[(int) g_ERUconfig.outputChannel % 4];
800045b4:	0c c6       	ld.bu %d15,[%a12]6
800045b6:	16 03       	and %d15,3
800045b8:	06 2f       	sh %d15,2
800045ba:	60 f2       	mov.a %a2,%d15
800045bc:	d9 2f d4 38 	lea %a15,[%a2]-29484
800045c0:	11 4f 00 ff 	addih.a %a15,%a15,61444
800045c4:	ec c2       	st.a [%a12]8,%a15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800045c6:	4c f0       	ld.w %d15,[%a15]0
800045c8:	b7 af 08 f0 	insert %d15,%d15,10,0,8
800045cc:	68 0f       	st.w [%a15]0,%d15
    src->B.TOS  = typOfService;
800045ce:	4c f0       	ld.w %d15,[%a15]0
800045d0:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
800045d4:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800045d6:	4c f0       	ld.w %d15,[%a15]0
800045d8:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
800045dc:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800045de:	4c f0       	ld.w %d15,[%a15]0
800045e0:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800045e4:	68 0f       	st.w [%a15]0,%d15
800045e6:	00 90       	ret 

800045e8 <asclin0TxISR>:
    IfxSrc_enable(g_ERUconfig.src);
}

ISR(asclin0TxISR)
{
    IfxAsclin_Asc_isrTransmit(&g_AsclinAsc.drivers.asc);
800045e8:	91 00 00 47 	movh.a %a4,28672
800045ec:	d9 44 a8 e0 	lea %a4,[%a4]2984 <70000ba8 <g_AsclinAsc+0x254>>
800045f0:	1d 00 0a 06 	j 80005204 <IfxAsclin_Asc_isrTransmit>

800045f4 <main>:
}

int main(void)
{
    osEE_tc_stm_set_clockpersec();
800045f4:	6d 00 bb 25 	call 8000916a <osEE_tc_stm_set_clockpersec>
    osEE_tc_stm_set_sr0(1000000U, 1U);
800045f8:	7b f0 00 40 	movh %d4,15
800045fc:	82 15       	mov %d5,1
800045fe:	1b 04 24 44 	addi %d4,%d4,16960
80004602:	6d 00 ce 25 	call 8000919e <osEE_tc_stm_set_sr0>

    UART_init();
80004606:	6d ff 31 fe 	call 80004268 <UART_init>
    initADC();
8000460a:	6d ff 7a ff 	call 800044fe <initADC>
    initPeripheralsAndERU();
8000460e:	6d ff 9c ff 	call 80004546 <initPeripheralsAndERU>
    
    /* custom driver init() added start*/
    lcd_init();
80004612:	6d ff 3c fd 	call 8000408a <lcd_init>
    initUltrasonic();
80004616:	6d 00 e0 20 	call 800087d6 <initUltrasonic>
    /* custom driver added end*/
    

    printfSerial("\n...............\n");
8000461a:	91 00 00 48 	movh.a %a4,32768
8000461e:	d9 44 0c 20 	lea %a4,[%a4]140 <8000008c <_start+0x6c>>
80004622:	6d ff 5c fe 	call 800042da <printfSerial>
    printfSerial("...OS Starts...\n");
80004626:	91 00 00 48 	movh.a %a4,32768
8000462a:	d9 44 1e 20 	lea %a4,[%a4]158 <8000009e <_start+0x7e>>
8000462e:	6d ff 56 fe 	call 800042da <printfSerial>
    printfSerial("...............\n");
80004632:	91 00 00 48 	movh.a %a4,32768
80004636:	d9 44 2f 20 	lea %a4,[%a4]175 <800000af <_start+0x8f>>
8000463a:	6d ff 50 fe 	call 800042da <printfSerial>

    StartOS(OSDEFAULTAPPMODE);
8000463e:	82 04       	mov %d4,0
80004640:	6d 00 1a 27 	call 80009474 <StartOS>
    return 0;
}
80004644:	82 02       	mov %d2,0
80004646:	00 90       	ret 

80004648 <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80004648:	02 4f       	mov %d15,%d4
8000464a:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
8000464c:	6d 00 6d 16 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
80004650:	02 24       	mov %d4,%d2
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004652:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80004654:	6d 00 66 15 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80004658:	8b 0f a2 22 	ge.u %d2,%d15,32
8000465c:	f6 28       	jnz %d2,8000466c <IfxVadc_disableAccess+0x24>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
8000465e:	19 f2 08 20 	ld.w %d2,[%a15]136
80004662:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
80004666:	59 ff 08 20 	st.w [%a15]136,%d15
8000466a:	3c 08       	j 8000467a <IfxVadc_disableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
8000466c:	19 f2 0c 20 	ld.w %d2,[%a15]140
80004670:	16 1f       	and %d15,31
80004672:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
80004676:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
8000467a:	02 84       	mov %d4,%d8
8000467c:	1d 00 d8 16 	j 8000742c <IfxScuWdt_setSafetyEndinit>

80004680 <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80004680:	02 4f       	mov %d15,%d4
80004682:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004684:	6d 00 51 16 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
80004688:	02 24       	mov %d4,%d2
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
8000468a:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
8000468c:	6d 00 4a 15 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80004690:	8b 0f a2 22 	ge.u %d2,%d15,32
80004694:	f6 28       	jnz %d2,800046a4 <IfxVadc_enableAccess+0x24>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
80004696:	19 f2 08 20 	ld.w %d2,[%a15]136
8000469a:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
8000469e:	59 ff 08 20 	st.w [%a15]136,%d15
800046a2:	3c 08       	j 800046b2 <IfxVadc_enableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
800046a4:	19 f2 0c 20 	ld.w %d2,[%a15]140
800046a8:	16 1f       	and %d15,31
800046aa:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
800046ae:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
800046b2:	02 84       	mov %d4,%d8
800046b4:	1d 00 bc 16 	j 8000742c <IfxScuWdt_setSafetyEndinit>

800046b8 <IfxVadc_configExternalMultiplexerMode>:

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
800046b8:	82 0f       	mov %d15,0
800046ba:	b7 1f 81 ff 	insert %d15,%d15,1,31,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
800046be:	39 a3 04 00 	ld.bu %d3,[%sp]4
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
800046c2:	37 4f 02 fd 	insert %d15,%d15,%d4,26,2
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
800046c6:	14 a2       	ld.bu %d2,[%sp]
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
800046c8:	67 3f 1e f0 	ins.t %d15,%d15,30,%d3,0
    emuxctr.B.EMUXCH   = channels;
800046cc:	37 5f 0a f8 	insert %d15,%d15,%d5,16,10
    emuxctr.B.EMUXSET  = startChannel;
800046d0:	37 6f 03 f0 	insert %d15,%d15,%d6,0,3
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800046d4:	3b f0 00 40 	mov %d4,15
    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
800046d8:	67 7f 1c f0 	ins.t %d15,%d15,28,%d7,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
800046dc:	40 5f       	mov.aa %a15,%a5
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
800046de:	67 2f 1d f0 	ins.t %d15,%d15,29,%d2,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
800046e2:	40 4c       	mov.aa %a12,%a4
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800046e4:	6d ff ce ff 	call 80004680 <IfxVadc_enableAccess>
    vadcG->EMUXCTR.U   = emuxctr.U;
800046e8:	59 ff 30 50 	st.w [%a15]368,%d15
    emuxctr.B.EMXWC    = 0;
800046ec:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
    vadcG->EMUXCTR.U   = emuxctr.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800046f0:	40 c4       	mov.aa %a4,%a12
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
    vadcG->EMUXCTR.U   = emuxctr.U;
    emuxctr.B.EMXWC    = 0;
    vadcG->EMUXCTR.U   = emuxctr.U;
800046f2:	59 ff 30 50 	st.w [%a15]368,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800046f6:	3b f0 00 40 	mov %d4,15
800046fa:	1d ff a7 ff 	j 80004648 <IfxVadc_disableAccess>

800046fe <IfxVadc_disablePostCalibration>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_disablePostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group, boolean disable)
{
800046fe:	40 4f       	mov.aa %a15,%a4
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
80004700:	ff 84 1c 80 	jge.u %d4,8,80004738 <IfxVadc_disablePostCalibration+0x3a>
80004704:	02 4f       	mov %d15,%d4
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004706:	3b f0 01 40 	mov %d4,31
8000470a:	02 58       	mov %d8,%d5
8000470c:	6d ff ba ff 	call 80004680 <IfxVadc_enableAccess>

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
80004710:	1b 0f 01 40 	addi %d4,%d15,16

        if (disable == TRUE)
        {
            vadc->GLOBCFG.U |= mask;
80004714:	19 f2 00 20 	ld.w %d2,[%a15]128
{
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
80004718:	82 1f       	mov %d15,1
8000471a:	0f 4f 00 f0 	sh %d15,%d15,%d4

        if (disable == TRUE)
8000471e:	df 18 04 80 	jne %d8,1,80004726 <IfxVadc_disablePostCalibration+0x28>
        {
            vadc->GLOBCFG.U |= mask;
80004722:	a6 2f       	or %d15,%d2
80004724:	3c 03       	j 8000472a <IfxVadc_disablePostCalibration+0x2c>
        }
        else
        {
            vadc->GLOBCFG.U &= ~mask;
80004726:	0f f2 e0 f0 	andn %d15,%d2,%d15
8000472a:	59 ff 00 20 	st.w [%a15]128,%d15
        }

        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000472e:	40 f4       	mov.aa %a4,%a15
80004730:	3b f0 01 40 	mov %d4,31
80004734:	1d ff 8a ff 	j 80004648 <IfxVadc_disableAccess>
80004738:	00 90       	ret 

8000473a <IfxVadc_enableGroupSync>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
8000473a:	40 4f       	mov.aa %a15,%a4
8000473c:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000473e:	6d 00 d6 15 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004742:	02 24       	mov %d4,%d2
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004744:	02 29       	mov %d9,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004746:	6d 00 d2 14 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
8000474a:	40 f4       	mov.aa %a4,%a15
8000474c:	3b f0 01 40 	mov %d4,31
    IfxScuWdt_clearCpuEndinit(passwd);

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
80004750:	19 ff 00 20 	ld.w %d15,[%a15]128
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004754:	6d ff 96 ff 	call 80004680 <IfxVadc_enableAccess>

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
80004758:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
        vadcGlobCfg.B.DCMSB = 1;
8000475c:	b7 1f 81 f3 	insert %d15,%d15,1,7,1

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004760:	40 f4       	mov.aa %a4,%a15
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
80004762:	59 ff 00 20 	st.w [%a15]128,%d15
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004766:	3b f0 01 40 	mov %d4,31
8000476a:	6d ff 6f ff 	call 80004648 <IfxVadc_disableAccess>
    }

    if (ccu6Num == 0)
8000476e:	df 08 1a 80 	jne %d8,0,800047a2 <IfxVadc_enableGroupSync+0x68>
    {
        // CCU60 Config
        CCU60_CLC.U = 0;
80004772:	a5 f8 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d8

        if (CCU60_CLC.U)
80004776:	85 ff 80 82 	ld.w %d15,f0002a00 <_SMALL_DATA4_+0x3fffaa00>
        {}

        CCU60_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
8000477a:	82 4f       	mov %d15,4
8000477c:	a5 ff 94 92 	st.w f0002a54 <_SMALL_DATA4_+0x3fffaa54>,%d15
        CCU60_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
80004780:	a5 ff 9c 92 	st.w f0002a5c <_SMALL_DATA4_+0x3fffaa5c>,%d15
        CCU60_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
80004784:	85 ff 80 a2 	ld.w %d15,f0002a80 <_SMALL_DATA4_+0x3fffaa80>
80004788:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000478c:	a5 ff 80 a2 	st.w f0002a80 <_SMALL_DATA4_+0x3fffaa80>,%d15
        CCU60_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
80004790:	3b 00 20 f4 	mov %d15,16896
80004794:	a5 ff b8 92 	st.w f0002a78 <_SMALL_DATA4_+0x3fffaa78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 0;                                                                  // CCU60_COUT63 routed to output signal CCU6061 TRIG1
80004798:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
8000479c:	8f 8f c3 f1 	andn %d15,%d15,56
800047a0:	3c 1d       	j 800047da <IfxVadc_enableGroupSync+0xa0>
    }
    else if (ccu6Num == 1)
800047a2:	df 18 1e 80 	jne %d8,1,800047de <IfxVadc_enableGroupSync+0xa4>
    {
        // CCU60 + CCU61 Config
        CCU60_CLC.U = 0;
800047a6:	82 0f       	mov %d15,0
800047a8:	a5 ff 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d15
        CCU61_CLC.U = 0;
800047ac:	a5 ff 80 c2 	st.w f0002b00 <_SMALL_DATA4_+0x3fffab00>,%d15

        if (CCU61_CLC.U)
800047b0:	85 ff 80 c2 	ld.w %d15,f0002b00 <_SMALL_DATA4_+0x3fffab00>
        {}

        CCU61_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
800047b4:	82 4f       	mov %d15,4
800047b6:	a5 ff 94 d2 	st.w f0002b54 <_SMALL_DATA4_+0x3fffab54>,%d15
        CCU61_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
800047ba:	a5 ff 9c d2 	st.w f0002b5c <_SMALL_DATA4_+0x3fffab5c>,%d15
        CCU61_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
800047be:	85 ff 80 e2 	ld.w %d15,f0002b80 <_SMALL_DATA4_+0x3fffab80>
800047c2:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
800047c6:	a5 ff 80 e2 	st.w f0002b80 <_SMALL_DATA4_+0x3fffab80>,%d15
        CCU61_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
800047ca:	3b 00 20 f4 	mov %d15,16896
800047ce:	a5 ff b8 d2 	st.w f0002b78 <_SMALL_DATA4_+0x3fffab78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 1;                                                                  // CCU61_COUT63 routed to output signal CCU6061 TRIG1
800047d2:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
800047d6:	b7 1f 83 f1 	insert %d15,%d15,1,3,3
800047da:	a5 ff 8c 82 	st.w f0002a0c <_SMALL_DATA4_+0x3fffaa0c>,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
800047de:	02 94       	mov %d4,%d9
800047e0:	1d 00 ba 15 	j 80007354 <IfxScuWdt_setCpuEndinit>

800047e4 <IfxVadc_getAdcAnalogFrequency>:
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
800047e4:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
800047e6:	6d 00 be 0c 	call 80006162 <IfxScuCcu_getSpbFrequency>
800047ea:	19 ff 00 20 	ld.w %d15,[%a15]128
800047ee:	16 1f       	and %d15,31
800047f0:	c2 1f       	add %d15,1
800047f2:	4b 0f 41 f1 	itof %d15,%d15
}
800047f6:	4b f2 51 20 	div.f %d2,%d2,%d15
800047fa:	00 90       	ret 

800047fc <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
800047fc:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
800047fe:	6d 00 b2 0c 	call 80006162 <IfxScuCcu_getSpbFrequency>
80004802:	19 ff 00 20 	ld.w %d15,[%a15]128
80004806:	37 0f 62 f4 	extr.u %d15,%d15,8,2
8000480a:	c2 1f       	add %d15,1
8000480c:	4b 0f 41 f1 	itof %d15,%d15
}
80004810:	4b f2 51 20 	div.f %d2,%d2,%d15
80004814:	00 90       	ret 

80004816 <IfxVadc_getAdcModuleFrequency>:


float32 IfxVadc_getAdcModuleFrequency(void)
{
    return IfxScuCcu_getSpbFrequency();
80004816:	1d 00 a6 0c 	j 80006162 <IfxScuCcu_getSpbFrequency>

8000481a <IfxVadc_getBackgroundScanStatus>:
}


IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
8000481a:	82 0f       	mov %d15,0
8000481c:	a0 7f       	mov.a %a15,7
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
    {
        if (vadc->BRSPND[i].U)
8000481e:	1b 0f 07 20 	addi %d2,%d15,112
80004822:	01 42 02 26 	addsc.a %a2,%a4,%d2,2
80004826:	54 22       	ld.w %d2,[%a2]
80004828:	f6 24       	jnz %d2,80004830 <IfxVadc_getBackgroundScanStatus+0x16>
8000482a:	c2 1f       	add %d15,1
IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
8000482c:	fc f9       	loop %a15,8000481e <IfxVadc_getBackgroundScanStatus+0x4>
8000482e:	00 90       	ret 
    {
        if (vadc->BRSPND[i].U)
        {
            return IfxVadc_Status_channelsStillPending;
80004830:	82 62       	mov %d2,6
            continue;
        }
    }

    return status;
}
80004832:	00 90       	ret 

80004834 <IfxVadc_getQueueStatus>:
IfxVadc_Status IfxVadc_getQueueStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    /* just fill level is checked */
    if (0x7 == group->QSR0.B.FILL)
80004834:	19 42 08 20 	ld.w %d2,[%a4]136
80004838:	8f f2 00 21 	and %d2,%d2,15
    {
        status = IfxVadc_Status_queueFull;
    }
    else
    {
        status = IfxVadc_Status_noError;
8000483c:	8b 72 00 22 	eq %d2,%d2,7
    }

    return status;
}
80004840:	06 22       	sh %d2,2
80004842:	00 90       	ret 

80004844 <IfxVadc_getResultBasedOnRequestSource>:
Ifx_VADC_RES IfxVadc_getResultBasedOnRequestSource(Ifx_VADC *vadc, Ifx_VADC_G *group, IfxVadc_ChannelId channel, IfxVadc_RequestSource sourceType)
{
    sint32       sourceResultRegister = -1;
    Ifx_VADC_RES tmpResult;

    switch (sourceType)
80004844:	df 15 09 00 	jeq %d5,1,80004856 <IfxVadc_getResultBasedOnRequestSource+0x12>
80004848:	76 54       	jz %d5,80004850 <IfxVadc_getResultBasedOnRequestSource+0xc>
8000484a:	df 25 0b 00 	jeq %d5,2,80004860 <IfxVadc_getResultBasedOnRequestSource+0x1c>
8000484e:	3c 39       	j 800048c0 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    {
    case IfxVadc_RequestSource_queue:
        sourceResultRegister = group->QCTRL0.B.SRCRESREG;
80004850:	19 5f 00 20 	ld.w %d15,[%a5]128
80004854:	3c 03       	j 8000485a <IfxVadc_getResultBasedOnRequestSource+0x16>
        break;

    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
80004856:	19 5f 20 20 	ld.w %d15,[%a5]160
8000485a:	16 0f       	and %d15,15
    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
        break;
    }

    if (sourceResultRegister > 0)
8000485c:	ee 39       	jnz %d15,800048ce <IfxVadc_getResultBasedOnRequestSource+0x8a>
8000485e:	3c 31       	j 800048c0 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
        break;

    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
80004860:	19 4f 00 80 	ld.w %d15,[%a4]512
80004864:	16 0f       	and %d15,15
        break;
    }

    if (sourceResultRegister > 0)
80004866:	ee 34       	jnz %d15,800048ce <IfxVadc_getResultBasedOnRequestSource+0x8a>

        return tmpResult;
    }
    else
    {
        if ((sourceType == IfxVadc_RequestSource_background) && (group->CHCTR[channel].B.RESTBS == 1))
80004868:	1b 04 06 f0 	addi %d15,%d4,96
8000486c:	90 5f       	addsc.a %a15,%a5,%d15,2
8000486e:	4c f0       	ld.w %d15,[%a15]0
80004870:	ef 4f 28 00 	jz.t %d15,20,800048c0 <IfxVadc_getResultBasedOnRequestSource+0x7c>
        {
            tmpResult.B.VF     = vadc->GLOBRES.B.VF;
80004874:	19 42 00 c0 	ld.w %d2,[%a4]768
80004878:	82 0f       	mov %d15,0
8000487a:	67 2f 9f ff 	ins.t %d15,%d15,31,%d2,31
            tmpResult.B.FCR    = vadc->GLOBRES.B.FCR;
8000487e:	19 42 00 c0 	ld.w %d2,[%a4]768
80004882:	67 2f 1e ff 	ins.t %d15,%d15,30,%d2,30
            tmpResult.B.CRS    = vadc->GLOBRES.B.CRS;
80004886:	19 42 00 c0 	ld.w %d2,[%a4]768
8000488a:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000488e:	37 2f 02 fe 	insert %d15,%d15,%d2,28,2
            tmpResult.B.EMUX   = vadc->GLOBRES.B.EMUX;
80004892:	19 42 00 c0 	ld.w %d2,[%a4]768
80004896:	37 02 e3 2c 	extr.u %d2,%d2,25,3
8000489a:	37 2f 83 fc 	insert %d15,%d15,%d2,25,3
            tmpResult.B.CHNR   = vadc->GLOBRES.B.CHNR;
8000489e:	19 42 00 c0 	ld.w %d2,[%a4]768
800048a2:	37 02 65 2a 	extr.u %d2,%d2,20,5
800048a6:	37 2f 05 fa 	insert %d15,%d15,%d2,20,5
            tmpResult.B.DRC    = vadc->GLOBRES.B.GNR; //The bitfields are the same but interpretation is different. TODO- define a generic result register type.
800048aa:	19 42 00 c0 	ld.w %d2,[%a4]768
800048ae:	37 02 64 28 	extr.u %d2,%d2,16,4
800048b2:	37 2f 04 f8 	insert %d15,%d15,%d2,16,4
            tmpResult.B.RESULT = vadc->GLOBRES.B.RESULT;
800048b6:	19 42 00 c0 	ld.w %d2,[%a4]768
800048ba:	37 2f 10 20 	insert %d2,%d15,%d2,0,16

            return tmpResult;
800048be:	00 90       	ret 
        }
        else
        {
            tmpResult.U = group->RES[group->CHCTR[channel].B.RESREG].U;
800048c0:	1b 04 06 40 	addi %d4,%d4,96
800048c4:	01 54 02 f6 	addsc.a %a15,%a5,%d4,2
800048c8:	4c f0       	ld.w %d15,[%a15]0
800048ca:	37 0f 64 f8 	extr.u %d15,%d15,16,4
800048ce:	1b 0f 0a f0 	addi %d15,%d15,160
800048d2:	90 55       	addsc.a %a5,%a5,%d15,2
800048d4:	54 52       	ld.w %d2,[%a5]

            return tmpResult;
800048d6:	00 90       	ret 

800048d8 <IfxVadc_getScanStatus>:

IfxVadc_Status IfxVadc_getScanStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    if (group->ASPND.U)
800048d8:	19 42 2c 20 	ld.w %d2,[%a4]172
    }
    else
    {
        return status;
    }
}
800048dc:	ab 62 a0 22 	seln %d2,%d2,%d2,6
800048e0:	00 90       	ret 

800048e2 <IfxVadc_getSrcAddress>:

volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
800048e2:	bf 45 0a 80 	jlt.u %d5,4,800048f6 <IfxVadc_getSrcAddress+0x14>
    {
        index -= 4;
800048e6:	9a c5       	add %d15,%d5,-4
800048e8:	8f ff 0f 51 	and %d5,%d15,255

        if ((group & 0x1) != 0)
800048ec:	8f 14 00 41 	and %d4,%d4,1
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
800048f0:	da 08       	mov %d15,8
800048f2:	ab 9f a0 44 	seln %d4,%d4,%d15,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
800048f6:	13 44 20 45 	madd %d4,%d5,%d4,4
800048fa:	91 00 00 f8 	movh.a %a15,32768
800048fe:	d9 ff 10 70 	lea %a15,[%a15]464 <800001d0 <IfxVadc_cfg_srcAddresses>>
80004902:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2

    return &(base[0]);
}
80004906:	c8 02       	ld.a %a2,[%a15]0
80004908:	00 90       	ret 

8000490a <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
8000490a:	19 4f 00 20 	ld.w %d15,[%a4]128
    return &(base[0]);
}


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
8000490e:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
80004910:	37 4f 02 f4 	insert %d15,%d15,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004914:	3b f0 01 40 	mov %d4,31
80004918:	6d ff b4 fe 	call 80004680 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
8000491c:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004920:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004922:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004926:	3b f0 01 40 	mov %d4,31
8000492a:	1d ff 8f fe 	j 80004648 <IfxVadc_disableAccess>

8000492e <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
8000492e:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
}


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
80004932:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
80004934:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004938:	3b f0 01 40 	mov %d4,31
8000493c:	6d ff a2 fe 	call 80004680 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
80004940:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004944:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004946:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000494a:	3b f0 01 40 	mov %d4,31
8000494e:	1d ff 7d fe 	j 80004648 <IfxVadc_disableAccess>

80004952 <IfxVadc_initializeFAdcD>:
}


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
80004952:	02 4f       	mov %d15,%d4
80004954:	40 4f       	mov.aa %a15,%a4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80004956:	6d 00 06 0c 	call 80006162 <IfxScuCcu_getSpbFrequency>
8000495a:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
8000495e:	4b f2 11 42 	div.u %e4,%d2,%d15
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004962:	82 3f       	mov %d15,3
80004964:	c2 f4       	add %d4,-1
80004966:	0b f4 90 41 	min.u %d4,%d4,%d15

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
8000496a:	1b 14 00 80 	addi %d8,%d4,1
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
8000496e:	40 f4       	mov.aa %a4,%a15

    divD   = (fadc / fAdcD - 1);

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80004970:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80004974:	6d ff cb ff 	call 8000490a <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
80004978:	02 82       	mov %d2,%d8
8000497a:	00 90       	ret 

8000497c <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
8000497c:	02 4f       	mov %d15,%d4
8000497e:	40 4f       	mov.aa %a15,%a4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80004980:	6d 00 f1 0b 	call 80006162 <IfxScuCcu_getSpbFrequency>
80004984:	4b 02 71 21 	ftouz %d2,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
80004988:	8f 22 00 40 	sh %d4,%d2,2
8000498c:	4b f4 11 42 	div.u %e4,%d4,%d15
80004990:	3b f0 01 50 	mov %d5,31

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
80004994:	c2 24       	add %d4,2
80004996:	06 e4       	sh %d4,-2
    divA   = __minu(divA - 1, 0x1Fu);
80004998:	c2 f4       	add %d4,-1
8000499a:	0b 54 90 41 	min.u %d4,%d4,%d5
    result = fadc / (divA + 1);
8000499e:	1b 14 00 30 	addi %d3,%d4,1
800049a2:	4b 32 11 62 	div.u %e6,%d2,%d3
800049a6:	02 6f       	mov %d15,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
800049a8:	7b 10 13 60 	movh %d6,305
800049ac:	1b 16 d0 62 	addi %d6,%d6,11521
800049b0:	3f 6f 08 80 	jlt.u %d15,%d6,800049c0 <IfxVadc_initializeFAdcI+0x44>
800049b4:	0b 53 90 41 	min.u %d4,%d3,%d5
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
800049b8:	9a 14       	add %d15,%d4,1
800049ba:	4b f2 11 22 	div.u %e2,%d2,%d15
800049be:	02 2f       	mov %d15,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
800049c0:	1b 0f ee 25 	addi %d2,%d15,24288
800049c4:	7b a0 12 30 	movh %d3,298
800049c8:	9b 82 ff 2f 	addih %d2,%d2,65528
800049cc:	1b 13 be 38 	addi %d3,%d3,-29727
800049d0:	7f 32 06 80 	jge.u %d2,%d3,800049dc <IfxVadc_initializeFAdcI+0x60>
    {
        result = 0;             /* Min / Max FAdcI frequency */
    }
    else
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
800049d4:	40 f4       	mov.aa %a4,%a15
800049d6:	6d ff ac ff 	call 8000492e <IfxVadc_initialiseAdcConverterClock>
800049da:	3c 02       	j 800049de <IfxVadc_initializeFAdcI+0x62>
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
    {
        result = 0;             /* Min / Max FAdcI frequency */
800049dc:	82 0f       	mov %d15,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
800049de:	02 f2       	mov %d2,%d15
800049e0:	00 90       	ret 

800049e2 <IfxVadc_isPostCalibration>:
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
        break;
    default: pcEnabled                = FALSE;
800049e2:	82 02       	mov %d2,0

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
800049e4:	ff 84 33 80 	jge.u %d4,8,80004a4a <IfxVadc_isPostCalibration+0x68>
800049e8:	91 00 00 f8 	movh.a %a15,32768
800049ec:	d9 ff bc 74 	lea %a15,[%a15]18940 <800049fc <IfxVadc_isPostCalibration+0x1a>>
800049f0:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
        break;
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
800049f4:	19 42 00 20 	ld.w %d2,[%a4]128

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
800049f8:	dc 0f       	ji %a15
800049fa:	00 00       	nop 
800049fc:	1d 00 10 00 	j 80004a1c <IfxVadc_isPostCalibration+0x3a>
80004a00:	1d 00 11 00 	j 80004a22 <IfxVadc_isPostCalibration+0x40>
80004a04:	1d 00 12 00 	j 80004a28 <IfxVadc_isPostCalibration+0x46>
80004a08:	1d 00 13 00 	j 80004a2e <IfxVadc_isPostCalibration+0x4c>
80004a0c:	1d 00 14 00 	j 80004a34 <IfxVadc_isPostCalibration+0x52>
80004a10:	1d 00 15 00 	j 80004a3a <IfxVadc_isPostCalibration+0x58>
80004a14:	1d 00 16 00 	j 80004a40 <IfxVadc_isPostCalibration+0x5e>
80004a18:	1d 00 17 00 	j 80004a46 <IfxVadc_isPostCalibration+0x64>
    {
    case IfxVadc_GroupId_0: pcEnabled = vadc->GLOBCFG.B.DPCAL0 == 0;
80004a1c:	07 22 10 28 	nand.t %d2,%d2,16,%d2,16
        break;
80004a20:	00 90       	ret 
    case IfxVadc_GroupId_1: pcEnabled = vadc->GLOBCFG.B.DPCAL1 == 0;
80004a22:	07 22 91 28 	nand.t %d2,%d2,17,%d2,17
        break;
80004a26:	00 90       	ret 
    case IfxVadc_GroupId_2: pcEnabled = vadc->GLOBCFG.B.DPCAL2 == 0;
80004a28:	07 22 12 29 	nand.t %d2,%d2,18,%d2,18
        break;
80004a2c:	00 90       	ret 
    case IfxVadc_GroupId_3: pcEnabled = vadc->GLOBCFG.B.DPCAL3 == 0;
80004a2e:	07 22 93 29 	nand.t %d2,%d2,19,%d2,19
        break;
80004a32:	00 90       	ret 
    case IfxVadc_GroupId_4: pcEnabled = vadc->GLOBCFG.B.DPCAL4 == 0;
80004a34:	07 22 14 2a 	nand.t %d2,%d2,20,%d2,20
        break;
80004a38:	00 90       	ret 
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
80004a3a:	07 22 95 2a 	nand.t %d2,%d2,21,%d2,21
        break;
80004a3e:	00 90       	ret 
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
80004a40:	07 22 16 2b 	nand.t %d2,%d2,22,%d2,22
        break;
80004a44:	00 90       	ret 
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
80004a46:	07 22 97 2b 	nand.t %d2,%d2,23,%d2,23
    default: pcEnabled                = FALSE;
        break;
    }

    return pcEnabled;
}
80004a4a:	00 90       	ret 

80004a4c <IfxVadc_getChannelConversionTime>:
    return status;
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
80004a4c:	02 40       	mov %d0,%d4
80004a4e:	02 68       	mov %d8,%d6
80004a50:	02 7a       	mov %d10,%d7
80004a52:	14 a4       	ld.bu %d4,[%sp]
    IfxVadc_ChannelResolution resolution;
    uint32                    n;

    uint32                    inputClassNum;

    if (inputClass <= IfxVadc_InputClasses_group1)
80004a54:	ff 25 08 80 	jge.u %d5,2,80004a64 <IfxVadc_getChannelConversionTime+0x18>
    {
        inputClassNum = inputClass;
        stcs          = vadcG->ICLASS[inputClassNum].B.STCS;
80004a58:	8f 80 00 f0 	sh %d15,%d0,8
80004a5c:	42 f5       	add %d5,%d15
80004a5e:	1b 85 12 50 	addi %d5,%d5,296
80004a62:	3c 03       	j 80004a68 <IfxVadc_getChannelConversionTime+0x1c>
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004a64:	1b 65 02 50 	addi %d5,%d5,38
80004a68:	01 45 02 f6 	addsc.a %a15,%a4,%d5,2
80004a6c:	4c f0       	ld.w %d15,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004a6e:	48 03       	ld.w %d3,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004a70:	16 1f       	and %d15,31
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
    }

    if (stcs > 16)
80004a72:	8b 1f 61 22 	lt.u %d2,%d15,17
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004a76:	37 03 63 34 	extr.u %d3,%d3,8,3
    }

    if (stcs > 16)
80004a7a:	f6 24       	jnz %d2,80004a82 <IfxVadc_getChannelConversionTime+0x36>
    {
        stcs = (stcs - 15) * 16; // Reference for the logic: Table 28-4 of TC29xB User Manual v1.3
80004a7c:	1b 1f ff ff 	addi %d15,%d15,-15
80004a80:	06 4f       	sh %d15,4
80004a82:	ff 63 35 80 	jge.u %d3,6,80004aec <IfxVadc_getChannelConversionTime+0xa0>
80004a86:	91 00 00 f8 	movh.a %a15,32768
80004a8a:	d9 ff 08 70 	lea %a15,[%a15]456 <800001c8 <CSWTCH.25>>
80004a8e:	01 f3 00 f6 	addsc.a %a15,%a15,%d3,0
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004a92:	82 02       	mov %d2,0
80004a94:	08 09       	ld.bu %d9,[%a15]0
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004a96:	df 04 2f 80 	jne %d4,0,80004af4 <IfxVadc_getChannelConversionTime+0xa8>
    {
        if (resolution != IfxVadc_ChannelResolution_10bitFast)
80004a9a:	df 53 0d 00 	jeq %d3,5,80004ab4 <IfxVadc_getChannelConversionTime+0x68>
        {
            /* Standard conversion */
            uint32 pc = IfxVadc_isPostCalibration(vadc, group) ? 2 : 0;
80004a9e:	02 04       	mov %d4,%d0
80004aa0:	6d ff a1 ff 	call 800049e2 <IfxVadc_isPostCalibration>
80004aa4:	92 24       	add %d4,%d15,2
80004aa6:	ab 22 a0 22 	seln %d2,%d2,%d2,2
80004aaa:	42 94       	add %d4,%d9
            conversionTime = (float32)(2 + stcs + n + pc) / analogFrequency + 2.0 / moduleFrequency;
80004aac:	42 24       	add %d4,%d2
80004aae:	4b 04 41 41 	itof %d4,%d4
80004ab2:	3c 04       	j 80004aba <IfxVadc_getChannelConversionTime+0x6e>
        }
        else
        {
            /* Fast compare mode */
            conversionTime = (float32)(2 + stcs + 2) / analogFrequency + 2.0 / moduleFrequency;
80004ab4:	c2 4f       	add %d15,4
80004ab6:	4b 0f 41 41 	itof %d4,%d15
80004aba:	4b 84 51 40 	div.f %d4,%d4,%d8
80004abe:	6d 00 e3 2b 	call 8000a284 <__extendsfdf2>
80004ac2:	02 a4       	mov %d4,%d10
80004ac4:	0b 23 10 88 	mov %e8,%d3,%d2
80004ac8:	6d 00 de 2b 	call 8000a284 <__extendsfdf2>
80004acc:	b7 00 21 4f 	imask %e4,0,30,1
80004ad0:	0b 23 10 68 	mov %e6,%d3,%d2
80004ad4:	6d 00 cd 2d 	call 8000a66e <__divdf3>
80004ad8:	0b 89 10 48 	mov %e4,%d9,%d8
80004adc:	0b 23 10 68 	mov %e6,%d3,%d2
80004ae0:	6d 00 b9 2c 	call 8000a452 <__adddf3>
80004ae4:	0b 23 10 48 	mov %e4,%d3,%d2
80004ae8:	1d 00 82 2e 	j 8000a7ec <__truncdfsf2>
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004aec:	82 09       	mov %d9,0
80004aee:	df 04 d8 7f 	jeq %d4,0,80004a9e <IfxVadc_getChannelConversionTime+0x52>
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004af2:	82 02       	mov %d2,0
    {
        // do nothing
    }

    return conversionTime;
}
80004af4:	00 90       	ret 

80004af6 <IfxVadc_resetKernel>:
    return pcEnabled;
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
80004af6:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004af8:	6d 00 f9 13 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80004afc:	02 24       	mov %d4,%d2
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004afe:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80004b00:	6d 00 f5 12 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b04:	3b f0 01 40 	mov %d4,31
80004b08:	40 f4       	mov.aa %a4,%a15
80004b0a:	6d ff bb fd 	call 80004680 <IfxVadc_enableAccess>
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
80004b0e:	48 c2       	ld.w %d2,[%a15]48
    vadc->KRST0.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004b10:	02 f4       	mov %d4,%d15
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
80004b12:	8f 12 40 21 	or %d2,%d2,1
80004b16:	68 c2       	st.w [%a15]48,%d2
    vadc->KRST0.B.RST = 1;
80004b18:	48 d2       	ld.w %d2,[%a15]52
80004b1a:	8f 12 40 21 	or %d2,%d2,1
80004b1e:	68 d2       	st.w [%a15]52,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004b20:	6d 00 1a 14 	call 80007354 <IfxScuWdt_setCpuEndinit>

    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */
80004b24:	48 d2       	ld.w %d2,[%a15]52
80004b26:	6f 12 ff 7f 	jz.t %d2,1,80004b24 <IfxVadc_resetKernel+0x2e>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004b2a:	02 f4       	mov %d4,%d15
80004b2c:	6d 00 df 12 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
80004b30:	48 b2       	ld.w %d2,[%a15]44
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b32:	3b f0 01 40 	mov %d4,31
    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
80004b36:	8f 12 40 21 	or %d2,%d2,1
80004b3a:	68 b2       	st.w [%a15]44,%d2
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b3c:	40 f4       	mov.aa %a4,%a15
80004b3e:	6d ff 85 fd 	call 80004648 <IfxVadc_disableAccess>
    IfxScuWdt_setCpuEndinit(passwd);
80004b42:	02 f4       	mov %d4,%d15
80004b44:	1d 00 08 14 	j 80007354 <IfxScuWdt_setCpuEndinit>

80004b48 <IfxVadc_selectPowerSupplyVoltage>:


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80004b48:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
80004b4c:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80004b4e:	67 4f 0e f0 	ins.t %d15,%d15,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b52:	3b f0 01 40 	mov %d4,31
80004b56:	6d ff 95 fd 	call 80004680 <IfxVadc_enableAccess>
void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
80004b5a:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b5e:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004b60:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004b64:	3b f0 01 40 	mov %d4,31
80004b68:	1d ff 70 fd 	j 80004648 <IfxVadc_disableAccess>

80004b6c <IfxVadc_setArbiterPriority>:
}


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80004b6c:	1b 87 01 f0 	addi %d15,%d7,24
    if (slotEnable != FALSE)
80004b70:	df 04 23 00 	jeq %d4,0,80004bb6 <IfxVadc_setArbiterPriority+0x4a>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80004b74:	19 42 04 00 	ld.w %d2,[%a4]4
80004b78:	0f f4 00 40 	sh %d4,%d4,%d15
80004b7c:	a6 24       	or %d4,%d2
80004b7e:	59 44 04 00 	st.w [%a4]4,%d4
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80004b82:	19 42 04 00 	ld.w %d2,[%a4]4
80004b86:	06 27       	sh %d7,2
80004b88:	82 3f       	mov %d15,3
80004b8a:	0f 7f 00 f0 	sh %d15,%d15,%d7
80004b8e:	0f f2 e0 f0 	andn %d15,%d2,%d15
80004b92:	6c 41       	st.w [%a4]4,%d15
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80004b94:	4c 41       	ld.w %d15,[%a4]4
80004b96:	0f 75 00 50 	sh %d5,%d5,%d7
80004b9a:	a6 f5       	or %d5,%d15
80004b9c:	59 45 04 00 	st.w [%a4]4,%d5

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004ba0:	4c 41       	ld.w %d15,[%a4]4
80004ba2:	c2 37       	add %d7,3
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80004ba4:	76 64       	jz %d6,80004bac <IfxVadc_setArbiterPriority+0x40>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004ba6:	d7 1f 01 77 	insert %d7,%d15,1,%d7,1
80004baa:	3c 03       	j 80004bb0 <IfxVadc_setArbiterPriority+0x44>
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80004bac:	d7 0f 01 77 	insert %d7,%d15,0,%d7,1
80004bb0:	59 47 04 00 	st.w [%a4]4,%d7
80004bb4:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80004bb6:	19 44 04 00 	ld.w %d4,[%a4]4
80004bba:	d7 04 01 ff 	insert %d15,%d4,0,%d15,1
80004bbe:	6c 41       	st.w [%a4]4,%d15
80004bc0:	00 90       	ret 

80004bc2 <IfxVadc_setScan>:

void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80004bc2:	19 4f 28 20 	ld.w %d15,[%a4]168
80004bc6:	26 54       	and %d4,%d5
80004bc8:	0f 5f e0 f0 	andn %d15,%d15,%d5
80004bcc:	0f 4f a0 50 	or %d5,%d15,%d4
80004bd0:	59 45 28 20 	st.w [%a4]168,%d5
80004bd4:	00 90       	ret 

80004bd6 <IfxVadc_startupCalibration>:
{
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bd6:	3b f0 01 40 	mov %d4,31
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004bda:	40 4f       	mov.aa %a15,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004bdc:	6d ff 52 fd 	call 80004680 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80004be0:	19 ff 00 20 	ld.w %d15,[%a15]128
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004be4:	40 f4       	mov.aa %a4,%a15
80004be6:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80004bea:	3b f0 01 40 	mov %d4,31
80004bee:	59 ff 00 20 	st.w [%a15]128,%d15
80004bf2:	6d ff 2b fd 	call 80004648 <IfxVadc_disableAccess>
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004bf6:	82 02       	mov %d2,0

    /* Wait for hardware self-test and calibration to complete */
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;
80004bf8:	82 0f       	mov %d15,0
80004bfa:	a0 72       	mov.a %a2,7


IFX_INLINE uint8 IfxVadc_getAdcCalibrationActiveState(Ifx_VADC *vadc, uint8 adcCalGroupNum)
{
    uint8 status;
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80004bfc:	8f a2 00 30 	sh %d3,%d2,10
80004c00:	01 f3 00 36 	addsc.a %a3,%a15,%d3,0
80004c04:	c2 12       	add %d2,1
80004c06:	19 33 40 20 	ld.w %d3,[%a3]1152
80004c0a:	37 03 61 3e 	extr.u %d3,%d3,28,1

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
            {
                calibrationRunning = TRUE;
80004c0e:	ab 1f a0 f3 	seln %d15,%d3,%d15,1
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80004c12:	fc 25       	loop %a2,80004bfc <IfxVadc_startupCalibration+0x26>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80004c14:	df 1f f1 7f 	jeq %d15,1,80004bf6 <IfxVadc_startupCalibration+0x20>
}
80004c18:	00 90       	ret 
	...

80004c1c <IfxAsclin_disableModule>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
80004c1c:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c1e:	6d 00 66 13 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004c22:	02 24       	mov %d4,%d2
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c24:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004c26:	6d 00 62 12 	call 800070ea <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80004c2a:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclin); /* disables the module*/
    IfxScuWdt_setCpuEndinit(psw);              /* sets the endinit protection back on*/
80004c2c:	02 f4       	mov %d4,%d15
80004c2e:	8f 12 40 21 	or %d2,%d2,1
80004c32:	68 02       	st.w [%a15]0,%d2
80004c34:	1d 00 90 13 	j 80007354 <IfxScuWdt_setCpuEndinit>

80004c38 <IfxAsclin_enableAscErrorFlags>:
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80004c38:	7b 10 00 f0 	movh %d15,1
80004c3c:	ab 0f 80 44 	sel %d4,%d4,%d15,0
80004c40:	19 4f 00 10 	ld.w %d15,[%a4]64
80004c44:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80004c48:	a6 f4       	or %d4,%d15
80004c4a:	59 44 00 10 	st.w [%a4]64,%d4
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80004c4e:	7b 00 40 f0 	movh %d15,1024
80004c52:	ab 0f 80 55 	sel %d5,%d5,%d15,0
80004c56:	19 4f 00 10 	ld.w %d15,[%a4]64
80004c5a:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80004c5e:	a6 f5       	or %d5,%d15
80004c60:	59 45 00 10 	st.w [%a4]64,%d5
80004c64:	00 90       	ret 

80004c66 <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
80004c66:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c68:	6d 00 41 13 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004c6c:	02 24       	mov %d4,%d2
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c6e:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004c70:	6d 00 3d 12 	call 800070ea <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
80004c74:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
80004c76:	02 f4       	mov %d4,%d15
80004c78:	8f 12 c0 21 	andn %d2,%d2,1
80004c7c:	68 02       	st.w [%a15]0,%d2
80004c7e:	1d 00 6b 13 	j 80007354 <IfxScuWdt_setCpuEndinit>

80004c82 <IfxAsclin_getAddress>:
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
    }
    else
    {
        module = NULL_PTR;
80004c82:	a0 02       	mov.a %a2,0

Ifx_ASCLIN *IfxAsclin_getAddress(IfxAsclin_Index asclin)
{
    Ifx_ASCLIN *module;

    if (asclin < IFXASCLIN_NUM_MODULES)
80004c84:	ff 44 09 00 	jge %d4,4,80004c96 <IfxAsclin_getAddress+0x14>
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
80004c88:	91 00 00 f8 	movh.a %a15,32768
80004c8c:	d9 ff a0 40 	lea %a15,[%a15]2336 <80000920 <IfxAsclin_cfg_indexMap>>
80004c90:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80004c94:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
80004c96:	00 90       	ret 

80004c98 <IfxAsclin_getFaFrequency>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004c98:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004c9c:	16 1f       	and %d15,31
float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
80004c9e:	c2 ff       	add %d15,-1
80004ca0:	8b 0f a1 22 	ge.u %d2,%d15,16
80004ca4:	df 02 32 80 	jne %d2,0,80004d08 <IfxAsclin_getFaFrequency+0x70>
80004ca8:	91 00 00 f8 	movh.a %a15,32768
80004cac:	d9 ff f4 24 	lea %a15,[%a15]19636 <80004cb4 <IfxAsclin_getFaFrequency+0x1c>>
80004cb0:	90 ff       	addsc.a %a15,%a15,%d15,2
80004cb2:	dc 0f       	ji %a15
80004cb4:	1d 00 20 00 	j 80004cf4 <IfxAsclin_getFaFrequency+0x5c>
80004cb8:	1d 00 20 00 	j 80004cf8 <IfxAsclin_getFaFrequency+0x60>
80004cbc:	1d 00 26 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cc0:	1d 00 1e 00 	j 80004cfc <IfxAsclin_getFaFrequency+0x64>
80004cc4:	1d 00 22 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cc8:	1d 00 20 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004ccc:	1d 00 1e 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cd0:	1d 00 18 00 	j 80004d00 <IfxAsclin_getFaFrequency+0x68>
80004cd4:	1d 00 1a 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cd8:	1d 00 18 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cdc:	1d 00 16 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004ce0:	1d 00 14 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004ce4:	1d 00 12 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004ce8:	1d 00 10 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cec:	1d 00 0e 00 	j 80004d08 <IfxAsclin_getFaFrequency+0x70>
80004cf0:	1d 00 0a 00 	j 80004d04 <IfxAsclin_getFaFrequency+0x6c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80004cf4:	1d 00 37 0a 	j 80006162 <IfxScuCcu_getSpbFrequency>
        break;
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
80004cf8:	1d 00 a6 08 	j 80005e44 <IfxScuCcu_getOsc0Frequency>
        break;
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80004cfc:	1d 00 c3 08 	j 80005e82 <IfxScuCcu_getPllErayFrequency>
        break;
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
80004d00:	1d 00 20 0a 	j 80006140 <IfxScuCcu_getBaud2Frequency>
        break;
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80004d04:	1d 00 0e 0a 	j 80006120 <IfxScuCcu_getBaud1Frequency>
        frequency = 0.0;
        break;
    }

    return frequency;
}
80004d08:	82 02       	mov %d2,0
80004d0a:	00 90       	ret 

80004d0c <IfxAsclin_getIndex>:

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004d0c:	91 00 00 38 	movh.a %a3,32768
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004d10:	82 0f       	mov %d15,0
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004d12:	d9 33 a0 40 	lea %a3,[%a3]2336 <80000920 <IfxAsclin_cfg_indexMap>>
80004d16:	a0 3f       	mov.a %a15,3
80004d18:	d0 32       	addsc.a %a2,%a3,%d15,3
80004d1a:	d4 25       	ld.a %a5,[%a2]
80004d1c:	7d 45 05 80 	jne.a %a5,%a4,80004d26 <IfxAsclin_getIndex+0x1a>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80004d20:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80004d24:	00 90       	ret 
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004d26:	c2 1f       	add %d15,1
80004d28:	fc f8       	loop %a15,80004d18 <IfxAsclin_getIndex+0xc>
IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;
80004d2a:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80004d2c:	00 90       	ret 

80004d2e <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
80004d2e:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
80004d30:	6d ff b4 ff 	call 80004c98 <IfxAsclin_getFaFrequency>
80004d34:	4c f5       	ld.w %d15,[%a15]20
80004d36:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004d3a:	c2 1f       	add %d15,1
80004d3c:	4b 0f 41 f1 	itof %d15,%d15
}
80004d40:	4b f2 51 20 	div.f %d2,%d2,%d15
80004d44:	00 90       	ret 

80004d46 <IfxAsclin_getOvsFrequency>:
    return result;
}


float32 IfxAsclin_getOvsFrequency(Ifx_ASCLIN *asclin)
{
80004d46:	40 4f       	mov.aa %a15,%a4
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
80004d48:	6d ff f3 ff 	call 80004d2e <IfxAsclin_getPdFrequency>
80004d4c:	48 83       	ld.w %d3,[%a15]32
80004d4e:	4c f8       	ld.w %d15,[%a15]32
80004d50:	37 03 6c 38 	extr.u %d3,%d3,16,12
80004d54:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004d58:	4b 03 41 31 	itof %d3,%d3
80004d5c:	4b 0f 41 f1 	itof %d15,%d15
80004d60:	4b 32 41 20 	mul.f %d2,%d2,%d3
}
80004d64:	4b f2 51 20 	div.f %d2,%d2,%d15
80004d68:	00 90       	ret 

80004d6a <IfxAsclin_getShiftFrequency>:
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
}


float32 IfxAsclin_getShiftFrequency(Ifx_ASCLIN *asclin)
{
80004d6a:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getOvsFrequency(asclin) / asclin->BITCON.B.OVERSAMPLING;
80004d6c:	6d ff ed ff 	call 80004d46 <IfxAsclin_getOvsFrequency>
80004d70:	4c f5       	ld.w %d15,[%a15]20
80004d72:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004d76:	4b 0f 41 f1 	itof %d15,%d15
}
80004d7a:	4b f2 51 20 	div.f %d2,%d2,%d15
80004d7e:	00 90       	ret 

80004d80 <IfxAsclin_getSrcPointerEr>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
80004d80:	6d ff c6 ff 	call 80004d0c <IfxAsclin_getIndex>
80004d84:	53 c2 20 f0 	mul %d15,%d2,12
80004d88:	60 ff       	mov.a %a15,%d15
80004d8a:	d9 f2 08 28 	lea %a2,[%a15]-32632
}
80004d8e:	11 42 00 2f 	addih.a %a2,%a2,61444
80004d92:	00 90       	ret 

80004d94 <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
80004d94:	6d ff bc ff 	call 80004d0c <IfxAsclin_getIndex>
80004d98:	53 c2 20 f0 	mul %d15,%d2,12
80004d9c:	60 ff       	mov.a %a15,%d15
80004d9e:	d9 f2 04 28 	lea %a2,[%a15]-32636
}
80004da2:	11 42 00 2f 	addih.a %a2,%a2,61444
80004da6:	00 90       	ret 

80004da8 <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
80004da8:	6d ff b2 ff 	call 80004d0c <IfxAsclin_getIndex>
80004dac:	53 c2 20 f0 	mul %d15,%d2,12
80004db0:	60 ff       	mov.a %a15,%d15
80004db2:	d9 f2 00 28 	lea %a2,[%a15]-32640
}
80004db6:	11 42 00 2f 	addih.a %a2,%a2,61444
80004dba:	00 90       	ret 

80004dbc <IfxAsclin_read16>:


uint32 IfxAsclin_read16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004dbc:	9f 04 04 80 	jned %d4,0,80004dc4 <IfxAsclin_read16+0x8>
        *data++ = (uint16)rxData->U;
        count--;
    }

    return count;
}
80004dc0:	82 02       	mov %d2,0
80004dc2:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint16)rxData->U;
80004dc4:	19 4f 08 10 	ld.w %d15,[%a4]72
80004dc8:	ac 50       	st.h [%a5]0,%d15
80004dca:	b0 25       	add.a %a5,2
80004dcc:	3c f8       	j 80004dbc <IfxAsclin_read16>

80004dce <IfxAsclin_read32>:
    return count;
}


uint32 IfxAsclin_read32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004dce:	9f 04 04 80 	jned %d4,0,80004dd6 <IfxAsclin_read32+0x8>
        *data++ = rxData->U;
        count--;
    }

    return count;
}
80004dd2:	82 02       	mov %d2,0
80004dd4:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = rxData->U;
80004dd6:	19 4f 08 10 	ld.w %d15,[%a4]72
80004dda:	6c 50       	st.w [%a5]0,%d15
80004ddc:	b0 45       	add.a %a5,4
80004dde:	3c f8       	j 80004dce <IfxAsclin_read32>

80004de0 <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004de0:	9f 04 04 80 	jned %d4,0,80004de8 <IfxAsclin_read8+0x8>
        *data++ = (uint8)rxData->U;
        count--;
    }

    return count;
}
80004de4:	82 02       	mov %d2,0
80004de6:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint8)rxData->U;
80004de8:	19 4f 08 10 	ld.w %d15,[%a4]72
80004dec:	2c 50       	st.b [%a5]0,%d15
80004dee:	b0 15       	add.a %a5,1
80004df0:	3c f8       	j 80004de0 <IfxAsclin_read8>

80004df2 <IfxAsclin_resetModule>:
    return count;
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
80004df2:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004df4:	6d 00 7b 12 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004df8:	02 24       	mov %d4,%d2
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004dfa:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004dfc:	6d 00 77 11 	call 800070ea <IfxScuWdt_clearCpuEndinit>

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004e00:	19 f2 34 30 	ld.w %d2,[%a15]244
    asclin->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004e04:	02 f4       	mov %d4,%d15
void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004e06:	8f 12 40 21 	or %d2,%d2,1
80004e0a:	59 f2 34 30 	st.w [%a15]244,%d2
    asclin->KRST1.B.RST = 1;
80004e0e:	19 f2 30 30 	ld.w %d2,[%a15]240
80004e12:	8f 12 40 21 	or %d2,%d2,1
80004e16:	59 f2 30 30 	st.w [%a15]240,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004e1a:	6d 00 9d 12 	call 80007354 <IfxScuWdt_setCpuEndinit>

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
80004e1e:	19 f2 34 30 	ld.w %d2,[%a15]244
80004e22:	6f 12 fe 7f 	jz.t %d2,1,80004e1e <IfxAsclin_resetModule+0x2c>
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004e26:	02 f4       	mov %d4,%d15
80004e28:	6d 00 61 11 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004e2c:	19 f2 2c 30 	ld.w %d2,[%a15]236

    IfxScuWdt_setCpuEndinit(passwd);
80004e30:	02 f4       	mov %d4,%d15

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004e32:	8f 12 40 21 	or %d2,%d2,1
80004e36:	59 f2 2c 30 	st.w [%a15]236,%d2

    IfxScuWdt_setCpuEndinit(passwd);
80004e3a:	1d 00 8d 12 	j 80007354 <IfxScuWdt_setCpuEndinit>

80004e3e <IfxAsclin_setClockSource>:
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004e3e:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004e42:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
80004e46:	59 4f 0c 10 	st.w [%a4]76,%d15

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80004e4a:	f6 46       	jnz %d4,80004e56 <IfxAsclin_setClockSource+0x18>
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004e4c:	19 4f 0c 10 	ld.w %d15,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004e50:	bf 0f fe 7f 	jlt %d15,0,80004e4c <IfxAsclin_setClockSource+0xe>
80004e54:	00 90       	ret 
80004e56:	19 4f 0c 10 	ld.w %d15,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80004e5a:	ff 0f fe 7f 	jge %d15,0,80004e56 <IfxAsclin_setClockSource+0x18>
80004e5e:	00 90       	ret 

80004e60 <IfxAsclin_setBaudrateBitFields>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004e60:	19 4f 0c 10 	ld.w %d15,[%a4]76
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004e64:	19 42 0c 10 	ld.w %d2,[%a4]76
80004e68:	16 1f       	and %d15,31
80004e6a:	8f f2 c1 21 	andn %d2,%d2,31
80004e6e:	59 42 0c 10 	st.w [%a4]76,%d2
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004e72:	19 42 0c 10 	ld.w %d2,[%a4]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004e76:	bf 02 fe 7f 	jlt %d2,0,80004e72 <IfxAsclin_setBaudrateBitFields+0x12>
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80004e7a:	19 42 14 00 	ld.w %d2,[%a4]20
80004e7e:	c2 f4       	add %d4,-1
80004e80:	37 42 0c 40 	insert %d4,%d2,%d4,0,12
80004e84:	59 44 14 00 	st.w [%a4]20,%d4
}


IFX_INLINE void IfxAsclin_setNumerator(Ifx_ASCLIN *asclin, uint16 numerator)
{
    asclin->BRG.B.NUMERATOR = numerator;
80004e88:	19 42 20 00 	ld.w %d2,[%a4]32
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);                             /* turns off the clock for settings */
    IfxAsclin_setPrescaler(asclin, prescaler);                                                   /* sets the prescaler*/
    IfxAsclin_setNumerator(asclin, numerator);                                                   /* sets the numerator*/
    IfxAsclin_setDenominator(asclin, denominator);                                               /* sets the denominator*/
    IfxAsclin_setOversampling(asclin, oversampling);                                             /* sets the oversampling*/
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
80004e8c:	02 f4       	mov %d4,%d15
80004e8e:	37 52 0c 58 	insert %d5,%d2,%d5,16,12
80004e92:	59 45 20 00 	st.w [%a4]32,%d5
}


IFX_INLINE void IfxAsclin_setDenominator(Ifx_ASCLIN *asclin, uint16 denominator)
{
    asclin->BRG.B.DENOMINATOR = denominator;
80004e96:	19 42 20 00 	ld.w %d2,[%a4]32
80004e9a:	37 62 0c 60 	insert %d6,%d2,%d6,0,12
80004e9e:	59 46 20 00 	st.w [%a4]32,%d6
}


IFX_INLINE void IfxAsclin_setOversampling(Ifx_ASCLIN *asclin, IfxAsclin_OversamplingFactor ovsFactor)
{
    asclin->BITCON.B.OVERSAMPLING = ovsFactor;
80004ea2:	19 42 14 00 	ld.w %d2,[%a4]20
80004ea6:	37 72 04 78 	insert %d7,%d2,%d7,16,4
80004eaa:	59 47 14 00 	st.w [%a4]20,%d7
80004eae:	1d ff c8 ff 	j 80004e3e <IfxAsclin_setClockSource>

80004eb2 <IfxAsclin_setBitTiming>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004eb2:	19 42 0c 10 	ld.w %d2,[%a4]76
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
80004eb6:	20 08       	sub.a %sp,8
80004eb8:	8f f2 01 21 	and %d2,%d2,31
80004ebc:	02 5f       	mov %d15,%d5
80004ebe:	40 4f       	mov.aa %a15,%a4
80004ec0:	02 48       	mov %d8,%d4
80004ec2:	02 6a       	mov %d10,%d6
80004ec4:	60 7d       	mov.a %a13,%d7
80004ec6:	60 2c       	mov.a %a12,%d2
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004ec8:	6d ff 33 ff 	call 80004d2e <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004ecc:	92 15       	add %d5,%d15,1
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004ece:	02 29       	mov %d9,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004ed0:	82 4f       	mov %d15,4
80004ed2:	0b f5 b0 f1 	max.u %d15,%d5,%d15
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004ed6:	8f ff 0f 21 	and %d2,%d15,255
80004eda:	59 a2 04 00 	st.w [%sp]4,%d2
80004ede:	82 16       	mov %d6,1
80004ee0:	0b 6a b0 61 	max.u %d6,%d10,%d6
80004ee4:	16 ff       	and %d15,255
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
80004ee6:	4b 0f 41 31 	itof %d3,%d15
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004eea:	8f f6 0f 61 	and %d6,%d6,255
    fOvs         = baudrate * oversampling;
80004eee:	4b 38 41 f0 	mul.f %d15,%d8,%d3
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004ef2:	60 6e       	mov.a %a14,%d6
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004ef4:	02 f4       	mov %d4,%d15
80004ef6:	6d 00 c7 29 	call 8000a284 <__extendsfdf2>
80004efa:	7b 00 f5 73 	movh %d7,16208
80004efe:	0b 23 10 48 	mov %e4,%d3,%d2
80004f02:	7b 20 2f 6d 	movh %d6,54002
80004f06:	1b d7 24 76 	addi %d7,%d7,25165
80004f0a:	1b c6 9f 6a 	addi %d6,%d6,-22020
80004f0e:	6d 00 de 2a 	call 8000a4ca <__muldf3>
80004f12:	0b 23 10 48 	mov %e4,%d3,%d2
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
    nBest          = n;
80004f16:	82 1c       	mov %d12,1
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004f18:	6d 00 6a 2c 	call 8000a7ec <__truncdfsf2>

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004f1c:	4b f9 51 50 	div.f %d5,%d9,%d15
80004f20:	91 00 00 20 	movh.a %a2,0

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);
80004f24:	82 01       	mov %d1,0

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004f26:	4b 05 71 51 	ftouz %d5,%d5
    }

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
80004f2a:	4b 05 61 31 	utof %d3,%d5
80004f2e:	4b 39 51 30 	div.f %d3,%d9,%d3
    relError       = __absf(fOvs - f);
80004f32:	6b 03 31 3f 	sub.f %d3,%d15,%d3
80004f36:	4b 13 01 00 	cmp.f %d0,%d3,%d1
80004f3a:	37 00 61 00 	extr.u %d0,%d0,0,1
80004f3e:	9b 03 00 48 	addih %d4,%d3,32768
80004f42:	2b 34 40 30 	sel %d3,%d0,%d4,%d3
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004f46:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004f4a:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004f4e:	df 00 45 80 	jne %d0,0,80004fd8 <IfxAsclin_setBitTiming+0x126>
80004f52:	8f 15 00 60 	sh %d6,%d5,1
            /* Increase the value of the oversampling to generate the required baudrate */
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
80004f56:	02 51       	mov %d1,%d5
    nBest          = n;
    adder_facL_min = 0;
80004f58:	82 0e       	mov %d14,0
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004f5a:	82 28       	mov %d8,2
80004f5c:	3b 00 00 71 	mov %d7,4096
80004f60:	7f 76 3b 80 	jge.u %d6,%d7,80004fd6 <IfxAsclin_setBitTiming+0x124>
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
80004f64:	a0 13       	mov.a %a3,1

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
80004f66:	82 1b       	mov %d11,1
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
80004f68:	df 28 09 00 	jeq %d8,2,80004f7a <IfxAsclin_setBitTiming+0xc8>
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004f6c:	73 8e 0a a0 	mul %d10,%d14,%d8
80004f70:	4b ca 11 a2 	div.u %e10,%d10,%d12
            adder_facH = adder_facL + 1;
80004f74:	60 a3       	mov.a %a3,%d10
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004f76:	02 ab       	mov %d11,%d10
            adder_facH = adder_facL + 1;
80004f78:	b0 13       	add.a %a3,1
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004f7a:	80 34       	mov.d %d4,%a3
80004f7c:	3f b4 25 80 	jlt.u %d4,%d11,80004fc6 <IfxAsclin_setBitTiming+0x114>
        {
            f           = (fpd * n) / (n * d + count);
80004f80:	4b 08 61 01 	utof %d0,%d8
80004f84:	0b 6b 00 40 	add %d4,%d11,%d6
80004f88:	4b 04 61 d1 	utof %d13,%d4
80004f8c:	4b 09 41 00 	mul.f %d0,%d9,%d0
            newRelError = __absf(fOvs - f);
80004f90:	80 2a       	mov.d %d10,%a2
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
        {
            f           = (fpd * n) / (n * d + count);
80004f92:	4b d0 51 00 	div.f %d0,%d0,%d13
            newRelError = __absf(fOvs - f);
80004f96:	6b 00 31 0f 	sub.f %d0,%d15,%d0
80004f9a:	4b a0 01 d0 	cmp.f %d13,%d0,%d10
80004f9e:	37 0d 61 d0 	extr.u %d13,%d13,0,1
80004fa2:	9b 00 00 a8 	addih %d10,%d0,32768
80004fa6:	2b 0a 40 0d 	sel %d0,%d13,%d10,%d0

            if (relError > (newRelError))
80004faa:	4b 03 01 d0 	cmp.f %d13,%d3,%d0
80004fae:	37 0d 61 d1 	extr.u %d13,%d13,2,1
80004fb2:	2b be 50 ed 	seln %d14,%d13,%d14,%d11
80004fb6:	2b 03 50 3d 	seln %d3,%d13,%d3,%d0
80004fba:	2b 8c 50 cd 	seln %d12,%d13,%d12,%d8
80004fbe:	2b 41 50 1d 	seln %d1,%d13,%d1,%d4
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004fc2:	c2 1b       	add %d11,1
80004fc4:	3c db       	j 80004f7a <IfxAsclin_setBitTiming+0xc8>
                dBest          = (n * d + count);
                adder_facL_min = count;
            }
        }

        if (relError <= limit)
80004fc6:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004fca:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004fce:	f6 04       	jnz %d0,80004fd6 <IfxAsclin_setBitTiming+0x124>
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004fd0:	c2 18       	add %d8,1
80004fd2:	42 56       	add %d6,%d5
80004fd4:	3c c6       	j 80004f60 <IfxAsclin_setBitTiming+0xae>
80004fd6:	02 15       	mov %d5,%d1
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004fd8:	19 f3 0c 10 	ld.w %d3,[%a15]76
80004fdc:	8f f3 c1 31 	andn %d3,%d3,31
80004fe0:	59 f3 0c 10 	st.w [%a15]76,%d3
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004fe4:	19 ff 0c 10 	ld.w %d15,[%a15]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004fe8:	bf 0f fe 7f 	jlt %d15,0,80004fe4 <IfxAsclin_setBitTiming+0x132>
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004fec:	4c f8       	ld.w %d15,[%a15]32
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004fee:	19 a2 04 00 	ld.w %d2,[%sp]4
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004ff2:	37 5f 0c 50 	insert %d5,%d15,%d5,0,12
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004ff6:	c2 f2       	add %d2,-1
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004ff8:	68 85       	st.w [%a15]32,%d5
    asclin->BRG.B.NUMERATOR   = nBest;
80004ffa:	4c f8       	ld.w %d15,[%a15]32

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ffc:	80 ea       	mov.d %d10,%a14
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80004ffe:	37 cf 0c c8 	insert %d12,%d15,%d12,16,12
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80005002:	80 c4       	mov.d %d4,%a12
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80005004:	68 8c       	st.w [%a15]32,%d12

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80005006:	4c f5       	ld.w %d15,[%a15]20
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80005008:	40 f4       	mov.aa %a4,%a15
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
8000500a:	37 2f 04 28 	insert %d2,%d15,%d2,16,4
8000500e:	68 52       	st.w [%a15]20,%d2

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005010:	4c f5       	ld.w %d15,[%a15]20

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80005012:	80 d2       	mov.d %d2,%a13

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005014:	37 af 04 6c 	insert %d6,%d15,%d10,24,4

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80005018:	7b 00 00 f8 	movh %d15,32768

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
8000501c:	68 56       	st.w [%a15]20,%d6

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
8000501e:	ab 0f 80 72 	sel %d7,%d2,%d15,0
80005022:	4c f5       	ld.w %d15,[%a15]20
80005024:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
80005028:	a6 7f       	or %d15,%d7
8000502a:	68 5f       	st.w [%a15]20,%d15

    IfxAsclin_setClockSource(asclin, source);
8000502c:	6d ff 09 ff 	call 80004e3e <IfxAsclin_setClockSource>

    return TRUE;
}
80005030:	82 12       	mov %d2,1
80005032:	00 90       	ret 

80005034 <IfxAsclin_write16>:
    }
}


uint32 IfxAsclin_write16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80005034:	9f 04 04 80 	jned %d4,0,8000503c <IfxAsclin_write16+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
80005038:	82 02       	mov %d2,0
8000503a:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
8000503c:	b9 5f 00 00 	ld.hu %d15,[%a5]0
80005040:	b0 25       	add.a %a5,2
80005042:	59 4f 04 10 	st.w [%a4]68,%d15
80005046:	3c f7       	j 80005034 <IfxAsclin_write16>

80005048 <IfxAsclin_write32>:
    return count;
}


uint32 IfxAsclin_write32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80005048:	9f 04 04 80 	jned %d4,0,80005050 <IfxAsclin_write32+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
8000504c:	82 02       	mov %d2,0
8000504e:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
80005050:	4c 50       	ld.w %d15,[%a5]0
80005052:	b0 45       	add.a %a5,4
80005054:	59 4f 04 10 	st.w [%a4]68,%d15
80005058:	3c f8       	j 80005048 <IfxAsclin_write32>

8000505a <IfxAsclin_write8>:
    return count;
}

#include <stdio.h>
uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
8000505a:	9f 04 04 80 	jned %d4,0,80005062 <IfxAsclin_write8+0x8>
        count--;

    }

    return count;
}
8000505e:	82 02       	mov %d2,0
80005060:	00 90       	ret 
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {

        txData->U = *data++;
80005062:	0c 50       	ld.bu %d15,[%a5]0
80005064:	b0 15       	add.a %a5,1
80005066:	59 4f 04 10 	st.w [%a4]68,%d15
8000506a:	3c f8       	j 8000505a <IfxAsclin_write8>

8000506c <IfxAsclin_Asc_getReadCount>:
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
8000506c:	cc 42       	ld.a %a15,[%a4]8


sint32 IfxAsclin_Asc_getReadCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_readCount(asclin->rx);
}
8000506e:	88 22       	ld.h %d2,[%a15]4
80005070:	00 90       	ret 

80005072 <IfxAsclin_Asc_getReadEvent>:


IfxStdIf_DPipe_ReadEvent IfxAsclin_Asc_getReadEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->rx->eventWriter;
80005072:	99 42 08 00 	ld.a %a2,[%a4]8
}
80005076:	d9 22 1d 00 	lea %a2,[%a2]29
8000507a:	00 90       	ret 

8000507c <IfxAsclin_Asc_getSendCount>:


uint32 IfxAsclin_Asc_getSendCount(IfxAsclin_Asc *asclin)
{
    return asclin->sendCount;
8000507c:	19 42 10 00 	ld.w %d2,[%a4]16
}
80005080:	00 90       	ret 

80005082 <IfxAsclin_Asc_getTxTimeStamp>:


Ifx_TickTime IfxAsclin_Asc_getTxTimeStamp(IfxAsclin_Asc *asclin)
{
    return asclin->txTimestamp;
80005082:	09 42 54 09 	ld.d %e2,[%a4]20
}
80005086:	00 90       	ret 

80005088 <IfxAsclin_Asc_getWriteCount>:


sint32 IfxAsclin_Asc_getWriteCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_writeCount(asclin->tx);
80005088:	cc 41       	ld.a %a15,[%a4]4
 *
 * \return Returns the free size in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_writeCount(Ifx_Fifo *fifo)
{
    return (Ifx_SizeT)(fifo->size - Ifx_Fifo_readCount(fifo));
8000508a:	88 c2       	ld.h %d2,[%a15]24
8000508c:	8c f2       	ld.h %d15,[%a15]4
8000508e:	a2 f2       	sub %d2,%d15
}
80005090:	37 02 50 20 	extr %d2,%d2,0,16
80005094:	00 90       	ret 

80005096 <IfxAsclin_Asc_getWriteEvent>:


IfxStdIf_DPipe_WriteEvent IfxAsclin_Asc_getWriteEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->tx->eventWriter;
80005096:	99 42 04 00 	ld.a %a2,[%a4]4
}
8000509a:	d9 22 1d 00 	lea %a2,[%a2]29
8000509e:	00 90       	ret 

800050a0 <IfxAsclin_Asc_isrError>:
}


void IfxAsclin_Asc_isrError(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin; /* getting the pointer to ASCLIN registers from module handler*/
800050a0:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE boolean IfxAsclin_getParityErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.PE;
800050a2:	4c fd       	ld.w %d15,[%a15]52

    /* store all the flags in the variable */
    if (IfxAsclin_getParityErrorFlagStatus(asclinSFR))
800050a4:	ef 0f 0a 00 	jz.t %d15,16,800050b8 <IfxAsclin_Asc_isrError+0x18>
}


IFX_INLINE void IfxAsclin_clearParityErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.PEC = 1;
800050a8:	4c ff       	ld.w %d15,[%a15]60
800050aa:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800050ae:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearParityErrorFlag(asclinSFR);
        asclin->errorFlags.flags.parityError = 1;
800050b0:	0c 4e       	ld.bu %d15,[%a4]14
800050b2:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
800050b6:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getFrameErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.FE;
800050b8:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR))
800050ba:	ef 2f 0a 00 	jz.t %d15,18,800050ce <IfxAsclin_Asc_isrError+0x2e>
}


IFX_INLINE void IfxAsclin_clearFrameErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.FEC = 1;
800050be:	4c ff       	ld.w %d15,[%a15]60
800050c0:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
800050c4:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlags.flags.frameError = 1;
800050c6:	0c 4e       	ld.bu %d15,[%a4]14
800050c8:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
800050cc:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFO;
800050ce:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR))
800050d0:	ef af 0a 00 	jz.t %d15,26,800050e4 <IfxAsclin_Asc_isrError+0x44>
}


IFX_INLINE void IfxAsclin_clearRxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFOC = 1;
800050d4:	4c ff       	ld.w %d15,[%a15]60
800050d6:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
800050da:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoOverflow = 1;
800050dc:	0c 4e       	ld.bu %d15,[%a4]14
800050de:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
800050e2:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoUnderflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFU;
800050e4:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoUnderflowFlagStatus(asclinSFR))
800050e6:	ef bf 0a 00 	jz.t %d15,27,800050fa <IfxAsclin_Asc_isrError+0x5a>
}


IFX_INLINE void IfxAsclin_clearRxFifoUnderflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFUC = 1;
800050ea:	4c ff       	ld.w %d15,[%a15]60
800050ec:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
800050f0:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoUnderflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoUnderflow = 1;
800050f2:	0c 4e       	ld.bu %d15,[%a4]14
800050f4:	b7 1f 81 f1 	insert %d15,%d15,1,3,1
800050f8:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getTxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.TFO;
800050fa:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR))
800050fc:	ef ef 0a 00 	jz.t %d15,30,80005110 <IfxAsclin_Asc_isrError+0x70>
}


IFX_INLINE void IfxAsclin_clearTxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.TFOC = 1;
80005100:	4c ff       	ld.w %d15,[%a15]60
80005102:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80005106:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.txFifoOverflow = 1;
80005108:	0c 4e       	ld.bu %d15,[%a4]14
8000510a:	b7 1f 01 f2 	insert %d15,%d15,1,4,1
8000510e:	2c 4e       	st.b [%a4]14,%d15
80005110:	00 90       	ret 

80005112 <IfxAsclin_Asc_resetSendCount>:
}


void IfxAsclin_Asc_resetSendCount(IfxAsclin_Asc *asclin)
{
    asclin->sendCount = 0;
80005112:	82 0f       	mov %d15,0
80005114:	6c 44       	st.w [%a4]16,%d15
80005116:	00 90       	ret 

80005118 <IfxAsclin_Asc_canReadCount>:
}


boolean IfxAsclin_Asc_canReadCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canReadCount(asclin->rx, count, timeout);
80005118:	99 44 08 00 	ld.a %a4,[%a4]8
8000511c:	1d 00 df 18 	j 800082da <Ifx_Fifo_canReadCount>

80005120 <IfxAsclin_Asc_flushTx>:

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80005120:	82 f2       	mov %d2,-1
80005122:	06 f2       	sh %d2,-1
80005124:	ba f4       	eq %d15,%d4,-1
80005126:	0b 52 00 f2 	and.eq %d15,%d2,%d5
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
}


boolean IfxAsclin_Asc_flushTx(IfxAsclin_Asc *asclin, Ifx_TickTime timeout)
{
8000512a:	40 4f       	mov.aa %a15,%a4
8000512c:	02 46       	mov %d6,%d4
    {
        deadLine = TIME_INFINITE;
8000512e:	82 f9       	mov %d9,-1
80005130:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80005132:	ee 16       	jnz %d15,8000515e <IfxAsclin_Asc_flushTx+0x3e>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005134:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80005138:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000513c:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80005140:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005142:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005146:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000514a:	02 39       	mov %d9,%d3
8000514c:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005150:	76 23       	jz %d2,80005156 <IfxAsclin_Asc_flushTx+0x36>
    {
        __enable();
80005152:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80005156:	0b 69 40 90 	addx %d9,%d9,%d6
8000515a:	0b 58 50 80 	addc %d8,%d8,%d5
 *
 * \return TRUE if the buffer is emptied.
 */
IFX_INLINE boolean Ifx_Fifo_flush(Ifx_Fifo *fifo, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(fifo, fifo->size, timeout);
8000515e:	c8 14       	ld.a %a4,[%a15]4
80005160:	02 57       	mov %d7,%d5
80005162:	c9 44 18 00 	ld.h %d4,[%a4]24
80005166:	6d 00 fd 19 	call 80008560 <Ifx_Fifo_canWriteCount>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000516a:	82 f4       	mov %d4,-1
8000516c:	06 f4       	sh %d4,-1
    boolean      result;

    /* Flush the software FIFO */
    result = Ifx_Fifo_flush(asclin->tx, timeout);

    if (result)
8000516e:	f6 23       	jnz %d2,80005174 <IfxAsclin_Asc_flushTx+0x54>
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
    {
        deadLine = TIME_INFINITE;
80005170:	82 02       	mov %d2,0
80005172:	00 90       	ret 
    {
        /* Flush the hardware FIFO (wait until all bytes have been transmitted) */
        do
        {
            result = IfxAsclin_getTxFifoFillLevel(asclin->asclin) == 0;
80005174:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
80005176:	4c 23       	ld.w %d15,[%a2]12
80005178:	37 0f 65 f8 	extr.u %d15,%d15,16,5
        } while (!result && !IfxStm_isDeadLine(deadline));
8000517c:	6e 1e       	jz %d15,800051b8 <IfxAsclin_Asc_flushTx+0x98>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000517e:	ba f9       	eq %d15,%d9,-1
80005180:	0b 84 00 f2 	and.eq %d15,%d4,%d8
80005184:	ee f9       	jnz %d15,80005176 <IfxAsclin_Asc_flushTx+0x56>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005186:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000518a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000518e:	0d 00 40 03 	disable 
80005192:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005194:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005198:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000519c:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800051a0:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800051a4:	76 23       	jz %d2,800051aa <IfxAsclin_Asc_flushTx+0x8a>
    {
        __enable();
800051a6:	0d 00 00 03 	enable 
800051aa:	0b 8f 00 21 	eq %d2,%d15,%d8
800051ae:	0b 93 30 22 	and.lt.u %d2,%d3,%d9
800051b2:	0b 8f 90 22 	or.lt %d2,%d15,%d8
800051b6:	3c dc       	j 8000516e <IfxAsclin_Asc_flushTx+0x4e>
800051b8:	82 12       	mov %d2,1
    }

    return result;
}
800051ba:	00 90       	ret 

800051bc <IfxAsclin_Asc_canWriteCount>:
}


boolean IfxAsclin_Asc_canWriteCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(asclin->tx, count, timeout);
800051bc:	99 44 04 00 	ld.a %a4,[%a4]4
800051c0:	1d 00 d0 19 	j 80008560 <Ifx_Fifo_canWriteCount>

800051c4 <IfxAsclin_Asc_clearRx>:
}


void IfxAsclin_Asc_clearRx(IfxAsclin_Asc *asclin)
{
    IfxAsclin_flushRxFifo(asclin->asclin);
800051c4:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
800051c6:	4c f4       	ld.w %d15,[%a15]16
800051c8:	96 01       	or %d15,1
800051ca:	68 4f       	st.w [%a15]16,%d15
    Ifx_Fifo_clear(asclin->rx);
800051cc:	99 44 08 00 	ld.a %a4,[%a4]8
800051d0:	1d 00 ad 19 	j 8000852a <Ifx_Fifo_clear>

800051d4 <IfxAsclin_Asc_clearTx>:
}


void IfxAsclin_Asc_clearTx(IfxAsclin_Asc *asclin)
{
800051d4:	40 4f       	mov.aa %a15,%a4
    Ifx_Fifo_clear(asclin->tx);
800051d6:	99 44 04 00 	ld.a %a4,[%a4]4
800051da:	6d 00 a8 19 	call 8000852a <Ifx_Fifo_clear>
    IfxAsclin_flushTxFifo(asclin->asclin);
800051de:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
800051e0:	4c f3       	ld.w %d15,[%a15]12
800051e2:	96 01       	or %d15,1
800051e4:	68 3f       	st.w [%a15]12,%d15
800051e6:	00 90       	ret 

800051e8 <IfxAsclin_Asc_read>:
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800051e8:	99 44 08 00 	ld.a %a4,[%a4]8
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800051ec:	0b 45 10 68 	mov %e6,%d5,%d4
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800051f0:	94 64       	ld.h %d4,[%a6]
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800051f2:	40 6f       	mov.aa %a15,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800051f4:	6d 00 e0 18 	call 800083b4 <Ifx_Fifo_read>

    *count -= left;
800051f8:	8c f0       	ld.h %d15,[%a15]0
800051fa:	a2 2f       	sub %d15,%d2
800051fc:	a8 0f       	st.h [%a15]0,%d15

    return left == 0;
}
800051fe:	8b 02 00 22 	eq %d2,%d2,0
80005202:	00 90       	ret 

80005204 <IfxAsclin_Asc_isrTransmit>:
    }
}

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
80005204:	20 18       	sub.a %sp,24
80005206:	40 4f       	mov.aa %a15,%a4
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005208:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
8000520c:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005210:	0d 00 40 03 	disable 
80005214:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005216:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000521a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000521e:	02 52       	mov %d2,%d5
80005220:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005224:	76 43       	jz %d4,8000522a <IfxAsclin_Asc_isrTransmit+0x26>
    {
        __enable();
80005226:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
8000522a:	89 f2 54 09 	st.d [%a15]20,%e2
    asclin->sendCount++;

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000522e:	c8 14       	ld.a %a4,[%a15]4

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
    asclin->txTimestamp = IfxStm_now();
    asclin->sendCount++;
80005230:	4c f4       	ld.w %d15,[%a15]16
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80005232:	c9 44 04 00 	ld.h %d4,[%a4]4
80005236:	c2 1f       	add %d15,1
80005238:	68 4f       	st.w [%a15]16,%d15

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000523a:	df 04 32 00 	jeq %d4,0,8000529e <IfxAsclin_Asc_isrTransmit+0x9a>
    {

        switch (asclin->dataBufferMode)
8000523e:	0c ff       	ld.bu %d15,[%a15]15
80005240:	6e 03       	jz %d15,80005246 <IfxAsclin_Asc_isrTransmit+0x42>
80005242:	9e 1d       	jeq %d15,1,8000527c <IfxAsclin_Asc_isrTransmit+0x78>
80005244:	00 90       	ret 
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
80005246:	c8 02       	ld.a %a2,[%a15]0
        case Ifx_DataBufferMode_normal:
        {

            uint8          ascData[16];
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;
80005248:	2c a7       	st.b [%sp]7,%d15

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
8000524a:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
8000524e:	4c 23       	ld.w %d15,[%a2]12
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
80005250:	d2 06       	mov %e6,0
80005252:	37 0f 65 f8 	extr.u %d15,%d15,16,5
80005256:	d9 a5 08 00 	lea %a5,[%sp]8
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
8000525a:	2c a7       	st.b [%sp]7,%d15

            i_count          = (16 - hw_tx_fill_level);
8000525c:	0c a7       	ld.bu %d15,[%sp]7
8000525e:	8b 0f 01 f1 	rsub %d15,%d15,16
80005262:	37 0f 70 f0 	extr.u %d15,%d15,0,16
80005266:	0b 4f 90 f1 	min.u %d15,%d15,%d4
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
8000526a:	37 0f 50 40 	extr %d4,%d15,0,16
8000526e:	6d 00 a3 18 	call 800083b4 <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
80005272:	c8 04       	ld.a %a4,[%a15]0
80005274:	d9 a5 08 00 	lea %a5,[%sp]8
80005278:	02 f4       	mov %d4,%d15
8000527a:	3c 10       	j 8000529a <IfxAsclin_Asc_isrTransmit+0x96>
        {

            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
8000527c:	d2 06       	mov %e6,0
8000527e:	d9 a5 08 00 	lea %a5,[%sp]8
80005282:	3b c0 00 40 	mov %d4,12
80005286:	6d 00 97 18 	call 800083b4 <Ifx_Fifo_read>

            ascData = packedData.data;
8000528a:	39 af 10 00 	ld.bu %d15,[%sp]16
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
8000528e:	c8 04       	ld.a %a4,[%a15]0
            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);

            ascData = packedData.data;
80005290:	d9 a5 18 00 	lea %a5,[%sp]24
80005294:	89 5f 2f f4 	st.b [+%a5]-17,%d15
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80005298:	82 14       	mov %d4,1
        }
        break;
8000529a:	1d ff e0 fe 	j 8000505a <IfxAsclin_write8>
    }
    else
    {

        /* Transmit buffer is empty */
        asclin->txInProgress = FALSE;
8000529e:	28 c4       	st.b [%a15]12,%d4
800052a0:	00 90       	ret 

800052a2 <IfxAsclin_Asc_isrReceive>:

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
800052a2:	0c 4f       	ld.bu %d15,[%a4]15
    }
}


void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
800052a4:	20 20       	sub.a %sp,32
800052a6:	40 4f       	mov.aa %a15,%a4
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
800052a8:	6e 34       	jz %d15,80005310 <IfxAsclin_Asc_isrReceive+0x6e>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
800052aa:	82 18       	mov %d8,1

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
800052ac:	df 1f 45 80 	jne %d15,1,80005336 <IfxAsclin_Asc_isrReceive+0x94>
    }
    case Ifx_DataBufferMode_timeStampSingle:
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
800052b0:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getRxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->RXFIFOCON.B.FILL;
800052b2:	4c 24       	ld.w %d15,[%a2]16
800052b4:	37 0f 65 f8 	extr.u %d15,%d15,16,5
800052b8:	6e 2b       	jz %d15,8000530e <IfxAsclin_Asc_isrReceive+0x6c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800052ba:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800052be:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800052c2:	0d 00 40 03 	disable 
800052c6:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800052c8:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800052cc:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800052d0:	8f 02 40 21 	or %d2,%d2,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800052d4:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800052d8:	76 33       	jz %d3,800052de <IfxAsclin_Asc_isrReceive+0x3c>
    {
        __enable();
800052da:	0d 00 00 03 	enable 
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
800052de:	c8 04       	ld.a %a4,[%a15]0
800052e0:	d9 a5 10 00 	lea %a5,[%sp]16
800052e4:	82 14       	mov %d4,1
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
800052e6:	78 02       	st.w [%sp]8,%d15
800052e8:	59 a2 04 00 	st.w [%sp]4,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
800052ec:	6d ff 7a fd 	call 80004de0 <IfxAsclin_read8>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800052f0:	c8 24       	ld.a %a4,[%a15]8

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
800052f2:	39 af 10 00 	ld.bu %d15,[%sp]16

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800052f6:	d2 06       	mov %e6,0
800052f8:	d9 a5 04 00 	lea %a5,[%sp]4
800052fc:	3b c0 00 40 	mov %d4,12

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
80005300:	2c ac       	st.b [%sp]12,%d15

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
80005302:	6d 00 a7 19 	call 80008650 <Ifx_Fifo_write>
80005306:	df 02 d5 7f 	jeq %d2,0,800052b0 <IfxAsclin_Asc_isrReceive+0xe>
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
8000530a:	28 d8       	st.b [%a15]13,%d8
8000530c:	3c d2       	j 800052b0 <IfxAsclin_Asc_isrReceive+0xe>
8000530e:	00 90       	ret 
    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
    {
        uint8 count;
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
80005310:	d4 44       	ld.a %a4,[%a4]
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
80005312:	d9 a5 10 00 	lea %a5,[%sp]16
80005316:	4c 44       	ld.w %d15,[%a4]16
80005318:	37 0f 65 f8 	extr.u %d15,%d15,16,5
8000531c:	02 f4       	mov %d4,%d15
8000531e:	6d ff 61 fd 	call 80004de0 <IfxAsclin_read8>

        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
80005322:	c8 24       	ld.a %a4,[%a15]8
80005324:	d2 06       	mov %e6,0
80005326:	d9 a5 10 00 	lea %a5,[%sp]16
8000532a:	02 f4       	mov %d4,%d15
8000532c:	6d 00 92 19 	call 80008650 <Ifx_Fifo_write>
80005330:	76 23       	jz %d2,80005336 <IfxAsclin_Asc_isrReceive+0x94>
        {
            /* Receive buffer is full, data is discard */
            asclin->rxSwFifoOverflow = TRUE;
80005332:	82 1f       	mov %d15,1
80005334:	28 df       	st.b [%a15]13,%d15
80005336:	00 90       	ret 

80005338 <IfxAsclin_Asc_blockingRead>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
80005338:	20 08       	sub.a %sp,8
    Ifx_SizeT count = 1;
8000533a:	82 1f       	mov %d15,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
8000533c:	40 4f       	mov.aa %a15,%a4
    Ifx_SizeT count = 1;
8000533e:	ac a3       	st.h [%sp]6,%d15
    uint8     data;

    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
80005340:	82 f4       	mov %d4,-1
80005342:	40 f4       	mov.aa %a4,%a15
80005344:	d9 a5 05 00 	lea %a5,[%sp]5
80005348:	d9 a6 06 00 	lea %a6,[%sp]6
8000534c:	9b 04 00 58 	addih %d5,%d4,32768
80005350:	6d ff 4c ff 	call 800051e8 <IfxAsclin_Asc_read>
80005354:	df 12 f6 ff 	jne %d2,1,80005340 <IfxAsclin_Asc_blockingRead+0x8>
    {}

    return data;
}
80005358:	39 a2 05 00 	ld.bu %d2,[%sp]5
8000535c:	00 90       	ret 

8000535e <IfxAsclin_Asc_disableModule>:
}


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
8000535e:	cc 40       	ld.a %a15,[%a4]0
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
80005360:	6d 00 c5 0f 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
80005364:	02 24       	mov %d4,%d2


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
80005366:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
80005368:	6d 00 c1 0e 	call 800070ea <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
8000536c:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclinSFR); /* disabling the module */
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
8000536e:	02 f4       	mov %d4,%d15
80005370:	8f 12 40 21 	or %d2,%d2,1
80005374:	68 02       	st.w [%a15]0,%d2
80005376:	1d 00 ef 0f 	j 80007354 <IfxScuWdt_setCpuEndinit>

8000537a <IfxAsclin_Asc_initModule>:
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
8000537a:	cc 50       	ld.a %a15,[%a5]0
    return &asclin->tx->eventWriter;
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
8000537c:	40 4e       	mov.aa %a14,%a4
8000537e:	40 5c       	mov.aa %a12,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
    IfxAsclin_Status status    = IfxAsclin_Status_noError;

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
80005380:	ec 40       	st.a [%a4]0,%a15

    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
80005382:	40 f4       	mov.aa %a4,%a15
80005384:	6d ff 71 fc 	call 80004c66 <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
80005388:	40 f4       	mov.aa %a4,%a15
8000538a:	82 04       	mov %d4,0
8000538c:	6d ff 59 fd 	call 80004e3e <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005390:	4c f6       	ld.w %d15,[%a15]24
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
80005392:	40 f4       	mov.aa %a4,%a15
80005394:	b7 0f 02 f8 	insert %d15,%d15,0,16,2
80005398:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
8000539a:	8c c4       	ld.h %d15,[%a12]8
8000539c:	48 52       	ld.w %d2,[%a15]20
8000539e:	c2 ff       	add %d15,-1
800053a0:	37 f2 0c f0 	insert %d15,%d2,%d15,0,12
800053a4:	68 5f       	st.w [%a15]20,%d15
800053a6:	39 c4 28 00 	ld.bu %d4,[%a12]40
800053aa:	6d ff 4a fd 	call 80004e3e <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
800053ae:	40 f4       	mov.aa %a4,%a15
800053b0:	19 c4 04 00 	ld.w %d4,[%a12]4
800053b4:	39 c5 0a 00 	ld.bu %d5,[%a12]10
800053b8:	39 c6 0d 00 	ld.bu %d6,[%a12]13
800053bc:	39 c7 0c 00 	ld.bu %d7,[%a12]12
800053c0:	6d ff 79 fd 	call 80004eb2 <IfxAsclin_setBitTiming>
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
800053c4:	40 f4       	mov.aa %a4,%a15
800053c6:	82 04       	mov %d4,0
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
800053c8:	02 29       	mov %d9,%d2
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
800053ca:	6d ff 3a fd 	call 80004e3e <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_enableLoopBackMode(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.LB = enable ? 1 : 0;
800053ce:	39 c2 38 00 	ld.bu %d2,[%a12]56
800053d2:	7b 00 00 f1 	movh %d15,4096
800053d6:	ab 0f 80 22 	sel %d2,%d2,%d15,0
800053da:	4c f1       	ld.w %d15,[%a15]4
800053dc:	b7 0f 01 fe 	insert %d15,%d15,0,28,1
800053e0:	a6 2f       	or %d15,%d2
800053e2:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxAsclin_enableParity(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
800053e4:	39 c2 14 00 	ld.bu %d2,[%a12]20
800053e8:	7b 00 00 f4 	movh %d15,16384
800053ec:	ab 0f 80 22 	sel %d2,%d2,%d15,0
800053f0:	4c f6       	ld.w %d15,[%a15]24
800053f2:	b7 0f 01 ff 	insert %d15,%d15,0,30,1
800053f6:	a6 2f       	or %d15,%d2
800053f8:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setParityType(Ifx_ASCLIN *asclin, IfxAsclin_ParityType type)
{
    asclin->FRAMECON.B.ODD = type;
800053fa:	48 62       	ld.w %d2,[%a15]24
800053fc:	39 cf 12 00 	ld.bu %d15,[%a12]18
80005400:	37 f2 81 ff 	insert %d15,%d2,%d15,31,1
80005404:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
80005406:	48 62       	ld.w %d2,[%a15]24
80005408:	0c cf       	ld.bu %d15,[%a12]15
8000540a:	37 f2 83 f4 	insert %d15,%d2,%d15,9,3
8000540e:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setShiftDirection(Ifx_ASCLIN *asclin, IfxAsclin_ShiftDirection dir)
{
    asclin->FRAMECON.B.MSB = dir;
80005410:	48 62       	ld.w %d2,[%a15]24
80005412:	39 cf 11 00 	ld.bu %d15,[%a12]17
80005416:	67 f2 1c f0 	ins.t %d15,%d2,28,%d15,0
8000541a:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setDataLength(Ifx_ASCLIN *asclin, IfxAsclin_DataLength length)
{
    asclin->DATCON.B.DATLEN = length;
8000541c:	48 72       	ld.w %d2,[%a15]28
8000541e:	39 cf 13 00 	ld.bu %d15,[%a12]19
80005422:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
80005426:	68 7f       	st.w [%a15]28,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
80005428:	48 32       	ld.w %d2,[%a15]12
8000542a:	39 cf 16 00 	ld.bu %d15,[%a12]22
8000542e:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80005432:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_setRxFifoOutletWidth(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoOutletWidth width)
{
    asclin->RXFIFOCON.B.OUTW = width;
80005434:	48 42       	ld.w %d2,[%a15]16
80005436:	39 cf 17 00 	ld.bu %d15,[%a12]23
8000543a:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
8000543e:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setIdleDelay(Ifx_ASCLIN *asclin, IfxAsclin_IdleDelay delay)
{
    asclin->FRAMECON.B.IDLE = delay;
80005440:	48 62       	ld.w %d2,[%a15]24
80005442:	0c ce       	ld.bu %d15,[%a12]14
80005444:	37 f2 03 f3 	insert %d15,%d2,%d15,6,3
80005448:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000544a:	39 c2 18 00 	ld.bu %d2,[%a12]24
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000544e:	da 0f       	mov %d15,15
80005450:	0b f2 90 21 	min.u %d2,%d2,%d15
80005454:	48 33       	ld.w %d3,[%a15]12
80005456:	37 23 04 24 	insert %d2,%d3,%d2,8,4
8000545a:	68 32       	st.w [%a15]12,%d2
}


IFX_INLINE void IfxAsclin_setRxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoInterruptLevel level)
{
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000545c:	39 c2 19 00 	ld.bu %d2,[%a12]25
80005460:	0b f2 90 f1 	min.u %d15,%d2,%d15
80005464:	48 42       	ld.w %d2,[%a15]16
80005466:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
8000546a:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
8000546c:	39 cf 10 00 	ld.bu %d15,[%a12]16
80005470:	48 62       	ld.w %d2,[%a15]24
80005472:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
80005476:	68 6f       	st.w [%a15]24,%d15
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/

    /* Pin mapping */
    const IfxAsclin_Asc_Pins *pins = config->pins;
80005478:	99 cd 24 00 	ld.a %a13,[%a12]36

    if (pins != NULL_PTR)
8000547c:	bd 0d 81 00 	jz.a %a13,8000557e <IfxAsclin_Asc_initModule+0x204>
    {
        IfxAsclin_Cts_In *cts = pins->cts;
80005480:	4c d0       	ld.w %d15,[%a13]0

        if (cts != NULL_PTR)
80005482:	6e 27       	jz %d15,800054d0 <IfxAsclin_Asc_initModule+0x156>
}


IFX_INLINE void IfxAsclin_initCtsPin(const IfxAsclin_Cts_In *cts, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (cts->pin.port != NULL_PTR)
80005484:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
80005486:	79 d5 04 00 	ld.b %d5,[%a13]4
8000548a:	99 24 04 00 	ld.a %a4,[%a2]4
8000548e:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005492:	bd 04 1f 00 	jz.a %a4,800054d0 <IfxAsclin_Asc_initModule+0x156>
80005496:	39 24 08 00 	ld.bu %d4,[%a2]8
8000549a:	8f f5 0f 51 	and %d5,%d5,255
8000549e:	6d 00 ba 03 	call 80005c12 <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
800054a2:	60 f3       	mov.a %a3,%d15
800054a4:	02 85       	mov %d5,%d8
800054a6:	99 34 04 00 	ld.a %a4,[%a3]4
800054aa:	39 34 08 00 	ld.bu %d4,[%a3]8
800054ae:	6d 00 30 04 	call 80005d0e <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
800054b2:	60 f3       	mov.a %a3,%d15
800054b4:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_enableCts(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
800054b6:	19 22 04 00 	ld.w %d2,[%a2]4
800054ba:	b7 f2 81 2e 	insert %d2,%d2,15,29,1
800054be:	59 22 04 00 	st.w [%a2]4,%d2
    if (cts->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
        IfxAsclin_enableCts(cts->module, TRUE);
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
800054c2:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setCtsInput(Ifx_ASCLIN *asclin, IfxAsclin_CtsInputSelect ctsi)
{
    asclin->IOCR.B.CTS = ctsi;
800054c4:	0c 3c       	ld.bu %d15,[%a3]12
800054c6:	19 22 04 00 	ld.w %d2,[%a2]4
800054ca:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
800054ce:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rx_In *rx = pins->rx;
800054d0:	4c d2       	ld.w %d15,[%a13]8

        if (rx != NULL_PTR)
800054d2:	6e 20       	jz %d15,80005512 <IfxAsclin_Asc_initModule+0x198>
}


IFX_INLINE void IfxAsclin_initRxPin(const IfxAsclin_Rx_In *rx, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (rx->pin.port != NULL_PTR)
800054d4:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
800054d6:	79 d5 0c 00 	ld.b %d5,[%a13]12
800054da:	99 24 04 00 	ld.a %a4,[%a2]4
800054de:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800054e2:	bd 04 18 00 	jz.a %a4,80005512 <IfxAsclin_Asc_initModule+0x198>
800054e6:	39 24 08 00 	ld.bu %d4,[%a2]8
800054ea:	8f f5 0f 51 	and %d5,%d5,255
800054ee:	6d 00 92 03 	call 80005c12 <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(rx->pin.port, rx->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
800054f2:	60 f3       	mov.a %a3,%d15
800054f4:	02 85       	mov %d5,%d8
800054f6:	99 34 04 00 	ld.a %a4,[%a3]4
800054fa:	39 34 08 00 	ld.bu %d4,[%a3]8
800054fe:	6d 00 08 04 	call 80005d0e <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
80005502:	60 f3       	mov.a %a3,%d15
80005504:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setRxInput(Ifx_ASCLIN *asclin, IfxAsclin_RxInputSelect alti)
{
    asclin->IOCR.B.ALTI = alti;
80005506:	0c 3c       	ld.bu %d15,[%a3]12
80005508:	19 22 04 00 	ld.w %d2,[%a2]4
8000550c:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3
80005510:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rts_Out *rts = pins->rts;
80005512:	4c d4       	ld.w %d15,[%a13]16

        if (rts != NULL_PTR)
80005514:	6e 1a       	jz %d15,80005548 <IfxAsclin_Asc_initModule+0x1ce>
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80005516:	60 f2       	mov.a %a2,%d15
80005518:	39 d2 14 00 	ld.bu %d2,[%a13]20
8000551c:	39 23 0c 00 	ld.bu %d3,[%a2]12
80005520:	99 24 04 00 	ld.a %a4,[%a2]4
80005524:	0f 23 a0 50 	or %d5,%d3,%d2
80005528:	39 24 08 00 	ld.bu %d4,[%a2]8
8000552c:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
80005530:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005534:	6d 00 6f 03 	call 80005c12 <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initRtsPin(const IfxAsclin_Rts_Out *rts, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
80005538:	60 f3       	mov.a %a3,%d15
8000553a:	02 85       	mov %d5,%d8
8000553c:	99 34 04 00 	ld.a %a4,[%a3]4
80005540:	39 34 08 00 	ld.bu %d4,[%a3]8
80005544:	6d 00 e5 03 	call 80005d0e <IfxPort_setPinPadDriver>
        }

        IfxAsclin_Tx_Out *tx = pins->tx;
80005548:	4c d6       	ld.w %d15,[%a13]24

        if (tx != NULL_PTR)
8000554a:	6e 1a       	jz %d15,8000557e <IfxAsclin_Asc_initModule+0x204>
8000554c:	60 f2       	mov.a %a2,%d15
8000554e:	39 d2 1c 00 	ld.bu %d2,[%a13]28
80005552:	39 23 0c 00 	ld.bu %d3,[%a2]12
80005556:	99 24 04 00 	ld.a %a4,[%a2]4
8000555a:	0f 23 a0 50 	or %d5,%d3,%d2
8000555e:	39 24 08 00 	ld.bu %d4,[%a2]8
80005562:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
80005566:	39 d8 1d 00 	ld.bu %d8,[%a13]29
8000556a:	6d 00 54 03 	call 80005c12 <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initTxPin(const IfxAsclin_Tx_Out *tx, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
8000556e:	60 f3       	mov.a %a3,%d15
80005570:	02 85       	mov %d5,%d8
80005572:	99 34 04 00 	ld.a %a4,[%a3]4
80005576:	39 34 08 00 	ld.bu %d4,[%a3]8
8000557a:	6d 00 ca 03 	call 80005d0e <IfxPort_setPinPadDriver>
        }
    }

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
8000557e:	40 f4       	mov.aa %a4,%a15
80005580:	39 c4 28 00 	ld.bu %d4,[%a12]40
80005584:	6d ff 5d fc 	call 80004e3e <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_disableAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSENABLE.U = 0x00000000;
80005588:	82 0f       	mov %d15,0
8000558a:	59 ff 00 10 	st.w [%a15]64,%d15
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAsclin_clearAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
8000558e:	82 f2       	mov %d2,-1
80005590:	68 f2       	st.w [%a15]60,%d2

    IfxAsclin_disableAllFlags(asclinSFR);                     /* disable all flags */
    IfxAsclin_clearAllFlags(asclinSFR);                       /* clear all flags */

    /* HW error flags */
    asclin->errorFlags.ALL = 0;
80005592:	2c ee       	st.b [%a14]14,%d15

    if (config->errorFlags.flags.parityError)
80005594:	4c ca       	ld.w %d15,[%a12]40
80005596:	2e 87       	jz.t %d15,8,800055a4 <IfxAsclin_Asc_initModule+0x22a>
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80005598:	19 ff 00 10 	ld.w %d15,[%a15]64
8000559c:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800055a0:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableParityErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.frameError)
800055a4:	4c ca       	ld.w %d15,[%a12]40
800055a6:	2e 97       	jz.t %d15,9,800055b4 <IfxAsclin_Asc_initModule+0x23a>
}


IFX_INLINE void IfxAsclin_enableFrameErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
800055a8:	19 ff 00 10 	ld.w %d15,[%a15]64
800055ac:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
800055b0:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableFrameErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoOverflow)
800055b4:	4c ca       	ld.w %d15,[%a12]40
800055b6:	2e a7       	jz.t %d15,10,800055c4 <IfxAsclin_Asc_initModule+0x24a>
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
800055b8:	19 ff 00 10 	ld.w %d15,[%a15]64
800055bc:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
800055c0:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoOverflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoUnderflow)
800055c4:	4c ca       	ld.w %d15,[%a12]40
800055c6:	2e b7       	jz.t %d15,11,800055d4 <IfxAsclin_Asc_initModule+0x25a>
}


IFX_INLINE void IfxAsclin_enableRxFifoUnderflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
800055c8:	19 ff 00 10 	ld.w %d15,[%a15]64
800055cc:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
800055d0:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoUnderflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.txFifoOverflow)
800055d4:	4c ca       	ld.w %d15,[%a12]40
800055d6:	2e c7       	jz.t %d15,12,800055e4 <IfxAsclin_Asc_initModule+0x26a>
}


IFX_INLINE void IfxAsclin_enableTxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
800055d8:	19 ff 00 10 	ld.w %d15,[%a15]64
800055dc:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800055e0:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableTxFifoOverflowFlag(asclinSFR, TRUE);
    }

    /* transmission flags */
    asclin->rxSwFifoOverflow = FALSE;
800055e4:	82 0f       	mov %d15,0
800055e6:	2c ed       	st.b [%a14]13,%d15
    asclin->txInProgress     = FALSE;
800055e8:	2c ec       	st.b [%a14]12,%d15

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
800055ea:	d2 04       	mov %e4,0
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800055ec:	39 c3 39 00 	ld.bu %d3,[%a12]57
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;
800055f0:	82 0f       	mov %d15,0
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
800055f2:	89 e4 54 09 	st.d [%a14]20,%e4
    asclin->sendCount      = 0;
800055f6:	6c e4       	st.w [%a14]16,%d15
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800055f8:	e9 e3 0f 00 	st.b [%a14]15,%d3
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
        elementSize = 1;
800055fc:	82 1f       	mov %d15,1
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
800055fe:	76 34       	jz %d3,80005606 <IfxAsclin_Asc_initModule+0x28c>
        break;
    case Ifx_DataBufferMode_timeStampSingle:
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
        break;
    default:
        elementSize = 0;
80005600:	ba 13       	eq %d15,%d3,1
80005602:	ab cf a0 ff 	seln %d15,%d15,%d15,12
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
80005606:	99 c4 2c 00 	ld.a %a4,[%a12]44
8000560a:	c9 c4 2a 00 	ld.h %d4,[%a12]42
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
8000560e:	02 f5       	mov %d5,%d15
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
80005610:	bc 44       	jz.a %a4,80005618 <IfxAsclin_Asc_initModule+0x29e>
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
80005612:	6d 00 36 16 	call 8000827e <Ifx_Fifo_init>
80005616:	3c 03       	j 8000561c <IfxAsclin_Asc_initModule+0x2a2>
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
80005618:	6d 00 50 16 	call 800082b8 <Ifx_Fifo_create>
    }

    if (config->rxBuffer != NULL_PTR)
8000561c:	99 c4 34 00 	ld.a %a4,[%a12]52
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
80005620:	b5 e2 04 00 	st.a [%a14]4,%a2
80005624:	c9 c4 30 00 	ld.h %d4,[%a12]48
    }

    if (config->rxBuffer != NULL_PTR)
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
80005628:	02 f5       	mov %d5,%d15
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
    }

    if (config->rxBuffer != NULL_PTR)
8000562a:	bc 44       	jz.a %a4,80005632 <IfxAsclin_Asc_initModule+0x2b8>
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
8000562c:	6d 00 29 16 	call 8000827e <Ifx_Fifo_init>
80005630:	3c 03       	j 80005636 <IfxAsclin_Asc_initModule+0x2bc>
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80005632:	6d 00 43 16 	call 800082b8 <Ifx_Fifo_create>
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;
80005636:	39 cf 22 00 	ld.bu %d15,[%a12]34

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
8000563a:	b9 c2 1e 00 	ld.hu %d2,[%a12]30
8000563e:	8b 3f 00 82 	eq %d8,%d15,3
80005642:	02 83       	mov %d3,%d8
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80005644:	b5 e2 08 00 	st.a [%a14]8,%a2
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
80005648:	8b 02 00 35 	or.ne %d3,%d2,0
8000564c:	df 03 1e 00 	jeq %d3,0,80005688 <IfxAsclin_Asc_initModule+0x30e>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
80005650:	40 f4       	mov.aa %a4,%a15
80005652:	6d ff a1 fb 	call 80004d94 <IfxAsclin_getSrcPointerRx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80005656:	54 22       	ld.w %d2,[%a2]
80005658:	39 c3 1e 00 	ld.bu %d3,[%a12]30
8000565c:	8f f2 cf 21 	andn %d2,%d2,255
80005660:	a6 32       	or %d2,%d3
80005662:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80005664:	54 22       	ld.w %d2,[%a2]
80005666:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
8000566a:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
8000566c:	54 22       	ld.w %d2,[%a2]
8000566e:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
80005672:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableRxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
80005674:	19 f2 00 10 	ld.w %d2,[%a15]64
80005678:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
8000567c:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005680:	54 22       	ld.w %d2,[%a2]
80005682:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80005686:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.rxPriority);
        IfxAsclin_enableRxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
80005688:	b9 c2 1c 00 	ld.hu %d2,[%a12]28
8000568c:	8b 02 00 85 	or.ne %d8,%d2,0
80005690:	df 08 1e 00 	jeq %d8,0,800056cc <IfxAsclin_Asc_initModule+0x352>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
80005694:	40 f4       	mov.aa %a4,%a15
80005696:	6d ff 89 fb 	call 80004da8 <IfxAsclin_getSrcPointerTx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000569a:	54 22       	ld.w %d2,[%a2]
8000569c:	39 c3 1c 00 	ld.bu %d3,[%a12]28
800056a0:	8f f2 cf 21 	andn %d2,%d2,255
800056a4:	a6 32       	or %d2,%d3
800056a6:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800056a8:	54 22       	ld.w %d2,[%a2]
800056aa:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
800056ae:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800056b0:	54 22       	ld.w %d2,[%a2]
800056b2:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
800056b6:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableTxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
800056b8:	19 f2 00 10 	ld.w %d2,[%a15]64
800056bc:	b7 f2 81 2f 	insert %d2,%d2,15,31,1
800056c0:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800056c4:	54 22       	ld.w %d2,[%a2]
800056c6:	b7 f2 01 25 	insert %d2,%d2,15,10,1
800056ca:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.txPriority);
        IfxAsclin_enableTxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
800056cc:	b9 c2 20 00 	ld.hu %d2,[%a12]32
800056d0:	df 02 1e 00 	jeq %d2,0,8000570c <IfxAsclin_Asc_initModule+0x392>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
800056d4:	40 f4       	mov.aa %a4,%a15
800056d6:	6d ff 55 fb 	call 80004d80 <IfxAsclin_getSrcPointerEr>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800056da:	54 22       	ld.w %d2,[%a2]
800056dc:	39 c3 20 00 	ld.bu %d3,[%a12]32
800056e0:	8f f2 cf 21 	andn %d2,%d2,255
800056e4:	a6 32       	or %d2,%d3
800056e6:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800056e8:	54 22       	ld.w %d2,[%a2]
800056ea:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
800056ee:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800056f0:	4c 20       	ld.w %d15,[%a2]0
800056f2:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
800056f6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
800056f8:	19 ff 00 10 	ld.w %d15,[%a15]64
800056fc:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80005700:	59 ff 00 10 	st.w [%a15]64,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005704:	4c 20       	ld.w %d15,[%a2]0
80005706:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000570a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableRxFifoInlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
8000570c:	4c f4       	ld.w %d15,[%a15]16

    IfxAsclin_flushRxFifo(asclinSFR);              // flushing Rx FIFO
    IfxAsclin_flushTxFifo(asclinSFR);              // flushing Tx FIFO

    return status;
}
8000570e:	02 92       	mov %d2,%d9
80005710:	96 02       	or %d15,2
80005712:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_enableTxFifoOutlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
80005714:	4c f3       	ld.w %d15,[%a15]12
80005716:	96 02       	or %d15,2
80005718:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
8000571a:	4c f4       	ld.w %d15,[%a15]16
8000571c:	96 01       	or %d15,1
8000571e:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
80005720:	4c f3       	ld.w %d15,[%a15]12
80005722:	96 01       	or %d15,1
80005724:	68 3f       	st.w [%a15]12,%d15
80005726:	00 90       	ret 

80005728 <IfxAsclin_Asc_initModuleConfig>:

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
80005728:	82 12       	mov %d2,1
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
8000572a:	7b 10 7e 34 	movh %d3,18401

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
8000572e:	e9 42 28 00 	st.b [%a4]40,%d2
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
80005732:	82 12       	mov %d2,1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
80005734:	82 0f       	mov %d15,0

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
80005736:	f9 42 08 00 	st.h [%a4]8,%d2
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
8000573a:	59 43 04 00 	st.w [%a4]4,%d3
    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
8000573e:	e9 42 0f 00 	st.b [%a4]15,%d2

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80005742:	82 33       	mov %d3,3
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
80005744:	e9 42 10 00 	st.b [%a4]16,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
80005748:	e9 42 16 00 	st.b [%a4]22,%d2
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
8000574c:	e9 42 17 00 	st.b [%a4]23,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
80005750:	82 f2       	mov %d2,-1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
80005752:	e9 4f 38 00 	st.b [%a4]56,%d15

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80005756:	e9 43 0a 00 	st.b [%a4]10,%d3

    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
8000575a:	2c 4c       	st.b [%a4]12,%d15
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
8000575c:	e9 43 0d 00 	st.b [%a4]13,%d3
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
80005760:	2c 4e       	st.b [%a4]14,%d15
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
80005762:	e9 4f 11 00 	st.b [%a4]17,%d15
    config->frame.parityBit               = FALSE;                             /* disable parity*/
80005766:	e9 4f 14 00 	st.b [%a4]20,%d15
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
8000576a:	e9 4f 12 00 	st.b [%a4]18,%d15
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
8000576e:	82 73       	mov %d3,7

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
80005770:	e9 4f 18 00 	st.b [%a4]24,%d15
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
80005774:	e9 4f 19 00 	st.b [%a4]25,%d15
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
80005778:	e9 4f 1a 00 	st.b [%a4]26,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
8000577c:	e9 42 29 00 	st.b [%a4]41,%d2
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
80005780:	82 0f       	mov %d15,0

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
80005782:	82 02       	mov %d2,0
}


void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;
80005784:	f4 45       	st.a [%a4],%a5
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
80005786:	e9 43 13 00 	st.b [%a4]19,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
8000578a:	ac 4f       	st.h [%a4]30,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
8000578c:	ac 4e       	st.h [%a4]28,%d15
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
8000578e:	f9 4f 20 00 	st.h [%a4]32,%d15
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
80005792:	e9 4f 22 00 	st.b [%a4]34,%d15

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
80005796:	59 42 24 00 	st.w [%a4]36,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
8000579a:	59 42 34 00 	st.w [%a4]52,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
8000579e:	59 42 2c 00 	st.w [%a4]44,%d2

    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
800057a2:	f9 42 2a 00 	st.h [%a4]42,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
800057a6:	f9 42 30 00 	st.h [%a4]48,%d2

    config->dataBufferMode = Ifx_DataBufferMode_normal;
800057aa:	e9 4f 39 00 	st.b [%a4]57,%d15
800057ae:	00 90       	ret 

800057b0 <IfxAsclin_Asc_initiateTransmission>:
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
800057b0:	0c 4c       	ld.bu %d15,[%a4]12
    config->dataBufferMode = Ifx_DataBufferMode_normal;
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
800057b2:	20 10       	sub.a %sp,16
800057b4:	40 4f       	mov.aa %a15,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
800057b6:	ee 20       	jnz %d15,800057f6 <IfxAsclin_Asc_initiateTransmission+0x46>
    {

        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800057b8:	99 44 04 00 	ld.a %a4,[%a4]4
800057bc:	8c 42       	ld.h %d15,[%a4]4
800057be:	6e 1c       	jz %d15,800057f6 <IfxAsclin_Asc_initiateTransmission+0x46>
        {
            uint8 data;

            asclin->txInProgress = TRUE;
800057c0:	82 1f       	mov %d15,1
800057c2:	28 cf       	st.b [%a15]12,%d15

            switch (asclin->dataBufferMode)
800057c4:	0c ff       	ld.bu %d15,[%a15]15
800057c6:	6e 0c       	jz %d15,800057de <IfxAsclin_Asc_initiateTransmission+0x2e>
800057c8:	de 11       	jne %d15,1,800057ea <IfxAsclin_Asc_initiateTransmission+0x3a>
            break;
            case Ifx_DataBufferMode_timeStampSingle:
            {

                Ifx_DataBufferMode_TimeStampSingle packedData;
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
800057ca:	d2 06       	mov %e6,0
800057cc:	d9 a5 04 00 	lea %a5,[%sp]4
800057d0:	3b c0 00 40 	mov %d4,12
800057d4:	6d 00 f0 15 	call 800083b4 <Ifx_Fifo_read>
                data = packedData.data;
800057d8:	0c ac       	ld.bu %d15,[%sp]12
800057da:	2c a3       	st.b [%sp]3,%d15
800057dc:	3c 07       	j 800057ea <IfxAsclin_Asc_initiateTransmission+0x3a>
            switch (asclin->dataBufferMode)
            {
            case Ifx_DataBufferMode_normal: // here
            {

                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
800057de:	d2 06       	mov %e6,0
800057e0:	d9 a5 03 00 	lea %a5,[%sp]3
800057e4:	82 14       	mov %d4,1
800057e6:	6d 00 e7 15 	call 800083b4 <Ifx_Fifo_read>
                data = packedData.data;
            }
            break;
            }

            IfxAsclin_write8(asclin->asclin, &data, 1);
800057ea:	c8 04       	ld.a %a4,[%a15]0
800057ec:	d9 a5 03 00 	lea %a5,[%sp]3
800057f0:	82 14       	mov %d4,1
800057f2:	6d ff 34 fc 	call 8000505a <IfxAsclin_write8>
800057f6:	00 90       	ret 

800057f8 <IfxAsclin_Asc_write>:
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800057f8:	40 4f       	mov.aa %a15,%a4

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
800057fa:	0c 4c       	ld.bu %d15,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800057fc:	99 44 04 00 	ld.a %a4,[%a4]4

    if (*count != 0)
80005800:	94 63       	ld.h %d3,[%a6]
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80005802:	0b 45 10 88 	mov %e8,%d5,%d4
80005806:	40 5d       	mov.aa %a13,%a5

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
80005808:	c9 44 18 00 	ld.h %d4,[%a4]24
#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
8000580c:	82 12       	mov %d2,1
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;

    if (*count != 0)
8000580e:	df 03 25 00 	jeq %d3,0,80005858 <IfxAsclin_Asc_write+0x60>
80005812:	40 6c       	mov.aa %a12,%a6
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
80005814:	ee 13       	jnz %d15,8000583a <IfxAsclin_Asc_write+0x42>
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
80005816:	37 04 70 f0 	extr.u %d15,%d4,0,16

    if (*count != 0)
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
8000581a:	7f 3f 10 00 	jge %d15,%d3,8000583a <IfxAsclin_Asc_write+0x42>
        {


            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
8000581e:	0b 89 10 68 	mov %e6,%d9,%d8
80005822:	6d 00 17 17 	call 80008650 <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
80005826:	40 f4       	mov.aa %a4,%a15
80005828:	6d ff c4 ff 	call 800057b0 <IfxAsclin_Asc_initiateTransmission>

            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
8000582c:	94 c4       	ld.h %d4,[%a12]
8000582e:	c8 14       	ld.a %a4,[%a15]4
80005830:	a2 f4       	sub %d4,%d15
80005832:	10 d5       	addsc.a %a5,%a13,%d15,0
80005834:	37 04 50 40 	extr %d4,%d4,0,16
80005838:	3c 03       	j 8000583e <IfxAsclin_Asc_write+0x46>

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
8000583a:	40 d5       	mov.aa %a5,%a13
8000583c:	02 34       	mov %d4,%d3
8000583e:	0b 89 10 68 	mov %e6,%d9,%d8
80005842:	6d 00 07 17 	call 80008650 <Ifx_Fifo_write>

            IfxAsclin_Asc_initiateTransmission(asclin);
80005846:	40 f4       	mov.aa %a4,%a15

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
80005848:	02 2f       	mov %d15,%d2

            IfxAsclin_Asc_initiateTransmission(asclin);
8000584a:	6d ff b3 ff 	call 800057b0 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
8000584e:	94 c2       	ld.h %d2,[%a12]
80005850:	a2 f2       	sub %d2,%d15
80005852:	b4 c2       	st.h [%a12],%d2
        result  = left == 0;
80005854:	8b 0f 00 22 	eq %d2,%d15,0

    }

    return result;
}
80005858:	00 90       	ret 

8000585a <IfxAsclin_Asc_blockingWrite>:
    return data;
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
8000585a:	20 10       	sub.a %sp,16
8000585c:	e9 a4 07 00 	st.b [%sp]7,%d4
    Ifx_SizeT count = 1;

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
80005860:	82 f4       	mov %d4,-1
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
80005862:	82 1f       	mov %d15,1

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
80005864:	d9 a5 07 00 	lea %a5,[%sp]7
80005868:	d9 a6 0e 00 	lea %a6,[%sp]14
8000586c:	9b 04 00 58 	addih %d5,%d4,32768
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
80005870:	ac a7       	st.h [%sp]14,%d15

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
}
80005872:	1d ff c3 ff 	j 800057f8 <IfxAsclin_Asc_write>

80005876 <IfxAsclin_Asc_stdIfDPipeInit>:


boolean IfxAsclin_Asc_stdIfDPipeInit(IfxStdIf_DPipe *stdif, IfxAsclin_Asc *asclin)
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));
80005876:	40 42       	mov.aa %a2,%a4
80005878:	82 0f       	mov %d15,0
8000587a:	c5 0f 0b 10 	lea %a15,4b <_.+0x4a>
8000587e:	24 2f       	st.b [%a2+],%d15
80005880:	fc ff       	loop %a15,8000587e <IfxAsclin_Asc_stdIfDPipeInit+0x8>

    /* Set the API link */
    stdif->driver         = asclin;
    stdif->write          = (IfxStdIf_DPipe_Write) & IfxAsclin_Asc_write;
80005882:	7b 00 00 f8 	movh %d15,32768
80005886:	1b 8f 7f f5 	addi %d15,%d15,22520
8000588a:	6c 42       	st.w [%a4]8,%d15
    stdif->read           = (IfxStdIf_DPipe_Read) & IfxAsclin_Asc_read;
8000588c:	7b 00 00 f8 	movh %d15,32768
80005890:	1b 8f 1e f5 	addi %d15,%d15,20968
80005894:	6c 43       	st.w [%a4]12,%d15
    stdif->getReadCount   = (IfxStdIf_DPipe_GetReadCount) & IfxAsclin_Asc_getReadCount;
80005896:	7b 00 00 f8 	movh %d15,32768
8000589a:	1b cf 06 f5 	addi %d15,%d15,20588
8000589e:	6c 44       	st.w [%a4]16,%d15
    stdif->getReadEvent   = (IfxStdIf_DPipe_GetReadEvent) & IfxAsclin_Asc_getReadEvent;
800058a0:	7b 00 00 f8 	movh %d15,32768
800058a4:	1b 2f 07 f5 	addi %d15,%d15,20594
800058a8:	6c 45       	st.w [%a4]20,%d15
    stdif->getWriteCount  = (IfxStdIf_DPipe_GetWriteCount) & IfxAsclin_Asc_getWriteCount;
800058aa:	7b 00 00 f8 	movh %d15,32768
800058ae:	1b 8f 08 f5 	addi %d15,%d15,20616
800058b2:	6c 46       	st.w [%a4]24,%d15
    stdif->getWriteEvent  = (IfxStdIf_DPipe_GetWriteEvent) & IfxAsclin_Asc_getWriteEvent;
800058b4:	7b 00 00 f8 	movh %d15,32768
800058b8:	1b 6f 09 f5 	addi %d15,%d15,20630
800058bc:	6c 47       	st.w [%a4]28,%d15
    stdif->canReadCount   = (IfxStdIf_DPipe_CanReadCount) & IfxAsclin_Asc_canReadCount;
800058be:	7b 00 00 f8 	movh %d15,32768
800058c2:	1b 8f 11 f5 	addi %d15,%d15,20760
800058c6:	6c 48       	st.w [%a4]32,%d15
    stdif->canWriteCount  = (IfxStdIf_DPipe_CanWriteCount) & IfxAsclin_Asc_canWriteCount;
800058c8:	7b 00 00 f8 	movh %d15,32768
800058cc:	1b cf 1b f5 	addi %d15,%d15,20924
800058d0:	6c 49       	st.w [%a4]36,%d15
    stdif->flushTx        = (IfxStdIf_DPipe_FlushTx) & IfxAsclin_Asc_flushTx;
800058d2:	7b 00 00 f8 	movh %d15,32768
800058d6:	1b 0f 12 f5 	addi %d15,%d15,20768
800058da:	6c 4a       	st.w [%a4]40,%d15
    stdif->clearTx        = (IfxStdIf_DPipe_ClearTx) & IfxAsclin_Asc_clearTx;
800058dc:	7b 00 00 f8 	movh %d15,32768
800058e0:	1b 4f 1d f5 	addi %d15,%d15,20948
800058e4:	6c 4b       	st.w [%a4]44,%d15
    stdif->clearRx        = (IfxStdIf_DPipe_ClearRx) & IfxAsclin_Asc_clearRx;
800058e6:	7b 00 00 f8 	movh %d15,32768
800058ea:	1b 4f 1c f5 	addi %d15,%d15,20932
800058ee:	6c 4c       	st.w [%a4]48,%d15
    stdif->onReceive      = (IfxStdIf_DPipe_OnReceive) & IfxAsclin_Asc_isrReceive;
800058f0:	7b 00 00 f8 	movh %d15,32768
800058f4:	1b 2f 2a f5 	addi %d15,%d15,21154
800058f8:	6c 4d       	st.w [%a4]52,%d15
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
800058fa:	7b 00 00 f8 	movh %d15,32768
800058fe:	1b 4f 20 f5 	addi %d15,%d15,20996
80005902:	6c 4e       	st.w [%a4]56,%d15
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
80005904:	7b 00 00 f8 	movh %d15,32768
80005908:	1b 0f 0a f5 	addi %d15,%d15,20640
8000590c:	6c 4f       	st.w [%a4]60,%d15
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
8000590e:	7b 00 00 f8 	movh %d15,32768
80005912:	1b cf 07 f5 	addi %d15,%d15,20604
80005916:	59 4f 00 10 	st.w [%a4]64,%d15
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
8000591a:	7b 00 00 f8 	movh %d15,32768
8000591e:	1b 2f 08 f5 	addi %d15,%d15,20610
80005922:	59 4f 04 10 	st.w [%a4]68,%d15
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
80005926:	7b 00 00 f8 	movh %d15,32768
8000592a:	1b 2f 11 f5 	addi %d15,%d15,20754
8000592e:	59 4f 08 10 	st.w [%a4]72,%d15
    stdif->txDisabled     = FALSE;
80005932:	82 0f       	mov %d15,0
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));

    /* Set the API link */
    stdif->driver         = asclin;
80005934:	f4 45       	st.a [%a4],%a5
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
    stdif->txDisabled     = FALSE;
80005936:	2c 44       	st.b [%a4]4,%d15
    return TRUE;
}
80005938:	82 12       	mov %d2,1
8000593a:	00 90       	ret 

8000593c <IfxPort_getAddress>:
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
8000593c:	91 00 00 28 	movh.a %a2,32768
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80005940:	82 05       	mov %d5,0
}


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
80005942:	82 02       	mov %d2,0
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005944:	d9 22 80 50 	lea %a2,[%a2]2368 <80000940 <IfxPort_cfg_indexMap>>
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80005948:	8f f5 0f f1 	and %d15,%d5,255
8000594c:	8b 02 00 32 	eq %d3,%d2,0
80005950:	8b 0f 61 34 	and.lt.u %d3,%d15,16
80005954:	76 3a       	jz %d3,80005968 <IfxPort_getAddress+0x2c>
80005956:	02 5f       	mov %d15,%d5
80005958:	16 ff       	and %d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
8000595a:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000595c:	82 02       	mov %d2,0
8000595e:	4c f1       	ld.w %d15,[%a15]4
80005960:	7e 42       	jne %d15,%d4,80005964 <IfxPort_getAddress+0x28>
        {
            module = IfxPort_cfg_indexMap[i].module;
80005962:	48 02       	ld.w %d2,[%a15]0
80005964:	c2 15       	add %d5,1
80005966:	3c f1       	j 80005948 <IfxPort_getAddress+0xc>

        i++;
    }

    return module;
}
80005968:	60 22       	mov.a %a2,%d2
8000596a:	00 90       	ret 

8000596c <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
8000596c:	91 00 00 38 	movh.a %a3,32768
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80005970:	82 0f       	mov %d15,0
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80005972:	d9 33 80 50 	lea %a3,[%a3]2368 <80000940 <IfxPort_cfg_indexMap>>
80005976:	a0 ff       	mov.a %a15,15
80005978:	d0 32       	addsc.a %a2,%a3,%d15,3
8000597a:	d4 25       	ld.a %a5,[%a2]
8000597c:	7d 45 05 80 	jne.a %a5,%a4,80005986 <IfxPort_getIndex+0x1a>
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
80005980:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80005984:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80005986:	c2 1f       	add %d15,1
80005988:	fc f8       	loop %a15,80005978 <IfxPort_getIndex+0xc>
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
8000598a:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
8000598c:	00 90       	ret 

8000598e <IfxPort_resetESR>:


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
8000598e:	40 4f       	mov.aa %a15,%a4
80005990:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005992:	6d 00 ac 0c 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005996:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005998:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
8000599a:	6d 00 a8 0b 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
8000599e:	82 12       	mov %d2,1
800059a0:	d9 f4 10 10 	lea %a4,[%a15]80
800059a4:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
800059a8:	d2 06       	mov %e6,0
800059aa:	02 27       	mov %d7,%d2
800059ac:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
800059b0:	02 f4       	mov %d4,%d15
800059b2:	1d 00 d1 0c 	j 80007354 <IfxScuWdt_setCpuEndinit>

800059b6 <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800059b6:	91 00 00 38 	movh.a %a3,32768
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800059ba:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800059bc:	d9 33 80 70 	lea %a3,[%a3]2496 <800009c0 <IfxPort_cfg_esrMasks>>
800059c0:	a0 ff       	mov.a %a15,15
800059c2:	d0 32       	addsc.a %a2,%a3,%d15,3
800059c4:	d4 25       	ld.a %a5,[%a2]
800059c6:	7d 54 0c 80 	jne.a %a4,%a5,800059de <IfxPort_disableEmergencyStop+0x28>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800059ca:	b9 2f 04 00 	ld.hu %d15,[%a2]4
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800059ce:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800059d0:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
800059d4:	6e 08       	jz %d15,800059e4 <IfxPort_disableEmergencyStop+0x2e>
            {
                IfxPort_resetESR(port, pinIndex);
800059d6:	6d ff dc ff 	call 8000598e <IfxPort_resetESR>
                result = TRUE;
800059da:	82 12       	mov %d2,1
800059dc:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800059de:	c2 1f       	add %d15,1
800059e0:	fc f1       	loop %a15,800059c2 <IfxPort_disableEmergencyStop+0xc>
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800059e2:	82 02       	mov %d2,0
            break;
        }
    }

    return result;
}
800059e4:	00 90       	ret 

800059e6 <IfxPort_setESR>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
800059e6:	40 4f       	mov.aa %a15,%a4
800059e8:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800059ea:	6d 00 80 0c 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800059ee:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800059f0:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800059f2:	6d 00 7c 0b 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
800059f6:	82 12       	mov %d2,1
800059f8:	0f 82 00 20 	sh %d2,%d2,%d8
800059fc:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005a00:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005a04:	02 27       	mov %d7,%d2
80005a06:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005a0a:	02 f4       	mov %d4,%d15
80005a0c:	1d 00 a4 0c 	j 80007354 <IfxScuWdt_setCpuEndinit>

80005a10 <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80005a10:	82 19       	mov %d9,1
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a12:	91 00 00 d8 	movh.a %a13,32768
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80005a16:	40 4c       	mov.aa %a12,%a4
80005a18:	02 48       	mov %d8,%d4
80005a1a:	0f 49 00 90 	sh %d9,%d9,%d4
    sint32  portIndex;
    boolean result = FALSE;
80005a1e:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a20:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005a22:	d9 dd 80 70 	lea %a13,[%a13]2496 <800009c0 <IfxPort_cfg_esrMasks>>
80005a26:	d0 df       	addsc.a %a15,%a13,%d15,3
80005a28:	c8 02       	ld.a %a2,[%a15]0
80005a2a:	7d 2c 0b 80 	jne.a %a12,%a2,80005a40 <IfxPort_enableEmergencyStop+0x30>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005a2e:	b9 f3 04 00 	ld.hu %d3,[%a15]4
80005a32:	26 93       	and %d3,%d9
80005a34:	76 36       	jz %d3,80005a40 <IfxPort_enableEmergencyStop+0x30>
            {
                IfxPort_setESR(port, pinIndex);
80005a36:	40 c4       	mov.aa %a4,%a12
80005a38:	02 84       	mov %d4,%d8
80005a3a:	6d ff d6 ff 	call 800059e6 <IfxPort_setESR>
                result = TRUE;
80005a3e:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005a40:	c2 1f       	add %d15,1
80005a42:	8b 0f 21 32 	ne %d3,%d15,16
80005a46:	df 03 f0 ff 	jne %d3,0,80005a26 <IfxPort_enableEmergencyStop+0x16>
            }
        }
    }

    return result;
}
80005a4a:	00 90       	ret 

80005a4c <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005a4c:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
80005a4e:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005a50:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005a52:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005a54:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80005a56:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005a58:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005a5a:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005a5c:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005a5e:	78 07       	st.w [%sp]28,%d15
80005a60:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005a64:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005a68:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005a6c:	3b 80 0f 70 	mov %d7,248
80005a70:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005a74:	9f 0f 07 80 	jned %d15,0,80005a82 <IfxPort_setGroupModeInput+0x36>
80005a78:	d9 44 10 00 	lea %a4,[%a4]16
80005a7c:	82 0f       	mov %d15,0
80005a7e:	a0 3f       	mov.a %a15,3
80005a80:	3c 1e       	j 80005abc <IfxPort_setGroupModeInput+0x70>
    {
        if ((imask & (1U << i)) != 0)
80005a82:	57 05 61 24 	extr.u %d2,%d5,%d4,1
80005a86:	df 02 19 00 	jeq %d2,0,80005ab8 <IfxPort_setGroupModeInput+0x6c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005a8a:	8f 34 c0 31 	andn %d3,%d4,3
80005a8e:	60 32       	mov.a %a2,%d3
80005a90:	d9 af 20 00 	lea %a15,[%sp]32
80005a94:	30 2f       	add.a %a15,%a2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80005a96:	8f 34 00 21 	and %d2,%d4,3
80005a9a:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80005a9c:	19 f0 f0 ff 	ld.w %d0,[%a15]-16
80005aa0:	0f 27 00 30 	sh %d3,%d7,%d2
80005aa4:	a6 03       	or %d3,%d0
80005aa6:	59 f3 f0 ff 	st.w [%a15]-16,%d3
            iocrVal[index]  |= (mode) << shift;
80005aaa:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
80005aae:	0f 26 00 20 	sh %d2,%d6,%d2
80005ab2:	a6 32       	or %d2,%d3
80005ab4:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005ab8:	c2 14       	add %d4,1
80005aba:	3c dd       	j 80005a74 <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005abc:	d9 a3 20 00 	lea %a3,[%sp]32
80005ac0:	90 32       	addsc.a %a2,%a3,%d15,2
80005ac2:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005ac6:	76 47       	jz %d4,80005ad4 <IfxPort_setGroupModeInput+0x88>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005ac8:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005acc:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005ace:	02 43       	mov %d3,%d4
80005ad0:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005ad4:	c2 1f       	add %d15,1
80005ad6:	b0 44       	add.a %a4,4
80005ad8:	fc f2       	loop %a15,80005abc <IfxPort_setGroupModeInput+0x70>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005ada:	00 90       	ret 

80005adc <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005adc:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
80005ade:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ae0:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005ae2:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ae4:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80005ae6:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005ae8:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005aea:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005aec:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005aee:	78 07       	st.w [%sp]28,%d15
80005af0:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005af4:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005af8:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005afc:	3b 80 0f 00 	mov %d0,248
80005b00:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b04:	9f 0f 07 80 	jned %d15,0,80005b12 <IfxPort_setGroupModeOutput+0x36>
80005b08:	d9 44 10 00 	lea %a4,[%a4]16
80005b0c:	82 0f       	mov %d15,0
80005b0e:	a0 3f       	mov.a %a15,3
80005b10:	3c 1f       	j 80005b4e <IfxPort_setGroupModeOutput+0x72>
    {
        if ((imask & (1U << i)) != 0)
80005b12:	57 05 61 24 	extr.u %d2,%d5,%d4,1
80005b16:	df 02 1a 00 	jeq %d2,0,80005b4a <IfxPort_setGroupModeOutput+0x6e>
        {
            uint32 index = i / 4;
80005b1a:	8f e4 1f 30 	sh %d3,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b1e:	d9 a2 20 00 	lea %a2,[%sp]32
80005b22:	01 23 02 f6 	addsc.a %a15,%a2,%d3,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80005b26:	8f 34 00 21 	and %d2,%d4,3
80005b2a:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
80005b2c:	a6 63       	or %d3,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b2e:	0f 20 00 70 	sh %d7,%d0,%d2
80005b32:	19 f1 f0 ff 	ld.w %d1,[%a15]-16
            iocrVal[index]  |= (mode | index) << shift;
80005b36:	0f 23 00 20 	sh %d2,%d3,%d2
80005b3a:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b3e:	a6 17       	or %d7,%d1
            iocrVal[index]  |= (mode | index) << shift;
80005b40:	a6 32       	or %d2,%d3
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005b42:	59 f7 f0 ff 	st.w [%a15]-16,%d7
            iocrVal[index]  |= (mode | index) << shift;
80005b46:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005b4a:	c2 14       	add %d4,1
80005b4c:	3c dc       	j 80005b04 <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005b4e:	d9 a3 20 00 	lea %a3,[%sp]32
80005b52:	90 32       	addsc.a %a2,%a3,%d15,2
80005b54:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005b58:	76 47       	jz %d4,80005b66 <IfxPort_setGroupModeOutput+0x8a>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005b5a:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005b5e:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005b60:	02 43       	mov %d3,%d4
80005b62:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode | index) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005b66:	c2 1f       	add %d15,1
80005b68:	b0 44       	add.a %a4,4
80005b6a:	fc f2       	loop %a15,80005b4e <IfxPort_setGroupModeOutput+0x72>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005b6c:	00 90       	ret 

80005b6e <IfxPort_setGroupPadDriver>:


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80005b6e:	20 10       	sub.a %sp,16
80005b70:	02 4f       	mov %d15,%d4
80005b72:	02 5a       	mov %d10,%d5
80005b74:	40 4c       	mov.aa %a12,%a4
80005b76:	02 69       	mov %d9,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005b78:	6d 00 b9 0b 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005b7c:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005b7e:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005b80:	6d 00 b5 0a 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005b84:	82 03       	mov %d3,0
80005b86:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80005b88:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005b8c:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80005b90:	59 a3 0c 00 	st.w [%sp]12,%d3
80005b94:	8b 1f a1 22 	ge.u %d2,%d15,17
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005b98:	8b 0f 01 31 	rsub %d3,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80005b9c:	0f fa 00 50 	sh %d5,%d10,%d15
80005ba0:	ab 03 a0 32 	seln %d3,%d2,%d3,0

        for (i = pinIndex; i < 16; i++)
80005ba4:	9f 03 03 80 	jned %d3,0,80005baa <IfxPort_setGroupPadDriver+0x3c>
80005ba8:	3c 1d       	j 80005be2 <IfxPort_setGroupPadDriver+0x74>
        {
            if ((imask & (1U << i)) != 0)
80005baa:	57 05 61 2f 	extr.u %d2,%d5,%d15,1
80005bae:	df 02 18 00 	jeq %d2,0,80005bde <IfxPort_setGroupPadDriver+0x70>
            {
                uint32 index = i / 8;
80005bb2:	8f df 1f 40 	sh %d4,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005bb6:	d9 a2 10 00 	lea %a2,[%sp]16
80005bba:	01 24 02 f6 	addsc.a %a15,%a2,%d4,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005bbe:	8f 7f 00 21 	and %d2,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80005bc2:	19 f4 f8 ff 	ld.w %d4,[%a15]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005bc6:	06 22       	sh %d2,2
                pdrMask[index] |= (0xFUL << shift);
80005bc8:	d7 f4 04 42 	insert %d4,%d4,15,%d2,4
                pdrVal[index]  |= (padDriver << shift);
80005bcc:	0f 29 00 20 	sh %d2,%d9,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005bd0:	59 f4 f8 ff 	st.w [%a15]-8,%d4
                pdrVal[index]  |= (padDriver << shift);
80005bd4:	19 f4 f0 ff 	ld.w %d4,[%a15]-16
80005bd8:	a6 42       	or %d2,%d4
80005bda:	59 f2 f0 ff 	st.w [%a15]-16,%d2
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80005bde:	c2 1f       	add %d15,1
80005be0:	3c e2       	j 80005ba4 <IfxPort_setGroupPadDriver+0x36>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005be2:	58 02       	ld.w %d15,[%sp]8
80005be4:	6e 08       	jz %d15,80005bf4 <IfxPort_setGroupPadDriver+0x86>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005be6:	d9 cf 00 10 	lea %a15,[%a12]64
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005bea:	54 a6       	ld.w %d6,[%sp]
80005bec:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005bee:	02 f7       	mov %d7,%d15
80005bf0:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005bf4:	58 03       	ld.w %d15,[%sp]12
80005bf6:	6e 09       	jz %d15,80005c08 <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005bf8:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005bfc:	19 a6 04 00 	ld.w %d6,[%sp]4
80005c00:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005c02:	02 f7       	mov %d7,%d15
80005c04:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005c08:	02 84       	mov %d4,%d8
}
80005c0a:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005c0e:	1d 00 a3 0b 	j 80007354 <IfxScuWdt_setCpuEndinit>

80005c12 <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80005c12:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005c16:	8f 34 00 91 	and %d9,%d4,3

    if (port == &MODULE_P40)
80005c1a:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80005c1e:	40 4f       	mov.aa %a15,%a4
80005c20:	02 4f       	mov %d15,%d4
80005c22:	02 5a       	mov %d10,%d5
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80005c24:	d9 4c 10 00 	lea %a12,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80005c28:	8f e4 1f b0 	sh %d11,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005c2c:	06 39       	sh %d9,3

    if (port == &MODULE_P40)
80005c2e:	7d 24 11 80 	jne.a %a4,%a2,80005c50 <IfxPort_setPinMode+0x3e>
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c32:	6d 00 5c 0b 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80005c36:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c38:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80005c3a:	6d 00 58 0a 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80005c3e:	19 f2 20 10 	ld.w %d2,[%a15]96
        IfxScuWdt_setCpuEndinit(passwd);
80005c42:	02 84       	mov %d4,%d8

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80005c44:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80005c48:	59 ff 20 10 	st.w [%a15]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80005c4c:	6d 00 84 0b 	call 80007354 <IfxScuWdt_setCpuEndinit>
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80005c50:	da ff       	mov %d15,255
80005c52:	01 cb 02 f6 	addsc.a %a15,%a12,%d11,2
80005c56:	0f 9f 00 f0 	sh %d15,%d15,%d9
80005c5a:	0f 9a 00 20 	sh %d2,%d10,%d9
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005c5e:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005c60:	02 f3       	mov %d3,%d15
80005c62:	49 f2 40 08 	ldmst [%a15]0,%e2
80005c66:	00 90       	ret 

80005c68 <IfxPort_setPinModeLvdsHigh>:
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80005c68:	02 5a       	mov %d10,%d5
80005c6a:	40 4f       	mov.aa %a15,%a4
80005c6c:	02 49       	mov %d9,%d4
80005c6e:	02 6f       	mov %d15,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c70:	6d 00 3d 0b 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005c74:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005c76:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005c78:	6d 00 39 0a 	call 800070ea <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80005c7c:	37 0a 48 50 	extr %d5,%d10,0,8
80005c80:	bf 05 11 00 	jlt %d5,0,80005ca2 <IfxPort_setPinModeLvdsHigh+0x3a>
    {
        if (pinIndex < 2)
80005c84:	bf 29 21 80 	jlt.u %d9,2,80005cc6 <IfxPort_setPinModeLvdsHigh+0x5e>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80005c88:	19 f2 24 20 	ld.w %d2,[%a15]164
80005c8c:	37 f2 01 f0 	insert %d15,%d2,%d15,0,1
80005c90:	59 ff 24 20 	st.w [%a15]164,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
80005c94:	19 ff 24 20 	ld.w %d15,[%a15]164
80005c98:	8f 2f c0 f1 	andn %d15,%d15,2
80005c9c:	59 ff 24 20 	st.w [%a15]164,%d15
80005ca0:	3c 13       	j 80005cc6 <IfxPort_setPinModeLvdsHigh+0x5e>
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80005ca2:	19 f2 28 20 	ld.w %d2,[%a15]168
80005ca6:	67 f2 0c f0 	ins.t %d15,%d2,12,%d15,0
80005caa:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_DIS    = 0;
80005cae:	19 ff 28 20 	ld.w %d15,[%a15]168
80005cb2:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80005cb6:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_PD     = 0;
80005cba:	19 ff 28 20 	ld.w %d15,[%a15]168
80005cbe:	b7 0f 01 f7 	insert %d15,%d15,0,14,1
80005cc2:	59 ff 28 20 	st.w [%a15]168,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80005cc6:	02 84       	mov %d4,%d8
80005cc8:	1d 00 46 0b 	j 80007354 <IfxScuWdt_setCpuEndinit>

80005ccc <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005ccc:	0b 65 10 a8 	mov %e10,%d5,%d6
80005cd0:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005cd2:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005cd6:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005cd8:	6d 00 09 0b 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005cdc:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005cde:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005ce0:	6d 00 05 0a 	call 800070ea <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80005ce4:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80005ce6:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005cea:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005cee:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80005cf2:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005cf6:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005cfa:	0f 2b 00 50 	sh %d5,%d11,%d2
80005cfe:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005d00:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005d02:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005d04:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80005d08:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005d0a:	1d 00 25 0b 	j 80007354 <IfxScuWdt_setCpuEndinit>

80005d0e <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80005d0e:	0b 45 10 88 	mov %e8,%d5,%d4
80005d12:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005d14:	6d 00 eb 0a 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005d18:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005d1a:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005d1c:	6d 00 e7 09 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80005d20:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005d24:	06 22       	sh %d2,2
80005d26:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80005d28:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005d2c:	3b f0 00 30 	mov %d3,15
80005d30:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80005d34:	0f 23 00 30 	sh %d3,%d3,%d2
80005d38:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005d3c:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005d3e:	02 37       	mov %d7,%d3
80005d40:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005d44:	02 f4       	mov %d4,%d15
80005d46:	1d 00 07 0b 	j 80007354 <IfxScuWdt_setCpuEndinit>
	...

80005d4c <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80005d4c:	7b e0 e4 30 	movh %d3,3662
80005d50:	1b 13 c0 31 	addi %d3,%d3,7169
80005d54:	0b 34 30 c1 	lt.u %d12,%d4,%d3
80005d58:	82 2f       	mov %d15,2
80005d5a:	ab 1f 80 cc 	sel %d12,%d12,%d15,1
80005d5e:	8f 4c 00 80 	sh %d8,%d12,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005d62:	7b c0 be 00 	movh %d0,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005d66:	91 40 0f 50 	movh.a %a5,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005d6a:	7b 80 82 6e 	movh %d6,59432
80005d6e:	91 80 7d 61 	movh.a %a6,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
80005d72:	19 4e 10 10 	ld.w %d14,[%a4]80
80005d76:	60 83       	mov.a %a3,%d8
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005d78:	1b 00 20 0c 	addi %d0,%d0,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80005d7c:	d2 0a       	mov %e10,0
80005d7e:	82 09       	mov %d9,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005d80:	3b 00 01 50 	mov %d5,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005d84:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005d88:	82 f7       	mov %d7,-1
80005d8a:	1b 06 c0 67 	addi %d6,%d6,31744
80005d8e:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
80005d92:	a0 ff       	mov.a %a15,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005d94:	4b 5e 11 22 	div.u %e2,%d14,%d5

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005d98:	7b 60 f8 1f 	movh %d1,65414
80005d9c:	1b 01 e0 1e 	addi %d1,%d1,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005da0:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005da2:	0b 12 40 10 	addx %d1,%d2,%d1
80005da6:	8b f3 bf 20 	addc %d2,%d3,-1
80005daa:	80 53       	mov.d %d3,%a5
80005dac:	ba 02       	eq %d15,%d2,0
80005dae:	0b 31 50 f2 	and.ge.u %d15,%d1,%d3
80005db2:	8b 02 00 f5 	or.ne %d15,%d2,0
80005db6:	ee 24       	jnz %d15,80005dfe <IfxScuCcu_calculateSysPllDividers+0xb2>
80005db8:	02 5d       	mov %d13,%d5
80005dba:	82 11       	mov %d1,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005dbc:	03 41 68 26 	madd.u %e2,%e6,%d1,%d4
80005dc0:	80 68       	mov.d %d8,%a6
80005dc2:	ba 03       	eq %d15,%d3,0
80005dc4:	0b 82 50 f2 	and.ge.u %d15,%d2,%d8
80005dc8:	8b 03 00 f5 	or.ne %d15,%d3,0
80005dcc:	ee 13       	jnz %d15,80005df2 <IfxScuCcu_calculateSysPllDividers+0xa6>
80005dce:	82 18       	mov %d8,1
80005dd0:	c5 02 3f 10 	lea %a2,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
80005dd4:	4b d8 11 22 	div.u %e2,%d8,%d13
80005dd8:	e2 e2       	mul %d2,%d14
80005dda:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
80005ddc:	df 02 18 00 	jeq %d2,0,80005e0c <IfxScuCcu_calculateSysPllDividers+0xc0>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
80005de0:	82 1f       	mov %d15,1
80005de2:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80005de6:	6a 8b       	cmovn %d11,%d15,%d8
80005de8:	6a 20       	cmovn %d0,%d15,%d2
80005dea:	6a 5a       	cmovn %d10,%d15,%d5
80005dec:	6a 19       	cmovn %d9,%d15,%d1
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
80005dee:	c2 18       	add %d8,1
80005df0:	fc 22       	loop %a2,80005dd4 <IfxScuCcu_calculateSysPllDividers+0x88>
80005df2:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80005df4:	42 c1       	add %d1,%d12
80005df6:	42 fd       	add %d13,%d15
80005df8:	8b 11 68 f2 	lt.u %d15,%d1,129
80005dfc:	ee e0       	jnz %d15,80005dbc <IfxScuCcu_calculateSysPllDividers+0x70>
80005dfe:	60 c2       	mov.a %a2,%d12
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005e00:	c2 f5       	add %d5,-1
80005e02:	01 23 20 30 	sub.a %a3,%a3,%a2
80005e06:	fd f0 c7 7f 	loop %a15,80005d94 <IfxScuCcu_calculateSysPllDividers+0x48>
80005e0a:	3c 05       	j 80005e14 <IfxScuCcu_calculateSysPllDividers+0xc8>

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
                                bestN          = n;
80005e0c:	0b 58 10 a8 	mov %e10,%d8,%d5
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
80005e10:	02 19       	mov %d9,%d1
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
80005e12:	82 00       	mov %d0,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005e14:	da 64       	mov %d15,100
80005e16:	06 14       	sh %d4,1
80005e18:	4b f4 11 42 	div.u %e4,%d4,%d15
80005e1c:	82 1f       	mov %d15,1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80005e1e:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005e20:	0b 40 50 f2 	and.ge.u %d15,%d0,%d4
80005e24:	ee 0f       	jnz %d15,80005e42 <IfxScuCcu_calculateSysPllDividers+0xf6>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005e26:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005e28:	c2 fb       	add %d11,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005e2a:	c2 fa       	add %d10,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005e2c:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005e2e:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005e32:	e9 4b 09 00 	st.b [%a4]9,%d11
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005e36:	e9 4a 08 00 	st.b [%a4]8,%d10
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005e3a:	e9 49 0a 00 	st.b [%a4]10,%d9
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80005e3e:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80005e40:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80005e42:	00 90       	ret 

80005e44 <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80005e44:	91 00 00 f7 	movh.a %a15,28672
80005e48:	19 f2 10 30 	ld.w %d2,[%a15]208 <700000d0 <IfxScuCcu_xtalFrequency>>
}
80005e4c:	4b 02 61 21 	utof %d2,%d2
80005e50:	00 90       	ret 

80005e52 <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005e52:	91 30 00 ff 	movh.a %a15,61443
80005e56:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005e5a:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005e5c:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005e60:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005e64:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005e68:	6e 0c       	jz %d15,80005e80 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005e6a:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
80005e6c:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005e6e:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005e72:	5e 17       	jne %d15,1,80005e80 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80005e74:	91 00 00 f7 	movh.a %a15,28672
80005e78:	19 f2 10 30 	ld.w %d2,[%a15]208 <700000d0 <IfxScuCcu_xtalFrequency>>
80005e7c:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}
80005e80:	00 90       	ret 

80005e82 <IfxScuCcu_getPllErayFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005e82:	91 30 00 ff 	movh.a %a15,61443
80005e86:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005e8a:	6d ff e4 ff 	call 80005e52 <IfxScuCcu_getOscFrequency>

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005e8e:	4c f9       	ld.w %d15,[%a15]36
80005e90:	2e 05       	jz.t %d15,0,80005e9a <IfxScuCcu_getPllErayFrequency+0x18>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80005e92:	4c fb       	ld.w %d15,[%a15]44
80005e94:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005e98:	3c 21       	j 80005eda <IfxScuCcu_getPllErayFrequency+0x58>
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80005e9a:	4c f9       	ld.w %d15,[%a15]36
80005e9c:	6f 3f 15 00 	jz.t %d15,3,80005ec6 <IfxScuCcu_getPllErayFrequency+0x44>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80005ea0:	48 b4       	ld.w %d4,[%a15]44
80005ea2:	8f f4 07 41 	and %d4,%d4,127
80005ea6:	c2 14       	add %d4,1
80005ea8:	6d 00 6f 24 	call 8000a786 <__floatsidf>
80005eac:	7b 80 19 54 	movh %d5,16792
80005eb0:	0b 23 10 68 	mov %e6,%d3,%d2
80005eb4:	82 04       	mov %d4,0
80005eb6:	1b 45 78 5d 	addi %d5,%d5,-10364
80005eba:	6d 00 da 23 	call 8000a66e <__divdf3>
80005ebe:	0b 23 10 48 	mov %e4,%d3,%d2
80005ec2:	1d 00 95 24 	j 8000a7ec <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80005ec6:	48 a3       	ld.w %d3,[%a15]40
80005ec8:	4c fb       	ld.w %d15,[%a15]44
80005eca:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005ece:	16 7f       	and %d15,127
80005ed0:	c2 13       	add %d3,1
80005ed2:	4b 03 41 31 	itof %d3,%d3
80005ed6:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005eda:	c2 1f       	add %d15,1
80005edc:	4b 0f 41 f1 	itof %d15,%d15
80005ee0:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005ee4:	00 90       	ret 

80005ee6 <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005ee6:	91 30 00 ff 	movh.a %a15,61443
80005eea:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80005eee:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005ef0:	7b f0 cb 24 	movh %d2,19647
80005ef4:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005ef8:	6f 3f 18 80 	jnz.t %d15,3,80005f28 <IfxScuCcu_getPllErayVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80005efc:	6d ff ab ff 	call 80005e52 <IfxScuCcu_getOscFrequency>
80005f00:	91 30 00 ff 	movh.a %a15,61443
80005f04:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80005f08:	48 03       	ld.w %d3,[%a15]0
80005f0a:	4c f0       	ld.w %d15,[%a15]0
80005f0c:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005f10:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005f14:	c2 13       	add %d3,1
80005f16:	4b 03 41 31 	itof %d3,%d3
80005f1a:	c2 1f       	add %d15,1
80005f1c:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005f20:	4b 0f 41 f1 	itof %d15,%d15
80005f24:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005f28:	00 90       	ret 

80005f2a <IfxScuCcu_getPllFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005f2a:	91 30 00 ff 	movh.a %a15,61443
80005f2e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005f32:	6d ff 90 ff 	call 80005e52 <IfxScuCcu_getOscFrequency>

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005f36:	4c f5       	ld.w %d15,[%a15]20
80005f38:	2e 06       	jz.t %d15,0,80005f44 <IfxScuCcu_getPllFrequency+0x1a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80005f3a:	4c f7       	ld.w %d15,[%a15]28
80005f3c:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005f40:	c2 1f       	add %d15,1
80005f42:	3c 28       	j 80005f92 <IfxScuCcu_getPllFrequency+0x68>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80005f44:	4c f5       	ld.w %d15,[%a15]20
80005f46:	6f 3f 15 00 	jz.t %d15,3,80005f70 <IfxScuCcu_getPllFrequency+0x46>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80005f4a:	48 74       	ld.w %d4,[%a15]28
80005f4c:	8f f4 07 41 	and %d4,%d4,127
80005f50:	c2 14       	add %d4,1
80005f52:	6d 00 1a 24 	call 8000a786 <__floatsidf>
80005f56:	7b 80 19 54 	movh %d5,16792
80005f5a:	0b 23 10 68 	mov %e6,%d3,%d2
80005f5e:	82 04       	mov %d4,0
80005f60:	1b 45 78 5d 	addi %d5,%d5,-10364
80005f64:	6d 00 85 23 	call 8000a66e <__divdf3>
80005f68:	0b 23 10 48 	mov %e4,%d3,%d2
80005f6c:	1d 00 40 24 	j 8000a7ec <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80005f70:	48 64       	ld.w %d4,[%a15]24
80005f72:	4c f7       	ld.w %d15,[%a15]28
80005f74:	37 04 e7 44 	extr.u %d4,%d4,9,7
80005f78:	8f ff 07 31 	and %d3,%d15,127
80005f7c:	4c f6       	ld.w %d15,[%a15]24
80005f7e:	c2 14       	add %d4,1
80005f80:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005f84:	4b 04 41 41 	itof %d4,%d4
80005f88:	c2 1f       	add %d15,1
80005f8a:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80005f8e:	4b 42 41 20 	mul.f %d2,%d2,%d4
80005f92:	4b 0f 41 f1 	itof %d15,%d15
80005f96:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005f9a:	00 90       	ret 

80005f9c <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005f9c:	91 30 00 ff 	movh.a %a15,61443
80005fa0:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005fa4:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005fa6:	7b f0 cb 24 	movh %d2,19647
80005faa:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005fae:	6f 3f 18 80 	jnz.t %d15,3,80005fde <IfxScuCcu_getPllVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80005fb2:	6d ff 50 ff 	call 80005e52 <IfxScuCcu_getOscFrequency>
80005fb6:	91 30 00 ff 	movh.a %a15,61443
80005fba:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80005fbe:	48 03       	ld.w %d3,[%a15]0
80005fc0:	4c f0       	ld.w %d15,[%a15]0
80005fc2:	37 03 e7 34 	extr.u %d3,%d3,9,7
80005fc6:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005fca:	c2 13       	add %d3,1
80005fcc:	4b 03 41 31 	itof %d3,%d3
80005fd0:	c2 1f       	add %d15,1
80005fd2:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005fd6:	4b 0f 41 f1 	itof %d15,%d15
80005fda:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005fde:	00 90       	ret 

80005fe0 <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80005fe0:	91 30 00 ff 	movh.a %a15,61443
80005fe4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005fe8:	4c f0       	ld.w %d15,[%a15]0
80005fea:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005fee:	6e 06       	jz %d15,80005ffa <IfxScuCcu_getSourceFrequency+0x1a>
80005ff0:	1e 13       	jeq %d15,1,80005ff6 <IfxScuCcu_getSourceFrequency+0x16>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80005ff2:	82 02       	mov %d2,0
80005ff4:	00 90       	ret 
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
80005ff6:	1d ff 9a ff 	j 80005f2a <IfxScuCcu_getPllFrequency>
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80005ffa:	7b f0 cb 24 	movh %d2,19647
80005ffe:	1b 02 c2 2b 	addi %d2,%d2,-17376
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
80006002:	00 90       	ret 

80006004 <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
80006004:	02 4f       	mov %d15,%d4
80006006:	6d ff ed ff 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
8000600a:	91 30 00 ff 	movh.a %a15,61443
8000600e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006012:	48 03       	ld.w %d3,[%a15]0
80006014:	37 03 64 34 	extr.u %d3,%d3,8,4
80006018:	4b 03 41 31 	itof %d3,%d3
8000601c:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80006020:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80006024:	4b f2 41 20 	mul.f %d2,%d2,%d15
80006028:	4b 02 71 21 	ftouz %d2,%d2
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
8000602c:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80006030:	a2 3f       	sub %d15,%d3
80006032:	3f 2f fd ff 	jlt.u %d15,%d2,8000602c <IfxScuCcu_wait+0x28>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80006036:	00 90       	ret 

80006038 <IfxScuCcu_getBbbFrequency>:
float32 IfxScuCcu_getBbbFrequency(void)
{
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006038:	6d ff d4 ff 	call 80005fe0 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
8000603c:	91 30 00 ff 	movh.a %a15,61443
80006040:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006044:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0;
80006046:	82 0f       	mov %d15,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006048:	37 03 64 36 	extr.u %d3,%d3,12,4
8000604c:	ff 53 30 80 	jge.u %d3,5,800060ac <IfxScuCcu_getBbbFrequency+0x74>
80006050:	91 00 00 f8 	movh.a %a15,32768
80006054:	d9 ff 20 16 	lea %a15,[%a15]24672 <80006060 <IfxScuCcu_getBbbFrequency+0x28>>
80006058:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000605c:	dc 0f       	ji %a15
8000605e:	00 00       	nop 
80006060:	1d 00 0a 00 	j 80006074 <IfxScuCcu_getBbbFrequency+0x3c>
80006064:	1d 00 17 00 	j 80006092 <IfxScuCcu_getBbbFrequency+0x5a>
80006068:	1d 00 18 00 	j 80006098 <IfxScuCcu_getBbbFrequency+0x60>
8000606c:	1d 00 19 00 	j 8000609e <IfxScuCcu_getBbbFrequency+0x66>
80006070:	1d 00 1a 00 	j 800060a4 <IfxScuCcu_getBbbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80006074:	91 30 00 ff 	movh.a %a15,61443
80006078:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
8000607c:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0;
8000607e:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80006080:	8f f3 00 31 	and %d3,%d3,15
80006084:	df 03 14 00 	jeq %d3,0,800060ac <IfxScuCcu_getBbbFrequency+0x74>
        {
            bbbFrequency = 0.0;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
80006088:	4c f0       	ld.w %d15,[%a15]0
8000608a:	16 0f       	and %d15,15
8000608c:	4b 0f 41 f1 	itof %d15,%d15
80006090:	3c 0c       	j 800060a8 <IfxScuCcu_getBbbFrequency+0x70>
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
80006092:	7b 00 1f f4 	movh %d15,16880
80006096:	3c 09       	j 800060a8 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
80006098:	7b 00 27 f4 	movh %d15,17008
8000609c:	3c 06       	j 800060a8 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
8000609e:	7b 00 2f f4 	movh %d15,17136
800060a2:	3c 03       	j 800060a8 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
800060a4:	7b 00 37 f4 	movh %d15,17264
800060a8:	4b f2 51 f0 	div.f %d15,%d2,%d15
        bbbFrequency = 0.0;
        break;
    }

    return bbbFrequency;
}
800060ac:	02 f2       	mov %d2,%d15
800060ae:	00 90       	ret 

800060b0 <IfxScuCcu_getMaxFrequency>:
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800060b0:	91 30 00 ff 	movh.a %a15,61443
800060b4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>

float32 IfxScuCcu_getMaxFrequency(void)
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();
800060b8:	6d ff 94 ff 	call 80005fe0 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
800060bc:	4c f0       	ld.w %d15,[%a15]0
800060be:	37 0f 64 f6 	extr.u %d15,%d15,12,4
800060c2:	ff 5f 2d 80 	jge.u %d15,5,8000611c <IfxScuCcu_getMaxFrequency+0x6c>
800060c6:	91 00 00 f8 	movh.a %a15,32768
800060ca:	d9 ff 14 36 	lea %a15,[%a15]24788 <800060d4 <IfxScuCcu_getMaxFrequency+0x24>>
800060ce:	90 ff       	addsc.a %a15,%a15,%d15,2
800060d0:	dc 0f       	ji %a15
800060d2:	00 00       	nop 
800060d4:	1d 00 0a 00 	j 800060e8 <IfxScuCcu_getMaxFrequency+0x38>
800060d8:	1d 00 14 00 	j 80006100 <IfxScuCcu_getMaxFrequency+0x50>
800060dc:	1d 00 15 00 	j 80006106 <IfxScuCcu_getMaxFrequency+0x56>
800060e0:	1d 00 16 00 	j 8000610c <IfxScuCcu_getMaxFrequency+0x5c>
800060e4:	1d 00 17 00 	j 80006112 <IfxScuCcu_getMaxFrequency+0x62>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
800060e8:	91 30 00 ff 	movh.a %a15,61443
800060ec:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
800060f0:	4c f0       	ld.w %d15,[%a15]0
800060f2:	16 0f       	and %d15,15
800060f4:	6e 15       	jz %d15,8000611e <IfxScuCcu_getMaxFrequency+0x6e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
800060f6:	4c f0       	ld.w %d15,[%a15]0
800060f8:	16 0f       	and %d15,15
800060fa:	4b 0f 41 f1 	itof %d15,%d15
800060fe:	3c 0c       	j 80006116 <IfxScuCcu_getMaxFrequency+0x66>
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80006100:	7b 00 17 f4 	movh %d15,16752
80006104:	3c 09       	j 80006116 <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
80006106:	7b 00 1f f4 	movh %d15,16880
8000610a:	3c 06       	j 80006116 <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
8000610c:	7b 00 27 f4 	movh %d15,17008
80006110:	3c 03       	j 80006116 <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
80006112:	7b 00 2f f4 	movh %d15,17136
80006116:	4b f2 51 20 	div.f %d2,%d2,%d15
        break;
8000611a:	00 90       	ret 
    default:
        maxFrequency = 0.0;
8000611c:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
8000611e:	00 90       	ret 

80006120 <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006120:	91 30 00 ff 	movh.a %a15,61443
80006124:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006128:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
8000612a:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000612c:	8f ff 00 81 	and %d8,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
80006130:	76 87       	jz %d8,8000613e <IfxScuCcu_getBaud1Frequency+0x1e>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
80006132:	6d ff bf ff 	call 800060b0 <IfxScuCcu_getMaxFrequency>
80006136:	4b 08 41 f1 	itof %d15,%d8
8000613a:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
8000613e:	00 90       	ret 

80006140 <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006140:	91 30 00 ff 	movh.a %a15,61443
80006144:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006148:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
8000614a:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000614c:	37 0f 64 82 	extr.u %d8,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
80006150:	16 f0       	and %d15,240
80006152:	6e 07       	jz %d15,80006160 <IfxScuCcu_getBaud2Frequency+0x20>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
80006154:	6d ff ae ff 	call 800060b0 <IfxScuCcu_getMaxFrequency>
80006158:	4b 08 41 f1 	itof %d15,%d8
8000615c:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
80006160:	00 90       	ret 

80006162 <IfxScuCcu_getSpbFrequency>:
float32 IfxScuCcu_getSpbFrequency(void)
{
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006162:	6d ff 3f ff 	call 80005fe0 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80006166:	91 30 00 ff 	movh.a %a15,61443
8000616a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000616e:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0;
80006170:	82 0f       	mov %d15,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006172:	37 03 64 36 	extr.u %d3,%d3,12,4
80006176:	ff 53 30 80 	jge.u %d3,5,800061d6 <IfxScuCcu_getSpbFrequency+0x74>
8000617a:	91 00 00 f8 	movh.a %a15,32768
8000617e:	d9 ff 08 66 	lea %a15,[%a15]24968 <80006188 <IfxScuCcu_getSpbFrequency+0x26>>
80006182:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80006186:	dc 0f       	ji %a15
80006188:	1d 00 0a 00 	j 8000619c <IfxScuCcu_getSpbFrequency+0x3a>
8000618c:	1d 00 18 00 	j 800061bc <IfxScuCcu_getSpbFrequency+0x5a>
80006190:	1d 00 19 00 	j 800061c2 <IfxScuCcu_getSpbFrequency+0x60>
80006194:	1d 00 1a 00 	j 800061c8 <IfxScuCcu_getSpbFrequency+0x66>
80006198:	1d 00 1b 00 	j 800061ce <IfxScuCcu_getSpbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
8000619c:	91 30 00 ff 	movh.a %a15,61443
800061a0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061a4:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0;
800061a6:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800061a8:	37 03 64 38 	extr.u %d3,%d3,16,4
800061ac:	df 03 15 00 	jeq %d3,0,800061d6 <IfxScuCcu_getSpbFrequency+0x74>
        {
            spbFrequency = 0.0;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
800061b0:	4c f0       	ld.w %d15,[%a15]0
800061b2:	37 0f 64 f8 	extr.u %d15,%d15,16,4
800061b6:	4b 0f 41 f1 	itof %d15,%d15
800061ba:	3c 0c       	j 800061d2 <IfxScuCcu_getSpbFrequency+0x70>
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
800061bc:	7b 00 1f f4 	movh %d15,16880
800061c0:	3c 09       	j 800061d2 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
800061c2:	7b 00 27 f4 	movh %d15,17008
800061c6:	3c 06       	j 800061d2 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
800061c8:	7b 00 2f f4 	movh %d15,17136
800061cc:	3c 03       	j 800061d2 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
800061ce:	7b 00 37 f4 	movh %d15,17264
800061d2:	4b f2 51 f0 	div.f %d15,%d2,%d15
        spbFrequency = 0.0;
        break;
    }

    return spbFrequency;
}
800061d6:	02 f2       	mov %d2,%d15
800061d8:	00 90       	ret 

800061da <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
800061da:	91 30 00 ff 	movh.a %a15,61443
800061de:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
800061e2:	48 09       	ld.w %d9,[%a15]0
    spbFreq = IfxScuCcu_getSpbFrequency();
800061e4:	6d ff bf ff 	call 80006162 <IfxScuCcu_getSpbFrequency>

    if (scuFdr.B.DM == 1)
800061e8:	bb 00 00 fc 	mov.u %d15,49152
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();
800061ec:	02 23       	mov %d3,%d2

    if (scuFdr.B.DM == 1)
800061ee:	26 9f       	and %d15,%d9
800061f0:	3b 00 00 24 	mov %d2,16384
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
800061f4:	b7 09 16 85 	insert %d8,%d9,0,10,22
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
800061f8:	7e 29       	jne %d15,%d2,8000620a <IfxScuCcu_getModuleFrequency+0x30>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
800061fa:	3b 00 40 20 	mov %d2,1024
800061fe:	a2 82       	sub %d2,%d8
80006200:	4b 02 41 21 	itof %d2,%d2
80006204:	4b 23 51 20 	div.f %d2,%d3,%d2
80006208:	00 90       	ret 
    }
    else if (scuFdr.B.DM == 2)
8000620a:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
8000620e:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
80006210:	7e 49       	jne %d15,%d4,80006222 <IfxScuCcu_getModuleFrequency+0x48>
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
80006212:	4b 08 41 21 	itof %d2,%d8
80006216:	7b 00 a8 f3 	movh %d15,14976
8000621a:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000621e:	4b f2 41 20 	mul.f %d2,%d2,%d15
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
80006222:	00 90       	ret 

80006224 <IfxScuCcu_getSriFrequency>:
float32 IfxScuCcu_getSriFrequency(void)
{
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006224:	6d ff de fe 	call 80005fe0 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80006228:	91 30 00 ff 	movh.a %a15,61443
8000622c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006230:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0;
80006232:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006234:	37 03 64 36 	extr.u %d3,%d3,12,4
80006238:	ff 53 31 80 	jge.u %d3,5,8000629a <IfxScuCcu_getSriFrequency+0x76>
8000623c:	91 00 00 f8 	movh.a %a15,32768
80006240:	d9 ff 0c 96 	lea %a15,[%a15]25164 <8000624c <IfxScuCcu_getSriFrequency+0x28>>
80006244:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80006248:	dc 0f       	ji %a15
8000624a:	00 00       	nop 
8000624c:	1d 00 0a 00 	j 80006260 <IfxScuCcu_getSriFrequency+0x3c>
80006250:	1d 00 18 00 	j 80006280 <IfxScuCcu_getSriFrequency+0x5c>
80006254:	1d 00 19 00 	j 80006286 <IfxScuCcu_getSriFrequency+0x62>
80006258:	1d 00 1a 00 	j 8000628c <IfxScuCcu_getSriFrequency+0x68>
8000625c:	1d 00 1b 00 	j 80006292 <IfxScuCcu_getSriFrequency+0x6e>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80006260:	91 30 00 ff 	movh.a %a15,61443
80006264:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006268:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0;
8000626a:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
8000626c:	37 03 64 34 	extr.u %d3,%d3,8,4
80006270:	df 03 15 00 	jeq %d3,0,8000629a <IfxScuCcu_getSriFrequency+0x76>
        {
            sriFrequency = 0.0;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80006274:	4c f0       	ld.w %d15,[%a15]0
80006276:	37 0f 64 f4 	extr.u %d15,%d15,8,4
8000627a:	4b 0f 41 f1 	itof %d15,%d15
8000627e:	3c 0c       	j 80006296 <IfxScuCcu_getSriFrequency+0x72>
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
80006280:	7b 00 1f f4 	movh %d15,16880
80006284:	3c 09       	j 80006296 <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
80006286:	7b 00 27 f4 	movh %d15,17008
8000628a:	3c 06       	j 80006296 <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
8000628c:	7b 00 2f f4 	movh %d15,17136
80006290:	3c 03       	j 80006296 <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
80006292:	7b 00 37 f4 	movh %d15,17264
80006296:	4b f2 51 f0 	div.f %d15,%d2,%d15
        sriFrequency = 0.0;
        break;
    }

    return sriFrequency;
}
8000629a:	02 f2       	mov %d2,%d15
8000629c:	00 90       	ret 

8000629e <IfxScuCcu_getCpuFrequency>:
    return bbbFrequency;
}


float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
8000629e:	02 4f       	mov %d15,%d4
    float32 frequency = IfxScuCcu_getSriFrequency();
800062a0:	6d ff c2 ff 	call 80006224 <IfxScuCcu_getSriFrequency>
    uint32  cpuDiv    = 0;

    switch (cpu)
800062a4:	1e 1d       	jeq %d15,1,800062be <IfxScuCcu_getCpuFrequency+0x20>
800062a6:	6e 07       	jz %d15,800062b4 <IfxScuCcu_getCpuFrequency+0x16>
800062a8:	de 2a       	jne %d15,2,800062dc <IfxScuCcu_getCpuFrequency+0x3e>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
800062aa:	91 30 00 ff 	movh.a %a15,61443
800062ae:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800062b2:	3c 0a       	j 800062c6 <IfxScuCcu_getCpuFrequency+0x28>
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
800062b4:	91 30 00 ff 	movh.a %a15,61443
800062b8:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800062bc:	3c 05       	j 800062c6 <IfxScuCcu_getCpuFrequency+0x28>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
800062be:	91 30 00 ff 	movh.a %a15,61443
800062c2:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
800062c6:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0;
        break;
    }

    if (cpuDiv != 0)
800062c8:	6e 0b       	jz %d15,800062de <IfxScuCcu_getCpuFrequency+0x40>
    {
        frequency = frequency * (cpuDiv / 64.0f);
800062ca:	4b 0f 61 f1 	utof %d15,%d15
800062ce:	7b 00 c8 33 	movh %d3,15488
800062d2:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
800062d6:	4b f2 41 20 	mul.f %d2,%d2,%d15
800062da:	00 90       	ret 
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0;
800062dc:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
800062de:	00 90       	ret 

800062e0 <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800062e0:	91 30 00 ff 	movh.a %a15,61443
800062e4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800062e8:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
800062ea:	7b 00 03 30 	movh %d3,48
800062ee:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800062f0:	37 0f 62 8a 	extr.u %d8,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
800062f4:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
800062f6:	76 3f       	jz %d3,80006314 <IfxScuCcu_getFsi2Frequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800062f8:	6d ff 96 ff 	call 80006224 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800062fc:	3b 00 f0 30 	mov %d3,3840
80006300:	26 3f       	and %d15,%d3
80006302:	1b 0f f0 ff 	addi %d15,%d15,-256
80006306:	8f 0f d0 f1 	andn %d15,%d15,256
8000630a:	ee 05       	jnz %d15,80006314 <IfxScuCcu_getFsi2Frequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
8000630c:	4b 08 41 f1 	itof %d15,%d8
80006310:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
80006314:	00 90       	ret 

80006316 <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006316:	91 30 00 ff 	movh.a %a15,61443
8000631a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000631e:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
80006320:	7b 00 30 30 	movh %d3,768
80006324:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006326:	37 0f 62 8c 	extr.u %d8,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
8000632a:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
8000632c:	76 3f       	jz %d3,8000634a <IfxScuCcu_getFsiFrequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
8000632e:	6d ff 7b ff 	call 80006224 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
80006332:	3b 00 f0 30 	mov %d3,3840
80006336:	26 3f       	and %d15,%d3
80006338:	1b 0f f0 ff 	addi %d15,%d15,-256
8000633c:	8f 0f d0 f1 	andn %d15,%d15,256
80006340:	ee 05       	jnz %d15,8000634a <IfxScuCcu_getFsiFrequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
80006342:	4b 08 41 f1 	itof %d15,%d8
80006346:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
8000634a:	00 90       	ret 

8000634c <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
8000634c:	19 4f 10 10 	ld.w %d15,[%a4]80
80006350:	91 00 00 c7 	movh.a %a12,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
80006354:	40 4f       	mov.aa %a15,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80006356:	59 cf 10 30 	st.w [%a12]208 <700000d0 <IfxScuCcu_xtalFrequency>>,%d15

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
8000635a:	6d 00 c8 07 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
8000635e:	02 29       	mov %d9,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80006360:	6d 00 e3 07 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006364:	02 94       	mov %d4,%d9
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80006366:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006368:	6d 00 c1 06 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
8000636c:	91 30 00 2f 	movh.a %a2,61443
80006370:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006374:	54 2c       	ld.w %d12,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;
80006376:	4c 20       	ld.w %d15,[%a2]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006378:	02 94       	mov %d4,%d9

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
8000637a:	96 08       	or %d15,8
8000637c:	6c 20       	st.w [%a2]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000637e:	6d 00 eb 07 	call 80007354 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006382:	02 84       	mov %d4,%d8
80006384:	6d 00 ce 06 	call 80007120 <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006388:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
8000638c:	91 30 00 3f 	movh.a %a3,61443
80006390:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006394:	4c 30       	ld.w %d15,[%a3]0
80006396:	91 30 00 2f 	movh.a %a2,61443
8000639a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000639e:	bf 0f fb 7f 	jlt %d15,0,80006394 <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800063a2:	4c 20       	ld.w %d15,[%a2]0
800063a4:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
800063a8:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
800063aa:	4c 20       	ld.w %d15,[%a2]0
800063ac:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800063b0:	6c 20       	st.w [%a2]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
800063b2:	91 30 00 2f 	movh.a %a2,61443
800063b6:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800063ba:	4c 20       	ld.w %d15,[%a2]0
800063bc:	96 10       	or %d15,16
800063be:	6c 20       	st.w [%a2]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON0.B.LCK != 0U)
800063c0:	91 30 00 2f 	movh.a %a2,61443
800063c4:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063c8:	4c 20       	ld.w %d15,[%a2]0
800063ca:	bf 0f ff 7f 	jlt %d15,0,800063c8 <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
800063ce:	91 30 00 2f 	movh.a %a2,61443
800063d2:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800063d6:	4c 20       	ld.w %d15,[%a2]0
800063d8:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
800063dc:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
800063de:	4c 20       	ld.w %d15,[%a2]0
800063e0:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800063e4:	6c 20       	st.w [%a2]0,%d15
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800063e6:	6d 00 82 07 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800063ea:	91 30 00 2f 	movh.a %a2,61443
800063ee:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800063f2:	02 2f       	mov %d15,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800063f4:	54 22       	ld.w %d2,[%a2]

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800063f6:	40 23       	mov.aa %a3,%a2
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800063f8:	8f 02 c6 21 	andn %d2,%d2,96
800063fc:	74 22       	st.w [%a2],%d2

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
800063fe:	19 c6 10 30 	ld.w %d6,[%a12]208 <700000d0 <IfxScuCcu_xtalFrequency>>
80006402:	7b 60 02 20 	movh %d2,38
80006406:	1b 02 5a 22 	addi %d2,%d2,9632
8000640a:	4b 26 11 62 	div.u %e6,%d6,%d2
8000640e:	54 22       	ld.w %d2,[%a2]
80006410:	c2 f6       	add %d6,-1
80006412:	37 62 05 68 	insert %d6,%d2,%d6,16,5
80006416:	74 26       	st.w [%a2],%d6

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
80006418:	54 22       	ld.w %d2,[%a2]
8000641a:	8f 42 40 21 	or %d2,%d2,4
8000641e:	74 22       	st.w [%a2],%d2

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80006420:	c5 02 3f 90 	lea %a2,27f <_.+0x27e>
80006424:	54 32       	ld.w %d2,[%a3]
80006426:	6f 12 05 80 	jnz.t %d2,1,80006430 <IfxScuCcu_init+0xe4>
8000642a:	fc 2d       	loop %a2,80006424 <IfxScuCcu_init+0xd8>
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
8000642c:	82 1b       	mov %d11,1
8000642e:	3c 05       	j 80006438 <IfxScuCcu_init+0xec>

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80006430:	54 32       	ld.w %d2,[%a3]
80006432:	6f 82 fc 7f 	jz.t %d2,8,8000642a <IfxScuCcu_init+0xde>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
80006436:	82 0b       	mov %d11,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
80006438:	02 f4       	mov %d4,%d15
8000643a:	6d 00 58 06 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000643e:	91 30 00 2f 	movh.a %a2,61443
80006442:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
80006446:	54 22       	ld.w %d2,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
80006448:	02 f4       	mov %d4,%d15
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000644a:	8f 82 40 21 	or %d2,%d2,8
8000644e:	74 22       	st.w [%a2],%d2
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
80006450:	91 30 00 2f 	movh.a %a2,61443
80006454:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006458:	54 22       	ld.w %d2,[%a2]
8000645a:	8f 82 40 21 	or %d2,%d2,8
8000645e:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinitPw);
80006460:	6d 00 7a 07 	call 80007354 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006464:	02 84       	mov %d4,%d8
80006466:	6d 00 e3 07 	call 8000742c <IfxScuWdt_setSafetyEndinit>
    }

    if (status == 0)
8000646a:	df 0b 29 81 	jne %d11,0,800066bc <IfxScuCcu_init+0x370>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000646e:	02 84       	mov %d4,%d8
80006470:	6d 00 58 06 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006474:	91 30 00 2f 	movh.a %a2,61443
80006478:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000647c:	4c 20       	ld.w %d15,[%a2]0
8000647e:	6f 5f ff 7f 	jz.t %d15,5,8000647c <IfxScuCcu_init+0x130>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80006482:	91 30 00 2f 	movh.a %a2,61443
80006486:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000648a:	54 22       	ld.w %d2,[%a2]
8000648c:	0c fa       	ld.bu %d15,[%a15]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000648e:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80006492:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006496:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
8000649a:	6c 20       	st.w [%a2]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
8000649c:	91 30 00 2f 	movh.a %a2,61443
800064a0:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800064a4:	54 22       	ld.w %d2,[%a2]
800064a6:	0c f8       	ld.bu %d15,[%a15]8
800064a8:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
800064ac:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
800064ae:	54 22       	ld.w %d2,[%a2]
800064b0:	0c f9       	ld.bu %d15,[%a15]9
800064b2:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
800064b6:	6c 20       	st.w [%a2]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
800064b8:	4c 20       	ld.w %d15,[%a2]0
800064ba:	96 40       	or %d15,64
800064bc:	6c 20       	st.w [%a2]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
800064be:	4c 20       	ld.w %d15,[%a2]0
800064c0:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
800064c4:	6c 20       	st.w [%a2]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
800064c6:	4c 20       	ld.w %d15,[%a2]0
800064c8:	96 20       	or %d15,32
800064ca:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
800064cc:	4c 20       	ld.w %d15,[%a2]0
800064ce:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800064d2:	6c 20       	st.w [%a2]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
800064d4:	4c 20       	ld.w %d15,[%a2]0
800064d6:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
800064da:	6c 20       	st.w [%a2]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800064dc:	6d ff 94 fd 	call 80006004 <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
800064e0:	91 30 00 2f 	movh.a %a2,61443
800064e4:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800064e8:	4c 20       	ld.w %d15,[%a2]0
800064ea:	6f 2f ff 7f 	jz.t %d15,2,800064e8 <IfxScuCcu_init+0x19c>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800064ee:	91 30 00 2f 	movh.a %a2,61443
800064f2:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800064f6:	4c 20       	ld.w %d15,[%a2]0

                    while (SCU_CCUCON0.B.LCK != 0U)
800064f8:	91 30 00 3f 	movh.a %a3,61443
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800064fc:	8f 1f c0 f1 	andn %d15,%d15,1
80006500:	6c 20       	st.w [%a2]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
80006502:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006506:	4c 30       	ld.w %d15,[%a3]0
80006508:	91 30 00 2f 	movh.a %a2,61443
8000650c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006510:	bf 0f fb 7f 	jlt %d15,0,80006506 <IfxScuCcu_init+0x1ba>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
80006514:	4c 20       	ld.w %d15,[%a2]0
80006516:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
8000651a:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
8000651c:	4c 20       	ld.w %d15,[%a2]0
8000651e:	91 30 00 cf 	movh.a %a12,61443
80006522:	d9 cc 30 06 	lea %a12,[%a12]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006526:	bf 0f fb 7f 	jlt %d15,0,8000651c <IfxScuCcu_init+0x1d0>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
8000652a:	48 34       	ld.w %d4,[%a15]12
8000652c:	6d ff 6c fd 	call 80006004 <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80006530:	4c f5       	ld.w %d15,[%a15]20
80006532:	54 c3       	ld.w %d3,[%a12]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80006534:	48 42       	ld.w %d2,[%a15]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80006536:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
8000653a:	26 f2       	and %d2,%d15
8000653c:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
80006540:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
80006544:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
80006548:	91 30 00 3f 	movh.a %a3,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
8000654c:	6c c0       	st.w [%a12]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
8000654e:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006552:	4c 30       	ld.w %d15,[%a3]0
80006554:	91 30 00 2f 	movh.a %a2,61443
80006558:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000655c:	bf 0f fb 7f 	jlt %d15,0,80006552 <IfxScuCcu_init+0x206>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80006560:	4c f7       	ld.w %d15,[%a15]28
80006562:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80006564:	48 62       	ld.w %d2,[%a15]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80006566:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
8000656a:	26 f2       	and %d2,%d15
8000656c:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon1.B.INSEL = 1;
80006570:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
80006574:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80006578:	91 30 00 3f 	movh.a %a3,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
8000657c:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
8000657e:	d9 33 00 16 	lea %a3,[%a3]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80006582:	4c 30       	ld.w %d15,[%a3]0
80006584:	91 30 00 2f 	movh.a %a2,61443
80006588:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
8000658c:	bf 0f fb 7f 	jlt %d15,0,80006582 <IfxScuCcu_init+0x236>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80006590:	4c f9       	ld.w %d15,[%a15]36
80006592:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80006594:	48 82       	ld.w %d2,[%a15]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80006596:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
8000659a:	26 f2       	and %d2,%d15
8000659c:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon2.B.UP = 1;
800065a0:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
800065a4:	91 30 00 3f 	movh.a %a3,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
800065a8:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
800065aa:	d9 33 0c 16 	lea %a3,[%a3]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
800065ae:	4c 30       	ld.w %d15,[%a3]0
800065b0:	91 30 00 2f 	movh.a %a2,61443
800065b4:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
800065b8:	bf 0f fb 7f 	jlt %d15,0,800065ae <IfxScuCcu_init+0x262>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
800065bc:	54 23       	ld.w %d3,[%a2]
800065be:	4c fb       	ld.w %d15,[%a15]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
800065c0:	48 a2       	ld.w %d2,[%a15]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
800065c2:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
800065c6:	26 f2       	and %d2,%d15
800065c8:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon5.B.UP = 1;
800065cc:	b7 1f 01 ff 	insert %d15,%d15,1,30,1

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
800065d0:	48 c2       	ld.w %d2,[%a15]48
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
800065d2:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
800065d4:	91 30 00 2f 	movh.a %a2,61443
800065d8:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800065dc:	54 23       	ld.w %d3,[%a2]
800065de:	4c fd       	ld.w %d15,[%a15]52
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
                        SCU_CCUCON8 = ccucon8;
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800065e0:	02 84       	mov %d4,%d8
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
800065e2:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
800065e6:	26 f2       	and %d2,%d15
800065e8:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON6 = ccucon6;
800065ec:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800065ee:	91 30 00 2f 	movh.a %a2,61443
800065f2:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
800065f6:	54 23       	ld.w %d3,[%a2]
800065f8:	4c ff       	ld.w %d15,[%a15]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800065fa:	48 e2       	ld.w %d2,[%a15]56
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800065fc:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
80006600:	26 f2       	and %d2,%d15
80006602:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON7 = ccucon7;
80006606:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
80006608:	91 30 00 2f 	movh.a %a2,61443
8000660c:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80006610:	54 23       	ld.w %d3,[%a2]
80006612:	19 ff 04 10 	ld.w %d15,[%a15]68 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
80006616:	19 f2 00 10 	ld.w %d2,[%a15]64 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
8000661a:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
8000661e:	26 f2       	and %d2,%d15
80006620:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON8 = ccucon8;
80006624:	6c 20       	st.w [%a2]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006626:	6d 00 03 07 	call 8000742c <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
8000662a:	91 00 80 cf 	movh.a %a12,63488
8000662e:	d9 cc 14 02 	lea %a12,[%a12]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
80006632:	19 ff 0c 10 	ld.w %d15,[%a15]76 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
80006636:	54 c3       	ld.w %d3,[%a12]

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006638:	19 f2 08 10 	ld.w %d2,[%a15]72 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
8000663c:	0f f3 e0 30 	andn %d3,%d3,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006640:	26 f2       	and %d2,%d15
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80006642:	02 94       	mov %d4,%d9
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006644:	0f 23 a0 f0 	or %d15,%d3,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80006648:	6d 00 51 05 	call 800070ea <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
8000664c:	6c c0       	st.w [%a12]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
8000664e:	02 94       	mov %d4,%d9
80006650:	6d 00 82 06 	call 80007354 <IfxScuWdt_setCpuEndinit>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006654:	91 30 00 df 	movh.a %a13,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006658:	91 30 00 cf 	movh.a %a12,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
8000665c:	82 0d       	mov %d13,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000665e:	d9 dd 14 06 	lea %a13,[%a13]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006662:	d9 cc 1c 06 	lea %a12,[%a12]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80006666:	0c f0       	ld.bu %d15,[%a15]0
80006668:	8f fd 0f 21 	and %d2,%d13,255
8000666c:	7f f2 28 80 	jge.u %d2,%d15,800066bc <IfxScuCcu_init+0x370>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006670:	02 84       	mov %d4,%d8
80006672:	6d 00 57 05 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006676:	4c d0       	ld.w %d15,[%a13]0
80006678:	6f 5f ff 7f 	jz.t %d15,5,80006676 <IfxScuCcu_init+0x32a>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
8000667c:	02 df       	mov %d15,%d13
8000667e:	16 ff       	and %d15,255
80006680:	53 cf 20 a0 	mul %d10,%d15,12
80006684:	c8 12       	ld.a %a2,[%a15]4
80006686:	4c c0       	ld.w %d15,[%a12]0
80006688:	60 a3       	mov.a %a3,%d10
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000668a:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
8000668c:	30 32       	add.a %a2,%a3
8000668e:	14 22       	ld.bu %d2,[%a2]
80006690:	37 2f 07 20 	insert %d2,%d15,%d2,0,7
80006694:	74 c2       	st.w [%a12],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006696:	6d 00 cb 06 	call 8000742c <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
8000669a:	c8 12       	ld.a %a2,[%a15]4
8000669c:	60 a3       	mov.a %a3,%d10
8000669e:	30 32       	add.a %a2,%a3
800066a0:	99 22 08 00 	ld.a %a2,[%a2]8
800066a4:	bc 23       	jz.a %a2,800066aa <IfxScuCcu_init+0x35e>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
800066a6:	2d 02 00 00 	calli %a2
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
800066aa:	c8 12       	ld.a %a2,[%a15]4
800066ac:	60 a3       	mov.a %a3,%d10
800066ae:	c2 1d       	add %d13,1
800066b0:	30 32       	add.a %a2,%a3
800066b2:	19 24 04 00 	ld.w %d4,[%a2]4
800066b6:	6d ff a7 fc 	call 80006004 <IfxScuCcu_wait>
800066ba:	3c d6       	j 80006666 <IfxScuCcu_init+0x31a>
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800066bc:	02 84       	mov %d4,%d8
800066be:	6d 00 31 05 	call 80007120 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
800066c2:	91 30 00 ff 	movh.a %a15,61443
800066c6:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800066ca:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066cc:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
800066ce:	8f 0f c4 f1 	andn %d15,%d15,64
800066d2:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066d4:	6d 00 ac 06 	call 8000742c <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800066d8:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800066dc:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;
800066de:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800066e2:	6d 00 04 05 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
800066e6:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800066e8:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800066ea:	96 08       	or %d15,8
800066ec:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800066ee:	91 30 00 ff 	movh.a %a15,61443
800066f2:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800066f6:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800066f8:	02 94       	mov %d4,%d9
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800066fa:	8f 8f c0 f1 	andn %d15,%d15,8
800066fe:	a6 fc       	or %d12,%d15
80006700:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006702:	6d 00 29 06 	call 80007354 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80006706:	02 b2       	mov %d2,%d11
80006708:	00 90       	ret 

8000670a <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
8000670a:	91 00 00 f8 	movh.a %a15,32768
8000670e:	d9 ff 88 90 	lea %a15,[%a15]2632 <80000a48 <IfxScuCcu_defaultClockConfig>>
80006712:	c5 02 14 00 	lea %a2,14 <_.+0x13>
80006716:	44 ff       	ld.w %d15,[%a15+]
80006718:	64 4f       	st.w [%a4+],%d15
8000671a:	fc 2e       	loop %a2,80006716 <IfxScuCcu_initConfig+0xc>
8000671c:	00 90       	ret 

8000671e <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
8000671e:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006720:	6d 00 e5 05 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
80006724:	02 2f       	mov %d15,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006726:	6d 00 00 06 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000672a:	02 f4       	mov %d4,%d15
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000672c:	02 28       	mov %d8,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000672e:	6d 00 de 04 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006732:	91 30 00 ff 	movh.a %a15,61443
80006736:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000673a:	48 03       	ld.w %d3,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
8000673c:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000673e:	02 f4       	mov %d4,%d15
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006740:	8f 82 40 21 	or %d2,%d2,8
80006744:	68 02       	st.w [%a15]0,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006746:	37 03 e1 a1 	extr.u %d10,%d3,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000674a:	6d 00 05 06 	call 80007354 <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000674e:	02 84       	mov %d4,%d8
80006750:	6d 00 e8 04 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
80006754:	91 30 00 ff 	movh.a %a15,61443
80006758:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000675c:	48 02       	ld.w %d2,[%a15]0
8000675e:	ef 02 0c 00 	jz.t %d2,16,80006776 <IfxScuCcu_initErayPll+0x58>
80006762:	48 02       	ld.w %d2,[%a15]0
80006764:	6f 12 09 80 	jnz.t %d2,1,80006776 <IfxScuCcu_initErayPll+0x58>
80006768:	91 30 00 ff 	movh.a %a15,61443
8000676c:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006770:	48 02       	ld.w %d2,[%a15]0
80006772:	6f 12 19 00 	jz.t %d2,1,800067a4 <IfxScuCcu_initErayPll+0x86>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
80006776:	91 30 00 ff 	movh.a %a15,61443
8000677a:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000677e:	48 02       	ld.w %d2,[%a15]0
80006780:	b7 f2 01 28 	insert %d2,%d2,15,16,1
80006784:	68 02       	st.w [%a15]0,%d2
        SCU_PLLERAYCON0.B.VCOPWD = 0;
80006786:	48 02       	ld.w %d2,[%a15]0
80006788:	8f 22 c0 21 	andn %d2,%d2,2
8000678c:	68 02       	st.w [%a15]0,%d2

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
8000678e:	91 30 00 ff 	movh.a %a15,61443
80006792:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006796:	48 02       	ld.w %d2,[%a15]0
80006798:	6f 12 ff ff 	jnz.t %d2,1,80006796 <IfxScuCcu_initErayPll+0x78>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
8000679c:	19 c4 04 00 	ld.w %d4,[%a12]4
800067a0:	6d ff 32 fc 	call 80006004 <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
800067a4:	91 30 00 ff 	movh.a %a15,61443
800067a8:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800067ac:	48 02       	ld.w %d2,[%a15]0
800067ae:	6f 02 15 80 	jnz.t %d2,0,800067d8 <IfxScuCcu_initErayPll+0xba>
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
800067b2:	48 02       	ld.w %d2,[%a15]0
800067b4:	6f 42 ff 7f 	jz.t %d2,4,800067b2 <IfxScuCcu_initErayPll+0x94>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
800067b8:	91 30 00 ff 	movh.a %a15,61443
800067bc:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800067c0:	48 02       	ld.w %d2,[%a15]0
800067c2:	b7 32 07 28 	insert %d2,%d2,3,16,7
800067c6:	68 02       	st.w [%a15]0,%d2

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
800067c8:	91 30 00 ff 	movh.a %a15,61443
800067cc:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800067d0:	48 02       	ld.w %d2,[%a15]0
800067d2:	8f 12 40 21 	or %d2,%d2,1
800067d6:	68 02       	st.w [%a15]0,%d2
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
800067d8:	91 30 00 ff 	movh.a %a15,61443
800067dc:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800067e0:	48 02       	ld.w %d2,[%a15]0
800067e2:	6f 52 ff 7f 	jz.t %d2,5,800067e0 <IfxScuCcu_initErayPll+0xc2>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
800067e6:	91 30 00 ff 	movh.a %a15,61443
800067ea:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800067ee:	48 03       	ld.w %d3,[%a15]0
800067f0:	39 c2 02 00 	ld.bu %d2,[%a12]2 <f0030000 <_SMALL_DATA4_+0x40028000>>
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800067f4:	02 84       	mov %d4,%d8
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
800067f6:	37 23 07 20 	insert %d2,%d3,%d2,0,7
800067fa:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
800067fc:	91 30 00 ff 	movh.a %a15,61443
80006800:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006804:	48 03       	ld.w %d3,[%a15]0
80006806:	14 c2       	ld.bu %d2,[%a12]
80006808:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
8000680c:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
8000680e:	48 03       	ld.w %d3,[%a15]0
80006810:	39 c2 01 00 	ld.bu %d2,[%a12]1
80006814:	37 23 85 24 	insert %d2,%d3,%d2,9,5
80006818:	68 02       	st.w [%a15]0,%d2
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
8000681a:	48 02       	ld.w %d2,[%a15]0
8000681c:	b7 f2 01 29 	insert %d2,%d2,15,18,1
80006820:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
80006822:	48 02       	ld.w %d2,[%a15]0
80006824:	8f 02 42 21 	or %d2,%d2,32
80006828:	68 02       	st.w [%a15]0,%d2

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000682a:	6d 00 01 06 	call 8000742c <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
8000682e:	91 10 00 f0 	movh.a %a15,1
80006832:	91 30 00 2f 	movh.a %a2,61443
80006836:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000683a:	d9 ff 0f dc 	lea %a15,[%a15]-15537 <c34f <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4f>>
8000683e:	fd f0 04 00 	loop %a15,80006846 <IfxScuCcu_initErayPll+0x128>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
80006842:	82 19       	mov %d9,1
80006844:	3c 05       	j 8000684e <IfxScuCcu_initErayPll+0x130>
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
80006846:	54 22       	ld.w %d2,[%a2]
80006848:	6f 22 fb 7f 	jz.t %d2,2,8000683e <IfxScuCcu_initErayPll+0x120>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
8000684c:	82 09       	mov %d9,0
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000684e:	02 84       	mov %d4,%d8
80006850:	6d 00 68 04 	call 80007120 <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
80006854:	91 30 00 ff 	movh.a %a15,61443
80006858:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000685c:	48 02       	ld.w %d2,[%a15]0
8000685e:	8f 12 c0 21 	andn %d2,%d2,1
80006862:	68 02       	st.w [%a15]0,%d2

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
80006864:	91 30 00 ff 	movh.a %a15,61443
80006868:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000686c:	48 02       	ld.w %d2,[%a15]0
8000686e:	6f 02 ff ff 	jnz.t %d2,0,8000686c <IfxScuCcu_initErayPll+0x14e>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
80006872:	91 30 00 ff 	movh.a %a15,61443
80006876:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000687a:	48 02       	ld.w %d2,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000687c:	02 84       	mov %d4,%d8

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
8000687e:	37 02 61 21 	extr.u %d2,%d2,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006882:	91 30 00 ff 	movh.a %a15,61443
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
80006886:	ab 19 80 92 	sel %d9,%d2,%d9,1
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000688a:	6d 00 d1 05 	call 8000742c <IfxScuWdt_setSafetyEndinit>

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000688e:	02 f4       	mov %d4,%d15
80006890:	6d 00 2d 04 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006894:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
80006898:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000689a:	8f 3a 00 30 	sh %d3,%d10,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000689e:	8f 82 40 21 	or %d2,%d2,8
800068a2:	68 02       	st.w [%a15]0,%d2
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800068a4:	91 30 00 ff 	movh.a %a15,61443
800068a8:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800068ac:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800068ae:	02 f4       	mov %d4,%d15
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800068b0:	8f 82 c0 21 	andn %d2,%d2,8
800068b4:	a6 32       	or %d2,%d3
800068b6:	68 02       	st.w [%a15]0,%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
800068b8:	6d 00 4e 05 	call 80007354 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
800068bc:	02 92       	mov %d2,%d9
800068be:	00 90       	ret 

800068c0 <IfxScuCcu_initErayPllConfig>:


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
800068c0:	91 00 00 f8 	movh.a %a15,32768
800068c4:	d9 ff 80 90 	lea %a15,[%a15]2624 <80000a40 <IfxScuCcu_defaultErayPllConfig>>
800068c8:	09 f2 40 09 	ld.d %e2,[%a15]
800068cc:	89 42 40 09 	st.d [%a4],%e2
800068d0:	00 90       	ret 

800068d2 <IfxScuCcu_setCpuFrequency>:
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
800068d2:	02 5a       	mov %d10,%d5
800068d4:	02 49       	mov %d9,%d4
    uint16  endinitSfty_pw;
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();
800068d6:	6d ff a7 fc 	call 80006224 <IfxScuCcu_getSriFrequency>
800068da:	02 2f       	mov %d15,%d2

    if (cpuFreq >= sriFreq)
800068dc:	4b 2a 01 20 	cmp.f %d2,%d10,%d2
800068e0:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
    {
        cpuDiv = 0;
800068e4:	82 08       	mov %d8,0
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
800068e6:	f6 29       	jnz %d2,800068f8 <IfxScuCcu_setCpuFrequency+0x26>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
800068e8:	7b 00 28 84 	movh %d8,17024
800068ec:	4b 8a 41 80 	mul.f %d8,%d10,%d8
800068f0:	4b f8 51 80 	div.f %d8,%d8,%d15
800068f4:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800068f8:	6d 00 17 05 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800068fc:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800068fe:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006900:	6d 00 10 04 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
80006904:	df 19 0f 00 	jeq %d9,1,80006922 <IfxScuCcu_setCpuFrequency+0x50>
80006908:	76 98       	jz %d9,80006918 <IfxScuCcu_setCpuFrequency+0x46>
8000690a:	df 29 11 80 	jne %d9,2,8000692c <IfxScuCcu_setCpuFrequency+0x5a>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
8000690e:	91 30 00 ff 	movh.a %a15,61443
80006912:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80006916:	3c 0a       	j 8000692a <IfxScuCcu_setCpuFrequency+0x58>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
80006918:	91 30 00 ff 	movh.a %a15,61443
8000691c:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006920:	3c 05       	j 8000692a <IfxScuCcu_setCpuFrequency+0x58>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
80006922:	91 30 00 ff 	movh.a %a15,61443
80006926:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
8000692a:	68 08       	st.w [%a15]0,%d8

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000692c:	02 a4       	mov %d4,%d10
8000692e:	6d 00 7f 05 	call 8000742c <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
80006932:	76 89       	jz %d8,80006944 <IfxScuCcu_setCpuFrequency+0x72>
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
80006934:	4b 08 61 81 	utof %d8,%d8
80006938:	7b 00 c8 23 	movh %d2,15488
8000693c:	4b 28 41 80 	mul.f %d8,%d8,%d2
80006940:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
80006944:	02 f2       	mov %d2,%d15
80006946:	00 90       	ret 

80006948 <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80006948:	91 30 00 ff 	movh.a %a15,61443
8000694c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
    return sriFreq;
}


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
80006950:	02 48       	mov %d8,%d4
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80006952:	4c f0       	ld.w %d15,[%a15]0

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006954:	6d ff 46 fb 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
80006958:	4b 82 51 20 	div.f %d2,%d2,%d8
8000695c:	4b 02 31 31 	ftoiz %d3,%d2
80006960:	4b 03 41 41 	itof %d4,%d3
80006964:	6b 04 31 22 	sub.f %d2,%d2,%d4
80006968:	7b 00 f0 43 	movh %d4,16128
8000696c:	4b 42 01 20 	cmp.f %d2,%d2,%d4
80006970:	37 02 61 21 	extr.u %d2,%d2,2,1
80006974:	42 32       	add %d2,%d3
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80006976:	82 13       	mov %d3,1
80006978:	0b 32 b0 21 	max.u %d2,%d2,%d3
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
8000697c:	8b e2 00 52 	eq %d5,%d2,14
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
80006980:	1b 92 ff 4f 	addi %d4,%d2,-7
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
    {
        gtmDiv = 12;
80006984:	ab c2 a0 95 	seln %d9,%d5,%d2,12
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
80006988:	8f 12 c0 31 	andn %d3,%d2,1
8000698c:	02 92       	mov %d2,%d9
8000698e:	8b 74 a0 92 	ge.u %d9,%d4,7
80006992:	2b 32 40 99 	sel %d9,%d9,%d2,%d3
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006996:	6d 00 c8 04 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
8000699a:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
8000699c:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
8000699e:	6d 00 c1 03 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
800069a2:	40 f2       	mov.aa %a2,%a15
800069a4:	54 22       	ld.w %d2,[%a2]
800069a6:	91 30 00 ff 	movh.a %a15,61443
800069aa:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800069ae:	bf 02 fb 7f 	jlt %d2,0,800069a4 <IfxScuCcu_setGtmFrequency+0x5c>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
800069b2:	37 9f 04 f6 	insert %d15,%d15,%d9,12,4
    ccucon1.B.UP     = 1U;
800069b6:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800069ba:	02 84       	mov %d4,%d8
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
800069bc:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800069be:	6d 00 37 05 	call 8000742c <IfxScuWdt_setSafetyEndinit>
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
800069c2:	6d ff 0f fb 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
800069c6:	4c f0       	ld.w %d15,[%a15]0
800069c8:	37 0f 64 f6 	extr.u %d15,%d15,12,4
800069cc:	4b 0f 41 f1 	itof %d15,%d15

    return IfxScuCcu_getGtmFrequency();
}
800069d0:	4b f2 51 20 	div.f %d2,%d2,%d15
800069d4:	00 90       	ret 

800069d6 <IfxScuCcu_setPll2ErayFrequency>:


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
800069d6:	02 48       	mov %d8,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
800069d8:	6d 00 a7 04 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
800069dc:	02 2f       	mov %d15,%d2
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800069de:	6d ff 84 fa 	call 80005ee6 <IfxScuCcu_getPllErayVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(password);
800069e2:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800069e4:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(password);
800069e6:	6d 00 9d 03 	call 80007120 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800069ea:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
800069ee:	91 30 00 ff 	movh.a %a15,61443
800069f2:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800069f6:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800069f8:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
800069fc:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800069fe:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006a02:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80006a06:	37 82 04 84 	insert %d8,%d2,%d8,8,4
80006a0a:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(password);
80006a0c:	6d 00 10 05 	call 8000742c <IfxScuWdt_setSafetyEndinit>

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
80006a10:	6d ff 6b fa 	call 80005ee6 <IfxScuCcu_getPllErayVcoFrequency>
80006a14:	4c f0       	ld.w %d15,[%a15]0
80006a16:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80006a1a:	c2 1f       	add %d15,1
80006a1c:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
80006a20:	4b f2 51 20 	div.f %d2,%d2,%d15
80006a24:	00 90       	ret 

80006a26 <IfxScuCcu_setPll2Frequency>:


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
80006a26:	02 48       	mov %d8,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006a28:	6d 00 7f 04 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
80006a2c:	02 2f       	mov %d15,%d2
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a2e:	6d ff b7 fa 	call 80005f9c <IfxScuCcu_getPllVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006a32:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a34:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006a36:	6d 00 75 03 	call 80007120 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a3a:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006a3e:	91 30 00 ff 	movh.a %a15,61443
80006a42:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80006a46:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a48:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006a4c:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006a4e:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006a52:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006a56:	37 82 07 84 	insert %d8,%d2,%d8,8,7
80006a5a:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006a5c:	6d 00 e8 04 	call 8000742c <IfxScuWdt_setSafetyEndinit>


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80006a60:	6d ff 9e fa 	call 80005f9c <IfxScuCcu_getPllVcoFrequency>
80006a64:	4c f0       	ld.w %d15,[%a15]0
80006a66:	37 0f 67 f4 	extr.u %d15,%d15,8,7
80006a6a:	c2 1f       	add %d15,1
80006a6c:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2Frequency();
}
80006a70:	4b f2 51 20 	div.f %d2,%d2,%d15
80006a74:	00 90       	ret 

80006a76 <IfxScuCcu_setSpbFrequency>:


float32 IfxScuCcu_setSpbFrequency(float32 spbFreq)
{
80006a76:	02 4f       	mov %d15,%d4
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006a78:	6d ff b4 fa 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80006a7c:	4b f2 51 20 	div.f %d2,%d2,%d15
80006a80:	82 24       	mov %d4,2
80006a82:	4b 02 71 21 	ftouz %d2,%d2
80006a86:	0b 42 b0 41 	max.u %d4,%d2,%d4
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
80006a8a:	8b e4 00 32 	eq %d3,%d4,14
    {
        spbDiv = 12;
80006a8e:	ab c4 a0 a3 	seln %d10,%d3,%d4,12
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
80006a92:	1b 94 ff 2f 	addi %d2,%d4,-7
    {
        spbDiv = spbDiv - 1;
80006a96:	8f 14 c0 f1 	andn %d15,%d4,1
80006a9a:	02 a4       	mov %d4,%d10
80006a9c:	8b 72 a0 a2 	ge.u %d10,%d2,7
80006aa0:	2b f4 40 aa 	sel %d10,%d10,%d4,%d15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
80006aa4:	6d 00 23 04 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
80006aa8:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006aaa:	6d 00 3e 04 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006aae:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006ab0:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006ab2:	6d 00 1c 03 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006ab6:	91 30 00 ff 	movh.a %a15,61443
80006aba:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006abe:	48 02       	ld.w %d2,[%a15]0
80006ac0:	3b 00 3e f0 	mov %d15,992
80006ac4:	a6 2f       	or %d15,%d2
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006ac6:	02 84       	mov %d4,%d8

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006ac8:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006aca:	6d 00 45 04 	call 80007354 <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006ace:	02 94       	mov %d4,%d9
80006ad0:	6d 00 28 03 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006ad4:	91 30 00 2f 	movh.a %a2,61443
80006ad8:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006adc:	4c 20       	ld.w %d15,[%a2]0
80006ade:	91 30 00 ff 	movh.a %a15,61443
80006ae2:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006ae6:	bf 0f fb 7f 	jlt %d15,0,80006adc <IfxScuCcu_setSpbFrequency+0x66>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006aea:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006aec:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
80006aee:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
80006af2:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006af6:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006af8:	6d 00 9a 04 	call 8000742c <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006afc:	02 84       	mov %d4,%d8
80006afe:	6d 00 f6 02 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80006b02:	91 30 00 ff 	movh.a %a15,61443
80006b06:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006b0a:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b0c:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80006b0e:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
80006b12:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006b14:	6d 00 20 04 	call 80007354 <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006b18:	91 30 00 ff 	movh.a %a15,61443
80006b1c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b20:	4c f0       	ld.w %d15,[%a15]0
80006b22:	bf 0f ff 7f 	jlt %d15,0,80006b20 <IfxScuCcu_setSpbFrequency+0xaa>
    {}

    return IfxScuCcu_getSpbFrequency();
80006b26:	1d ff 1e fb 	j 80006162 <IfxScuCcu_getSpbFrequency>

80006b2a <IfxScuCcu_setSriFrequency>:
}


float32 IfxScuCcu_setSriFrequency(float32 sriFreq)
{
80006b2a:	02 4f       	mov %d15,%d4
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
80006b2c:	6d ff 5a fa 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
80006b30:	4b f2 51 20 	div.f %d2,%d2,%d15
80006b34:	4b 02 31 31 	ftoiz %d3,%d2
80006b38:	4b 03 41 f1 	itof %d15,%d3
80006b3c:	6b 0f 31 22 	sub.f %d2,%d2,%d15
80006b40:	7b 00 f0 f3 	movh %d15,16128
80006b44:	4b f2 01 f0 	cmp.f %d15,%d2,%d15
80006b48:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80006b4c:	82 12       	mov %d2,1
80006b4e:	42 3f       	add %d15,%d3
80006b50:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
80006b54:	8b ef 00 42 	eq %d4,%d15,14
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
80006b58:	92 93       	add %d3,%d15,-7
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
    {
        sriDiv = 12;
80006b5a:	ab cf a0 94 	seln %d9,%d4,%d15,12
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
80006b5e:	8f 1f c0 21 	andn %d2,%d15,1
80006b62:	02 9f       	mov %d15,%d9
80006b64:	8b 73 a0 92 	ge.u %d9,%d3,7
80006b68:	2b 2f 40 99 	sel %d9,%d9,%d15,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006b6c:	6d 00 dd 03 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006b70:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006b72:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006b74:	6d 00 d6 02 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006b78:	91 30 00 2f 	movh.a %a2,61443
80006b7c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b80:	4c 20       	ld.w %d15,[%a2]0
80006b82:	91 30 00 ff 	movh.a %a15,61443
80006b86:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b8a:	bf 0f fb 7f 	jlt %d15,0,80006b80 <IfxScuCcu_setSriFrequency+0x56>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006b8e:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006b90:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
80006b92:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
80006b96:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006b9a:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006b9c:	6d 00 48 04 	call 8000742c <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006ba0:	4c f0       	ld.w %d15,[%a15]0
80006ba2:	bf 0f ff 7f 	jlt %d15,0,80006ba0 <IfxScuCcu_setSriFrequency+0x76>
    {}

    freq = IfxScuCcu_getSriFrequency();
80006ba6:	1d ff 3f fb 	j 80006224 <IfxScuCcu_getSriFrequency>

80006baa <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80006baa:	91 30 00 ff 	movh.a %a15,61443
80006bae:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006bb2:	4c f0       	ld.w %d15,[%a15]0
80006bb4:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80006bb8:	df 0f 81 00 	jeq %d15,0,80006cba <IfxScuCcu_switchToBackupClock+0x110>
80006bbc:	40 4f       	mov.aa %a15,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006bbe:	6d 00 b4 03 	call 80007326 <IfxScuWdt_getSafetyWatchdogPassword>
80006bc2:	02 29       	mov %d9,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006bc4:	6d 00 93 03 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006bc8:	0c f0       	ld.bu %d15,[%a15]0
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006bca:	02 28       	mov %d8,%d2
80006bcc:	53 cf 20 20 	mul %d2,%d15,12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006bd0:	91 30 00 ef 	movh.a %a14,61443
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006bd4:	91 30 00 df 	movh.a %a13,61443
80006bd8:	60 22       	mov.a %a2,%d2
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006bda:	d9 ee 14 06 	lea %a14,[%a14]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006bde:	d9 2c f4 ff 	lea %a12,[%a2]-12 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006be2:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006be6:	6e 1b       	jz %d15,80006c1c <IfxScuCcu_switchToBackupClock+0x72>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006be8:	02 94       	mov %d4,%d9
80006bea:	6d 00 9b 02 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006bee:	54 e2       	ld.w %d2,[%a14]
80006bf0:	6f 52 ff 7f 	jz.t %d2,5,80006bee <IfxScuCcu_switchToBackupClock+0x44>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006bf4:	c8 12       	ld.a %a2,[%a15]4
80006bf6:	54 d3       	ld.w %d3,[%a13]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006bf8:	02 94       	mov %d4,%d9
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006bfa:	30 c2       	add.a %a2,%a12
80006bfc:	14 22       	ld.bu %d2,[%a2]

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006bfe:	c2 ff       	add %d15,-1
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006c00:	37 23 07 20 	insert %d2,%d3,%d2,0,7
80006c04:	74 d2       	st.w [%a13],%d2

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006c06:	6d 00 13 04 	call 8000742c <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80006c0a:	c8 12       	ld.a %a2,[%a15]4
80006c0c:	30 c2       	add.a %a2,%a12
80006c0e:	19 24 04 00 	ld.w %d4,[%a2]4
80006c12:	6d ff f9 f9 	call 80006004 <IfxScuCcu_wait>
80006c16:	d9 cc f4 ff 	lea %a12,[%a12]-12
80006c1a:	3c e6       	j 80006be6 <IfxScuCcu_switchToBackupClock+0x3c>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006c1c:	02 84       	mov %d4,%d8
80006c1e:	6d 00 66 02 	call 800070ea <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006c22:	91 30 00 ff 	movh.a %a15,61443
80006c26:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006c2a:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006c2c:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006c2e:	02 84       	mov %d4,%d8
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006c30:	96 08       	or %d15,8
80006c32:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006c34:	37 02 e1 a1 	extr.u %d10,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006c38:	6d 00 8e 03 	call 80007354 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006c3c:	02 94       	mov %d4,%d9
80006c3e:	6d 00 71 02 	call 80007120 <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
80006c42:	91 30 00 2f 	movh.a %a2,61443
80006c46:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c4a:	4c 20       	ld.w %d15,[%a2]0
80006c4c:	91 30 00 ff 	movh.a %a15,61443
80006c50:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006c54:	bf 0f fb 7f 	jlt %d15,0,80006c4a <IfxScuCcu_switchToBackupClock+0xa0>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80006c58:	4c f0       	ld.w %d15,[%a15]0
80006c5a:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006c5e:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006c60:	4c f0       	ld.w %d15,[%a15]0
80006c62:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006c66:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
80006c68:	4c f0       	ld.w %d15,[%a15]0
80006c6a:	bf 0f ff 7f 	jlt %d15,0,80006c68 <IfxScuCcu_switchToBackupClock+0xbe>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006c6e:	91 30 00 ff 	movh.a %a15,61443
80006c72:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006c76:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006c78:	02 94       	mov %d4,%d9
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006c7a:	96 10       	or %d15,16
80006c7c:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006c7e:	4c f0       	ld.w %d15,[%a15]0
80006c80:	8f 0f c4 f1 	andn %d15,%d15,64
80006c84:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006c86:	6d 00 d3 03 	call 8000742c <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006c8a:	91 30 00 ff 	movh.a %a15,61443
80006c8e:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006c92:	02 84       	mov %d4,%d8
80006c94:	6d 00 2b 02 	call 800070ea <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006c98:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006c9a:	8f 3a 00 20 	sh %d2,%d10,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006c9e:	96 08       	or %d15,8
80006ca0:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006ca2:	91 30 00 ff 	movh.a %a15,61443
80006ca6:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006caa:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006cac:	02 84       	mov %d4,%d8
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006cae:	8f 8f c0 f1 	andn %d15,%d15,8
80006cb2:	a6 2f       	or %d15,%d2
80006cb4:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006cb6:	1d 00 4f 03 	j 80007354 <IfxScuWdt_setCpuEndinit>
80006cba:	00 90       	ret 

80006cbc <IfxScuEru_clearAllEventFlags>:
/******************************************************************************/

void IfxScuEru_clearAllEventFlags(void)
{
    uint32 mask = (0xFF << 16);
    MODULE_SCU.FMR.U = mask;
80006cbc:	91 30 00 ff 	movh.a %a15,61443
80006cc0:	7b f0 0f f0 	movh %d15,255
80006cc4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006cc8:	59 ff 24 80 	st.w [%a15]548 <f0030224 <_SMALL_DATA4_+0x40028224>>,%d15
80006ccc:	00 90       	ret 

80006cce <IfxScuEru_clearEventFlag>:
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006cce:	1b 04 01 40 	addi %d4,%d4,16
80006cd2:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006cd4:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006cd8:	0f 4f 00 f0 	sh %d15,%d15,%d4
    SCU_FMR.U = mask;
80006cdc:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006ce0:	68 0f       	st.w [%a15]0,%d15
80006ce2:	00 90       	ret 

80006ce4 <IfxScuEru_clearInputChannelConfiguration>:


void IfxScuEru_clearInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ce4:	8f f4 1f f0 	sh %d15,%d4,-1
80006ce8:	06 2f       	sh %d15,2
80006cea:	60 ff       	mov.a %a15,%d15
80006cec:	d9 ff 00 06 	lea %a15,[%a15]24576
80006cf0:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006cf4:	19 ff 10 80 	ld.w %d15,[%a15]528
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006cf8:	6f 04 05 00 	jz.t %d4,0,80006d02 <IfxScuEru_clearInputChannelConfiguration+0x1e>
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006cfc:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006d00:	3c 03       	j 80006d06 <IfxScuEru_clearInputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006d02:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006d06:	59 ff 10 80 	st.w [%a15]528,%d15
80006d0a:	00 90       	ret 

80006d0c <IfxScuEru_clearOutputChannelConfiguration>:


void IfxScuEru_clearOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d0c:	8f f4 1f f0 	sh %d15,%d4,-1
80006d10:	06 2f       	sh %d15,2
80006d12:	60 ff       	mov.a %a15,%d15
80006d14:	d9 ff 00 06 	lea %a15,[%a15]24576
80006d18:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006d1c:	19 ff 2c 80 	ld.w %d15,[%a15]556
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006d20:	6f 04 05 00 	jz.t %d4,0,80006d2a <IfxScuEru_clearOutputChannelConfiguration+0x1e>
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006d24:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006d28:	3c 03       	j 80006d2e <IfxScuEru_clearOutputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006d2a:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006d2e:	59 ff 2c 80 	st.w [%a15]556,%d15
80006d32:	00 90       	ret 

80006d34 <IfxScuEru_connectTrigger>:


void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d34:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006d38:	91 30 00 ff 	movh.a %a15,61443
80006d3c:	1b 4f 08 f0 	addi %d15,%d15,132
80006d40:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d44:	8f 75 00 51 	and %d5,%d5,7
80006d48:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d4a:	6f 04 08 00 	jz.t %d4,0,80006d5a <IfxScuEru_connectTrigger+0x26>
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006d4e:	4c f0       	ld.w %d15,[%a15]0
80006d50:	8f c5 01 50 	sh %d5,%d5,28
80006d54:	b7 0f 03 fe 	insert %d15,%d15,0,28,3
80006d58:	3c 06       	j 80006d64 <IfxScuEru_connectTrigger+0x30>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.INP0 = triggerSelect;
80006d5a:	4c f0       	ld.w %d15,[%a15]0
80006d5c:	8f c5 00 50 	sh %d5,%d5,12
80006d60:	b7 0f 03 f6 	insert %d15,%d15,0,12,3
80006d64:	a6 f5       	or %d5,%d15
80006d66:	68 05       	st.w [%a15]0,%d5
80006d68:	00 90       	ret 

80006d6a <IfxScuEru_disableAutoClear>:


void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d6a:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006d6e:	91 30 00 ff 	movh.a %a15,61443
80006d72:	1b 4f 08 f0 	addi %d15,%d15,132
80006d76:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d7a:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d7c:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d7e:	6f 04 05 00 	jz.t %d4,0,80006d88 <IfxScuEru_disableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006d82:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80006d86:	3c 03       	j 80006d8c <IfxScuEru_disableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = FALSE;
80006d88:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80006d8c:	68 0f       	st.w [%a15]0,%d15
80006d8e:	00 90       	ret 

80006d90 <IfxScuEru_disableFallingEdgeDetection>:


void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d90:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006d94:	91 30 00 ff 	movh.a %a15,61443
80006d98:	1b 4f 08 f0 	addi %d15,%d15,132
80006d9c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006da0:	90 ff       	addsc.a %a15,%a15,%d15,2
80006da2:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006da4:	6f 04 05 00 	jz.t %d4,0,80006dae <IfxScuEru_disableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006da8:	b7 0f 01 fc 	insert %d15,%d15,0,24,1
80006dac:	3c 03       	j 80006db2 <IfxScuEru_disableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = FALSE;
80006dae:	8f 0f d0 f1 	andn %d15,%d15,256
80006db2:	68 0f       	st.w [%a15]0,%d15
80006db4:	00 90       	ret 

80006db6 <IfxScuEru_disablePatternDetectionTrigger>:


void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006db6:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006dba:	91 30 00 ff 	movh.a %a15,61443
80006dbe:	1b bf 08 f0 	addi %d15,%d15,139
80006dc2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dc6:	90 ff       	addsc.a %a15,%a15,%d15,2
80006dc8:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006dca:	6f 04 05 00 	jz.t %d4,0,80006dd4 <IfxScuEru_disablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006dce:	b7 0f 81 fe 	insert %d15,%d15,0,29,1
80006dd2:	3c 03       	j 80006dd8 <IfxScuEru_disablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = FALSE;
80006dd4:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80006dd8:	68 0f       	st.w [%a15]0,%d15
80006dda:	00 90       	ret 

80006ddc <IfxScuEru_disableRisingEdgeDetection>:


void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ddc:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006de0:	91 30 00 ff 	movh.a %a15,61443
80006de4:	1b 4f 08 f0 	addi %d15,%d15,132
80006de8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dec:	90 ff       	addsc.a %a15,%a15,%d15,2
80006dee:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006df0:	6f 04 05 00 	jz.t %d4,0,80006dfa <IfxScuEru_disableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006df4:	b7 0f 81 fc 	insert %d15,%d15,0,25,1
80006df8:	3c 03       	j 80006dfe <IfxScuEru_disableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = FALSE;
80006dfa:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80006dfe:	68 0f       	st.w [%a15]0,%d15
80006e00:	00 90       	ret 

80006e02 <IfxScuEru_disableTriggerPulse>:


void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e02:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006e06:	91 30 00 ff 	movh.a %a15,61443
80006e0a:	1b 4f 08 f0 	addi %d15,%d15,132
80006e0e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e12:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e14:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e16:	6f 04 05 00 	jz.t %d4,0,80006e20 <IfxScuEru_disableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006e1a:	b7 0f 81 fd 	insert %d15,%d15,0,27,1
80006e1e:	3c 03       	j 80006e24 <IfxScuEru_disableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = FALSE;
80006e20:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80006e24:	68 0f       	st.w [%a15]0,%d15
80006e26:	00 90       	ret 

80006e28 <IfxScuEru_enableAutoClear>:


void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e28:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006e2c:	91 30 00 ff 	movh.a %a15,61443
80006e30:	1b 4f 08 f0 	addi %d15,%d15,132
80006e34:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e38:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e3a:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e3c:	6f 04 05 00 	jz.t %d4,0,80006e46 <IfxScuEru_enableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006e40:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80006e44:	3c 03       	j 80006e4a <IfxScuEru_enableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = TRUE;
80006e46:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80006e4a:	68 0f       	st.w [%a15]0,%d15
80006e4c:	00 90       	ret 

80006e4e <IfxScuEru_enableFallingEdgeDetection>:


void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e4e:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006e52:	91 30 00 ff 	movh.a %a15,61443
80006e56:	1b 4f 08 f0 	addi %d15,%d15,132
80006e5a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e5e:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e60:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006e62:	6f 04 05 00 	jz.t %d4,0,80006e6c <IfxScuEru_enableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006e66:	b7 ff 01 fc 	insert %d15,%d15,15,24,1
80006e6a:	3c 03       	j 80006e70 <IfxScuEru_enableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = TRUE;
80006e6c:	8f 0f 50 f1 	or %d15,%d15,256
80006e70:	68 0f       	st.w [%a15]0,%d15
80006e72:	00 90       	ret 

80006e74 <IfxScuEru_enablePatternDetectionTrigger>:


void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e74:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006e78:	91 30 00 ff 	movh.a %a15,61443
80006e7c:	1b bf 08 f0 	addi %d15,%d15,139
80006e80:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e84:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e86:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e88:	6f 04 05 00 	jz.t %d4,0,80006e92 <IfxScuEru_enablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006e8c:	b7 ff 81 fe 	insert %d15,%d15,15,29,1
80006e90:	3c 03       	j 80006e96 <IfxScuEru_enablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = TRUE;
80006e92:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80006e96:	68 0f       	st.w [%a15]0,%d15
80006e98:	00 90       	ret 

80006e9a <IfxScuEru_enableRisingEdgeDetection>:


void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e9a:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006e9e:	91 30 00 ff 	movh.a %a15,61443
80006ea2:	1b 4f 08 f0 	addi %d15,%d15,132
80006ea6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006eaa:	90 ff       	addsc.a %a15,%a15,%d15,2
80006eac:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006eae:	6f 04 05 00 	jz.t %d4,0,80006eb8 <IfxScuEru_enableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006eb2:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80006eb6:	3c 03       	j 80006ebc <IfxScuEru_enableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = TRUE;
80006eb8:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80006ebc:	68 0f       	st.w [%a15]0,%d15
80006ebe:	00 90       	ret 

80006ec0 <IfxScuEru_enableTriggerPulse>:


void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ec0:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006ec4:	91 30 00 ff 	movh.a %a15,61443
80006ec8:	1b 4f 08 f0 	addi %d15,%d15,132
80006ecc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ed0:	90 ff       	addsc.a %a15,%a15,%d15,2
80006ed2:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006ed4:	6f 04 05 00 	jz.t %d4,0,80006ede <IfxScuEru_enableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006ed8:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80006edc:	3c 03       	j 80006ee2 <IfxScuEru_enableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = TRUE;
80006ede:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80006ee2:	68 0f       	st.w [%a15]0,%d15
80006ee4:	00 90       	ret 

80006ee6 <IfxScuEru_getAllEventFlagsStatus>:
}


uint32 IfxScuEru_getAllEventFlagsStatus(void)
{
    return MODULE_SCU.EIFR.U;
80006ee6:	91 30 00 ff 	movh.a %a15,61443
80006eea:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006eee:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006ef2:	00 90       	ret 

80006ef4 <IfxScuEru_getEventFlagStatus>:


boolean IfxScuEru_getEventFlagStatus(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = (1U << inputChannel);
    return (MODULE_SCU.EIFR.U & mask) ? TRUE : FALSE;
80006ef4:	91 30 00 ff 	movh.a %a15,61443
80006ef8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006efc:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006f00:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006f04:	00 90       	ret 

80006f06 <IfxScuEru_getInputChannelConfiguration>:


uint32 IfxScuEru_getInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f06:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006f0a:	91 30 00 ff 	movh.a %a15,61443
80006f0e:	1b 4f 08 f0 	addi %d15,%d15,132
80006f12:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f16:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f18:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006f1a:	6f 04 05 00 	jz.t %d4,0,80006f24 <IfxScuEru_getInputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006f1e:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006f22:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.EICR[index].U & mask);
80006f24:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006f28:	00 90       	ret 

80006f2a <IfxScuEru_getOutputChannelConfiguration>:


uint32 IfxScuEru_getOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f2a:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006f2e:	91 30 00 ff 	movh.a %a15,61443
80006f32:	1b bf 08 f0 	addi %d15,%d15,139
80006f36:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f3a:	90 ff       	addsc.a %a15,%a15,%d15,2
80006f3c:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006f3e:	6f 04 05 00 	jz.t %d4,0,80006f48 <IfxScuEru_getOutputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006f42:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006f46:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.IGCR[index].U & mask);
80006f48:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006f4c:	00 90       	ret 

80006f4e <IfxScuEru_getPatternDetectionResult>:


boolean IfxScuEru_getPatternDetectionResult(IfxScuEru_OutputChannel outputChannel)
{
    uint32 mask = (1U << outputChannel);
    return (MODULE_SCU.PDRR.U & mask) ? TRUE : FALSE;
80006f4e:	91 30 00 ff 	movh.a %a15,61443
80006f52:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f56:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006f5a:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006f5e:	00 90       	ret 

80006f60 <IfxScuEru_getWholePatternDetectionResult>:


uint32 IfxScuEru_getWholePatternDetectionResult(void)
{
    return MODULE_SCU.PDRR.U;
80006f60:	91 30 00 ff 	movh.a %a15,61443
80006f64:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f68:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006f6c:	00 90       	ret 

80006f6e <IfxScuEru_selectExternalInput>:


void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006f6e:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006f72:	91 30 00 ff 	movh.a %a15,61443
80006f76:	1b 4f 08 f0 	addi %d15,%d15,132
80006f7a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006f7e:	8f 75 00 51 	and %d5,%d5,7
80006f82:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006f84:	6f 04 08 00 	jz.t %d4,0,80006f94 <IfxScuEru_selectExternalInput+0x26>
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006f88:	4c f0       	ld.w %d15,[%a15]0
80006f8a:	8f 45 01 50 	sh %d5,%d5,20
80006f8e:	b7 0f 03 fa 	insert %d15,%d15,0,20,3
80006f92:	3c 05       	j 80006f9c <IfxScuEru_selectExternalInput+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EXIS0 = inputSignal;
80006f94:	4c f0       	ld.w %d15,[%a15]0
80006f96:	06 45       	sh %d5,4
80006f98:	8f 0f c7 f1 	andn %d15,%d15,112
80006f9c:	a6 f5       	or %d5,%d15
80006f9e:	68 05       	st.w [%a15]0,%d5
80006fa0:	00 90       	ret 

80006fa2 <IfxScuEru_setEventFlag>:
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006fa2:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006fa4:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006fa8:	0f 4f 00 40 	sh %d4,%d15,%d4
    SCU_FMR.U = mask;
80006fac:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006fb0:	68 04       	st.w [%a15]0,%d4
80006fb2:	00 90       	ret 

80006fb4 <IfxScuEru_setFlagPatternDetection>:
}


void IfxScuEru_setFlagPatternDetection(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InputChannel inputChannel, boolean state)
{
80006fb4:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 shift, mask;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD) // for channels 1, 3 ,5 and 7
80006fb8:	6f 04 04 00 	jz.t %d4,0,80006fc0 <IfxScuEru_setFlagPatternDetection+0xc>
    {
        shift = (inputChannel + 16);                  // offset at location IPEN10
80006fbc:	1b 05 01 50 	addi %d5,%d5,16
80006fc0:	06 2f       	sh %d15,2
80006fc2:	60 f2       	mov.a %a2,%d15
80006fc4:	d9 2f 00 06 	lea %a15,[%a2]24576
80006fc8:	11 3f 00 ff 	addih.a %a15,%a15,61443
    {
        shift = inputChannel;
        mask  = (1 << shift);
        // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
        uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & ~mask) | ((uint32)state << shift);
80006fcc:	19 ff 2c 80 	ld.w %d15,[%a15]556
80006fd0:	d7 0f 01 f5 	insert %d15,%d15,0,%d5,1
80006fd4:	0f 56 00 50 	sh %d5,%d6,%d5
80006fd8:	a6 f5       	or %d5,%d15
80006fda:	59 f5 2c 80 	st.w [%a15]556,%d5
80006fde:	00 90       	ret 

80006fe0 <IfxScuEru_setInterruptGatingPattern>:


void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006fe0:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80006fe4:	91 30 00 ff 	movh.a %a15,61443
80006fe8:	1b bf 08 f0 	addi %d15,%d15,139
80006fec:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ff0:	8f 35 00 51 	and %d5,%d5,3
80006ff4:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006ff6:	6f 04 06 00 	jz.t %d4,0,80007002 <IfxScuEru_setInterruptGatingPattern+0x22>
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80006ffa:	4c f0       	ld.w %d15,[%a15]0
80006ffc:	37 5f 02 5f 	insert %d5,%d15,%d5,30,2
80007000:	3c 07       	j 8000700e <IfxScuEru_setInterruptGatingPattern+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.IGP0 = gatingPattern;
80007002:	4c f0       	ld.w %d15,[%a15]0
80007004:	8f e5 00 50 	sh %d5,%d5,14
80007008:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
8000700c:	a6 f5       	or %d5,%d15
8000700e:	68 05       	st.w [%a15]0,%d5
80007010:	00 90       	ret 

80007012 <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007012:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007016:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
80007018:	53 cf 20 f0 	mul %d15,%d15,12
8000701c:	60 f2       	mov.a %a2,%d15
8000701e:	d9 2f 00 46 	lea %a15,[%a2]24832
80007022:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80007026:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80007028:	2e 16       	jz.t %d15,1,80007034 <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000702a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000702e:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80007032:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007034:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80007038:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
8000703c:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80007040:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007042:	4c f0       	ld.w %d15,[%a15]0
80007044:	6f 0f ff 7f 	jz.t %d15,0,80007042 <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
80007048:	00 90       	ret 

8000704a <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000704a:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000704e:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
80007050:	53 cf 20 f0 	mul %d15,%d15,12
80007054:	60 f2       	mov.a %a2,%d15
80007056:	d9 2f 00 46 	lea %a15,[%a2]24832
8000705a:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
8000705e:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80007060:	2e 16       	jz.t %d15,1,8000706c <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80007062:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80007066:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000706a:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
8000706c:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80007070:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80007074:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80007078:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
8000707a:	4c f0       	ld.w %d15,[%a15]0
8000707c:	6f 0f ff 7f 	jz.t %d15,0,8000707a <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
80007080:	00 90       	ret 

80007082 <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80007082:	91 30 00 ff 	movh.a %a15,61443
80007086:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000708a:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000708c:	2e 16       	jz.t %d15,1,80007098 <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000708e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80007092:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80007096:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80007098:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000709c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
800070a0:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
800070a4:	91 30 00 ff 	movh.a %a15,61443
800070a8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070ac:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800070ae:	4c f0       	ld.w %d15,[%a15]0
800070b0:	6f 0f ff 7f 	jz.t %d15,0,800070ae <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
800070b4:	00 90       	ret 

800070b6 <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
800070b6:	91 30 00 ff 	movh.a %a15,61443
800070ba:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070be:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
800070c0:	2e 16       	jz.t %d15,1,800070cc <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800070c2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
800070c6:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800070ca:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
800070cc:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
800070d0:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
800070d4:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
800070d8:	91 30 00 ff 	movh.a %a15,61443
800070dc:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070e0:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
800070e2:	4c f0       	ld.w %d15,[%a15]0
800070e4:	6f 0f ff 7f 	jz.t %d15,0,800070e2 <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
800070e8:	00 90       	ret 

800070ea <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800070ea:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800070ee:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800070f0:	53 cf 20 f0 	mul %d15,%d15,12
800070f4:	06 24       	sh %d4,2
800070f6:	60 f2       	mov.a %a2,%d15
800070f8:	d9 2f 00 46 	lea %a15,[%a2]24832
800070fc:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007100:	4c f0       	ld.w %d15,[%a15]0
80007102:	2e 16       	jz.t %d15,1,8000710e <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007104:	4c f0       	ld.w %d15,[%a15]0
80007106:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000710a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000710c:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000710e:	4c f0       	ld.w %d15,[%a15]0
80007110:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007114:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007116:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80007118:	4c f0       	ld.w %d15,[%a15]0
8000711a:	6f 0f ff ff 	jnz.t %d15,0,80007118 <IfxScuWdt_clearCpuEndinit+0x2e>
}
8000711e:	00 90       	ret 

80007120 <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007120:	91 30 00 ff 	movh.a %a15,61443
80007124:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007128:	4c f0       	ld.w %d15,[%a15]0
8000712a:	06 24       	sh %d4,2
8000712c:	2e 16       	jz.t %d15,1,80007138 <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000712e:	4c f0       	ld.w %d15,[%a15]0
80007130:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007134:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007136:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007138:	91 30 00 ff 	movh.a %a15,61443
8000713c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007140:	4c f0       	ld.w %d15,[%a15]0
80007142:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007146:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007148:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000714a:	4c f0       	ld.w %d15,[%a15]0
8000714c:	6f 0f ff ff 	jnz.t %d15,0,8000714a <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
80007150:	00 90       	ret 

80007152 <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007152:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007156:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80007158:	53 cf 20 f0 	mul %d15,%d15,12
8000715c:	06 24       	sh %d4,2
8000715e:	60 f2       	mov.a %a2,%d15
80007160:	d9 2f 00 46 	lea %a15,[%a2]24832
80007164:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007168:	4c f0       	ld.w %d15,[%a15]0
8000716a:	2e 16       	jz.t %d15,1,80007176 <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000716c:	4c f0       	ld.w %d15,[%a15]0
8000716e:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007172:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007174:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007176:	4c f0       	ld.w %d15,[%a15]0
80007178:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000717c:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000717e:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80007180:	4c f0       	ld.w %d15,[%a15]0
80007182:	6f 0f ff ff 	jnz.t %d15,0,80007180 <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
80007186:	4c f1       	ld.w %d15,[%a15]4
80007188:	96 08       	or %d15,8
8000718a:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000718c:	4c f0       	ld.w %d15,[%a15]0
8000718e:	2e 16       	jz.t %d15,1,8000719a <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007190:	4c f0       	ld.w %d15,[%a15]0
80007192:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007196:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007198:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000719a:	4c f0       	ld.w %d15,[%a15]0
8000719c:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800071a0:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800071a2:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800071a4:	4c f0       	ld.w %d15,[%a15]0
800071a6:	6f 0f ff 7f 	jz.t %d15,0,800071a4 <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
800071aa:	00 90       	ret 

800071ac <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800071ac:	91 30 00 ff 	movh.a %a15,61443
800071b0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071b4:	4c f0       	ld.w %d15,[%a15]0
800071b6:	06 24       	sh %d4,2
800071b8:	2e 16       	jz.t %d15,1,800071c4 <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800071ba:	4c f0       	ld.w %d15,[%a15]0
800071bc:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800071c0:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800071c2:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800071c4:	91 30 00 ff 	movh.a %a15,61443
800071c8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071cc:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800071ce:	40 f2       	mov.aa %a2,%a15
800071d0:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800071d4:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800071d6:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800071d8:	4c 20       	ld.w %d15,[%a2]0
800071da:	91 30 00 ff 	movh.a %a15,61443
800071de:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071e2:	6f 0f fb ff 	jnz.t %d15,0,800071d8 <IfxScuWdt_disableSafetyWatchdog+0x2c>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
800071e6:	91 30 00 2f 	movh.a %a2,61443
800071ea:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
800071ee:	4c 20       	ld.w %d15,[%a2]0
800071f0:	96 08       	or %d15,8
800071f2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800071f4:	4c f0       	ld.w %d15,[%a15]0
800071f6:	2e 16       	jz.t %d15,1,80007202 <IfxScuWdt_disableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800071f8:	4c f0       	ld.w %d15,[%a15]0
800071fa:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800071fe:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007200:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007202:	91 30 00 ff 	movh.a %a15,61443
80007206:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000720a:	4c f0       	ld.w %d15,[%a15]0
8000720c:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007210:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007212:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007214:	4c f0       	ld.w %d15,[%a15]0
80007216:	6f 0f ff 7f 	jz.t %d15,0,80007214 <IfxScuWdt_disableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000721a:	00 90       	ret 

8000721c <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000721c:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007220:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80007222:	53 cf 20 f0 	mul %d15,%d15,12
80007226:	06 24       	sh %d4,2
80007228:	60 f2       	mov.a %a2,%d15
8000722a:	d9 2f 00 46 	lea %a15,[%a2]24832
8000722e:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007232:	4c f0       	ld.w %d15,[%a15]0
80007234:	2e 16       	jz.t %d15,1,80007240 <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007236:	4c f0       	ld.w %d15,[%a15]0
80007238:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000723c:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000723e:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007240:	4c f0       	ld.w %d15,[%a15]0
80007242:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007246:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007248:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000724a:	4c f0       	ld.w %d15,[%a15]0
8000724c:	6f 0f ff ff 	jnz.t %d15,0,8000724a <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
80007250:	4c f1       	ld.w %d15,[%a15]4
80007252:	8f 8f c0 f1 	andn %d15,%d15,8
80007256:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007258:	4c f0       	ld.w %d15,[%a15]0
8000725a:	2e 16       	jz.t %d15,1,80007266 <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000725c:	4c f0       	ld.w %d15,[%a15]0
8000725e:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007262:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007264:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007266:	4c f0       	ld.w %d15,[%a15]0
80007268:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000726c:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000726e:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007270:	4c f0       	ld.w %d15,[%a15]0
80007272:	6f 0f ff 7f 	jz.t %d15,0,80007270 <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80007276:	00 90       	ret 

80007278 <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007278:	91 30 00 ff 	movh.a %a15,61443
8000727c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007280:	4c f0       	ld.w %d15,[%a15]0
80007282:	06 24       	sh %d4,2
80007284:	2e 16       	jz.t %d15,1,80007290 <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007286:	4c f0       	ld.w %d15,[%a15]0
80007288:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000728c:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000728e:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007290:	91 30 00 ff 	movh.a %a15,61443
80007294:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007298:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000729a:	40 f2       	mov.aa %a2,%a15
8000729c:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072a0:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072a2:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800072a4:	4c 20       	ld.w %d15,[%a2]0
800072a6:	91 30 00 ff 	movh.a %a15,61443
800072aa:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072ae:	6f 0f fb ff 	jnz.t %d15,0,800072a4 <IfxScuWdt_enableSafetyWatchdog+0x2c>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
800072b2:	91 30 00 2f 	movh.a %a2,61443
800072b6:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
800072ba:	4c 20       	ld.w %d15,[%a2]0
800072bc:	8f 8f c0 f1 	andn %d15,%d15,8
800072c0:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800072c2:	4c f0       	ld.w %d15,[%a15]0
800072c4:	2e 16       	jz.t %d15,1,800072d0 <IfxScuWdt_enableSafetyWatchdog+0x58>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072c6:	4c f0       	ld.w %d15,[%a15]0
800072c8:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072cc:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072ce:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072d0:	91 30 00 ff 	movh.a %a15,61443
800072d4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072d8:	4c f0       	ld.w %d15,[%a15]0
800072da:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072de:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072e0:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800072e2:	4c f0       	ld.w %d15,[%a15]0
800072e4:	6f 0f ff 7f 	jz.t %d15,0,800072e2 <IfxScuWdt_enableSafetyWatchdog+0x6a>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800072e8:	00 90       	ret 

800072ea <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800072ea:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800072ee:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800072f0:	53 cf 20 f0 	mul %d15,%d15,12
800072f4:	60 f2       	mov.a %a2,%d15
800072f6:	d9 2f 00 46 	lea %a15,[%a2]24832
800072fa:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800072fe:	48 02       	ld.w %d2,[%a15]0
80007300:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
80007304:	8f f2 83 21 	xor %d2,%d2,63
80007308:	00 90       	ret 

8000730a <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000730a:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000730e:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
80007310:	53 cf 20 f0 	mul %d15,%d15,12
80007314:	60 f2       	mov.a %a2,%d15
80007316:	d9 2f 00 46 	lea %a15,[%a2]24832
8000731a:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
8000731e:	48 02       	ld.w %d2,[%a15]0
}
80007320:	8f 12 00 21 	and %d2,%d2,1
80007324:	00 90       	ret 

80007326 <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80007326:	91 30 00 ff 	movh.a %a15,61443
8000732a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000732e:	48 02       	ld.w %d2,[%a15]0
80007330:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
80007334:	8f f2 83 21 	xor %d2,%d2,63
80007338:	00 90       	ret 

8000733a <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
8000733a:	da 3c       	mov %d15,60
8000733c:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
8000733e:	82 cf       	mov %d15,-4
80007340:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
80007342:	82 0f       	mov %d15,0
80007344:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
80007346:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
80007348:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
8000734a:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
8000734c:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
8000734e:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
80007350:	2c 4a       	st.b [%a4]10,%d15
80007352:	00 90       	ret 

80007354 <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007354:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007358:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000735a:	53 cf 20 f0 	mul %d15,%d15,12
8000735e:	06 24       	sh %d4,2
80007360:	60 f2       	mov.a %a2,%d15
80007362:	d9 2f 00 46 	lea %a15,[%a2]24832
80007366:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000736a:	4c f0       	ld.w %d15,[%a15]0
8000736c:	2e 16       	jz.t %d15,1,80007378 <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000736e:	4c f0       	ld.w %d15,[%a15]0
80007370:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007374:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007376:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007378:	4c f0       	ld.w %d15,[%a15]0
8000737a:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000737e:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007380:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007382:	4c f0       	ld.w %d15,[%a15]0
80007384:	6f 0f ff 7f 	jz.t %d15,0,80007382 <IfxScuWdt_setCpuEndinit+0x2e>
}
80007388:	00 90       	ret 

8000738a <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
8000738a:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
8000738c:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000738e:	6f 12 0b 00 	jz.t %d2,1,800073a4 <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80007392:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
80007396:	37 02 6e 31 	extr.u %d3,%d2,2,14
8000739a:	8f f3 83 31 	xor %d3,%d3,63
8000739e:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800073a2:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
800073a4:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
800073a6:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
800073aa:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
800073ae:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
800073b2:	b9 53 02 00 	ld.hu %d3,[%a5]2
800073b6:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
800073ba:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
800073bc:	54 42       	ld.w %d2,[%a4]
800073be:	6f 02 ff ff 	jnz.t %d2,0,800073bc <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
800073c2:	39 52 04 00 	ld.bu %d2,[%a5]4
800073c6:	df 12 0a 00 	jeq %d2,1,800073da <IfxScuWdt_initCpuWatchdog+0x50>
800073ca:	76 26       	jz %d2,800073d6 <IfxScuWdt_initCpuWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
800073cc:	8b 22 20 22 	ne %d2,%d2,2
800073d0:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
800073d4:	3c 07       	j 800073e2 <IfxScuWdt_initCpuWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
800073d6:	82 0f       	mov %d15,0
        break;
800073d8:	3c 05       	j 800073e2 <IfxScuWdt_initCpuWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
800073da:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
800073de:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
800073e2:	39 52 05 00 	ld.bu %d2,[%a5]5
800073e6:	8b 02 20 22 	ne %d2,%d2,0
800073ea:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
800073ee:	39 52 06 00 	ld.bu %d2,[%a5]6
800073f2:	8b 02 20 22 	ne %d2,%d2,0
800073f6:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
800073fa:	39 52 07 00 	ld.bu %d2,[%a5]7
800073fe:	8b 02 20 22 	ne %d2,%d2,0
80007402:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
80007406:	39 52 08 00 	ld.bu %d2,[%a5]8
8000740a:	8b 02 20 22 	ne %d2,%d2,0
8000740e:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
80007412:	39 52 09 00 	ld.bu %d2,[%a5]9
80007416:	8b 02 20 22 	ne %d2,%d2,0
8000741a:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
8000741e:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
80007420:	b9 54 00 00 	ld.hu %d4,[%a5]0
80007424:	1d ff 98 ff 	j 80007354 <IfxScuWdt_setCpuEndinit>

80007428 <IfxScuWdt_serviceCpuWatchdog>:
}


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
80007428:	1d ff 96 ff 	j 80007354 <IfxScuWdt_setCpuEndinit>

8000742c <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000742c:	91 30 00 ff 	movh.a %a15,61443
80007430:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007434:	4c f0       	ld.w %d15,[%a15]0
80007436:	06 24       	sh %d4,2
80007438:	2e 16       	jz.t %d15,1,80007444 <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000743a:	4c f0       	ld.w %d15,[%a15]0
8000743c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007440:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007442:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007444:	91 30 00 ff 	movh.a %a15,61443
80007448:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000744c:	4c f0       	ld.w %d15,[%a15]0
8000744e:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007452:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007454:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007456:	4c f0       	ld.w %d15,[%a15]0
80007458:	6f 0f ff 7f 	jz.t %d15,0,80007456 <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000745c:	00 90       	ret 

8000745e <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
8000745e:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
80007460:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
80007462:	6f 12 0b 00 	jz.t %d2,1,80007478 <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80007466:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
8000746a:	37 02 6e 31 	extr.u %d3,%d2,2,14
8000746e:	8f f3 83 31 	xor %d3,%d3,63
80007472:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80007476:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
80007478:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
8000747a:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
8000747e:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
80007482:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
80007486:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000748a:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
8000748e:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007490:	54 42       	ld.w %d2,[%a4]
80007492:	6f 02 ff ff 	jnz.t %d2,0,80007490 <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
80007496:	39 52 04 00 	ld.bu %d2,[%a5]4
8000749a:	df 12 0a 00 	jeq %d2,1,800074ae <IfxScuWdt_initSafetyWatchdog+0x50>
8000749e:	76 26       	jz %d2,800074aa <IfxScuWdt_initSafetyWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
800074a0:	8b 22 20 22 	ne %d2,%d2,2
800074a4:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
800074a8:	3c 07       	j 800074b6 <IfxScuWdt_initSafetyWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
800074aa:	82 0f       	mov %d15,0
        break;
800074ac:	3c 05       	j 800074b6 <IfxScuWdt_initSafetyWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
800074ae:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
800074b2:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
800074b6:	39 52 05 00 	ld.bu %d2,[%a5]5
800074ba:	8b 02 20 22 	ne %d2,%d2,0
800074be:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
800074c2:	39 52 06 00 	ld.bu %d2,[%a5]6
800074c6:	8b 02 20 22 	ne %d2,%d2,0
800074ca:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
800074ce:	39 52 07 00 	ld.bu %d2,[%a5]7
800074d2:	8b 02 20 22 	ne %d2,%d2,0
800074d6:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
800074da:	39 52 08 00 	ld.bu %d2,[%a5]8
800074de:	8b 02 20 22 	ne %d2,%d2,0
800074e2:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
800074e6:	39 52 09 00 	ld.bu %d2,[%a5]9
800074ea:	8b 02 20 22 	ne %d2,%d2,0
800074ee:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 0 : 1;
800074f2:	39 52 0a 00 	ld.bu %d2,[%a5]10
800074f6:	8b 02 00 22 	eq %d2,%d2,0
800074fa:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800074fe:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
80007500:	b9 54 00 00 	ld.hu %d4,[%a5]0
80007504:	1d ff 94 ff 	j 8000742c <IfxScuWdt_setSafetyEndinit>

80007508 <IfxScuWdt_serviceSafetyWatchdog>:
}


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
80007508:	1d ff 92 ff 	j 8000742c <IfxScuWdt_setSafetyEndinit>

8000750c <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
8000750c:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
80007510:	2e 07       	jz.t %d15,0,8000751e <IfxScuWdt_enableWatchdogWithDebugger+0x12>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
80007512:	3b 00 00 f3 	mov %d15,12288
80007516:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
8000751a:	82 0f       	mov %d15,0
8000751c:	3c 11       	j 8000753e <IfxScuWdt_enableWatchdogWithDebugger+0x32>

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
8000751e:	3b 10 0a 20 	mov %d2,161
80007522:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
80007526:	da 5e       	mov %d15,94
80007528:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
8000752c:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
80007530:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
80007534:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
80007538:	6f 0f ed ff 	jnz.t %d15,0,80007512 <IfxScuWdt_enableWatchdogWithDebugger+0x6>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
8000753c:	82 1f       	mov %d15,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
8000753e:	85 f2 40 20 	ld.w %d2,f0000480 <_SMALL_DATA4_+0x3fff8480>
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
80007542:	37 02 e1 23 	extr.u %d2,%d2,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
80007546:	ab 1f 80 22 	sel %d2,%d2,%d15,1
8000754a:	00 90       	ret 

8000754c <IfxVadc_Adc_deInitGroup>:
    Ifx_VADC_G     *vadcG      = IfxVadc_Adc_getGroupRegsFromGroup(group);
    /* Get group index */
    IfxVadc_GroupId groupIndex = group->groupId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000754c:	0c 48       	ld.bu %d15,[%a4]8
8000754e:	d4 4c       	ld.a %a12,[%a4]
80007550:	1b 0f 01 f0 	addi %d15,%d15,16
80007554:	16 ff       	and %d15,255
80007556:	99 4d 04 00 	ld.a %a13,[%a4]4
8000755a:	02 f4       	mov %d4,%d15
8000755c:	40 c4       	mov.aa %a4,%a12
8000755e:	6d ff 91 e8 	call 80004680 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_resetGroup(Ifx_VADC_G *vadcG)
{
    vadcG->ARBCFG.B.ANONC = IfxVadc_AnalogConverterMode_off;   /* turn off group */
80007562:	54 d2       	ld.w %d2,[%a13]
    IfxVadc_resetGroup(vadcG);
    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007564:	40 c4       	mov.aa %a4,%a12
80007566:	8f 32 c0 21 	andn %d2,%d2,3
8000756a:	74 d2       	st.w [%a13],%d2
8000756c:	02 f4       	mov %d4,%d15
8000756e:	1d ff 6d e8 	j 80004648 <IfxVadc_disableAccess>

80007572 <IfxVadc_Adc_disableModule>:
}


void IfxVadc_Adc_disableModule(Ifx_VADC *vadc)
{
80007572:	40 4f       	mov.aa %a15,%a4
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007574:	6d ff bb fe 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80007578:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000757a:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
8000757c:	6d ff b7 fd 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.B.DISR = 1;
80007580:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setCpuEndinit(passwd);
80007582:	02 f4       	mov %d4,%d15

IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->CLC.B.DISR = 1;
80007584:	8f 12 40 21 	or %d2,%d2,1
80007588:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
8000758a:	1d ff e5 fe 	j 80007354 <IfxScuWdt_setCpuEndinit>

8000758e <IfxVadc_Adc_getChannelConfig>:
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
8000758e:	99 42 04 00 	ld.a %a2,[%a4]4
80007592:	99 2d 04 00 	ld.a %a13,[%a2]4
    IfxVadc_ChannelId channelIndex = channel->channel;
80007596:	79 42 00 00 	ld.b %d2,[%a4]0

    config->channelId = channel->channel;
    config->group     = channel->group;
8000759a:	b5 52 14 00 	st.a [%a5]20,%a2


IFX_INLINE Ifx_VADC_CHCTR IfxVadc_getChannelControlConfig(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U = vadcG->CHCTR[channelIndex].U;
8000759e:	1b 02 06 f0 	addi %d15,%d2,96
800075a2:	90 d2       	addsc.a %a2,%a13,%d15,2
void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
    IfxVadc_ChannelId channelIndex = channel->channel;

    config->channelId = channel->channel;
800075a4:	e9 52 0c 00 	st.b [%a5]12,%d2
800075a8:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
800075aa:	40 4c       	mov.aa %a12,%a4

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
800075ac:	37 0f 62 30 	extr.u %d3,%d15,0,2
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
800075b0:	40 5f       	mov.aa %a15,%a5

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
800075b2:	e9 53 0d 00 	st.b [%a5]13,%d3
    config->reference           = (IfxVadc_ChannelReference)tempChctr.B.REFSEL;
800075b6:	37 0f e1 35 	extr.u %d3,%d15,11,1
800075ba:	e9 53 0e 00 	st.b [%a5]14,%d3
    config->resultRegister      = (IfxVadc_ChannelResult)tempChctr.B.RESREG;
800075be:	37 0f 64 38 	extr.u %d3,%d15,16,4
800075c2:	e9 53 0f 00 	st.b [%a5]15,%d3
    config->globalResultUsage   = tempChctr.B.RESTBS;
800075c6:	37 0f 61 3a 	extr.u %d3,%d15,20,1
800075ca:	34 53       	st.b [%a5],%d3
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
800075cc:	37 0f 62 32 	extr.u %d3,%d15,4,2
800075d0:	e9 53 10 00 	st.b [%a5]16,%d3
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
800075d4:	37 0f 62 33 	extr.u %d3,%d15,6,2
800075d8:	e9 53 11 00 	st.b [%a5]17,%d3
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
800075dc:	37 0f 64 36 	extr.u %d3,%d15,12,4
800075e0:	e9 53 12 00 	st.b [%a5]18,%d3
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
800075e4:	37 0f 62 34 	extr.u %d3,%d15,8,2
800075e8:	e9 53 13 00 	st.b [%a5]19,%d3
    config->synchonize          = tempChctr.B.SYNC;
800075ec:	37 0f 61 35 	extr.u %d3,%d15,10,1
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800075f0:	37 0f e1 fa 	extr.u %d15,%d15,21,1
    config->globalResultUsage   = tempChctr.B.RESTBS;
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
    config->synchonize          = tempChctr.B.SYNC;
800075f4:	e9 53 01 00 	st.b [%a5]1,%d3
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800075f8:	2c 53       	st.b [%a5]3,%d15


IFX_INLINE Ifx_VADC_G_CHASS IfxVadc_getAssignedChannels(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CHASS assignChannels;
    assignChannels.U = vadcG->CHASS.U;
800075fa:	4c d2       	ld.w %d15,[%a13]8

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
800075fc:	57 0f 61 22 	extr.u %d2,%d15,%d2,1
80007600:	8f 12 80 21 	xor %d2,%d2,1
80007604:	e9 52 02 00 	st.b [%a5]2,%d2
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
80007608:	99 42 04 00 	ld.a %a2,[%a4]4
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
8000760c:	79 4f 00 00 	ld.b %d15,[%a4]0


IFX_INLINE Ifx_VADC_G_CEVNP0 IfxVadc_getChannelServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CEVNP0 serviceRequestNodePtr;
    serviceRequestNodePtr.U = vadcG->CEVNP0.U;
80007610:	19 d2 20 40 	ld.w %d2,[%a13]288
80007614:	06 2f       	sh %d15,2
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
80007616:	57 02 64 ff 	extr.u %d15,%d2,%d15,4
    config->rightAlignedStorage = tempChctr.B.RESPOS;

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
8000761a:	39 28 08 00 	ld.bu %d8,[%a2]8
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
8000761e:	0b 8f 10 48 	mov %e4,%d15,%d8
80007622:	6d ff 60 e9 	call 800048e2 <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
80007626:	54 22       	ld.w %d2,[%a2]
80007628:	6f a2 0a 00 	jz.t %d2,10,8000763c <IfxVadc_Adc_getChannelConfig+0xae>
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)channelServiceRequestNodePtr;
8000762c:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)src->B.SRPN;
8000762e:	4c 20       	ld.w %d15,[%a2]0
80007630:	16 ff       	and %d15,255
80007632:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)src->B.TOS;
80007634:	4c 20       	ld.w %d15,[%a2]0
80007636:	37 0f e2 f5 	extr.u %d15,%d15,11,2
8000763a:	3c 05       	j 80007644 <IfxVadc_Adc_getChannelConfig+0xb6>
    }
    else
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)0;
8000763c:	82 0f       	mov %d15,0
8000763e:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)0;
80007640:	82 0f       	mov %d15,0
80007642:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)0;
80007644:	28 9f       	st.b [%a15]9,%d15
    }

    uint32 resultServiceRequestNodePtr;

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80007646:	0c ff       	ld.bu %d15,[%a15]15
80007648:	79 c2 00 00 	ld.b %d2,[%a12]0
8000764c:	ff 8f 08 80 	jge.u %d15,8,8000765c <IfxVadc_Adc_getChannelConfig+0xce>


IFX_INLINE Ifx_VADC_G_REVNP0 IfxVadc_getChannelResultServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP0 resultServiceRequestNodePtr0;
    resultServiceRequestNodePtr0.U = vadcG->REVNP0.U;
80007650:	19 df 30 40 	ld.w %d15,[%a13]304
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
80007654:	06 22       	sh %d2,2
80007656:	57 0f 64 f2 	extr.u %d15,%d15,%d2,4
8000765a:	3c 08       	j 8000766a <IfxVadc_Adc_getChannelConfig+0xdc>
    }
    else
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer1(vadcG)).U >> ((channel->channel - IfxVadc_ChannelResult_8) * 4)) & 0xF;
8000765c:	9a 82       	add %d15,%d2,-8


IFX_INLINE Ifx_VADC_G_REVNP1 IfxVadc_getChannelResultServiceRequestNodePointer1(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP1 resultServiceRequestNodePtr1;
    resultServiceRequestNodePtr1.U = vadcG->REVNP1.U;
8000765e:	19 d3 34 40 	ld.w %d3,[%a13]308
80007662:	8f 2f 00 20 	sh %d2,%d15,2
80007666:	57 03 64 f2 	extr.u %d15,%d3,%d2,4
    }

    src = IfxVadc_getSrcAddress(groupIndex, resultServiceRequestNodePtr);
8000766a:	16 ff       	and %d15,255
8000766c:	0b 8f 10 48 	mov %e4,%d15,%d8
80007670:	6d ff 39 e9 	call 800048e2 <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
80007674:	54 22       	ld.w %d2,[%a2]
80007676:	6f a2 0a 00 	jz.t %d2,10,8000768a <IfxVadc_Adc_getChannelConfig+0xfc>
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)resultServiceRequestNodePtr;
8000767a:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)src->B.SRPN;
8000767c:	4c 20       	ld.w %d15,[%a2]0
8000767e:	16 ff       	and %d15,255
80007680:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)src->B.TOS;
80007682:	4c 20       	ld.w %d15,[%a2]0
80007684:	37 0f e2 f5 	extr.u %d15,%d15,11,2
80007688:	3c 05       	j 80007692 <IfxVadc_Adc_getChannelConfig+0x104>
    }
    else
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)0;
8000768a:	82 0f       	mov %d15,0
8000768c:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)0;
8000768e:	82 0f       	mov %d15,0
80007690:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)0;
80007692:	28 8f       	st.b [%a15]8,%d15
80007694:	00 90       	ret 

80007696 <IfxVadc_Adc_getChannelConversionTime>:
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007696:	cc 41       	ld.a %a15,[%a4]4
80007698:	c8 12       	ld.a %a2,[%a15]4
}


IFX_INLINE IfxVadc_InputClasses IfxVadc_getChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    return (IfxVadc_InputClasses)vadcG->CHCTR[channelIndex].B.ICLSEL;
8000769a:	79 4f 00 00 	ld.b %d15,[%a4]0
8000769e:	08 8a       	ld.bu %d10,[%a15]8
800076a0:	c8 0f       	ld.a %a15,[%a15]0
800076a2:	1b 0f 06 f0 	addi %d15,%d15,96
800076a6:	90 22       	addsc.a %a2,%a2,%d15,2
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
800076a8:	20 08       	sub.a %sp,8
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
800076aa:	40 f4       	mov.aa %a4,%a15
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
800076ac:	02 49       	mov %d9,%d4
800076ae:	54 28       	ld.w %d8,[%a2]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
800076b0:	6d ff 9a e8 	call 800047e4 <IfxVadc_getAdcAnalogFrequency>
800076b4:	02 2f       	mov %d15,%d2
800076b6:	6d ff b0 e8 	call 80004816 <IfxVadc_getAdcModuleFrequency>
800076ba:	8f 38 00 81 	and %d8,%d8,3
800076be:	74 a9       	st.w [%sp],%d9
800076c0:	40 f4       	mov.aa %a4,%a15
800076c2:	0b a8 10 48 	mov %e4,%d8,%d10
800076c6:	0b f2 10 68 	mov %e6,%d2,%d15
}
800076ca:	1d ff c1 e9 	j 80004a4c <IfxVadc_getChannelConversionTime>

800076ce <IfxVadc_Adc_getGroupConfig>:

void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
800076ce:	d4 4d       	ld.a %a13,[%a4]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
800076d0:	40 4e       	mov.aa %a14,%a4
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
800076d2:	99 4c 04 00 	ld.a %a12,[%a4]4
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800076d6:	40 d4       	mov.aa %a4,%a13
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
800076d8:	40 5f       	mov.aa %a15,%a5
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800076da:	6d ff 85 e8 	call 800047e4 <IfxVadc_getAdcAnalogFrequency>

    config->groupId                    = group->groupId;
800076de:	0c e8       	ld.bu %d15,[%a14]8
    config->module                     = &group->module;
800076e0:	e8 0e       	st.a [%a15]0,%a14
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);

    config->groupId                    = group->groupId;
800076e2:	28 4f       	st.b [%a15]4,%d15
}


IFX_INLINE IfxVadc_ArbitrationRounds IfxVadc_getArbiterRoundLength(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_ArbitrationRounds)vadcG->ARBCFG.B.ARBRND;
800076e4:	4c c0       	ld.w %d15,[%a12]0
800076e6:	37 0f 62 f2 	extr.u %d15,%d15,4,2
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);
800076ea:	e9 ff 32 00 	st.b [%a15]50,%d15
800076ee:	82 0f       	mov %d15,0
}


IFX_INLINE IfxVadc_ChannelResolution IfxVadc_getGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum)
{
    return (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
800076f0:	1b 8f 00 30 	addi %d3,%d15,8
800076f4:	01 c3 02 26 	addsc.a %a2,%a12,%d3,2

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
800076f8:	d0 f3       	addsc.a %a3,%a15,%d15,3
800076fa:	54 23       	ld.w %d3,[%a2]
800076fc:	37 03 63 34 	extr.u %d3,%d3,8,3
80007700:	e9 33 0c 00 	st.b [%a3]12,%d3
}


IFX_INLINE float32 IfxVadc_getGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = vadcG->ICLASS[inputClassNum].B.STCS;
80007704:	54 23       	ld.w %d3,[%a2]
80007706:	8f f3 01 31 	and %d3,%d3,31

    if (sampleTime > 16)
8000770a:	8b 13 61 42 	lt.u %d4,%d3,17
8000770e:	f6 44       	jnz %d4,80007716 <IfxVadc_Adc_getGroupConfig+0x48>
    {
        sampleTime = (sampleTime - 15) * 16;
80007710:	1b 13 ff 3f 	addi %d3,%d3,-15
80007714:	06 43       	sh %d3,4
    }

    return (float32)(IFXVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
80007716:	c2 23       	add %d3,2
80007718:	4b 03 41 31 	itof %d3,%d3
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
8000771c:	92 14       	add %d4,%d15,1
8000771e:	4b 23 51 30 	div.f %d3,%d3,%d2
80007722:	01 f4 03 26 	addsc.a %a2,%a15,%d4,3
80007726:	74 23       	st.w [%a2],%d3
    config->groupId                    = group->groupId;
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80007728:	1e 13       	jeq %d15,1,8000772e <IfxVadc_Adc_getGroupConfig+0x60>
8000772a:	82 1f       	mov %d15,1
8000772c:	3c e2       	j 800076f0 <IfxVadc_Adc_getGroupConfig+0x22>
}


IFX_INLINE boolean IfxVadc_isRequestScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN1;
8000772e:	19 c2 04 00 	ld.w %d2,[%a12]4
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
    }

    if (IfxVadc_isRequestScanSlotEnabled(vadcG) == TRUE)
80007732:	ef 92 33 00 	jz.t %d2,25,80007798 <IfxVadc_Adc_getGroupConfig+0xca>
    {
        config->arbiter.requestSlotScanEnabled          = TRUE;
80007736:	e9 ff 34 00 	st.b [%a15]52,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO1;
8000773a:	19 c2 04 00 	ld.w %d2,[%a12]4
8000773e:	37 02 62 22 	extr.u %d2,%d2,4,2
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
80007742:	e9 f2 1e 00 	st.b [%a15]30,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM1;
80007746:	19 c2 04 00 	ld.w %d2,[%a12]4
8000774a:	37 02 e1 23 	extr.u %d2,%d2,7,1
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);
8000774e:	e9 f2 1f 00 	st.b [%a15]31,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getScanSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->ASCTRL.B.XTSEL;
80007752:	19 c3 20 20 	ld.w %d3,[%a12]160
80007756:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
8000775a:	e9 f3 1b 00 	st.b [%a15]27,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getScanSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->ASCTRL.B.XTMODE;
8000775e:	19 c2 20 20 	ld.w %d2,[%a12]160
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007762:	8b f3 00 32 	eq %d3,%d3,15
80007766:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotScanEnabled          = TRUE;
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);
8000776a:	e9 f2 1d 00 	st.b [%a15]29,%d2

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000776e:	f6 35       	jnz %d3,80007778 <IfxVadc_Adc_getGroupConfig+0xaa>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getScanSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->ASMR.B.ENGT;
80007770:	19 cf 24 20 	ld.w %d15,[%a12]164
80007774:	16 03       	and %d15,3
80007776:	3c 02       	j 8000777a <IfxVadc_Adc_getGroupConfig+0xac>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_getScanSlotGatingMode(vadcG);
        }
        else if (config->scanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007778:	76 23       	jz %d2,8000777e <IfxVadc_Adc_getGroupConfig+0xb0>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
8000777a:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getScanSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->ASCTRL.B.GTSEL;
8000777e:	19 cf 20 20 	ld.w %d15,[%a12]160
80007782:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->scanRequest.triggerConfig.gatingSource = IfxVadc_getScanSlotGatingSource(vadcG);
80007786:	e9 ff 1a 00 	st.b [%a15]26,%d15
}


IFX_INLINE boolean IfxVadc_isAutoScanEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ASMR.B.SCAN;
8000778a:	19 cf 24 20 	ld.w %d15,[%a12]164
8000778e:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->scanRequest.autoscanEnabled            = IfxVadc_isAutoScanEnabled(vadcG);
80007792:	e9 ff 18 00 	st.b [%a15]24,%d15
80007796:	3c 0c       	j 800077ae <IfxVadc_Adc_getGroupConfig+0xe0>
    }
    else
    {
        config->scanRequest.autoscanEnabled             = FALSE;
80007798:	82 0f       	mov %d15,0
8000779a:	e9 ff 18 00 	st.b [%a15]24,%d15
        config->scanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
8000779e:	e9 ff 1c 00 	st.b [%a15]28,%d15
        config->scanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;    /* Use CCU6061 TRIG0 */
800077a2:	e9 ff 1a 00 	st.b [%a15]26,%d15
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800077a6:	e9 ff 1d 00 	st.b [%a15]29,%d15
        config->scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;   /* Trigger source taken from Gating Input */
800077aa:	e9 ff 1b 00 	st.b [%a15]27,%d15
}


IFX_INLINE boolean IfxVadc_isRequestQueueSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN0;
800077ae:	4c c1       	ld.w %d15,[%a12]4
800077b0:	37 0f 61 fc 	extr.u %d15,%d15,24,1
    }

    if (IfxVadc_isRequestQueueSlotEnabled(vadcG) == TRUE)
800077b4:	df 1f 30 80 	jne %d15,1,80007814 <IfxVadc_Adc_getGroupConfig+0x146>
    {
        config->arbiter.requestSlotQueueEnabled          = TRUE;
800077b8:	e9 ff 33 00 	st.b [%a15]51,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getQueueSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO0;
800077bc:	19 c2 04 00 	ld.w %d2,[%a12]4
800077c0:	8f 32 00 21 	and %d2,%d2,3
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
800077c4:	e9 f2 26 00 	st.b [%a15]38,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getQueueSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM0;
800077c8:	19 c2 04 00 	ld.w %d2,[%a12]4
800077cc:	37 02 e1 21 	extr.u %d2,%d2,3,1
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);
800077d0:	e9 f2 27 00 	st.b [%a15]39,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getQueueSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->QCTRL0.B.XTSEL;
800077d4:	19 c3 00 20 	ld.w %d3,[%a12]128
800077d8:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
800077dc:	e9 f3 23 00 	st.b [%a15]35,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getQueueSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->QCTRL0.B.XTMODE;
800077e0:	19 c2 00 20 	ld.w %d2,[%a12]128
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800077e4:	8b f3 00 32 	eq %d3,%d3,15
800077e8:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotQueueEnabled          = TRUE;
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);
800077ec:	e9 f2 25 00 	st.b [%a15]37,%d2

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800077f0:	f6 35       	jnz %d3,800077fa <IfxVadc_Adc_getGroupConfig+0x12c>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getQueueSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->QMR0.B.ENGT;
800077f2:	19 cf 04 20 	ld.w %d15,[%a12]132
800077f6:	16 03       	and %d15,3
800077f8:	3c 02       	j 800077fc <IfxVadc_Adc_getGroupConfig+0x12e>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_getQueueSlotGatingMode(vadcG);
        }
        else if (config->queueRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800077fa:	76 23       	jz %d2,80007800 <IfxVadc_Adc_getGroupConfig+0x132>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800077fc:	e9 ff 24 00 	st.b [%a15]36,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getQueueSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->QCTRL0.B.GTSEL;
80007800:	19 cf 00 20 	ld.w %d15,[%a12]128
80007804:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->queueRequest.triggerConfig.gatingSource = IfxVadc_getQueueSlotGatingSource(vadcG);
80007808:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.flushQueueAfterInit        = FALSE;
8000780c:	82 0f       	mov %d15,0
8000780e:	e9 ff 20 00 	st.b [%a15]32,%d15
80007812:	3c 0c       	j 8000782a <IfxVadc_Adc_getGroupConfig+0x15c>
    }
    else
    {
        config->queueRequest.flushQueueAfterInit         = FALSE;
80007814:	82 0f       	mov %d15,0
80007816:	e9 ff 20 00 	st.b [%a15]32,%d15
        config->queueRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
8000781a:	e9 ff 24 00 	st.b [%a15]36,%d15
        config->queueRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;        /* Use CCU6061 TRIG0 */
8000781e:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
80007822:	e9 ff 25 00 	st.b [%a15]37,%d15
        config->queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;       /* Trigger source taken from Gating Input */
80007826:	e9 ff 23 00 	st.b [%a15]35,%d15
}


IFX_INLINE boolean IfxVadc_isRequestBackgroundScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN2;
8000782a:	4c c1       	ld.w %d15,[%a12]4
8000782c:	37 0f 61 fd 	extr.u %d15,%d15,26,1
    }

    if (IfxVadc_isRequestBackgroundScanSlotEnabled(vadcG) == TRUE)
80007830:	df 1f 33 80 	jne %d15,1,80007896 <IfxVadc_Adc_getGroupConfig+0x1c8>
    {
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
80007834:	e9 ff 35 00 	st.b [%a15]53,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getBackgroundScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO2;
80007838:	19 c2 04 00 	ld.w %d2,[%a12]4
8000783c:	37 02 62 24 	extr.u %d2,%d2,8,2
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
80007840:	e9 f2 2e 00 	st.b [%a15]46,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getBackgroundScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM2;
80007844:	19 c2 04 00 	ld.w %d2,[%a12]4
80007848:	37 02 e1 25 	extr.u %d2,%d2,11,1
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);
8000784c:	e9 f2 2f 00 	st.b [%a15]47,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getBackgroundScanTriggerInput(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerSource)vadc->BRSCTRL.B.XTSEL;
80007850:	19 d3 00 80 	ld.w %d3,[%a13]512
80007854:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
80007858:	e9 f3 2b 00 	st.b [%a15]43,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getBackgroundScanTriggerMode(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerMode)vadc->BRSCTRL.B.XTMODE;
8000785c:	19 d2 00 80 	ld.w %d2,[%a13]512
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007860:	8b f3 00 32 	eq %d3,%d3,15
80007864:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);
80007868:	e9 f2 2d 00 	st.b [%a15]45,%d2

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000786c:	f6 35       	jnz %d3,80007876 <IfxVadc_Adc_getGroupConfig+0x1a8>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getBackgroundScanGatingMode(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingMode)vadc->BRSMR.B.ENGT;
8000786e:	19 df 04 80 	ld.w %d15,[%a13]516
80007872:	16 03       	and %d15,3
80007874:	3c 02       	j 80007878 <IfxVadc_Adc_getGroupConfig+0x1aa>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_getBackgroundScanGatingMode(vadc);
        }
        else if (config->backgroundScanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007876:	76 23       	jz %d2,8000787c <IfxVadc_Adc_getGroupConfig+0x1ae>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80007878:	e9 ff 2c 00 	st.b [%a15]44,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getBackgroundScanGatingSource(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingSource)vadc->BRSCTRL.B.GTSEL;
8000787c:	19 df 00 80 	ld.w %d15,[%a13]512
80007880:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->backgroundScanRequest.triggerConfig.gatingSource = IfxVadc_getBackgroundScanGatingSource(vadc);
80007884:	e9 ff 2a 00 	st.b [%a15]42,%d15
}


IFX_INLINE boolean IfxVadc_isAutoBackgroundScanEnabled(Ifx_VADC *vadc)
{
    return (boolean)vadc->BRSMR.B.SCAN;
80007888:	19 df 04 80 	ld.w %d15,[%a13]516
8000788c:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->backgroundScanRequest.autoBackgroundScanEnabled  = IfxVadc_isAutoBackgroundScanEnabled(vadc);
80007890:	e9 ff 28 00 	st.b [%a15]40,%d15
80007894:	3c 0c       	j 800078ac <IfxVadc_Adc_getGroupConfig+0x1de>
    }
    else
    {
        config->backgroundScanRequest.autoBackgroundScanEnabled   = FALSE;
80007896:	82 0f       	mov %d15,0
80007898:	e9 ff 28 00 	st.b [%a15]40,%d15
        config->backgroundScanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
8000789c:	e9 ff 2c 00 	st.b [%a15]44,%d15
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
800078a0:	e9 ff 2a 00 	st.b [%a15]42,%d15
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800078a4:	e9 ff 2d 00 	st.b [%a15]45,%d15
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
800078a8:	e9 ff 2b 00 	st.b [%a15]43,%d15


IFX_INLINE uint8 IfxVadc_getMasterIndex(Ifx_VADC_G *vadcG)
{
    uint8 masterIndex = 0;
    masterIndex = vadcG->SYNCTR.B.STSEL;
800078ac:	19 c3 00 10 	ld.w %d3,[%a12]64
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
800078b0:	39 e7 08 00 	ld.bu %d7,[%a14]8
800078b4:	8f 33 00 31 	and %d3,%d3,3
800078b8:	02 72       	mov %d2,%d7
IFX_INLINE IfxVadc_GroupId IfxVadc_Adc_getMasterId(IfxVadc_GroupId slave, IfxVadc_Adc_SYNCTR_STSEL masterIndex)
{
    uint8           i, idxOffset;
    IfxVadc_GroupId masterId = slave;

    if (masterIndex == 0)
800078ba:	df 03 1f 00 	jeq %d3,0,800078f8 <IfxVadc_Adc_getGroupConfig+0x22a>
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
800078be:	7b 00 00 58 	movh %d5,32768
800078c2:	1b 85 d3 50 	addi %d5,%d5,3384
800078c6:	13 87 20 55 	madd %d5,%d5,%d7,8
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
800078ca:	8b 47 60 42 	lt.u %d4,%d7,4
800078ce:	82 02       	mov %d2,0
800078d0:	ab 42 80 24 	sel %d2,%d4,%d2,4

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
800078d4:	1a 25       	add %d15,%d5,%d2
800078d6:	60 f4       	mov.a %a4,%d15
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
800078d8:	82 04       	mov %d4,0

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
800078da:	a0 32       	mov.a %a2,3
800078dc:	01 44 00 36 	addsc.a %a3,%a4,%d4,0
800078e0:	8f f4 0f 61 	and %d6,%d4,255
800078e4:	14 35       	ld.bu %d5,[%a3]
800078e6:	5f 35 06 80 	jne %d5,%d3,800078f2 <IfxVadc_Adc_getGroupConfig+0x224>
            {
                return (IfxVadc_GroupId)(i + idxOffset);
800078ea:	42 62       	add %d2,%d6
800078ec:	8f f2 0f 21 	and %d2,%d2,255
800078f0:	3c 04       	j 800078f8 <IfxVadc_Adc_getGroupConfig+0x22a>
800078f2:	c2 14       	add %d4,1
800078f4:	fc 24       	loop %a2,800078dc <IfxVadc_Adc_getGroupConfig+0x20e>
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
800078f6:	02 72       	mov %d2,%d7
800078f8:	28 52       	st.b [%a15]5,%d2


IFX_INLINE Ifx_VADC_GLOBCFG IfxVadc_getGlobalConfigValue(Ifx_VADC *vadc)
{
    Ifx_VADC_GLOBCFG globCfg;
    globCfg.U = vadc->GLOBCFG.U;
800078fa:	19 d2 00 20 	ld.w %d2,[%a13]128

    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
800078fe:	1b 07 01 f0 	addi %d15,%d7,16
80007902:	57 02 61 ff 	extr.u %d15,%d2,%d15,1
80007906:	e9 ff 30 00 	st.b [%a15]48,%d15
8000790a:	00 90       	ret 

8000790c <IfxVadc_Adc_initChannel>:


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
8000790c:	99 52 14 00 	ld.a %a2,[%a5]20
80007910:	d4 2e       	ld.a %a14,[%a2]
80007912:	99 2c 04 00 	ld.a %a12,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
80007916:	39 28 08 00 	ld.bu %d8,[%a2]8
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
8000791a:	b5 42 04 00 	st.a [%a4]4,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
8000791e:	02 84       	mov %d4,%d8
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
80007920:	40 4d       	mov.aa %a13,%a4
    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80007922:	40 e4       	mov.aa %a4,%a14
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
80007924:	40 5f       	mov.aa %a15,%a5
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;
80007926:	79 59 0c 00 	ld.b %d9,[%a5]12

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
8000792a:	6d ff ab e6 	call 80004680 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
8000792e:	1b 09 06 20 	addi %d2,%d9,96
80007932:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
80007936:	0c fe       	ld.bu %d15,[%a15]14
80007938:	54 22       	ld.w %d2,[%a2]
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000793a:	40 e4       	mov.aa %a4,%a14
8000793c:	67 f2 0b f0 	ins.t %d15,%d2,11,%d15,0
80007940:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
80007942:	54 22       	ld.w %d2,[%a2]
80007944:	0c ff       	ld.bu %d15,[%a15]15
80007946:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
8000794a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setLowerBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection lowerBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
8000794c:	54 22       	ld.w %d2,[%a2]
8000794e:	39 ff 10 00 	ld.bu %d15,[%a15]16
80007952:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007956:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setUpperBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection upperBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
80007958:	54 22       	ld.w %d2,[%a2]
8000795a:	39 ff 11 00 	ld.bu %d15,[%a15]17
8000795e:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80007962:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setSyncRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean synchonize)
{
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
80007964:	54 22       	ld.w %d2,[%a2]
80007966:	0c f1       	ld.bu %d15,[%a15]1
80007968:	67 f2 0a f0 	ins.t %d15,%d2,10,%d15,0
8000796c:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_InputClasses inputClass)
{
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
8000796e:	54 22       	ld.w %d2,[%a2]
80007970:	0c fd       	ld.bu %d15,[%a15]13
80007972:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007976:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelLimitCheckMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_LimitCheck limitCheck)
{
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
80007978:	54 22       	ld.w %d2,[%a2]
8000797a:	39 ff 13 00 	ld.bu %d15,[%a15]19
8000797e:	37 f2 02 f4 	insert %d15,%d2,%d15,8,2
80007982:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setResultPosition(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean rightAlignedStorage)
{
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
80007984:	54 22       	ld.w %d2,[%a2]
80007986:	0c f3       	ld.bu %d15,[%a15]3
80007988:	67 f2 15 f0 	ins.t %d15,%d2,21,%d15,0
8000798c:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBackgroundResultTarget(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean globalResultUsage)
{
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
8000798e:	54 22       	ld.w %d2,[%a2]
80007990:	0c f0       	ld.bu %d15,[%a15]0
80007992:	67 f2 14 f0 	ins.t %d15,%d2,20,%d15,0
80007996:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBoundaryMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundaryExtension boundaryMode)
{
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
80007998:	54 22       	ld.w %d2,[%a2]
8000799a:	39 ff 12 00 	ld.bu %d15,[%a15]18
8000799e:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
800079a2:	6c 20       	st.w [%a2]0,%d15
800079a4:	1b 08 01 f0 	addi %d15,%d8,16
800079a8:	16 ff       	and %d15,255
800079aa:	02 f4       	mov %d4,%d15
800079ac:	6d ff 6a e6 	call 80004680 <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
800079b0:	08 23       	ld.bu %d3,[%a15]2
800079b2:	82 12       	mov %d2,1
800079b4:	0f 92 00 20 	sh %d2,%d2,%d9
800079b8:	f6 35       	jnz %d3,800079c2 <IfxVadc_Adc_initChannel+0xb6>
}


IFX_INLINE void IfxVadc_setGroupPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U |= (1 << channelIndex);
800079ba:	19 c3 08 00 	ld.w %d3,[%a12]8
800079be:	a6 32       	or %d2,%d3
800079c0:	3c 05       	j 800079ca <IfxVadc_Adc_initChannel+0xbe>
}


IFX_INLINE void IfxVadc_setBackgroundPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U &= ~(1 << channelIndex);
800079c2:	19 c3 08 00 	ld.w %d3,[%a12]8
800079c6:	0f 23 e0 20 	andn %d2,%d3,%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800079ca:	02 f4       	mov %d4,%d15
800079cc:	59 c2 08 00 	st.w [%a12]8,%d2
800079d0:	40 e4       	mov.aa %a4,%a14
800079d2:	6d ff 3b e6 	call 80004648 <IfxVadc_disableAccess>
}


IFX_INLINE void IfxVadc_setChannelEventNodePointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr channelSrcNr, IfxVadc_ChannelId channel)
{
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
800079d6:	79 d3 00 00 	ld.b %d3,[%a13]0
800079da:	19 c5 20 40 	ld.w %d5,[%a12]288
800079de:	8f 23 00 f0 	sh %d15,%d3,2
800079e2:	3b f0 00 20 	mov %d2,15
800079e6:	0f f2 00 20 	sh %d2,%d2,%d15
800079ea:	0f 25 e0 20 	andn %d2,%d5,%d2

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
800079ee:	08 b4       	ld.bu %d4,[%a15]11
800079f0:	59 c2 20 40 	st.w [%a12]288,%d2
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
800079f4:	19 c2 20 40 	ld.w %d2,[%a12]288
800079f8:	0f f4 00 f0 	sh %d15,%d4,%d15
800079fc:	a6 2f       	or %d15,%d2
800079fe:	59 cf 20 40 	st.w [%a12]288,%d15

    if (config->channelPriority > 0)
80007a02:	b9 ff 06 00 	ld.hu %d15,[%a15]6
80007a06:	6e 1f       	jz %d15,80007a44 <IfxVadc_Adc_initChannel+0x138>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
80007a08:	02 84       	mov %d4,%d8
80007a0a:	08 b5       	ld.bu %d5,[%a15]11
80007a0c:	6d ff 6b e7 	call 800048e2 <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_clearChannelRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelId)
{
    vadcG->CEFCLR.U = 1 << channelId;
80007a10:	79 f2 0c 00 	ld.b %d2,[%a15]12
80007a14:	82 1f       	mov %d15,1
80007a16:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007a1a:	59 cf 10 40 	st.w [%a12]272,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007a1e:	54 22       	ld.w %d2,[%a2]
80007a20:	08 63       	ld.bu %d3,[%a15]6
80007a22:	8f f2 cf 21 	andn %d2,%d2,255
80007a26:	a6 32       	or %d2,%d3

        IfxVadc_clearChannelRequest(vadcG, config->channelId);
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
80007a28:	0c f9       	ld.bu %d15,[%a15]9
80007a2a:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007a2c:	54 22       	ld.w %d2,[%a2]
80007a2e:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007a32:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007a34:	4c 20       	ld.w %d15,[%a2]0
80007a36:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007a3a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007a3c:	4c 20       	ld.w %d15,[%a2]0
80007a3e:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007a42:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80007a44:	0c ff       	ld.bu %d15,[%a15]15
80007a46:	08 a2       	ld.bu %d2,[%a15]10
80007a48:	ff 8f 15 80 	jge.u %d15,8,80007a72 <IfxVadc_Adc_initChannel+0x166>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80007a4c:	19 c4 30 40 	ld.w %d4,[%a12]304
80007a50:	06 2f       	sh %d15,2
80007a52:	3b f0 00 30 	mov %d3,15
80007a56:	0f f3 00 30 	sh %d3,%d3,%d15
80007a5a:	0f 34 e0 30 	andn %d3,%d4,%d3
80007a5e:	59 c3 30 40 	st.w [%a12]304,%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
80007a62:	19 c3 30 40 	ld.w %d3,[%a12]304
80007a66:	0f f2 00 f0 	sh %d15,%d2,%d15
80007a6a:	a6 3f       	or %d15,%d3
80007a6c:	59 cf 30 40 	st.w [%a12]304,%d15
80007a70:	3c 14       	j 80007a98 <IfxVadc_Adc_initChannel+0x18c>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer1(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007a72:	c2 8f       	add %d15,-8
80007a74:	19 c4 34 40 	ld.w %d4,[%a12]308
80007a78:	06 2f       	sh %d15,2
80007a7a:	3b f0 00 30 	mov %d3,15
80007a7e:	0f f3 00 30 	sh %d3,%d3,%d15
80007a82:	0f 34 e0 30 	andn %d3,%d4,%d3
80007a86:	59 c3 34 40 	st.w [%a12]308,%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007a8a:	19 c3 34 40 	ld.w %d3,[%a12]308
80007a8e:	0f f2 00 f0 	sh %d15,%d2,%d15
80007a92:	a6 3f       	or %d15,%d3
80007a94:	59 cf 34 40 	st.w [%a12]308,%d15
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80007a98:	b9 ff 04 00 	ld.hu %d15,[%a15]4
80007a9c:	6e 24       	jz %d15,80007ae4 <IfxVadc_Adc_initChannel+0x1d8>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
80007a9e:	02 84       	mov %d4,%d8
80007aa0:	08 a5       	ld.bu %d5,[%a15]10
80007aa2:	6d ff 20 e7 	call 800048e2 <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_enableServiceRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelResult resultRegister)
{
    vadcG->RCR[resultRegister].B.SRGEN = 1;
80007aa6:	0c ff       	ld.bu %d15,[%a15]15
80007aa8:	1b 0f 08 f0 	addi %d15,%d15,128
80007aac:	90 c3       	addsc.a %a3,%a12,%d15,2
80007aae:	4c 30       	ld.w %d15,[%a3]0
80007ab0:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80007ab4:	6c 30       	st.w [%a3]0,%d15
}


IFX_INLINE void IfxVadc_clearAllResultRequests(Ifx_VADC_G *vadcG)
{
    vadcG->REFCLR.U = 0x0000FFFFu;
80007ab6:	bb f0 ff ff 	mov.u %d15,65535
80007aba:	59 cf 14 40 	st.w [%a12]276,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007abe:	54 22       	ld.w %d2,[%a2]
80007ac0:	08 43       	ld.bu %d3,[%a15]4
80007ac2:	8f f2 cf 21 	andn %d2,%d2,255
80007ac6:	a6 32       	or %d2,%d3

        IfxVadc_enableServiceRequest(vadcG, config->resultRegister);
        IfxVadc_clearAllResultRequests(vadcG);
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
80007ac8:	0c f8       	ld.bu %d15,[%a15]8
80007aca:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007acc:	54 22       	ld.w %d2,[%a2]
80007ace:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007ad2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007ad4:	4c 20       	ld.w %d15,[%a2]0
80007ad6:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007ada:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007adc:	4c 20       	ld.w %d15,[%a2]0
80007ade:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007ae2:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80007ae4:	40 e4       	mov.aa %a4,%a14
80007ae6:	02 84       	mov %d4,%d8
80007ae8:	6d ff b0 e5 	call 80004648 <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007aec:	0c ff       	ld.bu %d15,[%a15]15
    channel->channel   = config->channelId;

    return Status;
}
80007aee:	82 02       	mov %d2,0
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007af0:	2c d1       	st.b [%a13]1,%d15
    channel->channel   = config->channelId;
80007af2:	0c fc       	ld.bu %d15,[%a15]12
80007af4:	2c d0       	st.b [%a13]0,%d15

    return Status;
}
80007af6:	00 90       	ret 

80007af8 <IfxVadc_Adc_initChannelConfig>:
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
80007af8:	40 42       	mov.aa %a2,%a4
80007afa:	d2 02       	mov %e2,0
80007afc:	89 22 48 01 	st.d [%a2+]8,%e2
80007b00:	89 22 48 01 	st.d [%a2+]8,%e2
80007b04:	89 22 48 01 	st.d [%a2+]8,%e2
    config->group = group;
80007b08:	b5 45 14 00 	st.a [%a4]20,%a5
80007b0c:	00 90       	ret 

80007b0e <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80007b0e:	d4 52       	ld.a %a2,[%a5]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80007b10:	39 58 04 00 	ld.bu %d8,[%a5]4


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80007b14:	d4 2c       	ld.a %a12,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80007b16:	8f a8 00 90 	sh %d9,%d8,10
80007b1a:	1b 09 48 f0 	addi %d15,%d9,1152
80007b1e:	10 cd       	addsc.a %a13,%a12,%d15,0

    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
80007b20:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];

    /* check for write access */
    group->group   = vadcG;
80007b22:	b5 4d 04 00 	st.a [%a4]4,%a13
    group->module  = *config->module;
80007b26:	6c 40       	st.w [%a4]0,%d15
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
80007b28:	e9 48 08 00 	st.b [%a4]8,%d8
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007b2c:	40 c4       	mov.aa %a4,%a12
    config->group = group;
}


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
80007b2e:	40 5f       	mov.aa %a15,%a5
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007b30:	6d ff 5a e6 	call 800047e4 <IfxVadc_getAdcAnalogFrequency>

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007b34:	1b 08 01 f0 	addi %d15,%d8,16
80007b38:	8f ff 0f a1 	and %d10,%d15,255
80007b3c:	40 c4       	mov.aa %a4,%a12
80007b3e:	02 a4       	mov %d4,%d10
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007b40:	02 2b       	mov %d11,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007b42:	6d ff 9f e5 	call 80004680 <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007b46:	39 ff 33 00 	ld.bu %d15,[%a15]51
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007b4a:	40 d4       	mov.aa %a4,%a13
    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007b4c:	5e 17       	jne %d15,1,80007b5a <IfxVadc_Adc_initGroup+0x4c>
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007b4e:	82 14       	mov %d4,1
80007b50:	39 f5 26 00 	ld.bu %d5,[%a15]38
80007b54:	39 f6 27 00 	ld.bu %d6,[%a15]39
80007b58:	3c 03       	j 80007b5e <IfxVadc_Adc_initGroup+0x50>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80007b5a:	d2 04       	mov %e4,0
80007b5c:	82 06       	mov %d6,0
80007b5e:	82 07       	mov %d7,0
80007b60:	6d ff 06 e8 	call 80004b6c <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007b64:	39 ff 34 00 	ld.bu %d15,[%a15]52
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007b68:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007b6a:	5e 17       	jne %d15,1,80007b78 <IfxVadc_Adc_initGroup+0x6a>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007b6c:	82 14       	mov %d4,1
80007b6e:	39 f5 1e 00 	ld.bu %d5,[%a15]30
80007b72:	39 f6 1f 00 	ld.bu %d6,[%a15]31
80007b76:	3c 03       	j 80007b7c <IfxVadc_Adc_initGroup+0x6e>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80007b78:	d2 04       	mov %e4,0
80007b7a:	82 06       	mov %d6,0
80007b7c:	82 17       	mov %d7,1
80007b7e:	6d ff f7 e7 	call 80004b6c <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007b82:	39 ff 35 00 	ld.bu %d15,[%a15]53
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007b86:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007b88:	5e 17       	jne %d15,1,80007b96 <IfxVadc_Adc_initGroup+0x88>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007b8a:	82 14       	mov %d4,1
80007b8c:	39 f5 2e 00 	ld.bu %d5,[%a15]46
80007b90:	39 f6 2f 00 	ld.bu %d6,[%a15]47
80007b94:	3c 03       	j 80007b9a <IfxVadc_Adc_initGroup+0x8c>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
80007b96:	d2 04       	mov %e4,0
80007b98:	82 06       	mov %d6,0
80007b9a:	82 27       	mov %d7,2
80007b9c:	6d ff e8 e7 	call 80004b6c <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
80007ba0:	0c f5       	ld.bu %d15,[%a15]5
80007ba2:	be 8b       	jeq %d15,%d8,80007bd8 <IfxVadc_Adc_initGroup+0xca>
}


IFX_INLINE IfxVadc_Adc_SYNCTR_STSEL IfxVadc_Adc_getMasterKernelIndex(IfxVadc_GroupId slave, IfxVadc_GroupId master)
{
    return IfxVadc_Adc_masterIndex[slave][master];
80007ba4:	13 88 20 ff 	madd %d15,%d15,%d8,8
80007ba8:	91 00 00 28 	movh.a %a2,32768
80007bac:	d9 22 f8 40 	lea %a2,[%a2]3384 <80000d38 <IfxVadc_Adc_masterIndex>>
80007bb0:	10 22       	addsc.a %a2,%a2,%d15,0
80007bb2:	0c 20       	ld.bu %d15,[%a2]0
}


IFX_INLINE void IfxVadc_setMasterIndex(Ifx_VADC_G *vadcG, uint8 masterIndex)
{
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80007bb4:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007bb8:	8f 3f 00 21 	and %d2,%d15,3
80007bbc:	19 23 40 30 	ld.w %d3,[%a2]1216
80007bc0:	37 f3 02 f0 	insert %d15,%d3,%d15,0,2
80007bc4:	59 2f 40 30 	st.w [%a2]1216,%d15
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
80007bc8:	19 23 40 30 	ld.w %d3,[%a2]1216
80007bcc:	da 08       	mov %d15,8
80007bce:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007bd2:	a6 3f       	or %d15,%d3
80007bd4:	59 2f 40 30 	st.w [%a2]1216,%d15
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007bd8:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007bdc:	19 2f 40 20 	ld.w %d15,[%a2]1152
80007be0:	8f 3f c0 f1 	andn %d15,%d15,3
80007be4:	59 2f 40 20 	st.w [%a2]1152,%d15
}


IFX_INLINE void IfxVadc_setArbitrationRoundLength(Ifx_VADC_G *vadcG, IfxVadc_ArbitrationRounds arbiterRoundLength)
{
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80007be8:	39 ff 32 00 	ld.bu %d15,[%a15]50
80007bec:	19 22 40 20 	ld.w %d2,[%a2]1152
80007bf0:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007bf4:	59 2f 40 20 	st.w [%a2]1152,%d15
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007bf8:	39 ff 33 00 	ld.bu %d15,[%a15]51
80007bfc:	df 1f 5a 80 	jne %d15,1,80007cb0 <IfxVadc_Adc_initGroup+0x1a2>
    {
        const IfxVadc_Adc_QueueConfig *queueSlot = &config->queueRequest;

        /* configure external Trigger if enabled */
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007c00:	39 ff 25 00 	ld.bu %d15,[%a15]37
80007c04:	6e 28       	jz %d15,80007c54 <IfxVadc_Adc_initGroup+0x146>
}


IFX_INLINE void IfxVadc_enableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80007c06:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007c0a:	96 04       	or %d15,4
80007c0c:	59 2f 44 40 	st.w [%a2]1284,%d15


IFX_INLINE void IfxVadc_setQueueSlotTriggerOperatingConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U        = vadcG->QCTRL0.U;
80007c10:	19 23 40 40 	ld.w %d3,[%a2]1280
        {
            /* enable external trigger */
            IfxVadc_enableQueueSlotExternalTrigger(vadcG);
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
80007c14:	39 f2 25 00 	ld.bu %d2,[%a15]37
80007c18:	39 ff 23 00 	ld.bu %d15,[%a15]35
    qctrl0.B.XTWC   = 1;
80007c1c:	b7 13 81 37 	insert %d3,%d3,1,15,1
    qctrl0.B.XTMODE = triggerMode;
80007c20:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    qctrl0.B.XTSEL  = triggerSource;
80007c24:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80007c28:	59 23 40 40 	st.w [%a2]1280,%d3

            /* if last input is used the trigger input selection is extend by Gating inputs */
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80007c2c:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007c30:	8b ff 20 f2 	ne %d15,%d15,15
80007c34:	ee 16       	jnz %d15,80007c60 <IfxVadc_Adc_initGroup+0x152>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007c36:	19 23 40 40 	ld.w %d3,[%a2]1280
            {
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007c3a:	39 ff 22 00 	ld.bu %d15,[%a15]34
    qctrl0.B.GTWC      = 1;
80007c3e:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007c42:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007c46:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007c4a:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007c4e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007c52:	3c 05       	j 80007c5c <IfxVadc_Adc_initGroup+0x14e>
}


IFX_INLINE void IfxVadc_disableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
80007c54:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007c58:	8f 4f c0 f1 	andn %d15,%d15,4
80007c5c:	59 2f 44 40 	st.w [%a2]1284,%d15
            /* disable external trigger */
            IfxVadc_disableQueueSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007c60:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007c64:	8b ff 00 f2 	eq %d15,%d15,15
80007c68:	ee 15       	jnz %d15,80007c92 <IfxVadc_Adc_initGroup+0x184>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007c6a:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80007c6e:	39 f2 22 00 	ld.bu %d2,[%a15]34
80007c72:	19 23 40 40 	ld.w %d3,[%a2]1280
80007c76:	39 ff 24 00 	ld.bu %d15,[%a15]36
    qctrl0.B.GTWC      = 1;
80007c7a:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007c7e:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007c82:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007c86:	19 22 44 40 	ld.w %d2,[%a2]1284
80007c8a:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007c8e:	59 2f 44 40 	st.w [%a2]1284,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80007c92:	39 f2 20 00 	ld.bu %d2,[%a15]32
}


IFX_INLINE void IfxVadc_clearQueue(Ifx_VADC_G *vadcG, boolean flushQueue)
{
    vadcG->QMR0.B.FLUSH = flushQueue;
80007c96:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007c9a:	3b 00 40 f0 	mov %d15,1024
80007c9e:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80007ca2:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007ca6:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80007caa:	a6 2f       	or %d15,%d2
80007cac:	59 2f 44 40 	st.w [%a2]1284,%d15
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007cb0:	39 ff 34 00 	ld.bu %d15,[%a15]52
80007cb4:	df 1f 5a 80 	jne %d15,1,80007d68 <IfxVadc_Adc_initGroup+0x25a>
    {
        const IfxVadc_Adc_ScanConfig *scanSlot = &config->scanRequest;

        /* configure external Trigger if enabled */
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007cb8:	39 ff 1d 00 	ld.bu %d15,[%a15]29
}


IFX_INLINE void IfxVadc_enableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
80007cbc:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007cc0:	6e 28       	jz %d15,80007d10 <IfxVadc_Adc_initGroup+0x202>
80007cc2:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007cc6:	96 04       	or %d15,4
80007cc8:	59 2f 64 40 	st.w [%a2]1316,%d15


IFX_INLINE void IfxVadc_setScanSlotTriggerConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U        = vadcG->ASCTRL.U;
80007ccc:	19 23 60 40 	ld.w %d3,[%a2]1312
        {
            /* enable external trigger */
            IfxVadc_enableScanSlotExternalTrigger(vadcG);

            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80007cd0:	39 f2 1d 00 	ld.bu %d2,[%a15]29
80007cd4:	39 ff 1b 00 	ld.bu %d15,[%a15]27
    asctrl.B.XTWC   = 1;
80007cd8:	b7 13 81 37 	insert %d3,%d3,1,15,1
    asctrl.B.XTMODE = triggerMode;
80007cdc:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    asctrl.B.XTSEL  = triggerSource;
80007ce0:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->ASCTRL.U = asctrl.U;
80007ce4:	59 23 60 40 	st.w [%a2]1312,%d3

            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007ce8:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007cec:	8b ff 20 f2 	ne %d15,%d15,15
80007cf0:	ee 16       	jnz %d15,80007d1c <IfxVadc_Adc_initGroup+0x20e>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007cf2:	19 23 60 40 	ld.w %d3,[%a2]1312
            {
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007cf6:	39 ff 1a 00 	ld.bu %d15,[%a15]26
    asctrl.B.GTWC      = 1;
80007cfa:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007cfe:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007d02:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007d06:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d0a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007d0e:	3c 05       	j 80007d18 <IfxVadc_Adc_initGroup+0x20a>
}


IFX_INLINE void IfxVadc_disableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80007d10:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d14:	8f 4f c0 f1 	andn %d15,%d15,4
80007d18:	59 2f 64 40 	st.w [%a2]1316,%d15
        {
            IfxVadc_disableScanSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007d1c:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007d20:	8b ff 00 f2 	eq %d15,%d15,15
80007d24:	ee 15       	jnz %d15,80007d4e <IfxVadc_Adc_initGroup+0x240>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007d26:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80007d2a:	39 f2 1a 00 	ld.bu %d2,[%a15]26
80007d2e:	19 23 60 40 	ld.w %d3,[%a2]1312
80007d32:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    asctrl.B.GTWC      = 1;
80007d36:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007d3a:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007d3e:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007d42:	19 22 64 40 	ld.w %d2,[%a2]1316
80007d46:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007d4a:	59 2f 64 40 	st.w [%a2]1316,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80007d4e:	39 ff 18 00 	ld.bu %d15,[%a15]24
}


IFX_INLINE void IfxVadc_setAutoScan(Ifx_VADC_G *vadcG, boolean autoscanEnable)
{
    vadcG->ASMR.B.SCAN = autoscanEnable;
80007d52:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007d56:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007d5a:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007d5e:	8f 0f c1 f1 	andn %d15,%d15,16
80007d62:	a6 2f       	or %d15,%d2
80007d64:	59 2f 64 40 	st.w [%a2]1316,%d15
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007d68:	39 ff 35 00 	ld.bu %d15,[%a15]53
80007d6c:	df 1f 4f 80 	jne %d15,1,80007e0a <IfxVadc_Adc_initGroup+0x2fc>
    {
        const IfxVadc_Adc_BackgroundScanConfig *backgroundScanSlot = &config->backgroundScanRequest;

        /* configure external Trigger if enabled */
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007d70:	39 ff 2d 00 	ld.bu %d15,[%a15]45
80007d74:	6e 29       	jz %d15,80007dc6 <IfxVadc_Adc_initGroup+0x2b8>
}


IFX_INLINE void IfxVadc_enableBackgroundScanSlotExternalTrigger(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80007d76:	19 cf 04 80 	ld.w %d15,[%a12]516
80007d7a:	96 04       	or %d15,4
80007d7c:	59 cf 04 80 	st.w [%a12]516,%d15


IFX_INLINE void IfxVadc_setBackgroundScanSlotTriggerConfig(Ifx_VADC *vadc, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U        = vadc->BRSCTRL.U;
80007d80:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_enableBackgroundScanSlotExternalTrigger(vadc);

            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80007d84:	39 f2 2d 00 	ld.bu %d2,[%a15]45
80007d88:	39 ff 2b 00 	ld.bu %d15,[%a15]43
    brsctrl.B.XTWC   = 1;
80007d8c:	b7 13 81 37 	insert %d3,%d3,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80007d90:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    brsctrl.B.XTSEL  = triggerSource;
80007d94:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
80007d98:	59 c3 00 80 	st.w [%a12]512,%d3

            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007d9c:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007da0:	8b ff 20 f2 	ne %d15,%d15,15
80007da4:	ee 11       	jnz %d15,80007dc6 <IfxVadc_Adc_initGroup+0x2b8>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007da6:	19 c3 00 80 	ld.w %d3,[%a12]512
            {
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007daa:	39 ff 2a 00 	ld.bu %d15,[%a15]42
    brsctrl.B.GTWC     = 1;
80007dae:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007db2:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
80007db6:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007dba:	19 cf 04 80 	ld.w %d15,[%a12]516
80007dbe:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007dc2:	59 cf 04 80 	st.w [%a12]516,%d15
        {
            /* do nothing */
        }

        /* configure Gating if enabled */
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007dc6:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007dca:	8b ff 00 f2 	eq %d15,%d15,15
80007dce:	ee 13       	jnz %d15,80007df4 <IfxVadc_Adc_initGroup+0x2e6>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007dd0:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80007dd4:	39 f2 2a 00 	ld.bu %d2,[%a15]42
    brsctrl.B.GTWC     = 1;
80007dd8:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007ddc:	37 23 04 38 	insert %d3,%d3,%d2,16,4
80007de0:	39 ff 2c 00 	ld.bu %d15,[%a15]44
    vadc->BRSCTRL.U    = brsctrl.U;
80007de4:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007de8:	19 c2 04 80 	ld.w %d2,[%a12]516
80007dec:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007df0:	59 cf 04 80 	st.w [%a12]516,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
80007df4:	39 ff 28 00 	ld.bu %d15,[%a15]40
}


IFX_INLINE void IfxVadc_setAutoBackgroundScan(Ifx_VADC *vadc, boolean autoBackgroundScanEnable)
{
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80007df8:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007dfc:	19 cf 04 80 	ld.w %d15,[%a12]516
80007e00:	8f 0f c1 f1 	andn %d15,%d15,16
80007e04:	a6 2f       	or %d15,%d2
80007e06:	59 cf 04 80 	st.w [%a12]516,%d15
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80007e0a:	0c f5       	ld.bu %d15,[%a15]5
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007e0c:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007e10:	3a 8f       	eq %d15,%d15,%d8
80007e12:	ab 3f a0 2f 	seln %d2,%d15,%d15,3
80007e16:	19 2f 40 20 	ld.w %d15,[%a2]1152
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80007e1a:	02 84       	mov %d4,%d8
80007e1c:	8f 3f c0 f1 	andn %d15,%d15,3
80007e20:	a6 2f       	or %d15,%d2
80007e22:	59 2f 40 20 	st.w [%a2]1152,%d15
80007e26:	39 f5 30 00 	ld.bu %d5,[%a15]48
80007e2a:	40 c4       	mov.aa %a4,%a12
80007e2c:	6d ff 69 e4 	call 800046fe <IfxVadc_disablePostCalibration>
}


IFX_INLINE void IfxVadc_setGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
80007e30:	8f 88 00 80 	sh %d8,%d8,8
80007e34:	82 05       	mov %d5,0
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80007e36:	3b f0 0f 40 	mov %d4,255

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
80007e3a:	01 f5 03 26 	addsc.a %a2,%a15,%d5,3
80007e3e:	0b 58 00 20 	add %d2,%d8,%d5
80007e42:	1b 82 12 20 	addi %d2,%d2,296
80007e46:	0c 2c       	ld.bu %d15,[%a2]12
80007e48:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
80007e4c:	54 22       	ld.w %d2,[%a2]
80007e4e:	37 f2 03 f4 	insert %d15,%d2,%d15,8,3
80007e52:	6c 20       	st.w [%a2]0,%d15
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
80007e54:	9a 15       	add %d15,%d5,1
80007e56:	d0 f2       	addsc.a %a2,%a15,%d15,3

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007e58:	54 23       	ld.w %d3,[%a2]
80007e5a:	4b 3b 41 30 	mul.f %d3,%d11,%d3
80007e5e:	4b 03 71 31 	ftouz %d3,%d3
80007e62:	c2 e3       	add %d3,-2

    if (ticks > 31)
80007e64:	8b 03 62 f2 	lt.u %d15,%d3,32
80007e68:	ee 04       	jnz %d15,80007e70 <IfxVadc_Adc_initGroup+0x362>
    {
        ticks = (ticks / 16) + 15;
80007e6a:	06 c3       	sh %d3,-4
80007e6c:	1b f3 00 30 	addi %d3,%d3,15
80007e70:	0b 43 90 31 	min.u %d3,%d3,%d4
}


IFX_INLINE void IfxVadc_setGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007e74:	1a 58       	add %d15,%d8,%d5
80007e76:	1b 8f 12 f0 	addi %d15,%d15,296
80007e7a:	90 c2       	addsc.a %a2,%a12,%d15,2
80007e7c:	4c 20       	ld.w %d15,[%a2]0
80007e7e:	37 3f 05 30 	insert %d3,%d15,%d3,0,5
80007e82:	74 23       	st.w [%a2],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80007e84:	df 15 04 00 	jeq %d5,1,80007e8c <IfxVadc_Adc_initGroup+0x37e>
80007e88:	82 15       	mov %d5,1
80007e8a:	3c d8       	j 80007e3a <IfxVadc_Adc_initGroup+0x32c>
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007e8c:	40 c4       	mov.aa %a4,%a12
80007e8e:	02 a4       	mov %d4,%d10
80007e90:	6d ff dc e3 	call 80004648 <IfxVadc_disableAccess>

    return status;
}
80007e94:	82 02       	mov %d2,0
80007e96:	00 90       	ret 

80007e98 <IfxVadc_Adc_initGroupConfig>:
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80007e98:	40 42       	mov.aa %a2,%a4
80007e9a:	7b 60 58 f3 	movh %d15,13702
80007e9e:	d2 02       	mov %e2,0
80007ea0:	a0 6f       	mov.a %a15,6
80007ea2:	89 22 48 01 	st.d [%a2+]8,%e2
80007ea6:	fc fe       	loop %a15,80007ea2 <IfxVadc_Adc_initGroupConfig+0xa>
80007ea8:	1b df 7b f3 	addi %d15,%d15,14269
80007eac:	6c 42       	st.w [%a4]8,%d15
80007eae:	6c 44       	st.w [%a4]16,%d15
80007eb0:	82 1f       	mov %d15,1
80007eb2:	e9 4f 1e 00 	st.b [%a4]30,%d15
80007eb6:	e9 4f 20 00 	st.b [%a4]32,%d15
80007eba:	e9 4f 26 00 	st.b [%a4]38,%d15
80007ebe:	e9 4f 2e 00 	st.b [%a4]46,%d15
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
80007ec2:	f4 45       	st.a [%a4],%a5
80007ec4:	00 90       	ret 

80007ec6 <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80007ec6:	cc 50       	ld.a %a15,[%a5]0
    config->disablePostCalibration = FALSE;
}


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
80007ec8:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
    vadc->vadc = vadcSFR;
80007eca:	ec 40       	st.a [%a4]0,%a15
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007ecc:	6d ff 0f fa 	call 800072ea <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007ed0:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007ed2:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007ed4:	6d ff 0b f9 	call 800070ea <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80007ed8:	82 02       	mov %d2,0
80007eda:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007edc:	02 f4       	mov %d4,%d15
80007ede:	6d ff 3b fa 	call 80007354 <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
80007ee2:	40 f4       	mov.aa %a4,%a15
80007ee4:	39 c4 21 00 	ld.bu %d4,[%a12]33
80007ee8:	6d ff 30 e6 	call 80004b48 <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007eec:	19 c4 18 00 	ld.w %d4,[%a12]24
80007ef0:	40 f4       	mov.aa %a4,%a15
80007ef2:	4b 04 71 41 	ftouz %d4,%d4
    {
        return IfxVadc_Status_notInitialised;
80007ef6:	82 1f       	mov %d15,1
    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007ef8:	6d ff 42 e5 	call 8000497c <IfxVadc_initializeFAdcI>
80007efc:	df 02 57 00 	jeq %d2,0,80007faa <IfxVadc_Adc_initModule+0xe4>
    {
        /* do nothing */
    }

    /* Set digital Frequency */
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
80007f00:	19 c4 14 00 	ld.w %d4,[%a12]20
80007f04:	40 f4       	mov.aa %a4,%a15
80007f06:	4b 04 71 41 	ftouz %d4,%d4
80007f0a:	6d ff 24 e5 	call 80004952 <IfxVadc_initializeFAdcD>

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
80007f0e:	40 f4       	mov.aa %a4,%a15
80007f10:	6d ff 6a e4 	call 800047e4 <IfxVadc_getAdcAnalogFrequency>
80007f14:	82 03       	mov %d3,0
80007f16:	3b f0 0f 60 	mov %d6,255

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
    {
        /* configure ADC channel resolution ( conversion mode ) */
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
80007f1a:	9a 13       	add %d15,%d3,1
}


IFX_INLINE void IfxVadc_setGlobalResolution(Ifx_VADC *vadc, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
80007f1c:	1b 83 02 40 	addi %d4,%d3,40
80007f20:	d0 c2       	addsc.a %a2,%a12,%d15,3
80007f22:	01 f4 02 36 	addsc.a %a3,%a15,%d4,2
80007f26:	0c 20       	ld.bu %d15,[%a2]0
80007f28:	54 35       	ld.w %d5,[%a3]
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
80007f2a:	01 c3 03 26 	addsc.a %a2,%a12,%d3,3
80007f2e:	37 f5 03 f4 	insert %d15,%d5,%d15,8,3
80007f32:	6c 30       	st.w [%a3]0,%d15

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007f34:	4c 21       	ld.w %d15,[%a2]4
80007f36:	4b f2 41 f0 	mul.f %d15,%d2,%d15
80007f3a:	4b 0f 71 f1 	ftouz %d15,%d15
80007f3e:	c2 ef       	add %d15,-2

    if (ticks > 31)
80007f40:	8b 0f 62 52 	lt.u %d5,%d15,32
80007f44:	f6 54       	jnz %d5,80007f4c <IfxVadc_Adc_initModule+0x86>
    {
        ticks = (ticks / 16) + 15;
80007f46:	06 cf       	sh %d15,-4
80007f48:	1b ff 00 f0 	addi %d15,%d15,15
80007f4c:	0b 6f 90 f1 	min.u %d15,%d15,%d6
}


IFX_INLINE void IfxVadc_setGlobalSampleTime(Ifx_VADC *vadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007f50:	01 f4 02 26 	addsc.a %a2,%a15,%d4,2
80007f54:	54 24       	ld.w %d4,[%a2]
80007f56:	37 f4 05 f0 	insert %d15,%d4,%d15,0,5
80007f5a:	6c 20       	st.w [%a2]0,%d15
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80007f5c:	df 13 04 00 	jeq %d3,1,80007f64 <IfxVadc_Adc_initModule+0x9e>
80007f60:	82 13       	mov %d3,1
80007f62:	3c dc       	j 80007f1a <IfxVadc_Adc_initModule+0x54>
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007f64:	39 c2 20 00 	ld.bu %d2,[%a12]32

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
80007f68:	82 0f       	mov %d15,0
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007f6a:	df 12 20 80 	jne %d2,1,80007faa <IfxVadc_Adc_initModule+0xe4>
80007f6e:	82 08       	mov %d8,0
80007f70:	1b 08 01 f0 	addi %d15,%d8,16
80007f74:	16 ff       	and %d15,255
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007f76:	02 f4       	mov %d4,%d15
80007f78:	40 f4       	mov.aa %a4,%a15
80007f7a:	6d ff 83 e3 	call 80004680 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007f7e:	8f a8 00 20 	sh %d2,%d8,10
80007f82:	01 f2 00 26 	addsc.a %a2,%a15,%d2,0
80007f86:	c2 18       	add %d8,1
80007f88:	19 22 40 20 	ld.w %d2,[%a2]1152
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007f8c:	02 f4       	mov %d4,%d15
80007f8e:	8f 32 40 21 	or %d2,%d2,3
80007f92:	59 22 40 20 	st.w [%a2]1152,%d2
80007f96:	40 f4       	mov.aa %a4,%a15

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007f98:	8b 88 20 f2 	ne %d15,%d8,8
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007f9c:	6d ff 56 e3 	call 80004648 <IfxVadc_disableAccess>

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007fa0:	ee e8       	jnz %d15,80007f70 <IfxVadc_Adc_initModule+0xaa>
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
        }

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
80007fa2:	40 f4       	mov.aa %a4,%a15
80007fa4:	6d ff 19 e6 	call 80004bd6 <IfxVadc_startupCalibration>
    }

    return status;
80007fa8:	82 0f       	mov %d15,0
}
80007faa:	02 f2       	mov %d2,%d15
80007fac:	00 90       	ret 

80007fae <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007fae:	7b 90 b9 f4 	movh %d15,19353
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80007fb2:	40 4f       	mov.aa %a15,%a4
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007fb4:	1b 0f 68 f9 	addi %d15,%d15,-27008
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80007fb8:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
80007fba:	e8 05       	st.a [%a15]0,%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007fbc:	68 6f       	st.w [%a15]24,%d15

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
80007fbe:	6d ff 1f e4 	call 800047fc <IfxVadc_getAdcDigitalFrequency>
80007fc2:	68 52       	st.w [%a15]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
80007fc4:	6d ff cf f0 	call 80006162 <IfxScuCcu_getSpbFrequency>
80007fc8:	68 72       	st.w [%a15]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007fca:	7b 60 58 23 	movh %d2,13702
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80007fce:	82 0f       	mov %d15,0
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007fd0:	1b d2 7b 23 	addi %d2,%d2,14269
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80007fd4:	28 8f       	st.b [%a15]8,%d15
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007fd6:	68 12       	st.w [%a15]4,%d2
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
80007fd8:	e9 ff 10 00 	st.b [%a15]16,%d15
    config->globalInputClass[1].sampleTime = 1.0e-6;
80007fdc:	68 32       	st.w [%a15]12,%d2
    config->startupCalibration             = FALSE;
80007fde:	e9 ff 20 00 	st.b [%a15]32,%d15
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
80007fe2:	e9 ff 21 00 	st.b [%a15]33,%d15
80007fe6:	00 90       	ret 

80007fe8 <IfxVadc_Adc_initExternalMultiplexerModeConfig>:
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
80007fe8:	20 10       	sub.a %sp,16
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80007fea:	82 0f       	mov %d15,0
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007fec:	40 a2       	mov.aa %a2,%sp


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80007fee:	2c 49       	st.b [%a4]9,%d15
    emuxConfig->groupId               = IfxVadc_GroupId_0;
80007ff0:	2c 48       	st.b [%a4]8,%d15
    emuxConfig->emuxInterface         = IfxVadc_EmuxInterface_0;
80007ff2:	2c 4a       	st.b [%a4]10,%d15
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
80007ff4:	2c 45       	st.b [%a4]5,%d15
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
80007ff6:	2c 46       	st.b [%a4]6,%d15
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
80007ff8:	2c 47       	st.b [%a4]7,%d15
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
80007ffa:	2c 44       	st.b [%a4]4,%d15
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
80007ffc:	e9 4f 1c 00 	st.b [%a4]28,%d15
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80008000:	d2 02       	mov %e2,0
80008002:	89 22 48 01 	st.d [%a2+]8,%e2
80008006:	89 22 48 01 	st.d [%a2+]8,%e2
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
8000800a:	3b 00 f8 ff 	mov %d15,-128
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
8000800e:	f4 45       	st.a [%a4],%a5
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80008010:	40 af       	mov.aa %a15,%sp
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
80008012:	2c ac       	st.b [%sp]12,%d15
80008014:	d9 44 0c 00 	lea %a4,[%a4]12
80008018:	09 f2 48 01 	ld.d %e2,[%a15+]8
8000801c:	89 42 48 01 	st.d [%a4+]8,%e2
80008020:	09 f2 48 01 	ld.d %e2,[%a15+]8
80008024:	89 42 48 01 	st.d [%a4+]8,%e2
80008028:	00 90       	ret 

8000802a <IfxVadc_Adc_initExternalMultiplexerMode>:


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
8000802a:	0c 58       	ld.bu %d15,[%a5]8
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
8000802c:	20 08       	sub.a %sp,8
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
8000802e:	8f af 00 20 	sh %d2,%d15,10
80008032:	1b 02 48 20 	addi %d2,%d2,1152
80008036:	01 42 00 e6 	addsc.a %a14,%a4,%d2,0
}


IFX_INLINE void IfxVadc_setEmuxInterfaceForGroup(Ifx_VADC *vadc, IfxVadc_EmuxInterface emuxInterface, IfxVadc_GroupId group)
{
    if (emuxInterface == IfxVadc_EmuxInterface_0)
8000803a:	39 52 0a 00 	ld.bu %d2,[%a5]10
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
8000803e:	40 4c       	mov.aa %a12,%a4
80008040:	40 5f       	mov.aa %a15,%a5
80008042:	16 0f       	and %d15,15
80008044:	f6 2a       	jnz %d2,80008058 <IfxVadc_Adc_initExternalMultiplexerMode+0x2e>
    {
        vadc->EMUXSEL.B.EMUXGRP0 = group;
80008046:	19 42 30 f0 	ld.w %d2,[%a4]1008
8000804a:	8f f2 c0 21 	andn %d2,%d2,15
8000804e:	a6 2f       	or %d15,%d2
80008050:	59 cf 30 f0 	st.w [%a12]1008,%d15
80008054:	82 0f       	mov %d15,0
80008056:	3c 07       	j 80008064 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
    }
    else
    {
        vadc->EMUXSEL.B.EMUXGRP1 = group;
80008058:	19 42 30 f0 	ld.w %d2,[%a4]1008
8000805c:	06 4f       	sh %d15,4
8000805e:	8f 02 cf 21 	andn %d2,%d2,240
80008062:	3c f6       	j 8000804e <IfxVadc_Adc_initExternalMultiplexerMode+0x24>
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
    {
        if (emuxControl->emuxOutPinConfig.pins[count] != NULL_PTR)
80008064:	90 f2       	addsc.a %a2,%a15,%d15,2
80008066:	99 2d 0c 00 	ld.a %a13,[%a2]12
8000806a:	bd 0d 19 00 	jz.a %a13,8000809c <IfxVadc_Adc_initExternalMultiplexerMode+0x72>
8000806e:	39 d3 0c 00 	ld.bu %d3,[%a13]12
80008072:	39 f2 18 00 	ld.bu %d2,[%a15]24
80008076:	99 d4 04 00 	ld.a %a4,[%a13]4
8000807a:	0f 23 a0 50 	or %d5,%d3,%d2
8000807e:	39 d4 08 00 	ld.bu %d4,[%a13]8
80008082:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
80008086:	39 f8 19 00 	ld.bu %d8,[%a15]25
8000808a:	6d ff c4 ed 	call 80005c12 <IfxPort_setPinMode>


IFX_INLINE void IfxVadc_initEmuxPin(const IfxVadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(emux->pin.port, emux->pin.pinIndex, outputMode, emux->select);
    IfxPort_setPinPadDriver(emux->pin.port, emux->pin.pinIndex, padDriver);
8000808e:	99 d4 04 00 	ld.a %a4,[%a13]4
80008092:	39 d4 08 00 	ld.bu %d4,[%a13]8
80008096:	02 85       	mov %d5,%d8
80008098:	6d ff 3b ee 	call 80005d0e <IfxPort_setPinPadDriver>
8000809c:	c2 1f       	add %d15,1
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
8000809e:	df 3f e3 ff 	jne %d15,3,80008064 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
        }
    }

    IfxVadc_configExternalMultiplexerMode(vadc, vadcG, emuxControl->mode, emuxControl->channels, emuxControl->startChannel, emuxControl->code, emuxControl->sampleTimeControl, emuxControl->channelSelectionStyle);
800080a2:	0c f7       	ld.bu %d15,[%a15]7
800080a4:	08 44       	ld.bu %d4,[%a15]4
800080a6:	78 00       	st.w [%sp]0,%d15
800080a8:	39 ff 1c 00 	ld.bu %d15,[%a15]28
800080ac:	08 95       	ld.bu %d5,[%a15]9
800080ae:	08 56       	ld.bu %d6,[%a15]5
800080b0:	08 67       	ld.bu %d7,[%a15]6
800080b2:	78 01       	st.w [%sp]4,%d15
800080b4:	40 c4       	mov.aa %a4,%a12
800080b6:	40 e5       	mov.aa %a5,%a14
800080b8:	1d ff 00 e3 	j 800046b8 <IfxVadc_configExternalMultiplexerMode>

800080bc <Ifx_CircularBuffer_get32>:

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
800080bc:	cc 40       	ld.a %a15,[%a4]0
800080be:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 4;

    if (buffer->index >= buffer->length)
800080c2:	b9 43 06 00 	ld.hu %d3,[%a4]6

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
800080c6:	90 ff       	addsc.a %a15,%a15,%d15,2

    buffer->index += 4;
800080c8:	c2 4f       	add %d15,4
800080ca:	37 0f 70 f0 	extr.u %d15,%d15,0,16

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
800080ce:	48 02       	ld.w %d2,[%a15]0

    buffer->index += 4;
800080d0:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
800080d2:	3f 3f 04 80 	jlt.u %d15,%d3,800080da <Ifx_CircularBuffer_get32+0x1e>
    {
        buffer->index = 0;
800080d6:	82 0f       	mov %d15,0
800080d8:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
800080da:	00 90       	ret 

800080dc <Ifx_CircularBuffer_get16>:


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
800080dc:	cc 40       	ld.a %a15,[%a4]0
800080de:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 2;

    if (buffer->index >= buffer->length)
800080e2:	b9 43 06 00 	ld.hu %d3,[%a4]6
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
800080e6:	50 ff       	addsc.a %a15,%a15,%d15,1

    buffer->index += 2;
800080e8:	c2 2f       	add %d15,2
800080ea:	37 0f 70 f0 	extr.u %d15,%d15,0,16
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
800080ee:	b9 f2 00 00 	ld.hu %d2,[%a15]0

    buffer->index += 2;
800080f2:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
800080f4:	3f 3f 04 80 	jlt.u %d15,%d3,800080fc <Ifx_CircularBuffer_get16+0x20>
    {
        buffer->index = 0;
800080f8:	82 0f       	mov %d15,0
800080fa:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
800080fc:	00 90       	ret 

800080fe <Ifx_CircularBuffer_addDataIncr>:
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
800080fe:	cc 40       	ld.a %a15,[%a4]0
80008100:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    buffer->index                          += 4;

    if (buffer->index >= buffer->length)
80008104:	b9 42 06 00 	ld.hu %d2,[%a4]6
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80008108:	90 ff       	addsc.a %a15,%a15,%d15,2
    buffer->index                          += 4;
8000810a:	c2 4f       	add %d15,4
8000810c:	37 0f 70 f0 	extr.u %d15,%d15,0,16
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80008110:	68 04       	st.w [%a15]0,%d4
    buffer->index                          += 4;
80008112:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80008114:	3f 2f 04 80 	jlt.u %d15,%d2,8000811c <Ifx_CircularBuffer_addDataIncr+0x1e>
    {
        buffer->index = 0;
80008118:	82 0f       	mov %d15,0
8000811a:	ac 42       	st.h [%a4]4,%d15
8000811c:	00 90       	ret 

8000811e <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
8000811e:	80 52       	mov.d %d2,%a5
80008120:	37 04 70 40 	extr.u %d4,%d4,0,16
80008124:	8f 02 60 31 	nor %d3,%d2,0
80008128:	1a 42       	add %d15,%d2,%d4
8000812a:	42 3f       	add %d15,%d3
8000812c:	42 23       	add %d3,%d2
8000812e:	42 43       	add %d3,%d4
    uint8 *Dest = (uint8 *)data;
80008130:	40 5f       	mov.aa %a15,%a5
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008132:	82 06       	mov %d6,0
80008134:	37 0f 70 f0 	extr.u %d15,%d15,0,16
80008138:	6f f3 03 00 	jz.t %d3,15,8000813e <Ifx_CircularBuffer_read8+0x20>
8000813c:	82 0f       	mov %d15,0
    uint8 *Dest = (uint8 *)data;

    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
8000813e:	b9 43 04 00 	ld.hu %d3,[%a4]4
80008142:	d4 42       	ld.a %a2,[%a4]
80008144:	60 33       	mov.a %a3,%d3
80008146:	30 32       	add.a %a2,%a3
80008148:	14 23       	ld.bu %d3,[%a2]
8000814a:	24 f3       	st.b [%a15+],%d3
        Dest  = &Dest[1];
        buffer->index++;
8000814c:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
80008150:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
        Dest  = &Dest[1];
        buffer->index++;
80008154:	c2 13       	add %d3,1
80008156:	37 03 70 30 	extr.u %d3,%d3,0,16
8000815a:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
8000815e:	3f 53 04 80 	jlt.u %d3,%d5,80008166 <Ifx_CircularBuffer_read8+0x48>
        {
            buffer->index = 0;
80008162:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
80008166:	9f 0f ec ff 	jned %d15,0,8000813e <Ifx_CircularBuffer_read8+0x20>
8000816a:	c2 f4       	add %d4,-1
8000816c:	37 04 50 40 	extr %d4,%d4,0,16
80008170:	8b 04 40 43 	max %d4,%d4,0
80008174:	c2 14       	add %d4,1

    return Dest;
}
80008176:	1a 42       	add %d15,%d2,%d4
80008178:	60 f2       	mov.a %a2,%d15
8000817a:	00 90       	ret 

8000817c <Ifx_CircularBuffer_read32>:


void *Ifx_CircularBuffer_read32(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
8000817c:	37 04 70 40 	extr.u %d4,%d4,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;
80008180:	d4 42       	ld.a %a2,[%a4]
80008182:	1b f4 ff 5f 	addi %d5,%d4,-1
80008186:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
8000818a:	b9 46 06 00 	ld.hu %d6,[%a4]6
8000818e:	82 03       	mov %d3,0
80008190:	37 05 70 20 	extr.u %d2,%d5,0,16
80008194:	6f f5 03 00 	jz.t %d5,15,8000819a <Ifx_CircularBuffer_read32+0x1e>
80008198:	82 02       	mov %d2,0
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
8000819a:	10 2f       	addsc.a %a15,%a2,%d15,0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
8000819c:	c2 4f       	add %d15,4
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
8000819e:	48 05       	ld.w %d5,[%a15]0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
800081a0:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
800081a4:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
800081a8:	c2 13       	add %d3,1
800081aa:	68 05       	st.w [%a15]0,%d5
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
800081ac:	0b 6f 30 51 	lt.u %d5,%d15,%d6
800081b0:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
800081b4:	9f 02 f3 ff 	jned %d2,0,8000819a <Ifx_CircularBuffer_read32+0x1e>
800081b8:	c2 f4       	add %d4,-1
800081ba:	37 04 50 40 	extr %d4,%d4,0,16
800081be:	ac 42       	st.h [%a4]4,%d15
800081c0:	8b 04 40 43 	max %d4,%d4,0
800081c4:	c2 14       	add %d4,1

    return Dest;
}
800081c6:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
800081ca:	00 90       	ret 

800081cc <Ifx_CircularBuffer_write8>:


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
800081cc:	80 52       	mov.d %d2,%a5
800081ce:	37 04 70 40 	extr.u %d4,%d4,0,16
800081d2:	8f 02 60 31 	nor %d3,%d2,0
800081d6:	1a 42       	add %d15,%d2,%d4
800081d8:	42 3f       	add %d15,%d3
800081da:	42 23       	add %d3,%d2
800081dc:	42 43       	add %d3,%d4
    const uint8 *source = (const uint8 *)data;
800081de:	40 5f       	mov.aa %a15,%a5
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
800081e0:	82 06       	mov %d6,0
800081e2:	37 0f 70 f0 	extr.u %d15,%d15,0,16
800081e6:	6f f3 03 00 	jz.t %d3,15,800081ec <Ifx_CircularBuffer_write8+0x20>
800081ea:	82 0f       	mov %d15,0
    const uint8 *source = (const uint8 *)data;

    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
800081ec:	b9 43 04 00 	ld.hu %d3,[%a4]4
800081f0:	d4 42       	ld.a %a2,[%a4]
800081f2:	60 33       	mov.a %a3,%d3
800081f4:	04 f5       	ld.bu %d5,[%a15+]
800081f6:	30 32       	add.a %a2,%a3
800081f8:	34 25       	st.b [%a2],%d5
        source                                 = &source[1];
        buffer->index++;
800081fa:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
800081fe:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
        source                                 = &source[1];
        buffer->index++;
80008202:	c2 13       	add %d3,1
80008204:	37 03 70 30 	extr.u %d3,%d3,0,16
80008208:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
8000820c:	3f 53 04 80 	jlt.u %d3,%d5,80008214 <Ifx_CircularBuffer_write8+0x48>
        {
            buffer->index = 0;
80008210:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
80008214:	9f 0f ec ff 	jned %d15,0,800081ec <Ifx_CircularBuffer_write8+0x20>
80008218:	c2 f4       	add %d4,-1
8000821a:	37 04 50 40 	extr %d4,%d4,0,16
8000821e:	8b 04 40 43 	max %d4,%d4,0
80008222:	c2 14       	add %d4,1

    return source;
}
80008224:	1a 42       	add %d15,%d2,%d4
80008226:	60 f2       	mov.a %a2,%d15
80008228:	00 90       	ret 

8000822a <Ifx_CircularBuffer_write32>:


const void *Ifx_CircularBuffer_write32(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
8000822a:	37 04 70 40 	extr.u %d4,%d4,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;
8000822e:	d4 42       	ld.a %a2,[%a4]
80008230:	1b f4 ff 5f 	addi %d5,%d4,-1
80008234:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *((uint32 *)(&base[buffer->index])) = *source;
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
80008238:	b9 46 06 00 	ld.hu %d6,[%a4]6
8000823c:	82 03       	mov %d3,0
8000823e:	37 05 70 20 	extr.u %d2,%d5,0,16
80008242:	6f f5 03 00 	jz.t %d5,15,80008248 <Ifx_CircularBuffer_write32+0x1e>
80008246:	82 02       	mov %d2,0
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
80008248:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
8000824c:	c2 13       	add %d3,1
8000824e:	48 05       	ld.w %d5,[%a15]0
80008250:	10 2f       	addsc.a %a15,%a2,%d15,0
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;
80008252:	c2 4f       	add %d15,4
80008254:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
80008258:	68 05       	st.w [%a15]0,%d5
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
8000825a:	0b 6f 30 51 	lt.u %d5,%d15,%d6
8000825e:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
80008262:	9f 02 f3 ff 	jned %d2,0,80008248 <Ifx_CircularBuffer_write32+0x1e>
80008266:	c2 f4       	add %d4,-1
80008268:	37 04 50 40 	extr %d4,%d4,0,16
8000826c:	ac 42       	st.h [%a4]4,%d15
8000826e:	8b 04 40 43 	max %d4,%d4,0
80008272:	c2 14       	add %d4,1

    return source;
}
80008274:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
80008278:	00 90       	ret 

8000827a <Ifx_Fifo_destroy>:
}


void Ifx_Fifo_destroy(Ifx_Fifo *fifo)
{
    free(fifo);
8000827a:	1d 00 8d 14 	j 8000ab94 <free>

8000827e <Ifx_Fifo_init>:
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
8000827e:	82 0f       	mov %d15,0
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80008280:	80 42       	mov.d %d2,%a4
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
80008282:	e9 4f 1c 00 	st.b [%a4]28,%d15
        fifo->eventWriter        = TRUE;
80008286:	82 1f       	mov %d15,1
80008288:	e9 4f 1d 00 	st.b [%a4]29,%d15
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
8000828c:	1b 72 02 f0 	addi %d15,%d2,39
80008290:	8f 7f c0 f1 	andn %d15,%d15,7
80008294:	6c 40       	st.w [%a4]0,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
80008296:	c2 34       	add %d4,3
    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
80008298:	82 0f       	mov %d15,0
8000829a:	ac 42       	st.h [%a4]4,%d15
        fifo->shared.maxcount    = 0;
8000829c:	ac 48       	st.h [%a4]16,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
8000829e:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
800082a2:	82 0f       	mov %d15,0
    free(fifo);
}


Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
800082a4:	40 42       	mov.aa %a2,%a4
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
800082a6:	6c 43       	st.w [%a4]12,%d15
800082a8:	6c 42       	st.w [%a4]8,%d15
        fifo->startIndex         = fifo->endIndex = 0;
800082aa:	ac 4b       	st.h [%a4]22,%d15
800082ac:	ac 4a       	st.h [%a4]20,%d15
        fifo->size               = size;
800082ae:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
800082b2:	f9 45 1a 00 	st.h [%a4]26,%d5
    }

    return fifo;
}
800082b6:	00 90       	ret 

800082b8 <Ifx_Fifo_create>:
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
800082b8:	c2 34       	add %d4,3
800082ba:	37 04 50 f0 	extr %d15,%d4,0,16
 * This is valid is an OS is used.
 *
 */
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
800082be:	02 58       	mov %d8,%d5
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
800082c0:	8f 3f c0 f1 	andn %d15,%d15,3

    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
800082c4:	1b 8f 02 40 	addi %d4,%d15,40
800082c8:	6d 00 60 14 	call 8000ab88 <malloc>
800082cc:	40 24       	mov.aa %a4,%a2

    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
800082ce:	bc 25       	jz.a %a2,800082d8 <Ifx_Fifo_create+0x20>
    {
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
800082d0:	0b f8 10 48 	mov %e4,%d8,%d15
800082d4:	1d ff d5 ff 	j 8000827e <Ifx_Fifo_init>
    }

    return fifo;
}
800082d8:	00 90       	ret 

800082da <Ifx_Fifo_canReadCount>:
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
800082da:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be read from the buffer */
        result = FALSE;
800082dc:	82 02       	mov %d2,0
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
800082de:	3f f4 6a 00 	jlt %d4,%d15,800083b2 <Ifx_Fifo_canReadCount+0xd8>
800082e2:	8c 4c       	ld.h %d15,[%a4]24
800082e4:	3f 4f 67 00 	jlt %d15,%d4,800083b2 <Ifx_Fifo_canReadCount+0xd8>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800082e8:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
800082ec:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800082f0:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800082f4:	00 00       	nop 
    else
    {
        boolean interruptState;
        sint32  waitCount;
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);
800082f6:	8c 42       	ld.h %d15,[%a4]4
800082f8:	a2 f4       	sub %d4,%d15

        if (waitCount <= 0)
800082fa:	4e 4c       	jgtz %d4,80008312 <Ifx_Fifo_canReadCount+0x38>
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE;
800082fc:	82 1f       	mov %d15,1
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);

        if (waitCount <= 0)
        {
            fifo->shared.readerWaitx = 0;
800082fe:	59 42 08 00 	st.w [%a4]8,%d2
            fifo->eventReader        = TRUE;
80008302:	e9 4f 1c 00 	st.b [%a4]28,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
80008306:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008308:	df 00 55 00 	jeq %d0,0,800083b2 <Ifx_Fifo_canReadCount+0xd8>
    {
        __enable();
8000830c:	0d 00 00 03 	enable 
80008310:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008312:	82 f2       	mov %d2,-1
80008314:	06 f2       	sh %d2,-1
80008316:	ba f6       	eq %d15,%d6,-1
80008318:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000831c:	82 f5       	mov %d5,-1
8000831e:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008320:	ee 16       	jnz %d15,8000834c <Ifx_Fifo_canReadCount+0x72>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008322:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008326:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000832a:	0d 00 40 03 	disable 
8000832e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008330:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008334:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008338:	02 15       	mov %d5,%d1
8000833a:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000833e:	76 23       	jz %d2,80008344 <Ifx_Fifo_canReadCount+0x6a>
    {
        __enable();
80008340:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008344:	0b 65 40 50 	addx %d5,%d5,%d6
80008348:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
8000834c:	82 0f       	mov %d15,0
8000834e:	e9 4f 1c 00 	st.b [%a4]28,%d15
            fifo->shared.readerWaitx = waitCount;
80008352:	59 44 08 00 	st.w [%a4]8,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008356:	76 03       	jz %d0,8000835c <Ifx_Fifo_canReadCount+0x82>
    {
        __enable();
80008358:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000835c:	82 f6       	mov %d6,-1
8000835e:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008360:	39 4f 1c 00 	ld.bu %d15,[%a4]28
80008364:	6e 08       	jz %d15,80008374 <Ifx_Fifo_canReadCount+0x9a>
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
            result = fifo->eventReader == TRUE;
80008366:	39 42 1c 00 	ld.bu %d2,[%a4]28
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
8000836a:	82 0f       	mov %d15,0
8000836c:	6c 42       	st.w [%a4]8,%d15
            result = fifo->eventReader == TRUE;
8000836e:	8b 12 00 22 	eq %d2,%d2,1
80008372:	00 90       	ret 
80008374:	ba f5       	eq %d15,%d5,-1
80008376:	0b 36 00 f2 	and.eq %d15,%d6,%d3
8000837a:	ee f3       	jnz %d15,80008360 <Ifx_Fifo_canReadCount+0x86>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000837c:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008380:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008384:	0d 00 40 03 	disable 
80008388:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000838a:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000838e:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008392:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008396:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000839a:	76 23       	jz %d2,800083a0 <Ifx_Fifo_canReadCount+0xc6>
    {
        __enable();
8000839c:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
            fifo->shared.readerWaitx = waitCount;
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800083a0:	0b 3f 00 21 	eq %d2,%d15,%d3
800083a4:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
800083a8:	0b 3f 90 22 	or.lt %d2,%d15,%d3
800083ac:	df 02 da ff 	jne %d2,0,80008360 <Ifx_Fifo_canReadCount+0x86>
800083b0:	3c db       	j 80008366 <Ifx_Fifo_canReadCount+0x8c>
            result = fifo->eventReader == TRUE;
        }
    }

    return result;
}
800083b2:	00 90       	ret 

800083b4 <Ifx_Fifo_read>:
    return count - blockSize;
}

#include <stdio.h>
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
800083b4:	20 08       	sub.a %sp,8
800083b6:	40 4f       	mov.aa %a15,%a4
800083b8:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
800083ba:	df 04 b6 00 	jeq %d4,0,80008526 <Ifx_Fifo_read+0x172>
    {

        buffer.base   = fifo->buffer;
800083be:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800083c0:	82 f2       	mov %d2,-1
800083c2:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
800083c4:	8c 4c       	ld.h %d15,[%a4]24
800083c6:	06 f2       	sh %d2,-1
800083c8:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
800083ca:	8c 4a       	ld.h %d15,[%a4]20
    {
        deadLine = TIME_INFINITE;
800083cc:	82 fa       	mov %d10,-1
800083ce:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800083d0:	ba f6       	eq %d15,%d6,-1
800083d2:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800083d6:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800083d8:	ee 16       	jnz %d15,80008404 <Ifx_Fifo_read+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083da:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800083de:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083e2:	0d 00 40 03 	disable 
800083e6:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800083e8:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800083ec:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800083f0:	02 3a       	mov %d10,%d3
800083f2:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083f6:	76 23       	jz %d2,800083fc <Ifx_Fifo_read+0x48>
    {
        __enable();
800083f8:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800083fc:	0b 6a 40 a0 	addx %d10,%d10,%d6
80008400:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008404:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
80008406:	82 0d       	mov %d13,0
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventReader        = FALSE;
80008408:	82 0e       	mov %d14,0
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
8000840a:	a0 0c       	mov.a %a12,0
8000840c:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000840e:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80008412:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008416:	0d 00 40 03 	disable 
8000841a:	00 00       	nop 
{
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
8000841c:	88 2b       	ld.h %d11,[%a15]4
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000841e:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
80008422:	8c fd       	ld.h %d15,[%a15]26
80008424:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventReader        = FALSE;
80008428:	e9 fe 1c 00 	st.b [%a15]28,%d14
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
8000842c:	4b f2 01 22 	div %e2,%d2,%d15
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
80008430:	88 c2       	ld.h %d2,[%a15]24
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
80008432:	a2 3b       	sub %d11,%d3
80008434:	37 0b 70 b0 	extr.u %d11,%d11,0,16
80008438:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
8000843c:	0b f9 80 30 	sub %d3,%d9,%d15
80008440:	0b 23 80 21 	min %d2,%d3,%d2
80008444:	68 22       	st.w [%a15]8,%d2
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008446:	76 43       	jz %d4,8000844c <Ifx_Fifo_read+0x98>
    {
        __enable();
80008448:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginRead(fifo, count);

            if (blockSize != 0)
8000844c:	6e 20       	jz %d15,8000848c <Ifx_Fifo_read+0xd8>
            {
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
8000844e:	40 a4       	mov.aa %a4,%sp
80008450:	02 f4       	mov %d4,%d15
80008452:	6d ff 66 fe 	call 8000811e <Ifx_CircularBuffer_read8>
80008456:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008458:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000845c:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008460:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008464:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
80008466:	88 23       	ld.h %d3,[%a15]4
80008468:	a2 b3       	sub %d3,%d11
8000846a:	a8 23       	st.h [%a15]4,%d3

    if (fifo->shared.writerWaitx != 0)
8000846c:	48 33       	ld.w %d3,[%a15]12
8000846e:	76 39       	jz %d3,80008480 <Ifx_Fifo_read+0xcc>
    {
        fifo->shared.writerWaitx -= blockSize;
80008470:	5a f3       	sub %d15,%d3,%d15

        if (fifo->shared.writerWaitx <= 0)
80008472:	8e f3       	jlez %d15,80008478 <Ifx_Fifo_read+0xc4>

    fifo->shared.count -= blockSize;

    if (fifo->shared.writerWaitx != 0)
    {
        fifo->shared.writerWaitx -= blockSize;
80008474:	68 3f       	st.w [%a15]12,%d15
80008476:	3c 05       	j 80008480 <Ifx_Fifo_read+0xcc>

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE; /* Signal the writer */
80008478:	82 1f       	mov %d15,1
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
8000847a:	e8 3c       	st.a [%a15]12,%a12
            fifo->eventWriter        = TRUE; /* Signal the writer */
8000847c:	e9 ff 1d 00 	st.b [%a15]29,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008480:	76 23       	jz %d2,80008486 <Ifx_Fifo_read+0xd2>
    {
        __enable();
80008482:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
80008486:	a2 b9       	sub %d9,%d11
80008488:	37 09 50 90 	extr %d9,%d9,0,16
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
8000848c:	76 d4       	jz %d13,80008494 <Ifx_Fifo_read+0xe0>
            {
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
8000848e:	82 0f       	mov %d15,0
80008490:	68 2f       	st.w [%a15]8,%d15
                break;
80008492:	3c 48       	j 80008522 <Ifx_Fifo_read+0x16e>
80008494:	ba fa       	eq %d15,%d10,-1
80008496:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
8000849a:	ee 1b       	jnz %d15,800084d0 <Ifx_Fifo_read+0x11c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000849c:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800084a0:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084a4:	0d 00 40 03 	disable 
800084a8:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800084aa:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800084ae:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800084b2:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800084b6:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800084ba:	76 23       	jz %d2,800084c0 <Ifx_Fifo_read+0x10c>
    {
        __enable();
800084bc:	0d 00 00 03 	enable 
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800084c0:	0b 8f 00 21 	eq %d2,%d15,%d8
800084c4:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
800084c8:	0b f8 90 22 	or.lt %d2,%d8,%d15
800084cc:	df 02 e1 ff 	jne %d2,0,8000848e <Ifx_Fifo_read+0xda>
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
                break;
            }

            if (count != 0)
800084d0:	df 09 29 00 	jeq %d9,0,80008522 <Ifx_Fifo_read+0x16e>
            {
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800084d4:	39 ff 1c 00 	ld.bu %d15,[%a15]28
800084d8:	ee 1f       	jnz %d15,80008516 <Ifx_Fifo_read+0x162>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800084da:	ba fa       	eq %d15,%d10,-1
800084dc:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
800084e0:	ee fa       	jnz %d15,800084d4 <Ifx_Fifo_read+0x120>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800084e2:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800084e6:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084ea:	0d 00 40 03 	disable 
800084ee:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800084f0:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800084f4:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800084f8:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800084fc:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008500:	76 23       	jz %d2,80008506 <Ifx_Fifo_read+0x152>
    {
        __enable();
80008502:	0d 00 00 03 	enable 
80008506:	0b 8f 00 21 	eq %d2,%d15,%d8
8000850a:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
8000850e:	0b 8f 90 22 	or.lt %d2,%d15,%d8
80008512:	df 02 e1 ff 	jne %d2,0,800084d4 <Ifx_Fifo_read+0x120>
                {}

                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
80008516:	39 fd 1c 00 	ld.bu %d13,[%a15]28
8000851a:	8b 0d 00 d2 	eq %d13,%d13,0
8000851e:	1d ff 78 ff 	j 8000840e <Ifx_Fifo_read+0x5a>
            }
        } while (count != 0);

        fifo->startIndex = buffer.index;
80008522:	8c a2       	ld.h %d15,[%sp]4
80008524:	a8 af       	st.h [%a15]20,%d15
    }

    return count;
}
80008526:	02 92       	mov %d2,%d9
80008528:	00 90       	ret 

8000852a <Ifx_Fifo_clear>:
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000852a:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000852e:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008532:	0d 00 40 03 	disable 
80008536:	00 00       	nop 
{
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();

    if (fifo->shared.writerWaitx != 0)
80008538:	4c 43       	ld.w %d15,[%a4]12
8000853a:	6e 06       	jz %d15,80008546 <Ifx_Fifo_clear+0x1c>
    {
        fifo->shared.writerWaitx = 0;
8000853c:	82 0f       	mov %d15,0
8000853e:	6c 43       	st.w [%a4]12,%d15
        fifo->eventWriter        = TRUE; /* Signal the writer */
80008540:	82 1f       	mov %d15,1
80008542:	e9 4f 1d 00 	st.b [%a4]29,%d15
    }

    fifo->eventReader        = FALSE;
80008546:	82 0f       	mov %d15,0
80008548:	e9 4f 1c 00 	st.b [%a4]28,%d15
    fifo->shared.readerWaitx = 0;
8000854c:	82 0f       	mov %d15,0
8000854e:	6c 42       	st.w [%a4]8,%d15
    fifo->shared.count       = 0;
80008550:	ac 42       	st.h [%a4]4,%d15
    fifo->shared.maxcount    = 0;
80008552:	ac 48       	st.h [%a4]16,%d15
    fifo->startIndex         = fifo->endIndex;
80008554:	8c 4b       	ld.h %d15,[%a4]22
80008556:	ac 4a       	st.h [%a4]20,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008558:	76 23       	jz %d2,8000855e <Ifx_Fifo_clear+0x34>
    {
        __enable();
8000855a:	0d 00 00 03 	enable 
8000855e:	00 90       	ret 

80008560 <Ifx_Fifo_canWriteCount>:
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
80008560:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be written to the buffer */
        result = FALSE;
80008562:	82 02       	mov %d2,0
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
80008564:	3f f4 75 00 	jlt %d4,%d15,8000864e <Ifx_Fifo_canWriteCount+0xee>
80008568:	8c 4c       	ld.h %d15,[%a4]24
8000856a:	3f 4f 72 00 	jlt %d15,%d4,8000864e <Ifx_Fifo_canWriteCount+0xee>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000856e:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
80008572:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008576:	0d 00 40 03 	disable 
8000857a:	00 00       	nop 
    else
    {
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
8000857c:	c9 43 18 00 	ld.h %d3,[%a4]24
80008580:	8c 42       	ld.h %d15,[%a4]4
80008582:	5a f3       	sub %d15,%d3,%d15
80008584:	3f 4f 0d 00 	jlt %d15,%d4,8000859e <Ifx_Fifo_canWriteCount+0x3e>
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE;
80008588:	82 1f       	mov %d15,1
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
        {
            fifo->shared.writerWaitx = 0;
8000858a:	59 42 0c 00 	st.w [%a4]12,%d2
            fifo->eventWriter        = TRUE;
8000858e:	e9 4f 1d 00 	st.b [%a4]29,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
80008592:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008594:	df 00 5d 00 	jeq %d0,0,8000864e <Ifx_Fifo_canWriteCount+0xee>
    {
        __enable();
80008598:	0d 00 00 03 	enable 
8000859c:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000859e:	82 f2       	mov %d2,-1
800085a0:	06 f2       	sh %d2,-1
800085a2:	ba f6       	eq %d15,%d6,-1
800085a4:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800085a8:	82 f5       	mov %d5,-1
800085aa:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800085ac:	ee 16       	jnz %d15,800085d8 <Ifx_Fifo_canWriteCount+0x78>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800085ae:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800085b2:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085b6:	0d 00 40 03 	disable 
800085ba:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800085bc:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800085c0:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800085c4:	02 15       	mov %d5,%d1
800085c6:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085ca:	76 23       	jz %d2,800085d0 <Ifx_Fifo_canWriteCount+0x70>
    {
        __enable();
800085cc:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800085d0:	0b 65 40 50 	addx %d5,%d5,%d6
800085d4:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
800085d8:	82 0f       	mov %d15,0
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
800085da:	c9 42 04 00 	ld.h %d2,[%a4]4
            result                   = TRUE;
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
800085de:	e9 4f 1d 00 	st.b [%a4]29,%d15
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
800085e2:	8c 4c       	ld.h %d15,[%a4]24
800085e4:	5a f2       	sub %d15,%d2,%d15
800085e6:	42 f4       	add %d4,%d15
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800085e8:	82 02       	mov %d2,0
800085ea:	0b 42 a0 41 	max %d4,%d2,%d4
800085ee:	59 44 0c 00 	st.w [%a4]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085f2:	76 03       	jz %d0,800085f8 <Ifx_Fifo_canWriteCount+0x98>
    {
        __enable();
800085f4:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800085f8:	82 f6       	mov %d6,-1
800085fa:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800085fc:	39 4f 1d 00 	ld.bu %d15,[%a4]29
80008600:	6e 08       	jz %d15,80008610 <Ifx_Fifo_canWriteCount+0xb0>
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
            result = fifo->eventWriter == TRUE;
80008602:	39 42 1d 00 	ld.bu %d2,[%a4]29
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
80008606:	82 0f       	mov %d15,0
80008608:	6c 43       	st.w [%a4]12,%d15
            result = fifo->eventWriter == TRUE;
8000860a:	8b 12 00 22 	eq %d2,%d2,1
8000860e:	00 90       	ret 
80008610:	ba f5       	eq %d15,%d5,-1
80008612:	0b 36 00 f2 	and.eq %d15,%d6,%d3
80008616:	ee f3       	jnz %d15,800085fc <Ifx_Fifo_canWriteCount+0x9c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008618:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000861c:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008620:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008624:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008626:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000862a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000862e:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008632:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008636:	76 23       	jz %d2,8000863c <Ifx_Fifo_canWriteCount+0xdc>
    {
        __enable();
80008638:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
8000863c:	0b 3f 00 21 	eq %d2,%d15,%d3
80008640:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
80008644:	0b 3f 90 22 	or.lt %d2,%d15,%d3
80008648:	df 02 da ff 	jne %d2,0,800085fc <Ifx_Fifo_canWriteCount+0x9c>
8000864c:	3c db       	j 80008602 <Ifx_Fifo_canWriteCount+0xa2>
            result = fifo->eventWriter == TRUE;
        }
    }

    return result;
}
8000864e:	00 90       	ret 

80008650 <Ifx_Fifo_write>:
}


#include <stdio.h>
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80008650:	20 08       	sub.a %sp,8
80008652:	40 4f       	mov.aa %a15,%a4
80008654:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80008656:	df 04 be 00 	jeq %d4,0,800087d2 <Ifx_Fifo_write+0x182>
    {
        buffer.base   = fifo->buffer;
8000865a:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000865c:	82 f2       	mov %d2,-1
8000865e:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
80008660:	8c 4c       	ld.h %d15,[%a4]24
80008662:	06 f2       	sh %d2,-1
80008664:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
80008666:	8c 4b       	ld.h %d15,[%a4]22
    {
        deadLine = TIME_INFINITE;
80008668:	82 fa       	mov %d10,-1
8000866a:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000866c:	ba f6       	eq %d15,%d6,-1
8000866e:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
80008672:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008674:	ee 16       	jnz %d15,800086a0 <Ifx_Fifo_write+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008676:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000867a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000867e:	0d 00 40 03 	disable 
80008682:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008684:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008688:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000868c:	02 3a       	mov %d10,%d3
8000868e:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008692:	76 23       	jz %d2,80008698 <Ifx_Fifo_write+0x48>
    {
        __enable();
80008694:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008698:	0b 6a 40 a0 	addx %d10,%d10,%d6
8000869c:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800086a0:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
800086a2:	82 0d       	mov %d13,0
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventWriter        = FALSE;
800086a4:	82 0e       	mov %d14,0
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
800086a6:	a0 0c       	mov.a %a12,0
800086a8:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800086aa:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
800086ae:	37 05 e1 57 	extr.u %d5,%d5,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800086b2:	0d 00 40 03 	disable 
800086b6:	00 00       	nop 
{
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
800086b8:	88 c4       	ld.h %d4,[%a15]24
800086ba:	88 2b       	ld.h %d11,[%a15]4
800086bc:	0b b4 80 b0 	sub %d11,%d4,%d11
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800086c0:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
800086c4:	8c fd       	ld.h %d15,[%a15]26
800086c6:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventWriter        = FALSE;
800086ca:	e9 fe 1d 00 	st.b [%a15]29,%d14
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800086ce:	4b f2 01 22 	div %e2,%d2,%d15
800086d2:	a2 3b       	sub %d11,%d3
800086d4:	37 0b 70 b0 	extr.u %d11,%d11,0,16
800086d8:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventWriter        = FALSE;
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
800086dc:	0b f9 80 20 	sub %d2,%d9,%d15
800086e0:	0b 42 80 41 	min %d4,%d2,%d4
800086e4:	68 34       	st.w [%a15]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800086e6:	76 53       	jz %d5,800086ec <Ifx_Fifo_write+0x9c>
    {
        __enable();
800086e8:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
800086ec:	6e 26       	jz %d15,80008738 <Ifx_Fifo_write+0xe8>
            {

                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
800086ee:	40 a4       	mov.aa %a4,%sp
800086f0:	02 f4       	mov %d4,%d15
800086f2:	6d ff 6d fd 	call 800081cc <Ifx_CircularBuffer_write8>
800086f6:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800086f8:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800086fc:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008700:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008704:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
80008706:	88 22       	ld.h %d2,[%a15]4
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
80008708:	88 84       	ld.h %d4,[%a15]16
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
8000870a:	42 b2       	add %d2,%d11
8000870c:	37 02 50 20 	extr %d2,%d2,0,16
80008710:	a8 22       	st.h [%a15]4,%d2
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008712:	0b 24 a0 21 	max %d2,%d4,%d2
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
80008716:	a8 82       	st.h [%a15]16,%d2

    if (fifo->shared.readerWaitx != 0)
80008718:	48 22       	ld.w %d2,[%a15]8
8000871a:	76 29       	jz %d2,8000872c <Ifx_Fifo_write+0xdc>
    {
        fifo->shared.readerWaitx -= blockSize;
8000871c:	5a f2       	sub %d15,%d2,%d15

        if (fifo->shared.readerWaitx <= 0)
8000871e:	8e f3       	jlez %d15,80008724 <Ifx_Fifo_write+0xd4>
    fifo->shared.count   += blockSize;
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */

    if (fifo->shared.readerWaitx != 0)
    {
        fifo->shared.readerWaitx -= blockSize;
80008720:	68 2f       	st.w [%a15]8,%d15
80008722:	3c 05       	j 8000872c <Ifx_Fifo_write+0xdc>

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
80008724:	82 1f       	mov %d15,1
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
80008726:	e8 2c       	st.a [%a15]8,%a12
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
80008728:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000872c:	76 33       	jz %d3,80008732 <Ifx_Fifo_write+0xe2>
    {
        __enable();
8000872e:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
80008732:	a2 b9       	sub %d9,%d11
80008734:	37 09 50 90 	extr %d9,%d9,0,16
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008738:	76 d4       	jz %d13,80008740 <Ifx_Fifo_write+0xf0>
            {
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
8000873a:	82 0f       	mov %d15,0
8000873c:	68 3f       	st.w [%a15]12,%d15
                break;
8000873e:	3c 48       	j 800087ce <Ifx_Fifo_write+0x17e>
80008740:	ba fa       	eq %d15,%d10,-1
80008742:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008746:	ee 1b       	jnz %d15,8000877c <Ifx_Fifo_write+0x12c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008748:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000874c:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008750:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008754:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008756:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000875a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000875e:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008762:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008766:	76 23       	jz %d2,8000876c <Ifx_Fifo_write+0x11c>
    {
        __enable();
80008768:	0d 00 00 03 	enable 
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
8000876c:	0b 8f 00 21 	eq %d2,%d15,%d8
80008770:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
80008774:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008778:	df 02 e1 ff 	jne %d2,0,8000873a <Ifx_Fifo_write+0xea>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
8000877c:	df 09 29 00 	jeq %d9,0,800087ce <Ifx_Fifo_write+0x17e>
            {
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008780:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80008784:	ee 1f       	jnz %d15,800087c2 <Ifx_Fifo_write+0x172>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008786:	ba fa       	eq %d15,%d10,-1
80008788:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
8000878c:	ee fa       	jnz %d15,80008780 <Ifx_Fifo_write+0x130>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000878e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008792:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008796:	0d 00 40 03 	disable 
8000879a:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000879c:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800087a0:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800087a4:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800087a8:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800087ac:	76 23       	jz %d2,800087b2 <Ifx_Fifo_write+0x162>
    {
        __enable();
800087ae:	0d 00 00 03 	enable 
800087b2:	0b 8f 00 21 	eq %d2,%d15,%d8
800087b6:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
800087ba:	0b 8f 90 22 	or.lt %d2,%d15,%d8
800087be:	df 02 e1 ff 	jne %d2,0,80008780 <Ifx_Fifo_write+0x130>
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
800087c2:	39 fd 1d 00 	ld.bu %d13,[%a15]29
800087c6:	8b 0d 00 d2 	eq %d13,%d13,0
800087ca:	1d ff 70 ff 	j 800086aa <Ifx_Fifo_write+0x5a>
            }
        } while (count != 0);

        fifo->endIndex = buffer.index;
800087ce:	8c a2       	ld.h %d15,[%sp]4
800087d0:	a8 bf       	st.h [%a15]22,%d15
    }

    return count;
}
800087d2:	02 92       	mov %d2,%d9
800087d4:	00 90       	ret 

800087d6 <initUltrasonic>:
800087d6:	91 40 00 4f 	movh.a %a4,61444
800087da:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
800087de:	82 14       	mov %d4,1
800087e0:	3b 00 08 50 	mov %d5,128
800087e4:	6d ff 17 ea 	call 80005c12 <IfxPort_setPinMode>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800087e8:	91 40 00 4f 	movh.a %a4,61444
800087ec:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
800087f0:	82 24       	mov %d4,2
800087f2:	3b 80 00 50 	mov %d5,8
800087f6:	1d ff 0e ea 	j 80005c12 <IfxPort_setPinMode>

800087fa <delay_ms>:
    IfxPort_setPinModeOutput(TRIG_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeInput(ECHO_PIN, IfxPort_InputMode_pullDown);
}

void delay_ms(unsigned long delay)
{
800087fa:	02 4a       	mov %d10,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
800087fc:	6d ff f2 eb 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
80008800:	91 30 00 ff 	movh.a %a15,61443
80008804:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008808:	48 04       	ld.w %d4,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000880a:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000880e:	37 04 64 44 	extr.u %d4,%d4,8,4
80008812:	53 1f 40 00 	mul.u %e0,%d15,1
80008816:	4b 04 41 41 	itof %d4,%d4
    result |= ((uint64)stm->CAP.U) << 32;
8000881a:	8f 0f 40 61 	or %d6,%d15,0
8000881e:	4b 42 51 20 	div.f %d2,%d2,%d4
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
    uint64 ticks_per_ms = freq / 1000;
80008822:	3b 80 3e 40 	mov %d4,1000
    IfxPort_setPinModeInput(ECHO_PIN, IfxPort_InputMode_pullDown);
}

void delay_ms(unsigned long delay)
{
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
80008826:	4b 02 71 21 	ftouz %d2,%d2
    uint64 ticks_per_ms = freq / 1000;
8000882a:	4b 42 11 22 	div.u %e2,%d2,%d4
8000882e:	85 f3 2c 00 	ld.w %d3,f000002c <_SMALL_DATA4_+0x3fff802c>
    uint64 start = IfxStm_get(&MODULE_STM0);
    uint64 wait_ticks = delay * ticks_per_ms;
80008832:	73 a2 68 40 	mul.u %e4,%d2,%d10
80008836:	0f 13 a0 70 	or %d7,%d3,%d1

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000883a:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000883e:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008842:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80008846:	8f 0f 40 81 	or %d8,%d15,0
8000884a:	0f 32 a0 90 	or %d9,%d2,%d3

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
8000884e:	0b 68 c0 20 	subx %d2,%d8,%d6
80008852:	0b 79 d0 30 	subc %d3,%d9,%d7
80008856:	3a 53       	eq %d15,%d3,%d5
80008858:	0b 42 30 f2 	and.lt.u %d15,%d2,%d4
8000885c:	0b 53 a0 f2 	or.lt.u %d15,%d3,%d5
80008860:	ee ed       	jnz %d15,8000883a <delay_ms+0x40>
}
80008862:	00 90       	ret 

80008864 <delay_us>:

void delay_us(unsigned long delay)
{
80008864:	02 4a       	mov %d10,%d4
80008866:	6d ff bd eb 	call 80005fe0 <IfxScuCcu_getSourceFrequency>
8000886a:	91 30 00 ff 	movh.a %a15,61443
8000886e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008872:	48 04       	ld.w %d4,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008874:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008878:	37 04 64 44 	extr.u %d4,%d4,8,4
8000887c:	53 1f 40 00 	mul.u %e0,%d15,1
80008880:	4b 04 41 41 	itof %d4,%d4
    result |= ((uint64)stm->CAP.U) << 32;
80008884:	8f 0f 40 61 	or %d6,%d15,0
80008888:	4b 42 51 20 	div.f %d2,%d2,%d4
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
    uint64 ticks_per_us = freq / 1000000;
8000888c:	7b f0 00 40 	movh %d4,15
80008890:	1b 04 24 44 	addi %d4,%d4,16960
    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
}

void delay_us(unsigned long delay)
{
    uint32 freq = IfxStm_getFrequency(&MODULE_STM0);
80008894:	4b 02 71 21 	ftouz %d2,%d2
    uint64 ticks_per_us = freq / 1000000;
80008898:	4b 42 11 22 	div.u %e2,%d2,%d4
8000889c:	85 f3 2c 00 	ld.w %d3,f000002c <_SMALL_DATA4_+0x3fff802c>
    uint64 start = IfxStm_get(&MODULE_STM0);
    uint64 wait_ticks = delay * ticks_per_us;
800088a0:	73 a2 68 40 	mul.u %e4,%d2,%d10
800088a4:	0f 13 a0 70 	or %d7,%d3,%d1

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800088a8:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
800088ac:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
800088b0:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
800088b4:	8f 0f 40 81 	or %d8,%d15,0
800088b8:	0f 32 a0 90 	or %d9,%d2,%d3

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
800088bc:	0b 68 c0 20 	subx %d2,%d8,%d6
800088c0:	0b 79 d0 30 	subc %d3,%d9,%d7
800088c4:	3a 53       	eq %d15,%d3,%d5
800088c6:	0b 42 30 f2 	and.lt.u %d15,%d2,%d4
800088ca:	0b 53 a0 f2 	or.lt.u %d15,%d3,%d5
800088ce:	ee ed       	jnz %d15,800088a8 <delay_us+0x44>
}
800088d0:	00 90       	ret 

800088d2 <sendTrigger>:
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800088d2:	91 40 00 ff 	movh.a %a15,61444
800088d6:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
800088da:	82 2f       	mov %d15,2
800088dc:	68 1f       	st.w [%a15]4,%d15
}

void sendTrigger()
{
    IfxPort_setPinHigh(TRIG_PIN);
    delay_us(10);
800088de:	3b a0 00 40 	mov %d4,10
800088e2:	7b 20 00 f0 	movh %d15,2
800088e6:	6d ff bf ff 	call 80008864 <delay_us>
800088ea:	68 1f       	st.w [%a15]4,%d15
800088ec:	00 90       	ret 

800088ee <measureEchoTick>:

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800088ee:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800088f2:	85 f8 2c 00 	ld.w %d8,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800088f6:	53 1f 40 20 	mul.u %e2,%d15,1
}


IFX_INLINE boolean IfxPort_getPinState(Ifx_P *port, uint8 pinIndex)
{
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
800088fa:	91 40 00 ff 	movh.a %a15,61444
    result |= ((uint64)stm->CAP.U) << 32;
800088fe:	8f 0f 40 41 	or %d4,%d15,0
80008902:	0f 38 a0 50 	or %d5,%d8,%d3
{
    uint64 startTick = 0, elapsedTick = 0;
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008906:	7b 40 07 80 	movh %d8,116
    IfxPort_setPinLow(TRIG_PIN);
}

long measureEchoTick()
{
    uint64 startTick = 0, elapsedTick = 0;
8000890a:	d2 02       	mov %e2,0
8000890c:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008910:	1b 08 78 8f 	addi %d8,%d8,-2176
80008914:	4c f9       	ld.w %d15,[%a15]36

long measureEchoTick()
{
    uint64 startTick = 0, elapsedTick = 0;
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 0){
80008916:	6f 2f 17 80 	jnz.t %d15,2,80008944 <measureEchoTick+0x56>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000891a:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000891e:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008922:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80008926:	8f 0f 40 01 	or %d0,%d15,0
8000892a:	0f 32 a0 10 	or %d1,%d2,%d3
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
8000892e:	0b 40 c0 20 	subx %d2,%d0,%d4
80008932:	0b 51 d0 30 	subc %d3,%d1,%d5
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008936:	ba 03       	eq %d15,%d3,0
80008938:	0b 82 50 f2 	and.ge.u %d15,%d2,%d8
8000893c:	8b 03 00 f5 	or.ne %d15,%d3,0
80008940:	6e ea       	jz %d15,80008914 <measureEchoTick+0x26>
80008942:	3c 2c       	j 8000899a <measureEchoTick+0xac>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008944:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008948:	85 f8 2c 00 	ld.w %d8,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000894c:	53 1f 40 00 	mul.u %e0,%d15,1
80008950:	91 40 00 ff 	movh.a %a15,61444
    };
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 1){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
80008954:	7b 40 07 00 	movh %d0,116
    result |= ((uint64)stm->CAP.U) << 32;
80008958:	8f 0f 40 41 	or %d4,%d15,0
8000895c:	0f 18 a0 50 	or %d5,%d8,%d1
80008960:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
80008964:	1b 00 78 0f 	addi %d0,%d0,-2176
80008968:	4c f9       	ld.w %d15,[%a15]36
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
    };
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 1){
8000896a:	6f 2f 17 00 	jz.t %d15,2,80008998 <measureEchoTick+0xaa>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000896e:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80008972:	53 1f 40 20 	mul.u %e2,%d15,1
    result |= ((uint64)stm->CAP.U) << 32;
80008976:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
8000897a:	8f 0f 40 61 	or %d6,%d15,0
8000897e:	0f 32 a0 70 	or %d7,%d2,%d3
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
80008982:	0b 46 c0 20 	subx %d2,%d6,%d4
80008986:	0b 57 d0 30 	subc %d3,%d7,%d5
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
8000898a:	ba 03       	eq %d15,%d3,0
8000898c:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80008990:	8b 03 00 f5 	or.ne %d15,%d3,0
80008994:	6e ea       	jz %d15,80008968 <measureEchoTick+0x7a>
80008996:	3c 02       	j 8000899a <measureEchoTick+0xac>
    };
    return (long)elapsedTick;
80008998:	00 90       	ret 
{
    uint64 startTick = 0, elapsedTick = 0;
    startTick = IfxStm_get(&MODULE_STM0);
    while (IfxPort_getPinState(ECHO_PIN) == 0){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
8000899a:	82 f2       	mov %d2,-1
    while (IfxPort_getPinState(ECHO_PIN) == 1){
        elapsedTick = IfxStm_get(&MODULE_STM0)-startTick;
        if(elapsedTick >= (uint64) ECHO_TIMEOUT_TICK)return -1;
    };
    return (long)elapsedTick;
}
8000899c:	00 90       	ret 

8000899e <getUltrasonic>:

    while ((IfxStm_get(&MODULE_STM0) - start) < wait_ticks);
}

int getUltrasonic(){
    sendTrigger();
8000899e:	6d ff 9a ff 	call 800088d2 <sendTrigger>
    long echoTicks = measureEchoTick();
800089a2:	6d ff a6 ff 	call 800088ee <measureEchoTick>
800089a6:	02 2f       	mov %d15,%d2
    if(echoTicks==-1)return -1;
800089a8:	82 f2       	mov %d2,-1
800089aa:	1e fb       	jeq %d15,-1,800089c0 <getUltrasonic+0x22>
    return (long)elapsedTick;
}

int calculateDistanceCm(long elapsedTicks)
{
    long timeUs = elapsedTicks / 200;
800089ac:	3b 80 0c 20 	mov %d2,200
800089b0:	4b 2f 01 22 	div %e2,%d15,%d2
    long distanceCm = timeUs * 34 / 1000 / 2;
800089b4:	3b 80 3e f0 	mov %d15,1000
800089b8:	53 12 21 20 	mul %d2,%d2,17
800089bc:	4b f2 01 22 	div %e2,%d2,%d15
    sendTrigger();
    long echoTicks = measureEchoTick();
    if(echoTicks==-1)return -1;
    int distanceCm = calculateDistanceCm(echoTicks);
    return distanceCm;
}
800089c0:	00 90       	ret 

800089c2 <calculateDistanceCm>:
    return (long)elapsedTick;
}

int calculateDistanceCm(long elapsedTicks)
{
    long timeUs = elapsedTicks / 200;
800089c2:	3b 80 0c 20 	mov %d2,200
800089c6:	4b 24 01 42 	div %e4,%d4,%d2
    long distanceCm = timeUs * 34 / 1000 / 2;
800089ca:	3b 80 3e 20 	mov %d2,1000
800089ce:	53 14 21 40 	mul %d4,%d4,17
800089d2:	4b 24 01 22 	div %e2,%d4,%d2
    return (int) distanceCm;
}
800089d6:	00 90       	ret 

800089d8 <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800089d8:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800089dc:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800089e0:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800089e4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800089e8:	54 25       	ld.w %d5,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800089ea:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800089ec:	37 05 6e 51 	extr.u %d5,%d5,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800089f0:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
800089f4:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800089f8:	8f f5 83 51 	xor %d5,%d5,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800089fc:	8f f8 83 81 	xor %d8,%d8,63
80008a00:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
80008a04:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80008a06:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80008a0a:	3b 00 b8 f0 	mov %d15,2944
80008a0e:	cd 4f e0 0f 	mtcr $psw,%d15
80008a12:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80008a16:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80008a1a:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80008a1e:	cd 0f e0 0f 	mtcr $pcxi,%d15
80008a22:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008a26:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008a2a:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008a2c:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008a30:	cd 42 20 09 	mtcr $pcon1,%d2
80008a34:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008a38:	53 cf 20 f0 	mul %d15,%d15,12
80008a3c:	10 22       	addsc.a %a2,%a2,%d15,0
80008a3e:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008a40:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008a42:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008a46:	d9 2f 00 46 	lea %a15,[%a2]24832
80008a4a:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008a4e:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008a50:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008a54:	2e 16       	jz.t %d15,1,80008a60 <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008a56:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008a5a:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008a5e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008a60:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008a64:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008a68:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008a6a:	4c f0       	ld.w %d15,[%a15]0
80008a6c:	6f 0f ff ff 	jnz.t %d15,0,80008a6a <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80008a70:	82 0f       	mov %d15,0
80008a72:	cd cf 20 09 	mtcr $pcon0,%d15
80008a76:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008a7a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008a7c:	2e 16       	jz.t %d15,1,80008a88 <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008a7e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008a82:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008a86:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008a88:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008a8c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008a90:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008a92:	4c f0       	ld.w %d15,[%a15]0
80008a94:	6f 0f ff 7f 	jz.t %d15,0,80008a92 <osEE_tc_core0_start+0xba>
80008a98:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008a9c:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008aa0:	91 30 00 ff 	movh.a %a15,61443
80008aa4:	53 cf 20 f0 	mul %d15,%d15,12
80008aa8:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008aac:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008aae:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008ab0:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008ab2:	d9 2f 00 46 	lea %a15,[%a2]24832
80008ab6:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008aba:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008abe:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008ac0:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008ac4:	2e 16       	jz.t %d15,1,80008ad0 <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008ac6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008aca:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008ace:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008ad0:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008ad4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008ad8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008ada:	4c f0       	ld.w %d15,[%a15]0
80008adc:	6f 0f ff ff 	jnz.t %d15,0,80008ada <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80008ae0:	82 0f       	mov %d15,0
80008ae2:	cd 0f 04 09 	mtcr $dcon0,%d15
80008ae6:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008aea:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008aec:	2e 16       	jz.t %d15,1,80008af8 <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008aee:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008af2:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008af6:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008af8:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008afc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008b00:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008b02:	4c f0       	ld.w %d15,[%a15]0
80008b04:	6f 0f ff 7f 	jz.t %d15,0,80008b02 <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008b08:	91 30 00 ff 	movh.a %a15,61443
80008b0c:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008b10:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008b12:	2e 16       	jz.t %d15,1,80008b1e <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008b14:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008b18:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008b1c:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008b1e:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008b22:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008b26:	91 30 00 ff 	movh.a %a15,61443
80008b2a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008b2e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008b30:	4c f0       	ld.w %d15,[%a15]0
80008b32:	91 30 00 2f 	movh.a %a2,61443
80008b36:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008b3a:	6f 0f fb ff 	jnz.t %d15,0,80008b30 <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
80008b3e:	7b 00 00 f8 	movh %d15,32768
80008b42:	1b 0f 10 f1 	addi %d15,%d15,4352
80008b46:	cd 4f e2 0f 	mtcr $btv,%d15
80008b4a:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
80008b4e:	7b 00 00 f8 	movh %d15,32768
80008b52:	1b 0f 00 f2 	addi %d15,%d15,8192
80008b56:	cd 0f e2 0f 	mtcr $biv,%d15
80008b5a:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
80008b5e:	7b 20 00 f7 	movh %d15,28674
80008b62:	1b 0f b0 f9 	addi %d15,%d15,-25856
80008b66:	cd 8f e2 0f 	mtcr $isp,%d15
80008b6a:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008b6e:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008b70:	2e 16       	jz.t %d15,1,80008b7c <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008b72:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008b76:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008b7a:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008b7c:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008b80:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008b84:	91 30 00 ff 	movh.a %a15,61443
80008b88:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008b8c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008b8e:	4c f0       	ld.w %d15,[%a15]0
80008b90:	6f 0f ff 7f 	jz.t %d15,0,80008b8e <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
80008b94:	91 10 00 f7 	movh.a %a15,28673
80008b98:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80008b9c:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80008b9e:	91 10 00 f8 	movh.a %a15,32769
80008ba2:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008ba6:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
80008ba8:	91 10 00 f8 	movh.a %a15,32769
80008bac:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008bb0:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
80008bb2:	91 10 00 fb 	movh.a %a15,45057
80008bb6:	d9 ff 00 08 	lea %a15,[%a15]-32768 <b0008000 <_SMALL_DATA4_>>
80008bba:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80008bbc:	7b 20 00 f7 	movh %d15,28674
80008bc0:	7b 20 00 47 	movh %d4,28674
80008bc4:	1b 0f c0 69 	addi %d6,%d15,-25600
80008bc8:	1b 04 c0 4b 	addi %d4,%d4,-17408
80008bcc:	a2 64       	sub %d4,%d6
80008bce:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80008bd0:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80008bd2:	df 04 16 00 	jeq %d4,0,80008bfe <osEE_tc_core0_start+0x226>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80008bd6:	9a f4       	add %d15,%d4,-1
80008bd8:	06 6f       	sh %d15,6
80008bda:	12 63       	add %d3,%d15,%d6

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008bdc:	60 3f       	mov.a %a15,%d3
80008bde:	82 00       	mov %d0,0
80008be0:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008be2:	60 4f       	mov.a %a15,%d4
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008be4:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008be8:	37 03 70 73 	extr.u %d7,%d3,6,16
80008bec:	1b 0f fc ff 	addi %d15,%d15,-64

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008bf0:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008bf2:	37 27 10 28 	insert %d2,%d7,%d2,16,16
80008bf6:	42 6f       	add %d15,%d6

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008bf8:	82 53       	mov %d3,5
80008bfa:	fd f0 11 01 	loop %a15,80008e1c <osEE_tc_core0_start+0x444>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
80008bfe:	cd 82 e3 0f 	mtcr $fcx,%d2
80008c02:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008c06:	91 30 00 ff 	movh.a %a15,61443
80008c0a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008c0e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008c10:	2e 16       	jz.t %d15,1,80008c1c <osEE_tc_core0_start+0x244>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008c12:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008c16:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008c1a:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008c1c:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008c20:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008c24:	91 30 00 ff 	movh.a %a15,61443
80008c28:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008c2c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008c2e:	40 f2       	mov.aa %a2,%a15
80008c30:	4c 20       	ld.w %d15,[%a2]0
80008c32:	91 30 00 ff 	movh.a %a15,61443
80008c36:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008c3a:	6f 0f fb ff 	jnz.t %d15,0,80008c30 <osEE_tc_core0_start+0x258>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
80008c3e:	4c f1       	ld.w %d15,[%a15]4
80008c40:	96 08       	or %d15,8
80008c42:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008c44:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008c46:	2e 16       	jz.t %d15,1,80008c52 <osEE_tc_core0_start+0x27a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008c48:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008c4c:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008c50:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008c52:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008c56:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008c5a:	91 30 00 ff 	movh.a %a15,61443
80008c5e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008c62:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008c64:	4c f0       	ld.w %d15,[%a15]0
80008c66:	6f 0f ff 7f 	jz.t %d15,0,80008c64 <osEE_tc_core0_start+0x28c>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008c6a:	91 30 00 ff 	movh.a %a15,61443
80008c6e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008c72:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008c74:	2e 16       	jz.t %d15,1,80008c80 <osEE_tc_core0_start+0x2a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008c76:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008c7a:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008c7e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008c80:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008c84:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80008c88:	91 30 00 ff 	movh.a %a15,61443
80008c8c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008c90:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008c92:	40 f2       	mov.aa %a2,%a15
80008c94:	4c 20       	ld.w %d15,[%a2]0
80008c96:	91 30 00 ff 	movh.a %a15,61443
80008c9a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008c9e:	6f 0f fb ff 	jnz.t %d15,0,80008c94 <osEE_tc_core0_start+0x2bc>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80008ca2:	4c f1       	ld.w %d15,[%a15]4
80008ca4:	96 08       	or %d15,8
80008ca6:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008ca8:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008caa:	2e 16       	jz.t %d15,1,80008cb6 <osEE_tc_core0_start+0x2de>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008cac:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008cb0:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008cb4:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008cb6:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008cba:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008cbe:	91 30 00 ff 	movh.a %a15,61443
80008cc2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008cc6:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80008cc8:	4c f0       	ld.w %d15,[%a15]0
80008cca:	6f 0f ff 7f 	jz.t %d15,0,80008cc8 <osEE_tc_core0_start+0x2f0>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80008cce:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
80008cd2:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80008cd4:	d9 44 e0 d0 	lea %a4,[%a4]3936 <80000f60 <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
80008cd8:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
80008cda:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
80008cdc:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
80008cde:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
80008ce0:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80008ce2:	9e f6       	jeq %d15,-1,80008d0e <osEE_tc_core0_start+0x336>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
80008ce4:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
80008ce8:	76 49       	jz %d4,80008cfa <osEE_tc_core0_start+0x322>
        *block_to_clear.p_ull = 0ULL;
80008cea:	60 4f       	mov.a %a15,%d4
80008cec:	40 32       	mov.aa %a2,%a3
80008cee:	b0 ff       	add.a %a15,-1
80008cf0:	89 22 48 01 	st.d [%a2+]8,%e2
80008cf4:	fc fe       	loop %a15,80008cf0 <osEE_tc_core0_start+0x318>
80008cf6:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
80008cfa:	2e 22       	jz.t %d15,2,80008cfe <osEE_tc_core0_start+0x326>
        *block_to_clear.p_ui = 0x0U;
80008cfc:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
80008cfe:	2e 12       	jz.t %d15,1,80008d02 <osEE_tc_core0_start+0x32a>
        *block_to_clear.p_us = 0x0U;
80008d00:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80008d02:	2e 02       	jz.t %d15,0,80008d06 <osEE_tc_core0_start+0x32e>
        *block_to_clear.p_uc = 0x0U;
80008d04:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
80008d06:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
80008d0a:	bd 04 ea ff 	jnz.a %a4,80008cde <osEE_tc_core0_start+0x306>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
80008d0e:	91 00 00 68 	movh.a %a6,32768
80008d12:	d9 66 c8 f0 	lea %a6,[%a6]4040 <80000fc8 <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
80008d16:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
80008d18:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
80008d1a:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80008d1e:	df ff 21 00 	jeq %d15,-1,80008d60 <osEE_tc_core0_start+0x388>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
80008d22:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
80008d26:	76 4f       	jz %d4,80008d44 <osEE_tc_core0_start+0x36c>
80008d28:	60 4f       	mov.a %a15,%d4
80008d2a:	40 43       	mov.aa %a3,%a4
80008d2c:	40 52       	mov.aa %a2,%a5
80008d2e:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
80008d30:	09 22 48 01 	ld.d %e2,[%a2+]8
80008d34:	89 32 48 01 	st.d [%a3+]8,%e2
80008d38:	fc fc       	loop %a15,80008d30 <osEE_tc_core0_start+0x358>
80008d3a:	06 34       	sh %d4,3
80008d3c:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
80008d40:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
80008d44:	2e 23       	jz.t %d15,2,80008d4a <osEE_tc_core0_start+0x372>
        *block_dest.p_ui = *block_src.p_ui;
80008d46:	44 52       	ld.w %d2,[%a5+]
80008d48:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
80008d4a:	2e 14       	jz.t %d15,1,80008d52 <osEE_tc_core0_start+0x37a>
        *block_dest.p_us = *block_src.p_us;
80008d4c:	09 52 c2 00 	ld.hu %d2,[%a5+]2
80008d50:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80008d52:	2e 03       	jz.t %d15,0,80008d58 <osEE_tc_core0_start+0x380>
        *block_dest.p_uc = *block_src.p_uc;
80008d54:	0c 50       	ld.bu %d15,[%a5]0
80008d56:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
80008d58:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
80008d5c:	bd 06 dd ff 	jnz.a %a6,80008d16 <osEE_tc_core0_start+0x33e>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008d60:	91 30 00 ff 	movh.a %a15,61443
80008d64:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008d68:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008d6a:	2e 16       	jz.t %d15,1,80008d76 <osEE_tc_core0_start+0x39e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008d6c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008d70:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008d74:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008d76:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008d7a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80008d7e:	91 30 00 ff 	movh.a %a15,61443
80008d82:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008d86:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008d88:	4c f0       	ld.w %d15,[%a15]0
80008d8a:	6f 0f ff ff 	jnz.t %d15,0,80008d88 <osEE_tc_core0_start+0x3b0>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
80008d8e:	7b 20 22 f1 	movh %d15,4642
80008d92:	91 30 00 ff 	movh.a %a15,61443
80008d96:	1b 1f 10 f0 	addi %d15,%d15,257
80008d9a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008d9e:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
80008da0:	7b 00 00 f5 	movh %d15,20480
80008da4:	91 30 00 ff 	movh.a %a15,61443
80008da8:	1b 0f 10 f1 	addi %d15,%d15,4352
80008dac:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008db0:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
80008db2:	7b 70 00 f0 	movh %d15,7
80008db6:	91 30 00 ff 	movh.a %a15,61443
80008dba:	1b cf 01 f0 	addi %d15,%d15,28
80008dbe:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008dc2:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
80008dc4:	4c f0       	ld.w %d15,[%a15]0
80008dc6:	6f 1f ff 7f 	jz.t %d15,1,80008dc4 <osEE_tc_core0_start+0x3ec>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
80008dca:	91 30 00 ff 	movh.a %a15,61443
80008dce:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008dd2:	4c f0       	ld.w %d15,[%a15]0
80008dd4:	6f 8f ff 7f 	jz.t %d15,8,80008dd2 <osEE_tc_core0_start+0x3fa>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
80008dd8:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008ddc:	91 30 00 ff 	movh.a %a15,61443
80008de0:	1b 04 20 4c 	addi %d4,%d4,-15872
80008de4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008de8:	6d 00 58 00 	call 80008e98 <osEE_tc_set_pll_fsource>
80008dec:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008dee:	2e 16       	jz.t %d15,1,80008dfa <osEE_tc_core0_start+0x422>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008df0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008df4:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008df8:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008dfa:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008dfe:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008e02:	91 30 00 ff 	movh.a %a15,61443
80008e06:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008e0a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80008e0c:	4c f0       	ld.w %d15,[%a15]0
80008e0e:	6f 0f ff 7f 	jz.t %d15,0,80008e0c <osEE_tc_core0_start+0x434>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
80008e12:	6d ff f1 db 	call 800045f4 <main>
80008e16:	02 24       	mov %d4,%d2
80008e18:	6d 00 59 28 	call 8000deca <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008e1c:	60 f2       	mov.a %a2,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008e1e:	8f 4f 1e 40 	sh %d4,%d15,-28
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008e22:	74 22       	st.w [%a2],%d2
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008e24:	c2 f3       	add %d3,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008e26:	37 0f 70 23 	extr.u %d2,%d15,6,16
80008e2a:	37 42 10 28 	insert %d2,%d2,%d4,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80008e2e:	76 36       	jz %d3,80008e3a <osEE_tc_core0_start+0x462>
80008e30:	1b 0f fc ff 	addi %d15,%d15,-64
80008e34:	fc f4       	loop %a15,80008e1c <osEE_tc_core0_start+0x444>
80008e36:	1d ff e4 fe 	j 80008bfe <osEE_tc_core0_start+0x226>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80008e3a:	cd c2 e3 0f 	mtcr $lcx,%d2
80008e3e:	0d 00 c0 04 	isync 
80008e42:	3c f7       	j 80008e30 <osEE_tc_core0_start+0x458>

80008e44 <osEE_tc_stm_us_ticks>:
#if (defined(__TASKING__))
#define OS_STOP_SEC_GLOBAL_VAR_CLEARED
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
80008e44:	40 ae       	mov.aa %a14,%sp
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
80008e46:	91 00 00 f7 	movh.a %a15,28672
80008e4a:	19 ff a8 f0 	ld.w %d15,[%a15]3048 <70000be8 <osEE_tc_stm_freq_khz>>
80008e4e:	3b 80 3e 20 	mov %d2,1000
80008e52:	3f 2f 0c 80 	jlt.u %d15,%d2,80008e6a <osEE_tc_stm_us_ticks+0x26>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
80008e56:	7b 20 06 21 	movh %d2,4194
80008e5a:	1b 32 dd 24 	addi %d2,%d2,19923
80008e5e:	73 2f 68 20 	mul.u %e2,%d15,%d2
80008e62:	8f a3 1f 20 	sh %d2,%d3,-6
80008e66:	e2 42       	mul %d2,%d4
80008e68:	00 90       	ret 
  } else if (usec >= OSEE_KILO) {
80008e6a:	02 25       	mov %d5,%d2
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
80008e6c:	73 f4 0a 20 	mul %d2,%d4,%d15
80008e70:	7b 20 06 31 	movh %d3,4194
80008e74:	1b 33 dd 34 	addi %d3,%d3,19923
80008e78:	73 32 68 20 	mul.u %e2,%d2,%d3
80008e7c:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
80008e80:	3f 54 0b 80 	jlt.u %d4,%d5,80008e96 <osEE_tc_stm_us_ticks+0x52>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
80008e84:	7b 20 06 21 	movh %d2,4194
80008e88:	1b 32 dd 24 	addi %d2,%d2,19923
80008e8c:	73 24 68 40 	mul.u %e4,%d4,%d2
80008e90:	8f a5 1f 20 	sh %d2,%d5,-6
80008e94:	e2 f2       	mul %d2,%d15
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
  }
  return ticks;
}
80008e96:	00 90       	ret 

80008e98 <osEE_tc_set_pll_fsource>:
#define OSEE_TC_K2_MIN      (1U)
#define OSEE_TC_N_MAX       (128U)  /* '7 bits */
#define OSEE_TC_N_MIN       (1U)
#define OSEE_TC_DEV_ALLOWED (2U)

void osEE_tc_set_pll_fsource(OsEE_reg fpll) {
80008e98:	40 ae       	mov.aa %a14,%sp
  fPllLeastError  = OSEE_TC_CLOCK_MAX;
  fPllError       = OSEE_TC_CLOCK_MAX;

  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
80008e9a:	7b e0 e4 20 	movh %d2,3662
80008e9e:	1b 12 c0 21 	addi %d2,%d2,7169
80008ea2:	0b 24 30 f1 	lt.u %d15,%d4,%d2
80008ea6:	82 22       	mov %d2,2
80008ea8:	ab 12 80 ff 	sel %d15,%d15,%d2,1
80008eac:	60 f4       	mov.a %a4,%d15
80008eae:	53 ff 20 f0 	mul %d15,%d15,15
80008eb2:	60 f5       	mov.a %a5,%d15
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008eb4:	3b 00 01 e0 	mov %d14,16
80008eb8:	82 03       	mov %d3,0
80008eba:	7b c0 be 20 	movh %d2,3052
80008ebe:	1b 02 20 2c 	addi %d2,%d2,-15872
80008ec2:	02 28       	mov %d8,%d2
80008ec4:	82 01       	mov %d1,0
80008ec6:	82 0b       	mov %d11,0
80008ec8:	82 0d       	mov %d13,0
80008eca:	82 0c       	mov %d12,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80008ecc:	7b 10 13 a0 	movh %d10,305
80008ed0:	1b 0a d0 a2 	addi %d10,%d10,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80008ed4:	91 40 0f 60 	movh.a %a6,244
80008ed8:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
    {
      for (
80008edc:	a0 1d       	mov.a %a13,1
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80008ede:	53 14 40 60 	mul.u %e6,%d4,1
80008ee2:	60 62       	mov.a %a2,%d6
80008ee4:	60 73       	mov.a %a3,%d7

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80008ee6:	91 80 7d f1 	movh.a %a15,6104
80008eea:	d9 ff 41 08 	lea %a15,[%a15]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
        {
          for (
80008eee:	a0 1c       	mov.a %a12,1
80008ef0:	3c 5e       	j 80008fac <osEE_tc_set_pll_fsource+0x114>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80008ef2:	4b ea 11 62 	div.u %e6,%d10,%d14
80008ef6:	82 07       	mov %d7,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80008ef8:	7b 60 f8 ff 	movh %d15,65414
80008efc:	1b 0f e0 fe 	addi %d15,%d15,-4608
80008f00:	0b f6 40 60 	addx %d6,%d6,%d15
80008f04:	8b f7 bf 50 	addc %d5,%d7,-1
80008f08:	ba 05       	eq %d15,%d5,0
80008f0a:	80 67       	mov.d %d7,%a6
80008f0c:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80008f10:	8b 05 00 f5 	or.ne %d15,%d5,0
80008f14:	ee 4a       	jnz %d15,80008fa8 <osEE_tc_set_pll_fsource+0x110>
    {
      for (
80008f16:	df 00 56 00 	jeq %d0,0,80008fc2 <osEE_tc_set_pll_fsource+0x12a>
80008f1a:	02 e9       	mov %d9,%d14
80008f1c:	80 d0       	mov.d %d0,%a13
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80008f1e:	60 e7       	mov.a %a7,%d14
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80008f20:	80 2f       	mov.d %d15,%a2
80008f22:	73 f0 68 60 	mul.u %e6,%d0,%d15
80008f26:	80 3f       	mov.d %d15,%a3
80008f28:	03 f0 0a 77 	madd %d7,%d7,%d0,%d15

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80008f2c:	7b 80 82 fe 	movh %d15,59432
80008f30:	1b 0f c0 f7 	addi %d15,%d15,31744
80008f34:	0b f6 40 60 	addx %d6,%d6,%d15
80008f38:	8b f7 bf 50 	addc %d5,%d7,-1
80008f3c:	ba 05       	eq %d15,%d5,0
80008f3e:	80 f7       	mov.d %d7,%a15
80008f40:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80008f44:	8b 05 00 f5 	or.ne %d15,%d5,0
80008f48:	ee 25       	jnz %d15,80008f92 <osEE_tc_set_pll_fsource+0xfa>
        {
          for (
80008f4a:	0f 23 a0 f0 	or %d15,%d3,%d2
80008f4e:	6e 2d       	jz %d15,80008fa8 <osEE_tc_set_pll_fsource+0x110>
80008f50:	80 c6       	mov.d %d6,%a12
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
80008f52:	4b 96 11 22 	div.u %e2,%d6,%d9
80008f56:	02 2f       	mov %d15,%d2
80008f58:	e2 af       	mul %d15,%d10
80008f5a:	a2 4f       	sub %d15,%d4
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
80008f5c:	53 1f 40 20 	mul.u %e2,%d15,1
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008f60:	df 0f ac 00 	jeq %d15,0,800090b8 <osEE_tc_set_pll_fsource+0x220>
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
80008f64:	0b 13 00 51 	eq %d5,%d3,%d1
80008f68:	0b 8f 50 52 	and.ge.u %d5,%d15,%d8
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
80008f6c:	2b f8 40 85 	sel %d8,%d5,%d8,%d15
80008f70:	ab 01 80 15 	sel %d1,%d5,%d1,0
80008f74:	2b eb 40 b5 	sel %d11,%d5,%d11,%d14
80008f78:	2b 6d 40 d5 	sel %d13,%d5,%d13,%d6
80008f7c:	2b 0c 40 c5 	sel %d12,%d5,%d12,%d0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
80008f80:	c2 16       	add %d6,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
80008f82:	8b 16 68 52 	lt.u %d5,%d6,129
80008f86:	8b 0f 20 54 	and.ne %d5,%d15,0
80008f8a:	df 05 e4 ff 	jne %d5,0,80008f52 <osEE_tc_set_pll_fsource+0xba>
80008f8e:	02 d6       	mov %d6,%d13
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008f90:	02 6d       	mov %d13,%d6
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
80008f92:	80 4f       	mov.d %d15,%a4
80008f94:	42 f0       	add %d0,%d15
80008f96:	80 56       	mov.d %d6,%a5
80008f98:	42 69       	add %d9,%d6

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
80008f9a:	0f 32 a0 50 	or %d5,%d2,%d3
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
80008f9e:	8b d0 61 f2 	lt.u %d15,%d0,29
80008fa2:	8b 05 20 f4 	and.ne %d15,%d5,0
80008fa6:	ee bd       	jnz %d15,80008f20 <osEE_tc_set_pll_fsource+0x88>
80008fa8:	01 45 20 50 	sub.a %a5,%a5,%a4
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80008fac:	c2 fe       	add %d14,-1
    k2Steps = 1;
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
80008fae:	0f 32 a0 f0 	or %d15,%d2,%d3
80008fb2:	8b 0f 20 02 	ne %d0,%d15,0
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
80008fb6:	8b 0e 20 52 	ne %d5,%d14,0
80008fba:	8b 0f 20 54 	and.ne %d5,%d15,0
80008fbe:	df 05 9a ff 	jne %d5,0,80008ef2 <osEE_tc_set_pll_fsource+0x5a>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
80008fc2:	06 14       	sh %d4,1
80008fc4:	7b c0 1e f5 	movh %d15,20972
80008fc8:	1b ff 51 f8 	addi %d15,%d15,-31457
80008fcc:	73 f4 68 40 	mul.u %e4,%d4,%d15
80008fd0:	8f b5 1f 20 	sh %d2,%d5,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
80008fd4:	ba 01       	eq %d15,%d1,0
80008fd6:	0b 28 50 f2 	and.ge.u %d15,%d8,%d2
80008fda:	8b 01 00 f5 	or.ne %d15,%d1,0
80008fde:	ee 73       	jnz %d15,800090c4 <osEE_tc_set_pll_fsource+0x22c>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
80008fe0:	c2 fc       	add %d12,-1
80008fe2:	91 30 00 ff 	movh.a %a15,61443
80008fe6:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008fea:	4c f0       	ld.w %d15,[%a15]0
80008fec:	37 cf 07 c0 	insert %d12,%d15,%d12,0,7
80008ff0:	68 0c       	st.w [%a15]0,%d12

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
80008ff2:	91 30 00 ff 	movh.a %a15,61443
80008ff6:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008ffa:	4c f0       	ld.w %d15,[%a15]0
80008ffc:	6f 5f ff 7f 	jz.t %d15,5,80008ffa <osEE_tc_set_pll_fsource+0x162>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
80009000:	91 30 00 ff 	movh.a %a15,61443
80009004:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009008:	4c f0       	ld.w %d15,[%a15]0
8000900a:	96 01       	or %d15,1
8000900c:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
8000900e:	91 30 00 ff 	movh.a %a15,61443
80009012:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009016:	4c f0       	ld.w %d15,[%a15]0
80009018:	6f 0f ff 7f 	jz.t %d15,0,80009016 <osEE_tc_set_pll_fsource+0x17e>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000901c:	9a fb       	add %d15,%d11,-1
8000901e:	91 30 00 ff 	movh.a %a15,61443
80009022:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009026:	16 0f       	and %d15,15
80009028:	8f 8f 01 f0 	sh %d15,%d15,24
8000902c:	48 02       	ld.w %d2,[%a15]0
8000902e:	b7 02 04 2c 	insert %d2,%d2,0,24,4
80009032:	a6 2f       	or %d15,%d2
80009034:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
80009036:	9a fd       	add %d15,%d13,-1
80009038:	16 7f       	and %d15,127
8000903a:	8f 9f 00 f0 	sh %d15,%d15,9
8000903e:	48 02       	ld.w %d2,[%a15]0
80009040:	b7 02 87 24 	insert %d2,%d2,0,9,7
80009044:	a6 2f       	or %d15,%d2
80009046:	68 0f       	st.w [%a15]0,%d15

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
80009048:	4c f0       	ld.w %d15,[%a15]0
8000904a:	8f 2f c0 f1 	andn %d15,%d15,2
8000904e:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
80009050:	4c f0       	ld.w %d15,[%a15]0
80009052:	96 40       	or %d15,64
80009054:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
80009056:	4c f0       	ld.w %d15,[%a15]0
80009058:	96 20       	or %d15,32
8000905a:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
8000905c:	91 30 00 ff 	movh.a %a15,61443
80009060:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009064:	4c f0       	ld.w %d15,[%a15]0
80009066:	6f 3f ff ff 	jnz.t %d15,3,80009064 <osEE_tc_set_pll_fsource+0x1cc>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
8000906a:	91 30 00 ff 	movh.a %a15,61443
8000906e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009072:	4c f0       	ld.w %d15,[%a15]0
80009074:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80009078:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
8000907a:	91 30 00 ff 	movh.a %a15,61443
8000907e:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009082:	4c f0       	ld.w %d15,[%a15]0
80009084:	6f 2f ff 7f 	jz.t %d15,2,80009082 <osEE_tc_set_pll_fsource+0x1ea>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
80009088:	91 30 00 ff 	movh.a %a15,61443
8000908c:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009090:	4c f0       	ld.w %d15,[%a15]0
80009092:	8f 1f c0 f1 	andn %d15,%d15,1
80009096:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
80009098:	91 30 00 ff 	movh.a %a15,61443
8000909c:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800090a0:	4c f0       	ld.w %d15,[%a15]0
800090a2:	6f 0f ff ff 	jnz.t %d15,0,800090a0 <osEE_tc_set_pll_fsource+0x208>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
800090a6:	91 30 00 ff 	movh.a %a15,61443
800090aa:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800090ae:	4c f0       	ld.w %d15,[%a15]0
800090b0:	8f 0f c4 f1 	andn %d15,%d15,64
800090b4:	68 0f       	st.w [%a15]0,%d15
800090b6:	00 90       	ret 
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
            {
              fPllLeastError = fPllError;
800090b8:	02 28       	mov %d8,%d2
800090ba:	02 31       	mov %d1,%d3
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
800090bc:	80 7b       	mov.d %d11,%a7
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800090be:	02 0c       	mov %d12,%d0
800090c0:	1d ff 68 ff 	j 80008f90 <osEE_tc_set_pll_fsource+0xf8>
800090c4:	00 90       	ret 

800090c6 <osEE_tc_get_fsource>:
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
  }

}

OsEE_reg osEE_tc_get_fsource(void) {
800090c6:	40 ae       	mov.aa %a14,%sp
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
800090c8:	91 30 00 ff 	movh.a %a15,61443
800090cc:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090d0:	4c f0       	ld.w %d15,[%a15]0
800090d2:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
800090d6:	7b 60 5f 20 	movh %d2,1526
800090da:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
800090de:	6e 45       	jz %d15,80009168 <osEE_tc_get_fsource+0xa2>
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
800090e0:	91 30 00 ff 	movh.a %a15,61443
800090e4:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800090e8:	4c f0       	ld.w %d15,[%a15]0
800090ea:	6f 0f 11 00 	jz.t %d15,0,8000910c <osEE_tc_get_fsource+0x46>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
800090ee:	91 30 00 ff 	movh.a %a15,61443
800090f2:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
800090f6:	48 02       	ld.w %d2,[%a15]0
800090f8:	37 02 67 28 	extr.u %d2,%d2,16,7
800090fc:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
800090fe:	7b 10 13 f0 	movh %d15,305
80009102:	1b 0f d0 f2 	addi %d15,%d15,11520
80009106:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000910a:	00 90       	ret 
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000910c:	4c f0       	ld.w %d15,[%a15]0
8000910e:	6f 3f 11 00 	jz.t %d15,3,80009130 <osEE_tc_get_fsource+0x6a>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009112:	91 30 00 ff 	movh.a %a15,61443
80009116:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000911a:	48 02       	ld.w %d2,[%a15]0
8000911c:	8f f2 07 21 	and %d2,%d2,127
80009120:	9a 12       	add %d15,%d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
80009122:	7b 10 13 20 	movh %d2,305
80009126:	1b 02 d0 22 	addi %d2,%d2,11520
8000912a:	4b f2 11 22 	div.u %e2,%d2,%d15
8000912e:	00 90       	ret 
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009130:	91 30 00 ff 	movh.a %a15,61443
80009134:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009138:	4c f0       	ld.w %d15,[%a15]0
8000913a:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000913e:	91 30 00 ff 	movh.a %a15,61443
80009142:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009146:	4c f0       	ld.w %d15,[%a15]0
80009148:	37 0f 64 3c 	extr.u %d3,%d15,24,4
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000914c:	48 02       	ld.w %d2,[%a15]0
8000914e:	37 02 e7 44 	extr.u %d4,%d2,9,7
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009152:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
80009154:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80009158:	7b 10 13 20 	movh %d2,305
8000915c:	1b 02 d0 22 	addi %d2,%d2,11520
80009160:	4b f2 11 22 	div.u %e2,%d2,%d15
80009164:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
80009168:	00 90       	ret 

8000916a <osEE_tc_stm_set_clockpersec>:
  return ticks;
}

/* Set inside std time reference  */
void osEE_tc_stm_set_clockpersec(void)
{
8000916a:	40 ae       	mov.aa %a14,%sp
#if (defined(__TASKING__))
  /* I don't know where is declared */
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
8000916c:	6d ff ad ff 	call 800090c6 <osEE_tc_get_fsource>
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
80009170:	91 30 00 ff 	movh.a %a15,61443
80009174:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009178:	4c f0       	ld.w %d15,[%a15]0
8000917a:	37 0f 64 f4 	extr.u %d15,%d15,8,4
8000917e:	c2 12       	add %d2,1
80009180:	4b f2 11 22 	div.u %e2,%d2,%d15

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
80009184:	7b 20 06 f1 	movh %d15,4194
80009188:	1b 3f dd f4 	addi %d15,%d15,19923
8000918c:	73 f2 68 20 	mul.u %e2,%d2,%d15
80009190:	8f a3 1f f0 	sh %d15,%d3,-6
80009194:	91 00 00 f7 	movh.a %a15,28672
80009198:	59 ff a8 f0 	st.w [%a15]3048 <70000be8 <osEE_tc_stm_freq_khz>>,%d15
8000919c:	00 90       	ret 

8000919e <osEE_tc_stm_set_sr0>:
    that qualifier on pointers.
 */

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0(OsEE_reg usec,
    OsEE_tc_isr_hw_prio intvec)
{
8000919e:	40 ae       	mov.aa %a14,%sp
800091a0:	02 59       	mov %d9,%d5
800091a2:	4d c0 e1 8f 	mfcr %d8,$core_id
    5U;
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
800091a6:	6d ff 4f fe 	call 80008e44 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
800091aa:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
800091ae:	8f 38 00 f1 	and %d15,%d8,3
800091b2:	9b 0f 0f 40 	addih %d4,%d15,240
800091b6:	8f 84 00 40 	sh %d4,%d4,8
800091ba:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
800091bc:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
800091be:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
800091c0:	68 c2       	st.w [%a15]48,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
800091c2:	df 09 23 00 	jeq %d9,0,80009208 <osEE_tc_stm_set_sr0+0x6a>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
800091c6:	48 e2       	ld.w %d2,[%a15]56
800091c8:	b7 02 05 24 	insert %d2,%d2,0,8,5
800091cc:	68 e2       	st.w [%a15]56,%d2
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
800091ce:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
800091d2:	48 e2       	ld.w %d2,[%a15]56
800091d4:	37 32 05 30 	insert %d3,%d2,%d3,0,5
800091d8:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
800091da:	48 f2       	ld.w %d2,[%a15]60
800091dc:	8f 42 c0 21 	andn %d2,%d2,4
800091e0:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
800091e2:	48 f2       	ld.w %d2,[%a15]60
800091e4:	8f 12 40 21 	or %d2,%d2,1
800091e8:	68 f2       	st.w [%a15]60,%d2

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
800091ea:	06 3f       	sh %d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
800091ec:	60 f2       	mov.a %a2,%d15
800091ee:	d9 2f 50 28 	lea %a15,[%a2]-31600
800091f2:	11 4f 00 ff 	addih.a %a15,%a15,61444
800091f6:	b7 89 99 93 	insert %d9,%d9,8,7,25
800091fa:	8f 38 00 81 	and %d8,%d8,3
800091fe:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80009202:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009204:	68 09       	st.w [%a15]0,%d9
80009206:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en                 = 0U;
80009208:	48 f2       	ld.w %d2,[%a15]60
8000920a:	8f 12 c0 21 	andn %d2,%d2,1
8000920e:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
80009210:	1b 2f 09 f7 	addi %d15,%d15,28818
80009214:	9b 0f e0 f1 	addih %d15,%d15,7680
80009218:	06 3f       	sh %d15,3
8000921a:	82 02       	mov %d2,0
8000921c:	60 ff       	mov.a %a15,%d15
8000921e:	68 02       	st.w [%a15]0,%d2
80009220:	00 90       	ret 

80009222 <osEE_tc_stm_set_sr0_next_match>:
  }
}

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0_next_match(OsEE_reg usec)
{
80009222:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009224:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
80009228:	6d ff 0e fe 	call 80008e44 <osEE_tc_stm_us_ticks>
8000922c:	16 03       	and %d15,3
8000922e:	9b 0f 0f f0 	addih %d15,%d15,240
80009232:	8f 8f 00 f0 	sh %d15,%d15,8
80009236:	60 ff       	mov.a %a15,%d15
80009238:	4c fc       	ld.w %d15,[%a15]48
8000923a:	42 f2       	add %d2,%d15
8000923c:	68 c2       	st.w [%a15]48,%d2
8000923e:	00 90       	ret 

80009240 <osEE_tc_stm_set_sr1>:
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1(OsEE_reg usec,
  OsEE_tc_isr_hw_prio intvec)
{
80009240:	40 ae       	mov.aa %a14,%sp
80009242:	02 59       	mov %d9,%d5
80009244:	4d c0 e1 8f 	mfcr %d8,$core_id
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80009248:	6d ff fe fd 	call 80008e44 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000924c:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009250:	8f 38 00 f1 	and %d15,%d8,3
80009254:	9b 0f 0f 40 	addih %d4,%d15,240
80009258:	8f 84 00 40 	sh %d4,%d4,8
8000925c:	60 4f       	mov.a %a15,%d4
8000925e:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80009260:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009262:	68 d2       	st.w [%a15]52,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80009264:	df 09 28 00 	jeq %d9,0,800092b4 <osEE_tc_stm_set_sr1+0x74>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
80009268:	48 e2       	ld.w %d2,[%a15]56
8000926a:	b7 02 05 2c 	insert %d2,%d2,0,24,5
8000926e:	68 e2       	st.w [%a15]56,%d2
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80009270:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
80009274:	8f f3 01 31 	and %d3,%d3,31
80009278:	8f 03 01 30 	sh %d3,%d3,16
8000927c:	48 e2       	ld.w %d2,[%a15]56
8000927e:	b7 02 05 28 	insert %d2,%d2,0,16,5
80009282:	a6 23       	or %d3,%d2
80009284:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
80009286:	48 f2       	ld.w %d2,[%a15]60
80009288:	8f 02 44 21 	or %d2,%d2,64
8000928c:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
8000928e:	48 f2       	ld.w %d2,[%a15]60
80009290:	8f 02 41 21 	or %d2,%d2,16
80009294:	68 f2       	st.w [%a15]60,%d2
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
80009296:	06 3f       	sh %d15,3
80009298:	60 f2       	mov.a %a2,%d15
8000929a:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000929e:	11 4f 00 ff 	addih.a %a15,%a15,61444
800092a2:	b7 89 99 93 	insert %d9,%d9,8,7,25
800092a6:	8f 38 00 81 	and %d8,%d8,3
800092aa:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
800092ae:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
800092b0:	68 09       	st.w [%a15]0,%d9
800092b2:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
800092b4:	48 f2       	ld.w %d2,[%a15]60
800092b6:	8f 02 c1 21 	andn %d2,%d2,16
800092ba:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
800092bc:	06 3f       	sh %d15,3
800092be:	60 f2       	mov.a %a2,%d15
800092c0:	d9 2f 54 28 	lea %a15,[%a2]-31596
800092c4:	11 4f 00 ff 	addih.a %a15,%a15,61444
800092c8:	82 0f       	mov %d15,0
800092ca:	68 0f       	st.w [%a15]0,%d15
800092cc:	00 90       	ret 

800092ce <osEE_tc_stm_set_sr1_next_match>:
  }
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1_next_match(OsEE_reg usec)
{
800092ce:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
800092d0:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
800092d4:	6d ff b8 fd 	call 80008e44 <osEE_tc_stm_us_ticks>
800092d8:	16 03       	and %d15,3
800092da:	9b 0f 0f f0 	addih %d15,%d15,240
800092de:	8f 8f 00 f0 	sh %d15,%d15,8
800092e2:	60 ff       	mov.a %a15,%d15
800092e4:	4c fd       	ld.w %d15,[%a15]52
800092e6:	42 f2       	add %d2,%d15
800092e8:	68 d2       	st.w [%a15]52,%d2
800092ea:	00 90       	ret 

800092ec <osEE_tc_delay>:
}

void osEE_tc_delay(OsEE_reg usec)
{
800092ec:	40 ae       	mov.aa %a14,%sp
800092ee:	4d c0 e1 ff 	mfcr %d15,$core_id
800092f2:	16 03       	and %d15,3
800092f4:	9b 0f 0f f0 	addih %d15,%d15,240
800092f8:	8f 8f 00 f0 	sh %d15,%d15,8
800092fc:	60 f2       	mov.a %a2,%d15
800092fe:	d9 2f 10 00 	lea %a15,[%a2]16
80009302:	19 28 10 00 	ld.w %d8,[%a2]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);
80009306:	6d ff 9f fd 	call 80008e44 <osEE_tc_stm_us_ticks>
8000930a:	4c f0       	ld.w %d15,[%a15]0

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
8000930c:	a2 8f       	sub %d15,%d8
8000930e:	3f 2f fe ff 	jlt.u %d15,%d2,8000930a <osEE_tc_delay+0x1e>
    ; /* Wait */
  }
}
80009312:	00 90       	ret 

80009314 <osEE_tc_isr2_wrapper>:

#if (defined(__GNUC__))
#pragma section
#endif /* __GNUC__ */

static void OSEE_COMPILER_KEEP osEE_tc_isr2_wrapper(TaskType isr2_tid) {
80009314:	40 ae       	mov.aa %a14,%sp
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
80009316:	6d 00 87 05 	call 80009e24 <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
8000931a:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000931e:	00 80       	rfe 
80009320:	00 90       	ret 
	...

80009324 <osEE_shutdown_os>:
  osEE_shutdown_os
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
80009324:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009326:	cc 40       	ld.a %a15,[%a4]0
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80009328:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000932c:	82 32       	mov %d2,3
8000932e:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
80009332:	e9 f4 12 00 	st.b [%a15]18,%d4

  if (os_status == OSEE_KERNEL_STARTED) {
80009336:	5e 25       	jne %d15,2,80009340 <osEE_shutdown_os+0x1c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
80009338:	99 44 04 00 	ld.a %a4,[%a4]4
8000933c:	6d 00 89 06 	call 8000a04e <osEE_idle_task_terminate>
  } else {
    osEE_call_shutdown_hook(p_ccb, Error);
  }
  for (;;) {
    ; /* Endless Loop (entered only if Kernel Not Started) */
  }
80009340:	3c 00       	j 80009340 <osEE_shutdown_os+0x1c>

80009342 <DisableAllInterrupts>:
FUNC(void, OS_CODE)
  DisableAllInterrupts
(
  void
)
{
80009342:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009344:	91 00 00 f8 	movh.a %a15,32768
80009348:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000934c:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
80009350:	82 1f       	mov %d15,1
80009352:	e9 ff 1e 00 	st.b [%a15]30,%d15
80009356:	00 90       	ret 

80009358 <EnableAllInterrupts>:
FUNC(void, OS_CODE)
  EnableAllInterrupts
(
  void
)
{
80009358:	40 ae       	mov.aa %a14,%sp
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000935a:	91 00 00 f8 	movh.a %a15,32768
8000935e:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
80009362:	39 ff 1e 00 	ld.bu %d15,[%a15]30 <800000d4 <osEE_cdb_var>>
80009366:	6e 06       	jz %d15,80009372 <EnableAllInterrupts+0x1a>
    p_ccb->d_isr_all_cnt = 0U;
80009368:	82 0f       	mov %d15,0
8000936a:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000936e:	0d 00 00 03 	enable 
80009372:	00 90       	ret 

80009374 <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
80009374:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009376:	91 00 00 f8 	movh.a %a15,32768
8000937a:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
8000937e:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000d4 <osEE_cdb_var>>
80009382:	ee 0c       	jnz %d15,8000939a <SuspendAllInterrupts+0x26>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009384:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009388:	0d 00 40 03 	disable 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
8000938c:	68 5f       	st.w [%a15]20,%d15
    ++p_ccb->s_isr_all_cnt;
8000938e:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80009392:	c2 1f       	add %d15,1
80009394:	e9 ff 1c 00 	st.b [%a15]28,%d15
80009398:	00 90       	ret 
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
8000939a:	8b ff 0f 22 	eq %d2,%d15,255
8000939e:	f6 25       	jnz %d2,800093a8 <SuspendAllInterrupts+0x34>
    ++p_ccb->s_isr_all_cnt;
800093a0:	c2 1f       	add %d15,1
800093a2:	e9 ff 1c 00 	st.b [%a15]28,%d15
800093a6:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
800093a8:	91 00 00 48 	movh.a %a4,32768
800093ac:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
800093b0:	3b 90 01 40 	mov %d4,25
800093b4:	3c b8       	j 80009324 <osEE_shutdown_os>

800093b6 <ResumeAllInterrupts>:
FUNC(void, OS_CODE)
  ResumeAllInterrupts
(
  void
)
{
800093b6:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800093b8:	91 00 00 f8 	movh.a %a15,32768
800093bc:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
800093c0:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000d4 <osEE_cdb_var>>
800093c4:	6e 0b       	jz %d15,800093da <ResumeAllInterrupts+0x24>
    --p_ccb->s_isr_all_cnt;
800093c6:	c2 ff       	add %d15,-1
800093c8:	16 ff       	and %d15,255
800093ca:	e9 ff 1c 00 	st.b [%a15]28,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
800093ce:	ee 06       	jnz %d15,800093da <ResumeAllInterrupts+0x24>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800093d0:	4c f5       	ld.w %d15,[%a15]20
800093d2:	cd cf e2 0f 	mtcr $icr,%d15
800093d6:	0d 00 c0 04 	isync 
800093da:	00 90       	ret 

800093dc <SuspendOSInterrupts>:
FUNC(void, OS_CODE)
  SuspendOSInterrupts
(
  void
)
{
800093dc:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800093de:	91 00 00 f8 	movh.a %a15,32768
800093e2:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
800093e6:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000d4 <osEE_cdb_var>>
800093ea:	ee 18       	jnz %d15,8000941a <SuspendOSInterrupts+0x3e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800093ec:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800093f0:	8f f2 0f f1 	and %d15,%d2,255
800093f4:	8b 3f a1 f2 	ge.u %d15,%d15,19
800093f8:	ee 0a       	jnz %d15,8000940c <SuspendOSInterrupts+0x30>
    OsEE_icr icr_temp = icr;
800093fa:	02 2f       	mov %d15,%d2
800093fc:	3b 30 01 30 	mov %d3,19
80009400:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009404:	cd cf e2 0f 	mtcr $icr,%d15
80009408:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
8000940c:	68 62       	st.w [%a15]24,%d2
    ++p_ccb->s_isr_os_cnt;
8000940e:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80009412:	c2 1f       	add %d15,1
80009414:	e9 ff 1d 00 	st.b [%a15]29,%d15
80009418:	00 90       	ret 
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
8000941a:	8b ff 0f 22 	eq %d2,%d15,255
8000941e:	f6 25       	jnz %d2,80009428 <SuspendOSInterrupts+0x4c>
    ++p_ccb->s_isr_os_cnt;
80009420:	c2 1f       	add %d15,1
80009422:	e9 ff 1d 00 	st.b [%a15]29,%d15
80009426:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
80009428:	91 00 00 48 	movh.a %a4,32768
8000942c:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
80009430:	3b 90 01 40 	mov %d4,25
80009434:	1d ff 78 ff 	j 80009324 <osEE_shutdown_os>

80009438 <ResumeOSInterrupts>:
FUNC(void, OS_CODE)
  ResumeOSInterrupts
(
  void
)
{
80009438:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000943a:	91 00 00 f8 	movh.a %a15,32768
8000943e:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
80009442:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000d4 <osEE_cdb_var>>
80009446:	6e 16       	jz %d15,80009472 <ResumeOSInterrupts+0x3a>
    --p_ccb->s_isr_os_cnt;
80009448:	c2 ff       	add %d15,-1
8000944a:	16 ff       	and %d15,255
8000944c:	e9 ff 1d 00 	st.b [%a15]29,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
80009450:	ee 11       	jnz %d15,80009472 <ResumeOSInterrupts+0x3a>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
80009452:	48 62       	ld.w %d2,[%a15]24
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009454:	4d c0 e2 3f 	mfcr %d3,$icr
80009458:	02 3f       	mov %d15,%d3
8000945a:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000945e:	8f f2 0f 21 	and %d2,%d2,255
80009462:	5f 23 08 00 	jeq %d3,%d2,80009472 <ResumeOSInterrupts+0x3a>
80009466:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000946a:	cd cf e2 0f 	mtcr $icr,%d15
8000946e:	0d 00 c0 04 	isync 
80009472:	00 90       	ret 

80009474 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
80009474:	40 ae       	mov.aa %a14,%sp
80009476:	02 49       	mov %d9,%d4
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009478:	91 00 00 f8 	movh.a %a15,32768
8000947c:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009480:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009484:	8f f8 0f f1 	and %d15,%d8,255
80009488:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000948c:	ee 0a       	jnz %d15,800094a0 <StartOS+0x2c>
    OsEE_icr icr_temp = icr;
8000948e:	02 8f       	mov %d15,%d8
80009490:	3b 30 01 20 	mov %d2,19
80009494:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009498:	cd cf e2 0f 	mtcr $icr,%d15
8000949c:	0d 00 c0 04 	isync 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
800094a0:	39 ff 10 00 	ld.bu %d15,[%a15]16
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
800094a4:	82 15       	mov %d5,1
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
800094a6:	ee 21       	jnz %d15,800094e8 <StartOS+0x74>
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
800094a8:	6d 00 e6 05 	call 8000a074 <osEE_cpu_startos>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
800094ac:	3b 80 01 50 	mov %d5,24
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
800094b0:	df 02 1c 00 	jeq %d2,0,800094e8 <StartOS+0x74>
800094b4:	3c 24       	j 800094fc <StartOS+0x88>
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
      p_ccb->os_status = OSEE_KERNEL_STARTED;
800094b6:	82 2f       	mov %d15,2
800094b8:	e9 ff 10 00 	st.b [%a15]16,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
800094bc:	39 ff 10 00 	ld.bu %d15,[%a15]16
800094c0:	5e 2a       	jne %d15,2,800094d4 <StartOS+0x60>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
800094c2:	40 c4       	mov.aa %a4,%a12
800094c4:	99 c5 04 00 	ld.a %a5,[%a12]4
800094c8:	40 56       	mov.aa %a6,%a5
800094ca:	6d 00 3a 06 	call 8000a13e <osEE_hal_save_ctx_and_ready2stacked>
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
800094ce:	40 c4       	mov.aa %a4,%a12
800094d0:	6d 00 8a 04 	call 80009de4 <osEE_task_end>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
800094d4:	0d 00 40 03 	disable 
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
800094d8:	3c 00       	j 800094d8 <StartOS+0x64>
800094da:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800094de:	cd cf e2 0f 	mtcr $icr,%d15
800094e2:	0d 00 c0 04 	isync 
800094e6:	3c 1b       	j 8000951c <StartOS+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800094e8:	4d c0 e2 4f 	mfcr %d4,$icr
800094ec:	02 4f       	mov %d15,%d4
800094ee:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800094f2:	8f f8 0f 31 	and %d3,%d8,255
800094f6:	5f 34 f2 ff 	jne %d4,%d3,800094da <StartOS+0x66>
800094fa:	3c 11       	j 8000951c <StartOS+0xa8>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
800094fc:	91 00 00 28 	movh.a %a2,32768
80009500:	d9 22 14 30 	lea %a2,[%a2]212 <800000d4 <osEE_cdb_var>>
80009504:	99 2c 04 00 	ld.a %a12,[%a2]4 <80000004 <BootModeHeader0+0x4>>
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80009508:	82 1f       	mov %d15,1
8000950a:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
8000950e:	e9 f9 11 00 	st.b [%a15]17,%d9
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
80009512:	39 ff 10 00 	ld.bu %d15,[%a15]16
80009516:	df 1f d3 ff 	jne %d15,1,800094bc <StartOS+0x48>
8000951a:	3c ce       	j 800094b6 <StartOS+0x42>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
8000951c:	02 52       	mov %d2,%d5
8000951e:	00 90       	ret 

80009520 <GetActiveApplicationMode>:
FUNC(AppModeType, OS_CODE)
  GetActiveApplicationMode
(
  void
)
{
80009520:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
80009522:	91 00 00 f8 	movh.a %a15,32768
80009526:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
8000952a:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000d4 <osEE_cdb_var>>
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
8000952e:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80009532:	6e 03       	jz %d15,80009538 <GetActiveApplicationMode+0x18>
    app_mode = p_ccb->app_mode;
80009534:	39 f2 11 00 	ld.bu %d2,[%a15]17
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
80009538:	00 90       	ret 

8000953a <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
8000953a:	40 ae       	mov.aa %a14,%sp
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000953c:	91 00 00 f8 	movh.a %a15,32768
80009540:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009544:	4c f2       	ld.w %d15,[%a15]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009546:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009548:	7f f4 39 80 	jge.u %d4,%d15,800095ba <ActivateTask+0x80>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000954c:	91 00 00 f8 	movh.a %a15,32768
80009550:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009554:	c8 1f       	ld.a %a15,[%a15]4
80009556:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000955a:	c8 0f       	ld.a %a15,[%a15]0

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000955c:	39 ff 14 00 	ld.bu %d15,[%a15]20
80009560:	ff 2f 2d 80 	jge.u %d15,2,800095ba <ActivateTask+0x80>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009564:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009568:	8f f9 0f f1 	and %d15,%d9,255
8000956c:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009570:	ee 0a       	jnz %d15,80009584 <ActivateTask+0x4a>
    OsEE_icr icr_temp = icr;
80009572:	02 9f       	mov %d15,%d9
80009574:	3b 30 01 20 	mov %d2,19
80009578:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000957c:	cd cf e2 0f 	mtcr $icr,%d15
80009580:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
80009584:	40 f4       	mov.aa %a4,%a15
80009586:	6d 00 23 04 	call 80009dcc <osEE_task_activated>
8000958a:	02 28       	mov %d8,%d2

      if (ev == E_OK) {
8000958c:	f6 28       	jnz %d2,8000959c <ActivateTask+0x62>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
8000958e:	91 00 00 48 	movh.a %a4,32768
80009592:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
80009596:	40 f5       	mov.aa %a5,%a15
80009598:	6d 00 57 04 	call 80009e46 <osEE_scheduler_task_activated>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000959c:	4d c0 e2 3f 	mfcr %d3,$icr
800095a0:	02 3f       	mov %d15,%d3
800095a2:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800095a6:	8f f9 0f 21 	and %d2,%d9,255
800095aa:	5f 23 08 00 	jeq %d3,%d2,800095ba <ActivateTask+0x80>
800095ae:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800095b2:	cd cf e2 0f 	mtcr $icr,%d15
800095b6:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
800095ba:	02 82       	mov %d2,%d8
800095bc:	00 90       	ret 

800095be <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
800095be:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
800095c0:	91 00 00 f8 	movh.a %a15,32768
800095c4:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
800095c8:	48 03       	ld.w %d3,[%a15]0
800095ca:	91 00 00 28 	movh.a %a2,32768
800095ce:	d9 22 00 30 	lea %a2,[%a2]192 <800000c0 <osEE_kdb_var>>
800095d2:	4c 22       	ld.w %d15,[%a2]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
800095d4:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
800095d6:	7f f4 5e 80 	jge.u %d4,%d15,80009692 <ChainTask+0xd4>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
800095da:	91 00 00 28 	movh.a %a2,32768
800095de:	d9 22 00 30 	lea %a2,[%a2]192 <800000c0 <osEE_kdb_var>>
800095e2:	99 22 04 00 	ld.a %a2,[%a2]4 <80000004 <BootModeHeader0+0x4>>
800095e6:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
800095ea:	d4 2c       	ld.a %a12,[%a2]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
800095ec:	39 cf 14 00 	ld.bu %d15,[%a12]20
800095f0:	ff 2f 51 80 	jge.u %d15,2,80009692 <ChainTask+0xd4>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
800095f4:	39 ff 1c 00 	ld.bu %d15,[%a15]28
800095f8:	6e 09       	jz %d15,8000960a <ChainTask+0x4c>
        p_ccb->s_isr_all_cnt = 0U;
800095fa:	82 0f       	mov %d15,0
800095fc:	e9 ff 1c 00 	st.b [%a15]28,%d15
80009600:	4c f5       	ld.w %d15,[%a15]20
80009602:	cd cf e2 0f 	mtcr $icr,%d15
80009606:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000960a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000960e:	6e 06       	jz %d15,8000961a <ChainTask+0x5c>
        p_ccb->d_isr_all_cnt = 0U;
80009610:	82 0f       	mov %d15,0
80009612:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009616:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000961a:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000961e:	8f f8 0f f1 	and %d15,%d8,255
80009622:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009626:	ee 0a       	jnz %d15,8000963a <ChainTask+0x7c>
    OsEE_icr icr_temp = icr;
80009628:	02 8f       	mov %d15,%d8
8000962a:	3b 30 01 20 	mov %d2,19
8000962e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009632:	cd cf e2 0f 	mtcr $icr,%d15
80009636:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
8000963a:	80 cf       	mov.d %d15,%a12
8000963c:	7e 35       	jne %d15,%d3,80009646 <ChainTask+0x88>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
8000963e:	cc c3       	ld.a %a15,[%a12]12
80009640:	82 5f       	mov %d15,5
80009642:	28 2f       	st.b [%a15]2,%d15
80009644:	3c 15       	j 8000966e <ChainTask+0xb0>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
80009646:	40 c4       	mov.aa %a4,%a12
80009648:	6d 00 c2 03 	call 80009dcc <osEE_task_activated>
        if (ev == E_OK) {
8000964c:	df 02 1a 80 	jne %d2,0,80009680 <ChainTask+0xc2>
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
80009650:	91 00 00 48 	movh.a %a4,32768
80009654:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
80009658:	40 c5       	mov.aa %a5,%a12
8000965a:	6d 00 2a 04 	call 80009eae <osEE_scheduler_task_insert>
8000965e:	3c 08       	j 8000966e <ChainTask+0xb0>
80009660:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
80009664:	cd cf e2 0f 	mtcr $icr,%d15
80009668:	0d 00 c0 04 	isync 
8000966c:	00 90       	ret 
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000966e:	91 00 00 f8 	movh.a %a15,32768
80009672:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
80009676:	c8 0f       	ld.a %a15,[%a15]0
80009678:	c8 14       	ld.a %a4,[%a15]4
8000967a:	a0 05       	mov.a %a5,0
8000967c:	1d 00 98 05 	j 8000a1ac <osEE_hal_terminate_ctx>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009680:	4d c0 e2 3f 	mfcr %d3,$icr
80009684:	02 3f       	mov %d15,%d3
80009686:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000968a:	8f f8 0f 81 	and %d8,%d8,255
8000968e:	5f 83 e9 ff 	jne %d3,%d8,80009660 <ChainTask+0xa2>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
80009692:	00 90       	ret 

80009694 <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
80009694:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
80009696:	91 00 00 f8 	movh.a %a15,32768
8000969a:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000969e:	c8 02       	ld.a %a2,[%a15]0
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
800096a0:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000d4 <osEE_cdb_var>>
800096a4:	6e 09       	jz %d15,800096b6 <TerminateTask+0x22>
        p_ccb->s_isr_all_cnt = 0U;
800096a6:	82 0f       	mov %d15,0
800096a8:	e9 ff 1c 00 	st.b [%a15]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800096ac:	4c f5       	ld.w %d15,[%a15]20
800096ae:	cd cf e2 0f 	mtcr $icr,%d15
800096b2:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
800096b6:	39 ff 1e 00 	ld.bu %d15,[%a15]30
800096ba:	6e 06       	jz %d15,800096c6 <TerminateTask+0x32>
        p_ccb->d_isr_all_cnt = 0U;
800096bc:	82 0f       	mov %d15,0
800096be:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
800096c2:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800096c6:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800096ca:	8f ff 0f 21 	and %d2,%d15,255
800096ce:	8b 32 a1 22 	ge.u %d2,%d2,19
800096d2:	f6 29       	jnz %d2,800096e4 <TerminateTask+0x50>
800096d4:	3b 30 01 20 	mov %d2,19
800096d8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800096dc:	cd cf e2 0f 	mtcr $icr,%d15
800096e0:	0d 00 c0 04 	isync 
800096e4:	99 24 04 00 	ld.a %a4,[%a2]4
800096e8:	a0 05       	mov.a %a5,0
800096ea:	1d 00 61 05 	j 8000a1ac <osEE_hal_terminate_ctx>

800096ee <Schedule>:
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
800096ee:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
800096f0:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
800096f4:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
800096f8:	c8 0f       	ld.a %a15,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
800096fa:	c8 3c       	ld.a %a12,[%a15]12
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
800096fc:	39 c2 01 00 	ld.bu %d2,[%a12]1 <800000d4 <osEE_cdb_var>>
80009700:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000d4 <osEE_cdb_var>>
80009704:	5f f2 2d 80 	jne %d2,%d15,8000975e <Schedule+0x70>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009708:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000970c:	8f f8 0f f1 	and %d15,%d8,255
80009710:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009714:	ee 0a       	jnz %d15,80009728 <Schedule+0x3a>
    OsEE_icr icr_temp = icr;
80009716:	02 8f       	mov %d15,%d8
80009718:	3b 30 01 20 	mov %d2,19
8000971c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009720:	cd cf e2 0f 	mtcr $icr,%d15
80009724:	0d 00 c0 04 	isync 
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
80009728:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000972c:	2c c1       	st.b [%a12]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
8000972e:	91 00 00 48 	movh.a %a4,32768
80009732:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
80009736:	6d 00 36 04 	call 80009fa2 <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
8000973a:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000973e:	2c c1       	st.b [%a12]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009740:	4d c0 e2 3f 	mfcr %d3,$icr
80009744:	02 3f       	mov %d15,%d3
80009746:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000974a:	8f f8 0f 21 	and %d2,%d8,255
8000974e:	5f 23 08 00 	jeq %d3,%d2,8000975e <Schedule+0x70>
80009752:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009756:	cd cf e2 0f 	mtcr $icr,%d15
8000975a:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000975e:	82 02       	mov %d2,0
80009760:	00 90       	ret 

80009762 <GetResource>:
FUNC(StatusType, OS_CODE)
  GetResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
80009762:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009764:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
80009768:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
8000976c:	c8 04       	ld.a %a4,[%a15]0
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (res_id < p_kdb->p_kcb->free_res_index);
#else
  return (res_id < p_kdb->res_array_size);
8000976e:	91 00 00 f8 	movh.a %a15,32768
80009772:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009776:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
80009778:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000977a:	7f f4 4c 80 	jge.u %d4,%d15,80009812 <GetResource+0xb0>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
8000977e:	91 00 00 f8 	movh.a %a15,32768
80009782:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009786:	c8 3f       	ld.a %a15,[%a15]12
80009788:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000978c:	c8 03       	ld.a %a3,[%a15]0
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
8000978e:	d4 32       	ld.a %a2,[%a3]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
80009790:	cc 43       	ld.a %a15,[%a4]12
    CONST(TaskPrio, AUTOMATIC)
      reso_prio     = p_reso_db->prio;
80009792:	0c 34       	ld.bu %d15,[%a3]4
    CONST(TaskPrio, AUTOMATIC)
      current_prio  = p_curr_tcb->current_prio;
80009794:	08 14       	ld.bu %d4,[%a15]1
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009796:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000979a:	8f f2 0f 31 	and %d3,%d2,255
8000979e:	8b 33 a1 32 	ge.u %d3,%d3,19
800097a2:	f6 3a       	jnz %d3,800097b6 <GetResource+0x54>
    OsEE_icr icr_temp = icr;
800097a4:	02 23       	mov %d3,%d2
800097a6:	3b 30 01 50 	mov %d5,19
800097aa:	37 53 08 30 	insert %d3,%d3,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800097ae:	cd c3 e2 0f 	mtcr $icr,%d3
800097b2:	0d 00 c0 04 	isync 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
800097b6:	02 23       	mov %d3,%d2
      ev = E_OS_CORE;
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
800097b8:	7f f4 16 80 	jge.u %d4,%d15,800097e4 <GetResource+0x82>
        p_curr_tcb->current_prio = reso_prio;
800097bc:	28 1f       	st.b [%a15]1,%d15

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
800097be:	37 0f 48 50 	extr %d5,%d15,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
800097c2:	8b ff 2f 72 	ne %d7,%d15,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
800097c6:	16 7f       	and %d15,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
800097c8:	c2 1f       	add %d15,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
800097ca:	8f 02 d0 61 	andn %d6,%d2,256
800097ce:	8f f2 cf 31 	andn %d3,%d2,255
800097d2:	a6 f3       	or %d3,%d15
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
800097d4:	8f f2 cf 21 	andn %d2,%d2,255
800097d8:	2b 63 40 37 	sel %d3,%d7,%d3,%d6
800097dc:	8b 05 40 52 	lt %d5,%d5,0
800097e0:	2b 23 40 35 	sel %d3,%d5,%d3,%d2
        flags = osEE_hal_prepare_ipl(flags, reso_prio);
      }

      p_reso_cb->p_owner    = p_curr;
800097e4:	b5 24 08 00 	st.a [%a2]8,%a4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800097e8:	4d c0 e2 5f 	mfcr %d5,$icr
800097ec:	02 5f       	mov %d15,%d5
800097ee:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800097f2:	8f f3 0f 21 	and %d2,%d3,255
800097f6:	5f 25 08 00 	jeq %d5,%d2,80009806 <GetResource+0xa4>
800097fa:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800097fe:	cd cf e2 0f 	mtcr $icr,%d15
80009802:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
80009806:	4c f1       	ld.w %d15,[%a15]4
80009808:	6c 20       	st.w [%a2]0,%d15
      p_reso_cb->prev_prio  = current_prio;
8000980a:	e9 24 04 00 	st.b [%a2]4,%d4
      p_curr_tcb->p_last_m  = p_reso_db;
8000980e:	e8 13       	st.a [%a15]4,%a3

      ev = E_OK;
80009810:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
80009812:	00 90       	ret 

80009814 <ReleaseResource>:
FUNC(StatusType, OS_CODE)
  ReleaseResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
80009814:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009816:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_curr = p_ccb->p_curr;
8000981a:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
8000981e:	c8 03       	ld.a %a3,[%a15]0
80009820:	91 00 00 f8 	movh.a %a15,32768
80009824:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009828:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
8000982a:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000982c:	7f f4 69 80 	jge.u %d4,%d15,800098fe <ReleaseResource+0xea>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
80009830:	cc 33       	ld.a %a15,[%a3]12
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
80009832:	91 00 00 28 	movh.a %a2,32768
80009836:	d9 22 00 30 	lea %a2,[%a2]192 <800000c0 <osEE_kdb_var>>
8000983a:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
8000983e:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, TYPEDEF)
      p_reso_cb   = p_reso_db->p_cb;
80009842:	d4 22       	ld.a %a2,[%a2]
80009844:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009846:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000984a:	8f ff 0f 21 	and %d2,%d15,255
8000984e:	8b 32 a1 22 	ge.u %d2,%d2,19
80009852:	f6 2a       	jnz %d2,80009866 <ReleaseResource+0x52>
    OsEE_icr icr_temp = icr;
80009854:	02 f2       	mov %d2,%d15
80009856:	3b 30 01 30 	mov %d3,19
8000985a:	37 32 08 20 	insert %d2,%d2,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000985e:	cd c2 e2 0f 	mtcr $icr,%d2
80009862:	0d 00 c0 04 	isync 
    {
      VAR(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      /* Pop the Resources head */
      p_curr_tcb->p_last_m = p_curr_tcb->p_last_m->p_cb->p_next;
80009866:	c8 14       	ld.a %a4,[%a15]4
80009868:	d4 44       	ld.a %a4,[%a4]
8000986a:	54 42       	ld.w %d2,[%a4]
8000986c:	68 12       	st.w [%a15]4,%d2

      if (p_curr_tcb->p_last_m != NULL) {
8000986e:	df 02 1a 00 	jeq %d2,0,800098a2 <ReleaseResource+0x8e>
        CONST(TaskPrio, AUTOMATIC)
          prev_prio = p_reso_cb->prev_prio;
80009872:	39 23 04 00 	ld.bu %d3,[%a2]4

        p_curr_tcb->current_prio = prev_prio;
80009876:	28 13       	st.b [%a15]1,%d3

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
80009878:	37 03 48 40 	extr %d4,%d3,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000987c:	8b f3 2f 62 	ne %d6,%d3,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
80009880:	8f f3 07 31 	and %d3,%d3,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
80009884:	c2 13       	add %d3,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
80009886:	8f 0f d0 51 	andn %d5,%d15,256
8000988a:	8f ff cf 21 	andn %d2,%d15,255
8000988e:	a6 32       	or %d2,%d3
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009890:	8f ff cf f1 	andn %d15,%d15,255
80009894:	2b 52 40 26 	sel %d2,%d6,%d2,%d5
80009898:	8b 04 40 42 	lt %d4,%d4,0
8000989c:	2b f2 40 f4 	sel %d15,%d4,%d2,%d15
800098a0:	3c 17       	j 800098ce <ReleaseResource+0xba>
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;
800098a2:	39 35 1d 00 	ld.bu %d5,[%a3]29

        p_curr_tcb->current_prio = dispatch_prio;
800098a6:	28 15       	st.b [%a15]1,%d5

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
800098a8:	37 05 48 60 	extr %d6,%d5,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
800098ac:	8b f5 2f 42 	ne %d4,%d5,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
800098b0:	8f f5 07 51 	and %d5,%d5,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
800098b4:	c2 15       	add %d5,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
800098b6:	8f 0f d0 21 	andn %d2,%d15,256
800098ba:	8f ff cf 31 	andn %d3,%d15,255
800098be:	a6 53       	or %d3,%d5
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
800098c0:	8f ff cf 51 	andn %d5,%d15,255
800098c4:	2b 23 40 34 	sel %d3,%d4,%d3,%d2
800098c8:	fa 06       	lt %d15,%d6,0
800098ca:	2b 53 40 ff 	sel %d15,%d15,%d3,%d5
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_reso_cb->p_owner = NULL;
800098ce:	82 02       	mov %d2,0
800098d0:	59 22 08 00 	st.w [%a2]8,%d2

      /* Preemption point */
      (void)osEE_scheduler_task_preemption_point(p_kdb);
800098d4:	91 00 00 48 	movh.a %a4,32768
800098d8:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
800098dc:	6d 00 63 03 	call 80009fa2 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800098e0:	4d c0 e2 5f 	mfcr %d5,$icr
800098e4:	02 53       	mov %d3,%d5
800098e6:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800098ea:	16 ff       	and %d15,255
800098ec:	5f f5 08 00 	jeq %d5,%d15,800098fc <ReleaseResource+0xe8>
800098f0:	37 f3 08 30 	insert %d3,%d3,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800098f4:	cd c3 e2 0f 	mtcr $icr,%d3
800098f8:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      ev = E_OK;
800098fc:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
800098fe:	00 90       	ret 

80009900 <ShutdownOS>:
FUNC(StatusType, OS_CODE)
  ShutdownOS
(
  VAR(StatusType, AUTOMATIC) Error
)
{
80009900:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009902:	91 00 00 f8 	movh.a %a15,32768
80009906:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000990a:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000990e:	8f f2 0f f1 	and %d15,%d2,255
80009912:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009916:	ee 0a       	jnz %d15,8000992a <ShutdownOS+0x2a>
    OsEE_icr icr_temp = icr;
80009918:	02 2f       	mov %d15,%d2
8000991a:	3b 30 01 30 	mov %d3,19
8000991e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009922:	cd cf e2 0f 	mtcr $icr,%d15
80009926:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000992a:	39 ff 10 00 	ld.bu %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
8000992e:	c2 ff       	add %d15,-1
80009930:	16 ff       	and %d15,255
80009932:	ff 2f 08 80 	jge.u %d15,2,80009942 <ShutdownOS+0x42>
        (os_status == OSEE_KERNEL_STARTING))
    {
      osEE_shutdown_os(p_cdb, Error);
80009936:	91 00 00 48 	movh.a %a4,32768
8000993a:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
8000993e:	1d ff f3 fc 	j 80009324 <osEE_shutdown_os>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009942:	4d c0 e2 3f 	mfcr %d3,$icr
80009946:	02 3f       	mov %d15,%d3
80009948:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000994c:	8f f2 0f 21 	and %d2,%d2,255
80009950:	5f 23 08 00 	jeq %d3,%d2,80009960 <ShutdownOS+0x60>
80009954:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009958:	cd cf e2 0f 	mtcr $icr,%d15
8000995c:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
80009960:	82 72       	mov %d2,7
80009962:	00 90       	ret 

80009964 <GetTaskID>:
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
80009964:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009966:	91 00 00 f8 	movh.a %a15,32768
8000996a:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
8000996e:	3b e0 00 20 	mov %d2,14
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
80009972:	bd 04 24 00 	jz.a %a4,800099ba <GetTaskID+0x56>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
80009976:	c8 02       	ld.a %a2,[%a15]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009978:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000997c:	ff 2f 05 80 	jge.u %d15,2,80009986 <GetTaskID+0x22>
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
80009980:	19 22 10 00 	ld.w %d2,[%a2]16
80009984:	3c 19       	j 800099b6 <GetTaskID+0x52>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80009986:	82 f2       	mov %d2,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009988:	de 27       	jne %d15,2,800099b6 <GetTaskID+0x52>
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
8000998a:	c8 3f       	ld.a %a15,[%a15]12
8000998c:	c8 0f       	ld.a %a15,[%a15]0

      while (p_sn != NULL) {
8000998e:	bd 0f 14 00 	jz.a %a15,800099b6 <GetTaskID+0x52>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009992:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009994:	39 2f 14 00 	ld.bu %d15,[%a2]20
80009998:	ff 2f 0b 80 	jge.u %d15,2,800099ae <GetTaskID+0x4a>
8000999c:	3c 06       	j 800099a8 <GetTaskID+0x44>
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
8000999e:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
800099a0:	39 2f 14 00 	ld.bu %d15,[%a2]20
800099a4:	ff 2f 05 80 	jge.u %d15,2,800099ae <GetTaskID+0x4a>
          tid = p_searched_tdb->tid;
800099a8:	19 22 10 00 	ld.w %d2,[%a2]16
          break;
800099ac:	3c 05       	j 800099b6 <GetTaskID+0x52>
        } else {
          p_sn = p_sn->p_next;
800099ae:	c8 0f       	ld.a %a15,[%a15]0
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
800099b0:	bd 0f f7 ff 	jnz.a %a15,8000999e <GetTaskID+0x3a>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
800099b4:	82 f2       	mov %d2,-1
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
800099b6:	74 42       	st.w [%a4],%d2
    ev = E_OK;
800099b8:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
800099ba:	00 90       	ret 

800099bc <GetTaskState>:
  GetTaskState
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(TaskStateRefType, AUTOMATIC)  State
)
{
800099bc:	40 ae       	mov.aa %a14,%sp
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
800099be:	3b e0 00 20 	mov %d2,14
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
800099c2:	bd 04 38 00 	jz.a %a4,80009a32 <GetTaskState+0x76>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
800099c6:	91 00 00 f8 	movh.a %a15,32768
800099ca:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
800099ce:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
800099d0:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
800099d2:	7f f4 30 80 	jge.u %d4,%d15,80009a32 <GetTaskState+0x76>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
800099d6:	91 00 00 f8 	movh.a %a15,32768
800099da:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
800099de:	c8 1f       	ld.a %a15,[%a15]4
800099e0:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
800099e4:	c8 0f       	ld.a %a15,[%a15]0
800099e6:	c8 3f       	ld.a %a15,[%a15]12
    switch (local_state) {
800099e8:	0c f2       	ld.bu %d15,[%a15]2
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
800099ea:	82 02       	mov %d2,0
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
800099ec:	ff 6f 23 80 	jge.u %d15,6,80009a32 <GetTaskState+0x76>
800099f0:	91 10 00 f8 	movh.a %a15,32769
800099f4:	d9 ff bc 79 	lea %a15,[%a15]-26116 <800099fc <GetTaskState+0x40>>
800099f8:	90 ff       	addsc.a %a15,%a15,%d15,2
800099fa:	dc 0f       	ji %a15
800099fc:	1d 00 0c 00 	j 80009a14 <GetTaskState+0x58>
80009a00:	1d 00 0e 00 	j 80009a1c <GetTaskState+0x60>
80009a04:	1d 00 0c 00 	j 80009a1c <GetTaskState+0x60>
80009a08:	1d 00 0e 00 	j 80009a24 <GetTaskState+0x68>
80009a0c:	1d 00 10 00 	j 80009a2c <GetTaskState+0x70>
80009a10:	1d 00 0e 00 	j 80009a2c <GetTaskState+0x70>
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
80009a14:	82 0f       	mov %d15,0
80009a16:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009a18:	82 02       	mov %d2,0
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
80009a1a:	00 90       	ret 
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
80009a1c:	82 1f       	mov %d15,1
80009a1e:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009a20:	82 02       	mov %d2,0
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
80009a22:	00 90       	ret 
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
80009a24:	82 3f       	mov %d15,3
80009a26:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009a28:	82 02       	mov %d2,0
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
80009a2a:	00 90       	ret 
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
80009a2c:	82 4f       	mov %d15,4
80009a2e:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
80009a30:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
80009a32:	00 90       	ret 

80009a34 <WaitEvent>:
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009a34:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
80009a36:	91 00 00 f8 	movh.a %a15,32768
80009a3a:	99 fc 14 30 	ld.a %a12,[%a15]212 <800000d4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009a3e:	d4 cd       	ld.a %a13,[%a12]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80009a40:	cc d3       	ld.a %a15,[%a13]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009a42:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009a46:	8f f8 0f f1 	and %d15,%d8,255
80009a4a:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009a4e:	ee 0a       	jnz %d15,80009a62 <WaitEvent+0x2e>
    OsEE_icr icr_temp = icr;
80009a50:	02 8f       	mov %d15,%d8
80009a52:	3b 30 01 20 	mov %d2,19
80009a56:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009a5a:	cd cf e2 0f 	mtcr $icr,%d15
80009a5e:	0d 00 c0 04 	isync 
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
80009a62:	4c f3       	ld.w %d15,[%a15]12
80009a64:	26 4f       	and %d15,%d4
80009a66:	ee 13       	jnz %d15,80009a8c <WaitEvent+0x58>
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
80009a68:	68 24       	st.w [%a15]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
80009a6a:	91 00 00 48 	movh.a %a4,32768
80009a6e:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
80009a72:	d9 c5 04 00 	lea %a5,[%a12]4 <800000d4 <osEE_cdb_var>>
80009a76:	6d 00 98 01 	call 80009da6 <osEE_scheduler_core_pop_running>
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
80009a7a:	e8 42       	st.a [%a15]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
80009a7c:	82 3f       	mov %d15,3
80009a7e:	28 2f       	st.b [%a15]2,%d15

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
80009a80:	40 d4       	mov.aa %a4,%a13
80009a82:	d4 c5       	ld.a %a5,[%a12]
80009a84:	6d 00 c1 02 	call 8000a006 <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
80009a88:	82 0f       	mov %d15,0
80009a8a:	68 2f       	st.w [%a15]8,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009a8c:	4d c0 e2 3f 	mfcr %d3,$icr
80009a90:	02 3f       	mov %d15,%d3
80009a92:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009a96:	8f f8 0f 21 	and %d2,%d8,255
80009a9a:	5f 23 08 00 	jeq %d3,%d2,80009aaa <WaitEvent+0x76>
80009a9e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009aa2:	cd cf e2 0f 	mtcr $icr,%d15
80009aa6:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
80009aaa:	82 02       	mov %d2,0
80009aac:	00 90       	ret 

80009aae <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009aae:	40 ae       	mov.aa %a14,%sp
80009ab0:	20 08       	sub.a %sp,8
80009ab2:	91 00 00 f8 	movh.a %a15,32768
80009ab6:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009aba:	4c f2       	ld.w %d15,[%a15]8
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009abc:	3f f4 06 80 	jlt.u %d4,%d15,80009ac8 <SetEvent+0x1a>
    ev = E_OS_ID;
80009ac0:	82 3f       	mov %d15,3
80009ac2:	e9 ef ff ff 	st.b [%a14]-1,%d15
80009ac6:	3c 3c       	j 80009b3e <SetEvent+0x90>
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009ac8:	91 00 00 f8 	movh.a %a15,32768
80009acc:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009ad0:	c8 1f       	ld.a %a15,[%a15]4
80009ad2:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009ad6:	c8 04       	ld.a %a4,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009ad8:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009adc:	8f f8 0f f1 	and %d15,%d8,255
80009ae0:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009ae4:	ee 0a       	jnz %d15,80009af8 <SetEvent+0x4a>
    OsEE_icr icr_temp = icr;
80009ae6:	02 8f       	mov %d15,%d8
80009ae8:	3b 30 01 20 	mov %d2,19
80009aec:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009af0:	cd cf e2 0f 	mtcr $icr,%d15
80009af4:	0d 00 c0 04 	isync 
80009af8:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
80009afa:	d9 e5 ff ff 	lea %a5,[%a14]-1
80009afe:	6d 00 82 01 	call 80009e02 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
80009b02:	bc 2f       	jz.a %a2,80009b20 <SetEvent+0x72>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
80009b04:	91 00 00 48 	movh.a %a4,32768
80009b08:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
80009b0c:	40 25       	mov.aa %a5,%a2
80009b0e:	6d 00 e7 01 	call 80009edc <osEE_scheduler_task_unblocked>
80009b12:	76 27       	jz %d2,80009b20 <SetEvent+0x72>
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
80009b14:	91 00 00 48 	movh.a %a4,32768
80009b18:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
80009b1c:	6d 00 43 02 	call 80009fa2 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009b20:	4d c0 e2 3f 	mfcr %d3,$icr
80009b24:	02 3f       	mov %d15,%d3
80009b26:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009b2a:	8f f8 0f 21 	and %d2,%d8,255
80009b2e:	5f 23 08 00 	jeq %d3,%d2,80009b3e <SetEvent+0x90>
80009b32:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009b36:	cd cf e2 0f 	mtcr $icr,%d15
80009b3a:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009b3e:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80009b42:	00 90       	ret 

80009b44 <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
80009b44:	40 ae       	mov.aa %a14,%sp
80009b46:	91 00 00 f8 	movh.a %a15,32768
80009b4a:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009b4e:	4c f2       	ld.w %d15,[%a15]8
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009b50:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009b52:	7f f4 11 80 	jge.u %d4,%d15,80009b74 <GetEvent+0x30>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009b56:	91 00 00 f8 	movh.a %a15,32768
80009b5a:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
80009b5e:	c8 1f       	ld.a %a15,[%a15]4
80009b60:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
80009b64:	c8 0f       	ld.a %a15,[%a15]0
80009b66:	c8 3f       	ld.a %a15,[%a15]12
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
80009b68:	3b e0 00 20 	mov %d2,14
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
80009b6c:	bc 44       	jz.a %a4,80009b74 <GetEvent+0x30>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
80009b6e:	4c f3       	ld.w %d15,[%a15]12
80009b70:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
80009b72:	82 02       	mov %d2,0
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009b74:	00 90       	ret 

80009b76 <ClearEvent>:
FUNC(StatusType, OS_CODE)
  ClearEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009b76:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
80009b78:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009b7c:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80009b80:	c8 0f       	ld.a %a15,[%a15]0
80009b82:	c8 3f       	ld.a %a15,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009b84:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009b88:	8f f2 0f f1 	and %d15,%d2,255
80009b8c:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009b90:	ee 0a       	jnz %d15,80009ba4 <ClearEvent+0x2e>
    OsEE_icr icr_temp = icr;
80009b92:	02 2f       	mov %d15,%d2
80009b94:	3b 30 01 30 	mov %d3,19
80009b98:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009b9c:	cd cf e2 0f 	mtcr $icr,%d15
80009ba0:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
80009ba4:	4c f3       	ld.w %d15,[%a15]12
80009ba6:	0f 4f e0 40 	andn %d4,%d15,%d4
80009baa:	68 34       	st.w [%a15]12,%d4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009bac:	4d c0 e2 3f 	mfcr %d3,$icr
80009bb0:	02 3f       	mov %d15,%d3
80009bb2:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009bb6:	8f f2 0f 21 	and %d2,%d2,255
80009bba:	5f 23 08 00 	jeq %d3,%d2,80009bca <ClearEvent+0x54>
80009bbe:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009bc2:	cd cf e2 0f 	mtcr $icr,%d15
80009bc6:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
80009bca:	82 02       	mov %d2,0
80009bcc:	00 90       	ret 

80009bce <GetISRID>:
FUNC(ISRType, OS_CODE)
  GetISRID
(
  void
)
{
80009bce:	40 ae       	mov.aa %a14,%sp
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80009bd0:	91 00 00 f8 	movh.a %a15,32768
80009bd4:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
80009bd8:	c8 0f       	ld.a %a15,[%a15]0
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009bda:	39 ff 14 00 	ld.bu %d15,[%a15]20 <800000d4 <osEE_cdb_var>>
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
80009bde:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009be0:	5e 22       	jne %d15,2,80009be4 <GetISRID+0x16>
    isr_id = p_tdb->tid;
80009be2:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
80009be4:	00 90       	ret 
	...

80009be8 <osEE_release_all_m>:
static FUNC_P2VAR(OsEE_MDB, OS_APPL_CONST, OS_CODE)
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
80009be8:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
80009bea:	99 43 0c 00 	ld.a %a3,[%a4]12

  while ((p_tcb->p_last_m != NULL)
80009bee:	cc 31       	ld.a %a15,[%a3]4
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
80009bf0:	a0 02       	mov.a %a2,0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
80009bf2:	bc fb       	jz.a %a15,80009c08 <osEE_release_all_m+0x20>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
80009bf4:	82 0f       	mov %d15,0
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
80009bf6:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
80009bf8:	68 2f       	st.w [%a15]8,%d15
    /* Save the first M not realesed */
    if (p_mdb == NULL) {
80009bfa:	7c 23       	jnz.a %a2,80009c00 <osEE_release_all_m+0x18>
      p_mdb = p_tcb->p_last_m;
80009bfc:	99 32 04 00 	ld.a %a2,[%a3]4
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
80009c00:	c8 0f       	ld.a %a15,[%a15]0
80009c02:	ec 31       	st.a [%a3]4,%a15
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
80009c04:	bd 0f f9 ff 	jnz.a %a15,80009bf6 <osEE_release_all_m+0xe>
    p_tcb->p_last_m = NULL;
  }
#endif /* OSEE_HAS_SPINLOCKS */

  return p_mdb;
}
80009c08:	00 90       	ret 

80009c0a <osEE_scheduler_task_wrapper_restore>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_restore
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
80009c0a:	40 ae       	mov.aa %a14,%sp
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
80009c0c:	cc 43       	ld.a %a15,[%a4]12
80009c0e:	82 4f       	mov %d15,4
80009c10:	28 2f       	st.b [%a15]2,%d15
80009c12:	00 90       	ret 

80009c14 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
80009c14:	40 ae       	mov.aa %a14,%sp
80009c16:	40 4f       	mov.aa %a15,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
80009c18:	99 42 0c 00 	ld.a %a2,[%a4]12
80009c1c:	39 22 01 00 	ld.bu %d2,[%a2]1
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
80009c20:	82 4f       	mov %d15,4
80009c22:	2c 22       	st.b [%a2]2,%d15
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_priority < OSEE_ISR_ALL_PRIO) {
80009c24:	8b f2 0f f2 	eq %d15,%d2,255
80009c28:	ee 13       	jnz %d15,80009c4e <osEE_scheduler_task_wrapper_run+0x3a>
80009c2a:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
80009c2e:	37 02 48 40 	extr %d4,%d2,0,8
80009c32:	82 03       	mov %d3,0
80009c34:	ce 45       	jgez %d4,80009c3e <osEE_scheduler_task_wrapper_run+0x2a>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
80009c36:	8f f2 07 21 	and %d2,%d2,127
80009c3a:	1b 12 00 30 	addi %d3,%d2,1
80009c3e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c42:	cd cf e2 0f 	mtcr $icr,%d15
80009c46:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009c4a:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
80009c4e:	c8 62       	ld.a %a2,[%a15]24
80009c50:	2d 02 00 00 	calli %a2
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
80009c54:	91 00 00 28 	movh.a %a2,32768
80009c58:	99 22 14 30 	ld.a %a2,[%a2]212 <800000d4 <osEE_cdb_var>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
80009c5c:	82 0f       	mov %d15,0
80009c5e:	e9 2f 1d 00 	st.b [%a2]29,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
80009c62:	39 2f 1c 00 	ld.bu %d15,[%a2]28
80009c66:	6e 09       	jz %d15,80009c78 <osEE_scheduler_task_wrapper_run+0x64>
    p_ccb->s_isr_all_cnt = 0U;
80009c68:	82 0f       	mov %d15,0
80009c6a:	e9 2f 1c 00 	st.b [%a2]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c6e:	4c 25       	ld.w %d15,[%a2]20
80009c70:	cd cf e2 0f 	mtcr $icr,%d15
80009c74:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
80009c78:	39 2f 1e 00 	ld.bu %d15,[%a2]30
80009c7c:	6e 06       	jz %d15,80009c88 <osEE_scheduler_task_wrapper_run+0x74>
    p_ccb->d_isr_all_cnt = 0U;
80009c7e:	82 0f       	mov %d15,0
80009c80:	e9 2f 1e 00 	st.b [%a2]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009c84:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009c88:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009c8c:	8f ff 0f 21 	and %d2,%d15,255
80009c90:	8b 32 a1 22 	ge.u %d2,%d2,19
80009c94:	f6 29       	jnz %d2,80009ca6 <osEE_scheduler_task_wrapper_run+0x92>
80009c96:	3b 30 01 20 	mov %d2,19
80009c9a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c9e:	cd cf e2 0f 	mtcr $icr,%d15
80009ca2:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
80009ca6:	39 ff 14 00 	ld.bu %d15,[%a15]20
80009caa:	5e 24       	jne %d15,2,80009cb2 <osEE_scheduler_task_wrapper_run+0x9e>
  /* [SWS_Os_00369]: If a Category 2 ISR calls GetResource() and ends (returns)
      without calling the corresponding ReleaseResource(), the Operating System
      module shall perform the ReleaseResource() call and shall call the
      ErrorHook() E_OS_RESOURCE */
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_mdb = osEE_release_all_m(p_to_term);
80009cac:	40 f4       	mov.aa %a4,%a15
80009cae:	5c 9d       	call 80009be8 <osEE_release_all_m>
80009cb0:	3c 03       	j 80009cb6 <osEE_scheduler_task_wrapper_run+0xa2>
    osEE_call_error_hook(p_ccb, E_OS_MISSINGEND);
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
/* [SWS_Os_0070]: If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and still holds OSEK Resources,
    the Operating System shall release them. */
    (void)osEE_release_all_m(p_to_term);
80009cb2:	40 f4       	mov.aa %a4,%a15
80009cb4:	5c 9a       	call 80009be8 <osEE_release_all_m>
80009cb6:	c8 14       	ld.a %a4,[%a15]4
80009cb8:	a0 05       	mov.a %a5,0
80009cba:	1d 00 79 02 	j 8000a1ac <osEE_hal_terminate_ctx>

80009cbe <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
80009cbe:	40 ae       	mov.aa %a14,%sp
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
80009cc0:	91 00 00 f8 	movh.a %a15,32768
80009cc4:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
80009cc8:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000d4 <osEE_cdb_var>>
80009ccc:	df 2f fe 7f 	jeq %d15,2,80009cc8 <osEE_idle_hook_wrapper+0xa>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
80009cd0:	91 00 00 f8 	movh.a %a15,32768
80009cd4:	d9 ff 14 30 	lea %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
80009cd8:	c8 14       	ld.a %a4,[%a15]4
80009cda:	6d 00 ba 01 	call 8000a04e <osEE_idle_task_terminate>
80009cde:	00 90       	ret 

80009ce0 <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
80009ce0:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009ce2:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
80009ce4:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
80009ce6:	99 32 0c 00 	ld.a %a2,[%a3]12

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
80009cea:	bd 02 13 00 	jz.a %a2,80009d10 <osEE_scheduler_core_rq_preempt_stk+0x30>
    p_ret_tdb = p_ret_sn->p_tdb;
80009cee:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
80009cf2:	bd 0f 1b 00 	jz.a %a15,80009d28 <osEE_scheduler_core_rq_preempt_stk+0x48>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
80009cf6:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
80009cfa:	c8 16       	ld.a %a6,[%a15]4
80009cfc:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
80009d00:	39 42 01 00 	ld.bu %d2,[%a4]1
80009d04:	0c 61       	ld.bu %d15,[%a6]1
80009d06:	7f f2 13 80 	jge.u %d2,%d15,80009d2c <osEE_scheduler_core_rq_preempt_stk+0x4c>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
80009d0a:	82 2f       	mov %d15,2
80009d0c:	2c 42       	st.b [%a4]2,%d15
80009d0e:	3c 11       	j 80009d30 <osEE_scheduler_core_rq_preempt_stk+0x50>
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
80009d10:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
80009d12:	bd 0f 1e 00 	jz.a %a15,80009d4e <osEE_scheduler_core_rq_preempt_stk+0x6e>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
80009d16:	99 42 04 00 	ld.a %a2,[%a4]4
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
80009d1a:	99 24 0c 00 	ld.a %a4,[%a2]12
80009d1e:	82 2f       	mov %d15,2
80009d20:	2c 42       	st.b [%a4]2,%d15
80009d22:	3c 07       	j 80009d30 <osEE_scheduler_core_rq_preempt_stk+0x50>
  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
    if (p_tcb->current_prio < dispatch_prio) {
      p_tcb->current_prio = dispatch_prio;
80009d24:	2c 51       	st.b [%a5]1,%d15
80009d26:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
80009d28:	a0 02       	mov.a %a2,0
80009d2a:	00 90       	ret 
80009d2c:	a0 02       	mov.a %a2,0
80009d2e:	00 90       	ret 
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
80009d30:	4c f0       	ld.w %d15,[%a15]0
80009d32:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
80009d34:	c8 14       	ld.a %a4,[%a15]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
80009d36:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
80009d3a:	4c 33       	ld.w %d15,[%a3]12
80009d3c:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
80009d3e:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
80009d40:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
80009d42:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
80009d46:	39 52 01 00 	ld.bu %d2,[%a5]1
80009d4a:	3f f2 ed ff 	jlt.u %d2,%d15,80009d24 <osEE_scheduler_core_rq_preempt_stk+0x44>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
80009d4e:	00 90       	ret 

80009d50 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
80009d50:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
80009d52:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
80009d54:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
80009d56:	76 44       	jz %d4,80009d5e <osEE_sn_priority_insert+0xe>
80009d58:	39 f2 1c 00 	ld.bu %d2,[%a15]28
80009d5c:	3c 03       	j 80009d62 <osEE_sn_priority_insert+0x12>
80009d5e:	39 22 01 00 	ld.bu %d2,[%a2]1
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
80009d62:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
80009d64:	a0 06       	mov.a %a6,0
80009d66:	7c f3       	jnz.a %a15,80009d6c <osEE_sn_priority_insert+0x1c>
80009d68:	3c 14       	j 80009d90 <osEE_sn_priority_insert+0x40>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
80009d6a:	60 ff       	mov.a %a15,%d15
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
80009d6c:	c8 12       	ld.a %a2,[%a15]4
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
80009d6e:	99 23 0c 00 	ld.a %a3,[%a2]12

    if (as_ready) {
80009d72:	76 44       	jz %d4,80009d7a <osEE_sn_priority_insert+0x2a>
      prio_to_check = p_cur_tdb->ready_prio;
80009d74:	39 2f 1c 00 	ld.bu %d15,[%a2]28
80009d78:	3c 02       	j 80009d7c <osEE_sn_priority_insert+0x2c>
    } else {
      prio_to_check = p_cur_tcb->current_prio;
80009d7a:	0c 31       	ld.bu %d15,[%a3]1
    }

    if (new_task_prio <= prio_to_check)
80009d7c:	3f 2f 06 80 	jlt.u %d15,%d2,80009d88 <osEE_sn_priority_insert+0x38>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
80009d80:	4c f0       	ld.w %d15,[%a15]0
80009d82:	40 f6       	mov.aa %a6,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
80009d84:	ee f3       	jnz %d15,80009d6a <osEE_sn_priority_insert+0x1a>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
80009d86:	60 ff       	mov.a %a15,%d15
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
80009d88:	bc 64       	jz.a %a6,80009d90 <osEE_sn_priority_insert+0x40>
    p_prev->p_next = p_sn_new;
80009d8a:	f4 65       	st.a [%a6],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
80009d8c:	82 02       	mov %d2,0
80009d8e:	3c 03       	j 80009d94 <osEE_sn_priority_insert+0x44>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
80009d90:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
80009d92:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
80009d94:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
80009d96:	00 90       	ret 

80009d98 <osEE_scheduler_rq_insert>:
(
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
80009d98:	40 ae       	mov.aa %a14,%sp
  p_sn_new->p_tdb = p_tdb_new;
80009d9a:	b5 56 04 00 	st.a [%a5]4,%a6

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
80009d9e:	82 14       	mov %d4,1
80009da0:	6d ff d8 ff 	call 80009d50 <osEE_sn_priority_insert>
#else
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_FALSE);
#endif /* !OSEE_SCHEDULER_GLOBAL */
}
80009da4:	00 90       	ret 

80009da6 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
80009da6:	40 ae       	mov.aa %a14,%sp
80009da8:	40 4d       	mov.aa %a13,%a4
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
80009daa:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
80009dac:	c8 3c       	ld.a %a12,[%a15]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
80009dae:	4c c0       	ld.w %d15,[%a12]0
80009db0:	68 3f       	st.w [%a15]12,%d15
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
80009db2:	6d ff 97 ff 	call 80009ce0 <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
80009db6:	4c f3       	ld.w %d15,[%a15]12

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
80009db8:	7c 28       	jnz.a %a2,80009dc8 <osEE_scheduler_core_pop_running+0x22>
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
80009dba:	80 d3       	mov.d %d3,%a13
80009dbc:	c2 43       	add %d3,4
80009dbe:	92 42       	add %d2,%d15,4
80009dc0:	6a 32       	cmovn %d2,%d15,%d3
80009dc2:	60 2d       	mov.a %a13,%d2
80009dc4:	4c d0       	ld.w %d15,[%a13]0
80009dc6:	68 0f       	st.w [%a15]0,%d15
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
80009dc8:	40 c2       	mov.aa %a2,%a12
80009dca:	00 90       	ret 

80009dcc <osEE_task_activated>:

FUNC(StatusType, OS_CODE) osEE_task_activated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80009dcc:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
80009dce:	cc 43       	ld.a %a15,[%a4]12
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
80009dd0:	0c f0       	ld.bu %d15,[%a15]0
80009dd2:	39 43 1e 00 	ld.bu %d3,[%a4]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
80009dd6:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
80009dd8:	7f 3f 05 80 	jge.u %d15,%d3,80009de2 <osEE_task_activated+0x16>
    ++p_tcb_act->current_num_of_act;
80009ddc:	c2 1f       	add %d15,1
80009dde:	28 0f       	st.b [%a15]0,%d15
    ev = E_OK;
80009de0:	82 02       	mov %d2,0
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
80009de2:	00 90       	ret 

80009de4 <osEE_task_end>:
FUNC(void, OS_CODE)
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
80009de4:	40 ae       	mov.aa %a14,%sp
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
80009de6:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
80009de8:	39 4f 1c 00 	ld.bu %d15,[%a4]28
80009dec:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
80009dee:	0c f0       	ld.bu %d15,[%a15]0
80009df0:	c2 ff       	add %d15,-1
80009df2:	16 ff       	and %d15,255
80009df4:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
80009df6:	ee 03       	jnz %d15,80009dfc <osEE_task_end+0x18>
    p_tcb->status = OSEE_TASK_SUSPENDED;
80009df8:	28 2f       	st.b [%a15]2,%d15
80009dfa:	00 90       	ret 
  } else {
    p_tcb->status = OSEE_TASK_READY;
80009dfc:	82 1f       	mov %d15,1
80009dfe:	28 2f       	st.b [%a15]2,%d15
80009e00:	00 90       	ret 

80009e02 <osEE_task_event_set_mask>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)    p_tdb_waking_up,
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
80009e02:	40 ae       	mov.aa %a14,%sp
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
80009e04:	cc 43       	ld.a %a15,[%a4]12
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
80009e06:	02 42       	mov %d2,%d4
80009e08:	02 43       	mov %d3,%d4
80009e0a:	49 f2 4c 08 	ldmst [%a15]12,%e2

    *p_ev = E_OK;
80009e0e:	82 0f       	mov %d15,0
80009e10:	2c 50       	st.b [%a5]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
80009e12:	4c f2       	ld.w %d15,[%a15]8
80009e14:	26 f4       	and %d4,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
80009e16:	a0 02       	mov.a %a2,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
80009e18:	76 45       	jz %d4,80009e22 <osEE_task_event_set_mask+0x20>
      p_own_sn = p_tcb_waking_up->p_own_sn;
80009e1a:	c8 42       	ld.a %a2,[%a15]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
80009e1c:	bc 23       	jz.a %a2,80009e22 <osEE_task_event_set_mask+0x20>
        p_tcb_waking_up->p_own_sn = NULL;
80009e1e:	82 0f       	mov %d15,0
80009e20:	68 4f       	st.w [%a15]16,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
80009e22:	00 90       	ret 

80009e24 <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
80009e24:	40 ae       	mov.aa %a14,%sp
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
80009e26:	91 00 00 48 	movh.a %a4,32768
80009e2a:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
80009e2e:	cc 41       	ld.a %a15,[%a4]4
80009e30:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009e34:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
80009e36:	cc 53       	ld.a %a15,[%a5]12
80009e38:	0c f0       	ld.bu %d15,[%a15]0
80009e3a:	c2 1f       	add %d15,1
80009e3c:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
80009e3e:	a0 06       	mov.a %a6,0
80009e40:	6d 00 c4 00 	call 80009fc8 <osEE_scheduler_task_set_running>
80009e44:	00 90       	ret 

80009e46 <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80009e46:	40 ae       	mov.aa %a14,%sp
80009e48:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
80009e4a:	99 52 0c 00 	ld.a %a2,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
80009e4e:	91 00 00 f8 	movh.a %a15,32768
80009e52:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
80009e56:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
80009e58:	99 43 0c 00 	ld.a %a3,[%a4]12 <800000d4 <osEE_cdb_var>>
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
80009e5c:	39 32 01 00 	ld.bu %d2,[%a3]1 <800000d4 <osEE_cdb_var>>
80009e60:	0c 21       	ld.bu %d15,[%a2]1
80009e62:	7f f2 15 80 	jge.u %d2,%d15,80009e8c <osEE_scheduler_task_activated+0x46>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009e66:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80009e68:	4c 20       	ld.w %d15,[%a2]0
80009e6a:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
80009e6c:	82 02       	mov %d2,0
80009e6e:	74 22       	st.w [%a2],%d2
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
80009e70:	82 2f       	mov %d15,2
80009e72:	2c 32       	st.b [%a3]2,%d15

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
80009e74:	b5 25 04 00 	st.a [%a2]4,%a5
    p_new_stk->p_next           = p_ccb->p_stk_sn;
80009e78:	4c f3       	ld.w %d15,[%a15]12
80009e7a:	6c 20       	st.w [%a2]0,%d15
    p_ccb->p_stk_sn             = p_new_stk;
80009e7c:	e8 32       	st.a [%a15]12,%a2
    p_ccb->p_curr               = p_tdb_act;
80009e7e:	e8 05       	st.a [%a15]0,%a5
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
80009e80:	cc 53       	ld.a %a15,[%a5]12
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
80009e82:	68 32       	st.w [%a15]12,%d2

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
80009e84:	6d 00 c1 00 	call 8000a006 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
80009e88:	82 12       	mov %d2,1
80009e8a:	00 90       	ret 
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
80009e8c:	0c 22       	ld.bu %d15,[%a2]2
80009e8e:	ee 05       	jnz %d15,80009e98 <osEE_scheduler_task_activated+0x52>
    p_tcb_act->status = OSEE_TASK_READY;
80009e90:	82 1f       	mov %d15,1
80009e92:	2c 22       	st.b [%a2]2,%d15
80009e94:	82 0f       	mov %d15,0
80009e96:	6c 23       	st.w [%a2]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009e98:	c8 25       	ld.a %a5,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80009e9a:	4c 50       	ld.w %d15,[%a5]0
80009e9c:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
80009e9e:	82 0f       	mov %d15,0
80009ea0:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80009ea2:	d9 f4 04 00 	lea %a4,[%a15]4
80009ea6:	6d ff 79 ff 	call 80009d98 <osEE_scheduler_rq_insert>
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
80009eaa:	82 02       	mov %d2,0
  }

  return is_preemption;
}
80009eac:	00 90       	ret 

80009eae <osEE_scheduler_task_insert>:
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80009eae:	40 ae       	mov.aa %a14,%sp
80009eb0:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
80009eb2:	cc 53       	ld.a %a15,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
80009eb4:	91 00 00 28 	movh.a %a2,32768
80009eb8:	99 24 14 30 	ld.a %a4,[%a2]212 <800000d4 <osEE_cdb_var>>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
80009ebc:	0c f2       	ld.bu %d15,[%a15]2
80009ebe:	ee 05       	jnz %d15,80009ec8 <osEE_scheduler_task_insert+0x1a>
    p_tcb_act->status = OSEE_TASK_READY;
80009ec0:	82 1f       	mov %d15,1
80009ec2:	28 2f       	st.b [%a15]2,%d15
80009ec4:	82 0f       	mov %d15,0
80009ec6:	68 3f       	st.w [%a15]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009ec8:	99 45 08 00 	ld.a %a5,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
80009ecc:	4c 50       	ld.w %d15,[%a5]0
80009ece:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
80009ed0:	82 0f       	mov %d15,0
80009ed2:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80009ed4:	b0 44       	add.a %a4,4
80009ed6:	6d ff 61 ff 	call 80009d98 <osEE_scheduler_rq_insert>

    osEE_unlock_core(p_cdb);
  }

  return head_changed;
}
80009eda:	00 90       	ret 

80009edc <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
80009edc:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
80009ede:	99 56 04 00 	ld.a %a6,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
80009ee2:	cc 63       	ld.a %a15,[%a6]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
80009ee4:	91 00 00 28 	movh.a %a2,32768
80009ee8:	99 2c 14 30 	ld.a %a12,[%a2]212 <800000d4 <osEE_cdb_var>>

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
80009eec:	82 2f       	mov %d15,2
80009eee:	28 2f       	st.b [%a15]2,%d15
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
80009ef0:	39 6f 1c 00 	ld.bu %d15,[%a6]28
80009ef4:	28 1f       	st.b [%a15]1,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80009ef6:	d9 c4 04 00 	lea %a4,[%a12]4
80009efa:	6d ff 4f ff 	call 80009d98 <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
80009efe:	82 0f       	mov %d15,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
80009f00:	df 12 0a 80 	jne %d2,1,80009f14 <osEE_scheduler_task_unblocked+0x38>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
80009f04:	d4 c2       	ld.a %a2,[%a12]
80009f06:	99 22 0c 00 	ld.a %a2,[%a2]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
80009f0a:	0c f1       	ld.bu %d15,[%a15]1
80009f0c:	39 22 01 00 	ld.bu %d2,[%a2]1
80009f10:	0b f2 30 f1 	lt.u %d15,%d2,%d15
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
80009f14:	02 f2       	mov %d2,%d15
80009f16:	00 90       	ret 

80009f18 <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
80009f18:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009f1a:	91 00 00 f8 	movh.a %a15,32768
80009f1e:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
80009f22:	c8 0d       	ld.a %a13,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
80009f24:	99 dc 0c 00 	ld.a %a12,[%a13]12 <800000d4 <osEE_cdb_var>>

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
80009f28:	f4 5d       	st.a [%a5],%a13

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
80009f2a:	0c c2       	ld.bu %d15,[%a12]2
80009f2c:	de 4a       	jne %d15,4,80009f60 <osEE_scheduler_task_terminated+0x48>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
80009f2e:	91 00 00 48 	movh.a %a4,32768
80009f32:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
80009f36:	d9 f5 04 00 	lea %a5,[%a15]4 <800000d4 <osEE_cdb_var>>
80009f3a:	6d ff 36 ff 	call 80009da6 <osEE_scheduler_core_pop_running>
80009f3e:	80 28       	mov.d %d8,%a2

      p_tdb_to = p_ccb->p_curr;
80009f40:	4c f0       	ld.w %d15,[%a15]0

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
80009f42:	80 d2       	mov.d %d2,%a13
80009f44:	5f f2 06 00 	jeq %d2,%d15,80009f50 <osEE_scheduler_task_terminated+0x38>
        osEE_task_end(p_tdb_term);
80009f48:	40 d4       	mov.aa %a4,%a13
80009f4a:	6d ff 4d ff 	call 80009de4 <osEE_task_end>
80009f4e:	3c 04       	j 80009f56 <osEE_scheduler_task_terminated+0x3e>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
80009f50:	14 c2       	ld.bu %d2,[%a12]
80009f52:	c2 f2       	add %d2,-1
80009f54:	34 c2       	st.b [%a12],%d2
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
80009f56:	48 22       	ld.w %d2,[%a15]8
80009f58:	60 82       	mov.a %a2,%d8
80009f5a:	74 22       	st.w [%a2],%d2
  (*pp_first)       = p_to_free;
80009f5c:	68 28       	st.w [%a15]8,%d8
80009f5e:	3c 20       	j 80009f9e <osEE_scheduler_task_terminated+0x86>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
80009f60:	c8 35       	ld.a %a5,[%a15]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
80009f62:	54 52       	ld.w %d2,[%a5]
80009f64:	68 32       	st.w [%a15]12,%d2
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
80009f66:	39 df 1c 00 	ld.bu %d15,[%a13]28
80009f6a:	2c c1       	st.b [%a12]1,%d15
      p_tcb_term->status = OSEE_TASK_READY;
80009f6c:	82 1f       	mov %d15,1
80009f6e:	2c c2       	st.b [%a12]2,%d15
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
80009f70:	0c c0       	ld.bu %d15,[%a12]0
80009f72:	5e 13       	jne %d15,1,80009f78 <osEE_scheduler_task_terminated+0x60>
80009f74:	82 0f       	mov %d15,0
80009f76:	6c c3       	st.w [%a12]12,%d15
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
80009f78:	d9 fc 04 00 	lea %a12,[%a15]4
80009f7c:	40 c4       	mov.aa %a4,%a12
80009f7e:	40 d6       	mov.aa %a6,%a13
80009f80:	6d ff 0c ff 	call 80009d98 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
80009f84:	91 00 00 48 	movh.a %a4,32768
80009f88:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
80009f8c:	40 c5       	mov.aa %a5,%a12
80009f8e:	6d ff a9 fe 	call 80009ce0 <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
80009f92:	7c 25       	jnz.a %a2,80009f9c <osEE_scheduler_task_terminated+0x84>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
80009f94:	c8 32       	ld.a %a2,[%a15]12
80009f96:	4c 21       	ld.w %d15,[%a2]4
          p_ccb->p_curr           = p_tdb_to;
80009f98:	68 0f       	st.w [%a15]0,%d15
80009f9a:	3c 02       	j 80009f9e <osEE_scheduler_task_terminated+0x86>
        } else {
          p_tdb_to = p_ccb->p_curr;
80009f9c:	4c f0       	ld.w %d15,[%a15]0
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
80009f9e:	60 f2       	mov.a %a2,%d15
80009fa0:	00 90       	ret 

80009fa2 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
80009fa2:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009fa4:	91 00 00 48 	movh.a %a4,32768
80009fa8:	99 4f 14 30 	ld.a %a15,[%a4]212 <800000d4 <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
80009fac:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <osEE_cdb_var>>
80009fb0:	d9 f5 04 00 	lea %a5,[%a15]4 <800000d4 <osEE_cdb_var>>
80009fb4:	6d ff 96 fe 	call 80009ce0 <osEE_scheduler_core_rq_preempt_stk>

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
80009fb8:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
80009fba:	bc 26       	jz.a %a2,80009fc6 <osEE_scheduler_task_preemption_point+0x24>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
80009fbc:	40 24       	mov.aa %a4,%a2
80009fbe:	c8 05       	ld.a %a5,[%a15]0
80009fc0:	6d 00 23 00 	call 8000a006 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
80009fc4:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
80009fc6:	00 90       	ret 

80009fc8 <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
80009fc8:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009fca:	91 00 00 f8 	movh.a %a15,32768
80009fce:	99 ff 14 30 	ld.a %a15,[%a15]212 <800000d4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
80009fd2:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
80009fd4:	48 32       	ld.w %d2,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
80009fd6:	99 42 0c 00 	ld.a %a2,[%a4]12 <800000d4 <osEE_cdb_var>>
80009fda:	0c 22       	ld.bu %d15,[%a2]2
80009fdc:	5e 43       	jne %d15,4,80009fe2 <osEE_scheduler_task_set_running+0x1a>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
80009fde:	82 2f       	mov %d15,2
80009fe0:	2c 22       	st.b [%a2]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
80009fe2:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
80009fe4:	7c 68       	jnz.a %a6,80009ff4 <osEE_scheduler_task_set_running+0x2c>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009fe6:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80009fe8:	4c 20       	ld.w %d15,[%a2]0
80009fea:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
80009fec:	82 0f       	mov %d15,0
80009fee:	6c 20       	st.w [%a2]0,%d15
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
80009ff0:	e8 32       	st.a [%a15]12,%a2
80009ff2:	3c 02       	j 80009ff6 <osEE_scheduler_task_set_running+0x2e>
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
80009ff4:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
80009ff6:	c8 32       	ld.a %a2,[%a15]12
80009ff8:	b5 25 04 00 	st.a [%a2]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
80009ffc:	c8 3f       	ld.a %a15,[%a15]12
80009ffe:	68 02       	st.w [%a15]0,%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000a000:	6d 00 03 00 	call 8000a006 <osEE_change_context_from_running>
8000a004:	00 90       	ret 

8000a006 <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a006:	40 ae       	mov.aa %a14,%sp
8000a008:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a00a:	99 52 0c 00 	ld.a %a2,[%a5]12
8000a00e:	0c 22       	ld.bu %d15,[%a2]2
8000a010:	5e 28       	jne %d15,2,8000a020 <osEE_change_context_from_running+0x1a>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000a012:	40 54       	mov.aa %a4,%a5
8000a014:	99 55 04 00 	ld.a %a5,[%a5]4
8000a018:	c8 16       	ld.a %a6,[%a15]4
8000a01a:	6d 00 73 00 	call 8000a100 <osEE_hal_save_ctx_and_restore_ctx>
8000a01e:	00 90       	ret 
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
8000a020:	40 54       	mov.aa %a4,%a5
8000a022:	99 55 04 00 	ld.a %a5,[%a5]4
8000a026:	c8 16       	ld.a %a6,[%a15]4
8000a028:	6d 00 8b 00 	call 8000a13e <osEE_hal_save_ctx_and_ready2stacked>
8000a02c:	00 90       	ret 

8000a02e <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a02e:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a030:	cc 53       	ld.a %a15,[%a5]12
8000a032:	0c f2       	ld.bu %d15,[%a15]2
8000a034:	5e 27       	jne %d15,2,8000a042 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000a036:	40 54       	mov.aa %a4,%a5
8000a038:	99 55 04 00 	ld.a %a5,[%a5]4
8000a03c:	6d 00 74 00 	call 8000a124 <osEE_hal_restore_ctx>
8000a040:	00 90       	ret 
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
8000a042:	40 54       	mov.aa %a4,%a5
8000a044:	99 55 04 00 	ld.a %a5,[%a5]4
8000a048:	6d 00 8d 00 	call 8000a162 <osEE_hal_ready2stacked>
8000a04c:	00 90       	ret 

8000a04e <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
8000a04e:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
8000a050:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000a054:	cc 40       	ld.a %a15,[%a4]0
8000a056:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000a058:	cc 50       	ld.a %a15,[%a5]0
8000a05a:	3c 02       	j 8000a05e <osEE_idle_task_terminate+0x10>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000a05c:	60 ff       	mov.a %a15,%d15
8000a05e:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
8000a060:	8b 0f 20 22 	ne %d2,%d15,0
8000a064:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000a068:	df 02 fa ff 	jne %d2,0,8000a05c <osEE_idle_task_terminate+0xe>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000a06c:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
8000a06e:	6d 00 5b 00 	call 8000a124 <osEE_hal_restore_ctx>
8000a072:	00 90       	ret 

8000a074 <osEE_cpu_startos>:
}
#endif /* OSEE_SINGLECORE */
#endif /* OSEE_TC_HAS_ISR1_TO_CONF */

OsEE_bool osEE_cpu_startos(void)
{
8000a074:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000a076:	4d c0 e1 5f 	mfcr %d5,$core_id
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000a07a:	91 00 00 f8 	movh.a %a15,32768
8000a07e:	d9 ff 00 30 	lea %a15,[%a15]192 <800000c0 <osEE_kdb_var>>
8000a082:	c8 2f       	ld.a %a15,[%a15]8
8000a084:	b0 ff       	add.a %a15,-1
  for (i = 0U; i < tdb_size; ++i) {
8000a086:	bd 0f 2a 00 	jz.a %a15,8000a0da <osEE_cpu_startos+0x66>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000a08a:	91 00 00 28 	movh.a %a2,32768
8000a08e:	d9 22 00 30 	lea %a2,[%a2]192 <800000c0 <osEE_kdb_var>>
8000a092:	19 23 04 00 	ld.w %d3,[%a2]4 <80000004 <BootModeHeader0+0x4>>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000a096:	8f 35 00 51 	and %d5,%d5,3
8000a09a:	8f b5 00 50 	sh %d5,%d5,11
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000a09e:	bb f0 ff 4f 	mov.u %d4,65535
8000a0a2:	82 0f       	mov %d15,0
8000a0a4:	b0 ff       	add.a %a15,-1
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000a0a6:	60 33       	mov.a %a3,%d3
8000a0a8:	90 32       	addsc.a %a2,%a3,%d15,2
8000a0aa:	d4 22       	ld.a %a2,[%a2]
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a0ac:	39 22 14 00 	ld.bu %d2,[%a2]20
8000a0b0:	df 22 12 80 	jne %d2,2,8000a0d4 <osEE_cpu_startos+0x60>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000a0b4:	b9 22 08 00 	ld.hu %d2,[%a2]8
8000a0b8:	5f 42 0e 00 	jeq %d2,%d4,8000a0d4 <osEE_cpu_startos+0x60>
8000a0bc:	60 24       	mov.a %a4,%d2
8000a0be:	d9 43 00 08 	lea %a3,[%a4]-32768
8000a0c2:	11 43 00 3f 	addih.a %a3,%a3,61444
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000a0c6:	39 22 1c 00 	ld.bu %d2,[%a2]28
8000a0ca:	c2 12       	add %d2,1
8000a0cc:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000a0d0:	a6 52       	or %d2,%d5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000a0d2:	74 32       	st.w [%a3],%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000a0d4:	c2 1f       	add %d15,1
8000a0d6:	fd f0 e8 7f 	loop %a15,8000a0a6 <osEE_cpu_startos+0x32>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000a0da:	82 12       	mov %d2,1
8000a0dc:	00 90       	ret 

8000a0de <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a0de:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000a0e2:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000a0e4:	0c 22       	ld.bu %d15,[%a2]2
8000a0e6:	1e 27       	jeq %d15,2,8000a0f4 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000a0e8:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000a0ea:	c8 1f       	ld.a %a15,[%a15]4
8000a0ec:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
8000a0ee:	1d 00 3a 00 	j 8000a162 <osEE_hal_ready2stacked>
8000a0f2:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
8000a0f4:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000a0f6:	c8 1f       	ld.a %a15,[%a15]4
8000a0f8:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000a0fa:	1d 00 15 00 	j 8000a124 <osEE_hal_restore_ctx>
8000a0fe:	00 90       	ret 

8000a100 <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000a100:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000a102:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000a106:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000a108:	4c 60       	ld.w %d15,[%a6]0
8000a10a:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a10e:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000a112:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000a116:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000a118:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000a11c:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
8000a11e:	1d 00 03 00 	j 8000a124 <osEE_hal_restore_ctx>
8000a122:	00 90       	ret 

8000a124 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
8000a124:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000a126:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
8000a128:	4c f2       	ld.w %d15,[%a15]8
8000a12a:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000a12c:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000a130:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
8000a134:	4c f0       	ld.w %d15,[%a15]0
8000a136:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
8000a138:	1d ff 69 fd 	j 80009c0a <osEE_scheduler_task_wrapper_restore>
8000a13c:	00 90       	ret 

8000a13e <osEE_hal_save_ctx_and_ready2stacked>:
8000a13e:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000a140:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000a144:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000a146:	4c 60       	ld.w %d15,[%a6]0
8000a148:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a14c:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000a150:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000a154:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000a156:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000a15a:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
8000a15c:	1d 00 03 00 	j 8000a162 <osEE_hal_ready2stacked>
8000a160:	00 90       	ret 

8000a162 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000a162:	cc 50       	ld.a %a15,[%a5]0
8000a164:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
8000a166:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000a16a:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000a16c:	d9 f2 f0 ff 	lea %a2,[%a15]-16
8000a170:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000a172:	4c 50       	ld.w %d15,[%a5]0
8000a174:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a178:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000a17c:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000a180:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000a182:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000a186:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000a188:	1d ff 46 fd 	j 80009c14 <osEE_scheduler_task_wrapper_run>
8000a18c:	00 90       	ret 

8000a18e <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
8000a18e:	4d 40 e0 ff 	mfcr %d15,$psw
8000a192:	8f ff c7 f1 	andn %d15,%d15,127
8000a196:	cd 4f e0 0f 	mtcr $psw,%d15
8000a19a:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000a19e:	91 10 00 f8 	movh.a %a15,32769
8000a1a2:	d9 ff 1e 3a 	lea %a15,[%a15]-24354 <8000a0de <osEE_tc_change_context_from_task_end>>
8000a1a6:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000a1a8:	00 80       	rfe 
8000a1aa:	00 90       	ret 

8000a1ac <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000a1ac:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
8000a1ae:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000a1b2:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
8000a1b6:	cc 40       	ld.a %a15,[%a4]0
8000a1b8:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000a1ba:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000a1be:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000a1c2:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000a1c4:	8f c3 01 30 	sh %d3,%d3,28
8000a1c8:	a6 43       	or %d3,%d4
8000a1ca:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000a1cc:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
8000a1ce:	bc f3       	jz.a %a15,8000a1d4 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
8000a1d0:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
8000a1d2:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
8000a1d4:	cd 8f e3 0f 	mtcr $fcx,%d15
8000a1d8:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000a1dc:	cd 03 e0 0f 	mtcr $pcxi,%d3
8000a1e0:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
8000a1e4:	cc 40       	ld.a %a15,[%a4]0
8000a1e6:	4c f0       	ld.w %d15,[%a15]0
8000a1e8:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000a1ea:	91 00 00 48 	movh.a %a4,32768
8000a1ee:	d9 44 00 30 	lea %a4,[%a4]192 <800000c0 <osEE_kdb_var>>
8000a1f2:	d9 a5 04 00 	lea %a5,[%sp]4 <800000c0 <osEE_kdb_var>>
8000a1f6:	6d ff 91 fe 	call 80009f18 <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000a1fa:	d8 01       	ld.a %a15,[%sp]4
8000a1fc:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000a200:	1e 25       	jeq %d15,2,8000a20a <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
8000a202:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
8000a204:	1d ff 6d ff 	j 8000a0de <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000a208:	3c 00       	j 8000a208 <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000a20a:	40 24       	mov.aa %a4,%a2
8000a20c:	6d ff c1 ff 	call 8000a18e <osEE_tc_change_context_from_isr2_end>
8000a210:	3c fc       	j 8000a208 <osEE_hal_terminate_ctx+0x5c>

8000a212 <__lshrdi3>:
8000a212:	6f 56 0c 80 	jnz.t %d6,5,8000a22a <__lshrdi3+0x18>
8000a216:	8b 06 02 71 	rsub %d7,%d6,32
8000a21a:	32 56       	rsub %d6
8000a21c:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
8000a220:	0f 65 00 30 	sh %d3,%d5,%d6
8000a224:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
8000a228:	00 90       	ret 
8000a22a:	8b 06 02 60 	add %d6,%d6,32
8000a22e:	32 56       	rsub %d6
8000a230:	0f 65 00 20 	sh %d2,%d5,%d6
8000a234:	82 03       	mov %d3,0
8000a236:	00 90       	ret 

8000a238 <__floatundisf>:
8000a238:	7b 00 02 20 	movh %d2,32
8000a23c:	0b 25 30 f1 	lt.u %d15,%d5,%d2
8000a240:	02 4a       	mov %d10,%d4
8000a242:	02 54       	mov %d4,%d5
8000a244:	ee 08       	jnz %d15,8000a254 <__floatundisf+0x1c>
8000a246:	b7 0a 95 f5 	insert %d15,%d10,0,11,21
8000a24a:	6e 05       	jz %d15,8000a254 <__floatundisf+0x1c>
8000a24c:	b7 0a 0b a0 	insert %d10,%d10,0,0,11
8000a250:	b7 fa 81 a5 	insert %d10,%d10,15,11,1
8000a254:	6d 00 ea 02 	call 8000a828 <__floatunsidf>
8000a258:	0b 23 10 48 	mov %e4,%d3,%d2
8000a25c:	82 06       	mov %d6,0
8000a25e:	7b 00 1f 74 	movh %d7,16880
8000a262:	6d 00 34 01 	call 8000a4ca <__muldf3>
8000a266:	02 a4       	mov %d4,%d10
8000a268:	0b 23 10 88 	mov %e8,%d3,%d2
8000a26c:	6d 00 de 02 	call 8000a828 <__floatunsidf>
8000a270:	0b 89 10 48 	mov %e4,%d9,%d8
8000a274:	0b 23 10 68 	mov %e6,%d3,%d2
8000a278:	6d 00 ed 00 	call 8000a452 <__adddf3>
8000a27c:	0b 23 10 48 	mov %e4,%d3,%d2
8000a280:	1d 00 b6 02 	j 8000a7ec <__truncdfsf2>

8000a284 <__extendsfdf2>:
8000a284:	20 20       	sub.a %sp,32
8000a286:	d9 a4 20 00 	lea %a4,[%sp]32
8000a28a:	89 44 2c f5 	st.w [+%a4]-20,%d4
8000a28e:	d9 a5 10 00 	lea %a5,[%sp]16
8000a292:	6d 00 f1 02 	call 8000a874 <__unpack_f>
8000a296:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000a29a:	39 a4 10 00 	ld.bu %d4,[%sp]16
8000a29e:	8f e2 1f f0 	sh %d15,%d2,-2
8000a2a2:	8f e2 01 20 	sh %d2,%d2,30
8000a2a6:	74 a2       	st.w [%sp],%d2
8000a2a8:	78 01       	st.w [%sp]4,%d15
8000a2aa:	19 a5 14 00 	ld.w %d5,[%sp]20
8000a2ae:	19 a6 18 00 	ld.w %d6,[%sp]24
8000a2b2:	1d 00 8e 02 	j 8000a7ce <__make_dp>

8000a2b6 <_fpadd_parts>:
8000a2b6:	0c 40       	ld.bu %d15,[%a4]0
8000a2b8:	40 42       	mov.aa %a2,%a4
8000a2ba:	bf 2f cb 80 	jlt.u %d15,2,8000a450 <_fpadd_parts+0x19a>
8000a2be:	14 52       	ld.bu %d2,[%a5]
8000a2c0:	40 52       	mov.aa %a2,%a5
8000a2c2:	bf 22 c7 80 	jlt.u %d2,2,8000a450 <_fpadd_parts+0x19a>
8000a2c6:	5e 4e       	jne %d15,4,8000a2e2 <_fpadd_parts+0x2c>
8000a2c8:	40 42       	mov.aa %a2,%a4
8000a2ca:	df 42 c3 80 	jne %d2,4,8000a450 <_fpadd_parts+0x19a>
8000a2ce:	19 42 04 00 	ld.w %d2,[%a4]4
8000a2d2:	4c 51       	ld.w %d15,[%a5]4
8000a2d4:	5f f2 be 00 	jeq %d2,%d15,8000a450 <_fpadd_parts+0x19a>
8000a2d8:	91 00 00 f8 	movh.a %a15,32768
8000a2dc:	d9 f2 f8 50 	lea %a2,[%a15]3448 <80000d78 <__thenan_df>>
8000a2e0:	00 90       	ret 
8000a2e2:	40 52       	mov.aa %a2,%a5
8000a2e4:	df 42 b6 00 	jeq %d2,4,8000a450 <_fpadd_parts+0x19a>
8000a2e8:	df 22 11 80 	jne %d2,2,8000a30a <_fpadd_parts+0x54>
8000a2ec:	40 42       	mov.aa %a2,%a4
8000a2ee:	df 2f b1 80 	jne %d15,2,8000a450 <_fpadd_parts+0x19a>
8000a2f2:	40 63       	mov.aa %a3,%a6
8000a2f4:	a0 4f       	mov.a %a15,4
8000a2f6:	44 4f       	ld.w %d15,[%a4+]
8000a2f8:	64 3f       	st.w [%a3+],%d15
8000a2fa:	fc fe       	loop %a15,8000a2f6 <_fpadd_parts+0x40>
8000a2fc:	4c 21       	ld.w %d15,[%a2]4
8000a2fe:	19 52 04 00 	ld.w %d2,[%a5]4
8000a302:	40 62       	mov.aa %a2,%a6
8000a304:	26 2f       	and %d15,%d2
8000a306:	6c 61       	st.w [%a6]4,%d15
8000a308:	00 90       	ret 
8000a30a:	40 52       	mov.aa %a2,%a5
8000a30c:	df 2f a2 00 	jeq %d15,2,8000a450 <_fpadd_parts+0x19a>
8000a310:	4c 42       	ld.w %d15,[%a4]8
8000a312:	19 52 08 00 	ld.w %d2,[%a5]8
8000a316:	40 6f       	mov.aa %a15,%a6
8000a318:	52 23       	sub %d3,%d15,%d2
8000a31a:	0b 30 c0 c1 	abs %d12,%d3
8000a31e:	8b 0c 84 42 	ge %d4,%d12,64
8000a322:	40 5c       	mov.aa %a12,%a5
8000a324:	40 4d       	mov.aa %a13,%a4
8000a326:	09 4a 4c 09 	ld.d %e10,[%a4]12
8000a32a:	09 58 4c 09 	ld.d %e8,[%a5]12
8000a32e:	df 04 35 80 	jne %d4,0,8000a398 <_fpadd_parts+0xe2>
8000a332:	bf 13 19 00 	jlt %d3,1,8000a364 <_fpadd_parts+0xae>
8000a336:	0b 89 10 48 	mov %e4,%d9,%d8
8000a33a:	02 c6       	mov %d6,%d12
8000a33c:	6d ff 6b ff 	call 8000a212 <__lshrdi3>
8000a340:	d2 14       	mov %e4,1
8000a342:	02 c6       	mov %d6,%d12
8000a344:	02 2e       	mov %d14,%d2
8000a346:	02 3d       	mov %d13,%d3
8000a348:	6d 00 89 02 	call 8000a85a <__ashldi3>
8000a34c:	8b f2 9f 20 	addx %d2,%d2,-1
8000a350:	8b f3 bf 30 	addc %d3,%d3,-1
8000a354:	26 82       	and %d2,%d8
8000a356:	26 93       	and %d3,%d9
8000a358:	a6 23       	or %d3,%d2
8000a35a:	02 e8       	mov %d8,%d14
8000a35c:	8b 03 00 85 	or.ne %d8,%d3,0
8000a360:	02 d9       	mov %d9,%d13
8000a362:	3c 21       	j 8000a3a4 <_fpadd_parts+0xee>
8000a364:	df 03 20 00 	jeq %d3,0,8000a3a4 <_fpadd_parts+0xee>
8000a368:	0b ab 10 48 	mov %e4,%d11,%d10
8000a36c:	02 c6       	mov %d6,%d12
8000a36e:	6d ff 52 ff 	call 8000a212 <__lshrdi3>
8000a372:	d2 14       	mov %e4,1
8000a374:	02 c6       	mov %d6,%d12
8000a376:	02 2e       	mov %d14,%d2
8000a378:	02 3d       	mov %d13,%d3
8000a37a:	6d 00 70 02 	call 8000a85a <__ashldi3>
8000a37e:	8b f2 9f 20 	addx %d2,%d2,-1
8000a382:	8b f3 bf 30 	addc %d3,%d3,-1
8000a386:	26 a2       	and %d2,%d10
8000a388:	26 b3       	and %d3,%d11
8000a38a:	a6 23       	or %d3,%d2
8000a38c:	02 ea       	mov %d10,%d14
8000a38e:	42 cf       	add %d15,%d12
8000a390:	8b 03 00 a5 	or.ne %d10,%d3,0
8000a394:	02 db       	mov %d11,%d13
8000a396:	3c 07       	j 8000a3a4 <_fpadd_parts+0xee>
8000a398:	3f f2 05 00 	jlt %d2,%d15,8000a3a2 <_fpadd_parts+0xec>
8000a39c:	02 2f       	mov %d15,%d2
8000a39e:	d2 0a       	mov %e10,0
8000a3a0:	3c 02       	j 8000a3a4 <_fpadd_parts+0xee>
8000a3a2:	d2 08       	mov %e8,0
8000a3a4:	19 d4 04 00 	ld.w %d4,[%a13]4
8000a3a8:	19 c2 04 00 	ld.w %d2,[%a12]4
8000a3ac:	5f 24 34 00 	jeq %d4,%d2,8000a414 <_fpadd_parts+0x15e>
8000a3b0:	0b 8a c0 20 	subx %d2,%d10,%d8
8000a3b4:	0b 9b d0 30 	subc %d3,%d11,%d9
8000a3b8:	76 45       	jz %d4,8000a3c2 <_fpadd_parts+0x10c>
8000a3ba:	0b a8 c0 20 	subx %d2,%d8,%d10
8000a3be:	0b b9 d0 30 	subc %d3,%d9,%d11
8000a3c2:	0e 37       	jltz %d3,8000a3d0 <_fpadd_parts+0x11a>
8000a3c4:	82 04       	mov %d4,0
8000a3c6:	68 14       	st.w [%a15]4,%d4
8000a3c8:	68 2f       	st.w [%a15]8,%d15
8000a3ca:	89 f2 4c 09 	st.d [%a15]12,%e2
8000a3ce:	3c 0c       	j 8000a3e6 <_fpadd_parts+0x130>
8000a3d0:	68 2f       	st.w [%a15]8,%d15
8000a3d2:	8b 03 00 f1 	rsub %d15,%d3,0
8000a3d6:	82 14       	mov %d4,1
8000a3d8:	8b 02 00 31 	rsub %d3,%d2,0
8000a3dc:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
8000a3e0:	68 14       	st.w [%a15]4,%d4
8000a3e2:	68 33       	st.w [%a15]12,%d3
8000a3e4:	68 4f       	st.w [%a15]16,%d15
8000a3e6:	82 f5       	mov %d5,-1
8000a3e8:	06 c5       	sh %d5,-4
8000a3ea:	48 32       	ld.w %d2,[%a15]12
8000a3ec:	48 43       	ld.w %d3,[%a15]16
8000a3ee:	8b f2 9f 60 	addx %d6,%d2,-1
8000a3f2:	8b f3 bf 40 	addc %d4,%d3,-1
8000a3f6:	3a 54       	eq %d15,%d4,%d5
8000a3f8:	8b f6 3f f4 	and.ne %d15,%d6,-1
8000a3fc:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
8000a400:	6e 12       	jz %d15,8000a424 <_fpadd_parts+0x16e>
8000a402:	4c f2       	ld.w %d15,[%a15]8
8000a404:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a408:	c2 ff       	add %d15,-1
8000a40a:	06 12       	sh %d2,1
8000a40c:	68 32       	st.w [%a15]12,%d2
8000a40e:	68 43       	st.w [%a15]16,%d3
8000a410:	68 2f       	st.w [%a15]8,%d15
8000a412:	3c ec       	j 8000a3ea <_fpadd_parts+0x134>
8000a414:	0b a8 40 20 	addx %d2,%d8,%d10
8000a418:	68 2f       	st.w [%a15]8,%d15
8000a41a:	0b b9 50 f0 	addc %d15,%d9,%d11
8000a41e:	68 14       	st.w [%a15]4,%d4
8000a420:	68 32       	st.w [%a15]12,%d2
8000a422:	68 4f       	st.w [%a15]16,%d15
8000a424:	82 3f       	mov %d15,3
8000a426:	28 0f       	st.b [%a15]0,%d15
8000a428:	4c f4       	ld.w %d15,[%a15]16
8000a42a:	7b 00 00 42 	movh %d4,8192
8000a42e:	0b 4f 30 31 	lt.u %d3,%d15,%d4
8000a432:	48 32       	ld.w %d2,[%a15]12
8000a434:	40 f2       	mov.aa %a2,%a15
8000a436:	f6 3d       	jnz %d3,8000a450 <_fpadd_parts+0x19a>
8000a438:	8f 12 00 31 	and %d3,%d2,1
8000a43c:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
8000a440:	06 ff       	sh %d15,-1
8000a442:	96 00       	or %d15,0
8000a444:	68 4f       	st.w [%a15]16,%d15
8000a446:	4c f2       	ld.w %d15,[%a15]8
8000a448:	a6 32       	or %d2,%d3
8000a44a:	c2 1f       	add %d15,1
8000a44c:	68 32       	st.w [%a15]12,%d2
8000a44e:	68 2f       	st.w [%a15]8,%d15
8000a450:	00 90       	ret 

8000a452 <__adddf3>:
8000a452:	20 50       	sub.a %sp,80
8000a454:	d9 a4 04 00 	lea %a4,[%sp]4
8000a458:	d9 a5 14 00 	lea %a5,[%sp]20
8000a45c:	89 a4 44 09 	st.d [%sp]4,%e4
8000a460:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a464:	6d 00 d9 02 	call 8000aa16 <__unpack_d>
8000a468:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a46c:	d9 a5 28 00 	lea %a5,[%sp]40
8000a470:	6d 00 d3 02 	call 8000aa16 <__unpack_d>
8000a474:	d9 a4 14 00 	lea %a4,[%sp]20
8000a478:	d9 a5 28 00 	lea %a5,[%sp]40
8000a47c:	d9 a6 3c 00 	lea %a6,[%sp]60
8000a480:	6d ff 1b ff 	call 8000a2b6 <_fpadd_parts>
8000a484:	40 24       	mov.aa %a4,%a2
8000a486:	1d 00 3f 02 	j 8000a904 <__pack_d>

8000a48a <__subdf3>:
8000a48a:	20 50       	sub.a %sp,80
8000a48c:	d9 a4 04 00 	lea %a4,[%sp]4
8000a490:	d9 a5 14 00 	lea %a5,[%sp]20
8000a494:	89 a4 44 09 	st.d [%sp]4,%e4
8000a498:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a49c:	6d 00 bd 02 	call 8000aa16 <__unpack_d>
8000a4a0:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a4a4:	d9 a5 28 00 	lea %a5,[%sp]40
8000a4a8:	6d 00 b7 02 	call 8000aa16 <__unpack_d>
8000a4ac:	58 0b       	ld.w %d15,[%sp]44
8000a4ae:	d9 a4 14 00 	lea %a4,[%sp]20
8000a4b2:	8f 1f 80 f1 	xor %d15,%d15,1
8000a4b6:	d9 a5 28 00 	lea %a5,[%sp]40
8000a4ba:	d9 a6 3c 00 	lea %a6,[%sp]60
8000a4be:	78 0b       	st.w [%sp]44,%d15
8000a4c0:	6d ff fb fe 	call 8000a2b6 <_fpadd_parts>
8000a4c4:	40 24       	mov.aa %a4,%a2
8000a4c6:	1d 00 1f 02 	j 8000a904 <__pack_d>

8000a4ca <__muldf3>:
8000a4ca:	20 50       	sub.a %sp,80
8000a4cc:	d9 a4 04 00 	lea %a4,[%sp]4
8000a4d0:	d9 a5 14 00 	lea %a5,[%sp]20
8000a4d4:	89 a4 44 09 	st.d [%sp]4,%e4
8000a4d8:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a4dc:	6d 00 9d 02 	call 8000aa16 <__unpack_d>
8000a4e0:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a4e4:	d9 a5 28 00 	lea %a5,[%sp]40
8000a4e8:	6d 00 97 02 	call 8000aa16 <__unpack_d>
8000a4ec:	39 a3 14 00 	ld.bu %d3,[%sp]20
8000a4f0:	ff 23 0c 80 	jge.u %d3,2,8000a508 <__muldf3+0x3e>
8000a4f4:	19 a2 18 00 	ld.w %d2,[%sp]24
8000a4f8:	58 0b       	ld.w %d15,[%sp]44
8000a4fa:	d9 a4 14 00 	lea %a4,[%sp]20
8000a4fe:	0b f2 10 f1 	ne %d15,%d2,%d15
8000a502:	78 06       	st.w [%sp]24,%d15
8000a504:	1d 00 b3 00 	j 8000a66a <__muldf3+0x1a0>
8000a508:	39 af 28 00 	ld.bu %d15,[%sp]40
8000a50c:	ff 2f 0c 80 	jge.u %d15,2,8000a524 <__muldf3+0x5a>
8000a510:	58 0b       	ld.w %d15,[%sp]44
8000a512:	19 a2 18 00 	ld.w %d2,[%sp]24
8000a516:	d9 a4 28 00 	lea %a4,[%sp]40
8000a51a:	0b f2 10 f1 	ne %d15,%d2,%d15
8000a51e:	78 0b       	st.w [%sp]44,%d15
8000a520:	1d 00 a5 00 	j 8000a66a <__muldf3+0x1a0>
8000a524:	df 43 09 80 	jne %d3,4,8000a536 <__muldf3+0x6c>
8000a528:	91 00 00 48 	movh.a %a4,32768
8000a52c:	d9 44 f8 50 	lea %a4,[%a4]3448 <80000d78 <__thenan_df>>
8000a530:	df 2f 9d 00 	jeq %d15,2,8000a66a <__muldf3+0x1a0>
8000a534:	3c e0       	j 8000a4f4 <__muldf3+0x2a>
8000a536:	5e 48       	jne %d15,4,8000a546 <__muldf3+0x7c>
8000a538:	91 00 00 48 	movh.a %a4,32768
8000a53c:	d9 44 f8 50 	lea %a4,[%a4]3448 <80000d78 <__thenan_df>>
8000a540:	df 23 95 00 	jeq %d3,2,8000a66a <__muldf3+0x1a0>
8000a544:	3c e6       	j 8000a510 <__muldf3+0x46>
8000a546:	df 23 d7 7f 	jeq %d3,2,8000a4f4 <__muldf3+0x2a>
8000a54a:	df 2f e3 7f 	jeq %d15,2,8000a510 <__muldf3+0x46>
8000a54e:	58 08       	ld.w %d15,[%sp]32
8000a550:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
8000a554:	d2 00       	mov %e0,0
8000a556:	19 a0 34 00 	ld.w %d0,[%sp]52
8000a55a:	73 bf 68 60 	mul.u %e6,%d15,%d11
8000a55e:	82 0c       	mov %d12,0
8000a560:	73 0f 68 40 	mul.u %e4,%d15,%d0
8000a564:	19 aa 24 00 	ld.w %d10,[%sp]36
8000a568:	82 02       	mov %d2,0
8000a56a:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
8000a56e:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
8000a572:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
8000a576:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
8000a57a:	82 0d       	mov %d13,0
8000a57c:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
8000a580:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
8000a584:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
8000a588:	0b 54 10 08 	mov %e0,%d4,%d5
8000a58c:	42 20       	add %d0,%d2
8000a58e:	3a 73       	eq %d15,%d3,%d7
8000a590:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
8000a594:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
8000a598:	8b 0f 00 62 	eq %d6,%d15,0
8000a59c:	3a 50       	eq %d15,%d0,%d5
8000a59e:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
8000a5a2:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
8000a5a6:	ba 0f       	eq %d15,%d15,0
8000a5a8:	53 1f 40 40 	mul.u %e4,%d15,1
8000a5ac:	02 38       	mov %d8,%d3
8000a5ae:	82 09       	mov %d9,0
8000a5b0:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
8000a5b4:	02 5f       	mov %d15,%d5
8000a5b6:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
8000a5ba:	42 6f       	add %d15,%d6
8000a5bc:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
8000a5c0:	0b 4f 10 68 	mov %e6,%d15,%d4
8000a5c4:	0b 62 40 40 	addx %d4,%d2,%d6
8000a5c8:	0b 73 50 20 	addc %d2,%d3,%d7
8000a5cc:	58 07       	ld.w %d15,[%sp]28
8000a5ce:	19 a3 30 00 	ld.w %d3,[%sp]48
8000a5d2:	19 a5 18 00 	ld.w %d5,[%sp]24
8000a5d6:	42 3f       	add %d15,%d3
8000a5d8:	19 a3 2c 00 	ld.w %d3,[%sp]44
8000a5dc:	c2 4f       	add %d15,4
8000a5de:	0b 35 10 31 	ne %d3,%d5,%d3
8000a5e2:	59 a3 00 10 	st.w [%sp]64,%d3
8000a5e6:	7b 00 00 52 	movh %d5,8192
8000a5ea:	0b 52 50 31 	ge.u %d3,%d2,%d5
8000a5ee:	df 03 1b 00 	jeq %d3,0,8000a624 <__muldf3+0x15a>
8000a5f2:	8f 14 00 31 	and %d3,%d4,1
8000a5f6:	76 37       	jz %d3,8000a604 <__muldf3+0x13a>
8000a5f8:	8f f0 1f 30 	sh %d3,%d0,-1
8000a5fc:	77 10 80 1f 	dextr %d1,%d0,%d1,31
8000a600:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
8000a604:	77 42 80 4f 	dextr %d4,%d2,%d4,31
8000a608:	c2 1f       	add %d15,1
8000a60a:	06 f2       	sh %d2,-1
8000a60c:	3c ed       	j 8000a5e6 <__muldf3+0x11c>
8000a60e:	77 42 80 20 	dextr %d2,%d2,%d4,1
8000a612:	06 14       	sh %d4,1
8000a614:	ce 04       	jgez %d0,8000a61c <__muldf3+0x152>
8000a616:	8f 14 40 51 	or %d5,%d4,1
8000a61a:	02 54       	mov %d4,%d5
8000a61c:	77 10 80 00 	dextr %d0,%d0,%d1,1
8000a620:	c2 ff       	add %d15,-1
8000a622:	06 11       	sh %d1,1
8000a624:	7b 00 00 51 	movh %d5,4096
8000a628:	0b 52 30 31 	lt.u %d3,%d2,%d5
8000a62c:	df 03 f1 ff 	jne %d3,0,8000a60e <__muldf3+0x144>
8000a630:	78 11       	st.w [%sp]68,%d15
8000a632:	02 4f       	mov %d15,%d4
8000a634:	16 ff       	and %d15,255
8000a636:	8b 0f 28 f2 	ne %d15,%d15,128
8000a63a:	ee 0f       	jnz %d15,8000a658 <__muldf3+0x18e>
8000a63c:	a6 10       	or %d0,%d1
8000a63e:	77 42 00 fc 	dextr %d15,%d2,%d4,24
8000a642:	8b 00 20 02 	ne %d0,%d0,0
8000a646:	0f f0 e0 00 	andn %d0,%d0,%d15
8000a64a:	76 07       	jz %d0,8000a658 <__muldf3+0x18e>
8000a64c:	8b 04 88 40 	addx %d4,%d4,128
8000a650:	8b 02 a0 20 	addc %d2,%d2,0
8000a654:	8f f4 cf 41 	andn %d4,%d4,255
8000a658:	d9 a4 10 10 	lea %a4,[%sp]80
8000a65c:	82 3f       	mov %d15,3
8000a65e:	59 a4 08 10 	st.w [%sp]72,%d4
8000a662:	59 a2 0c 10 	st.w [%sp]76,%d2
8000a666:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <IfxAsclin1_TX_P20_10_OUT+0xc>>,%d15
8000a66a:	1d 00 4d 01 	j 8000a904 <__pack_d>

8000a66e <__divdf3>:
8000a66e:	20 38       	sub.a %sp,56
8000a670:	40 a4       	mov.aa %a4,%sp
8000a672:	d9 a5 10 00 	lea %a5,[%sp]16
8000a676:	89 a4 40 09 	st.d [%sp],%e4
8000a67a:	89 a6 48 09 	st.d [%sp]8,%e6
8000a67e:	6d 00 cc 01 	call 8000aa16 <__unpack_d>
8000a682:	d9 a4 08 00 	lea %a4,[%sp]8
8000a686:	d9 a5 24 00 	lea %a5,[%sp]36
8000a68a:	6d 00 c6 01 	call 8000aa16 <__unpack_d>
8000a68e:	39 a2 10 00 	ld.bu %d2,[%sp]16
8000a692:	bf 22 76 80 	jlt.u %d2,2,8000a77e <__divdf3+0x110>
8000a696:	39 af 24 00 	ld.bu %d15,[%sp]36
8000a69a:	d9 a4 24 00 	lea %a4,[%sp]36
8000a69e:	bf 2f 72 80 	jlt.u %d15,2,8000a782 <__divdf3+0x114>
8000a6a2:	19 a4 14 00 	ld.w %d4,[%sp]20
8000a6a6:	19 a3 28 00 	ld.w %d3,[%sp]40
8000a6aa:	c6 43       	xor %d3,%d4
8000a6ac:	59 a3 14 00 	st.w [%sp]20,%d3
8000a6b0:	1b e2 ff 3f 	addi %d3,%d2,-2
8000a6b4:	8f d3 0f 31 	and %d3,%d3,253
8000a6b8:	f6 38       	jnz %d3,8000a6c8 <__divdf3+0x5a>
8000a6ba:	91 00 00 48 	movh.a %a4,32768
8000a6be:	d9 44 f8 50 	lea %a4,[%a4]3448 <80000d78 <__thenan_df>>
8000a6c2:	5f f2 5e 80 	jne %d2,%d15,8000a77e <__divdf3+0x110>
8000a6c6:	3c 5e       	j 8000a782 <__divdf3+0x114>
8000a6c8:	5e 47       	jne %d15,4,8000a6d6 <__divdf3+0x68>
8000a6ca:	d2 02       	mov %e2,0
8000a6cc:	82 0f       	mov %d15,0
8000a6ce:	89 a2 5c 09 	st.d [%sp]28,%e2
8000a6d2:	78 06       	st.w [%sp]24,%d15
8000a6d4:	3c 55       	j 8000a77e <__divdf3+0x110>
8000a6d6:	5e 25       	jne %d15,2,8000a6e0 <__divdf3+0x72>
8000a6d8:	82 4f       	mov %d15,4
8000a6da:	e9 af 10 00 	st.b [%sp]16,%d15
8000a6de:	3c 50       	j 8000a77e <__divdf3+0x110>
8000a6e0:	58 06       	ld.w %d15,[%sp]24
8000a6e2:	09 a2 5c 09 	ld.d %e2,[%sp]28
8000a6e6:	09 a4 70 09 	ld.d %e4,[%sp]48
8000a6ea:	19 a6 2c 00 	ld.w %d6,[%sp]44
8000a6ee:	52 66       	sub %d6,%d15,%d6
8000a6f0:	3a 53       	eq %d15,%d3,%d5
8000a6f2:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
8000a6f6:	59 a6 18 00 	st.w [%sp]24,%d6
8000a6fa:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
8000a6fe:	ee 07       	jnz %d15,8000a70c <__divdf3+0x9e>
8000a700:	c2 f6       	add %d6,-1
8000a702:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a706:	59 a6 18 00 	st.w [%sp]24,%d6
8000a70a:	06 12       	sh %d2,1
8000a70c:	82 01       	mov %d1,0
8000a70e:	7b 00 00 f1 	movh %d15,4096
8000a712:	82 00       	mov %d0,0
8000a714:	82 07       	mov %d7,0
8000a716:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
8000a71a:	0b 53 00 61 	eq %d6,%d3,%d5
8000a71e:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8000a722:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8000a726:	f6 6b       	jnz %d6,8000a73c <__divdf3+0xce>
8000a728:	0f 10 a0 80 	or %d8,%d0,%d1
8000a72c:	0f f7 a0 60 	or %d6,%d7,%d15
8000a730:	0b 42 c0 20 	subx %d2,%d2,%d4
8000a734:	02 80       	mov %d0,%d8
8000a736:	02 67       	mov %d7,%d6
8000a738:	0b 53 d0 30 	subc %d3,%d3,%d5
8000a73c:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
8000a740:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a744:	06 ff       	sh %d15,-1
8000a746:	06 12       	sh %d2,1
8000a748:	fd f0 e9 7f 	loop %a15,8000a71a <__divdf3+0xac>
8000a74c:	02 0f       	mov %d15,%d0
8000a74e:	16 ff       	and %d15,255
8000a750:	8b 0f 28 f2 	ne %d15,%d15,128
8000a754:	0b 70 10 48 	mov %e4,%d0,%d7
8000a758:	ee 0f       	jnz %d15,8000a776 <__divdf3+0x108>
8000a75a:	a6 32       	or %d2,%d3
8000a75c:	77 07 00 fc 	dextr %d15,%d7,%d0,24
8000a760:	8b 02 20 22 	ne %d2,%d2,0
8000a764:	0f f2 e0 20 	andn %d2,%d2,%d15
8000a768:	76 27       	jz %d2,8000a776 <__divdf3+0x108>
8000a76a:	8b 00 88 00 	addx %d0,%d0,128
8000a76e:	8b 07 a0 40 	addc %d4,%d7,0
8000a772:	8f f0 cf 51 	andn %d5,%d0,255
8000a776:	59 a5 1c 00 	st.w [%sp]28,%d5
8000a77a:	59 a4 20 00 	st.w [%sp]32,%d4
8000a77e:	d9 a4 10 00 	lea %a4,[%sp]16
8000a782:	1d 00 c1 00 	j 8000a904 <__pack_d>

8000a786 <__floatsidf>:
8000a786:	20 18       	sub.a %sp,24
8000a788:	82 3f       	mov %d15,3
8000a78a:	2c a4       	st.b [%sp]4,%d15
8000a78c:	8f 14 1e f0 	sh %d15,%d4,-31
8000a790:	78 02       	st.w [%sp]8,%d15
8000a792:	f6 44       	jnz %d4,8000a79a <__floatsidf+0x14>
8000a794:	82 2f       	mov %d15,2
8000a796:	2c a4       	st.b [%sp]4,%d15
8000a798:	3c 16       	j 8000a7c4 <__floatsidf+0x3e>
8000a79a:	6e 09       	jz %d15,8000a7ac <__floatsidf+0x26>
8000a79c:	7b 00 00 f8 	movh %d15,32768
8000a7a0:	82 02       	mov %d2,0
8000a7a2:	7b 00 1e 3c 	movh %d3,49632
8000a7a6:	5f f4 13 00 	jeq %d4,%d15,8000a7cc <__floatsidf+0x46>
8000a7aa:	32 54       	rsub %d4
8000a7ac:	0f 04 b0 f1 	clz %d15,%d4
8000a7b0:	1b df 01 60 	addi %d6,%d15,29
8000a7b4:	82 05       	mov %d5,0
8000a7b6:	6d 00 52 00 	call 8000a85a <__ashldi3>
8000a7ba:	8b ff 01 f1 	rsub %d15,%d15,31
8000a7be:	89 a2 50 09 	st.d [%sp]16,%e2
8000a7c2:	78 03       	st.w [%sp]12,%d15
8000a7c4:	d9 a4 04 00 	lea %a4,[%sp]4
8000a7c8:	6d 00 9e 00 	call 8000a904 <__pack_d>
8000a7cc:	00 90       	ret 

8000a7ce <__make_dp>:
8000a7ce:	20 18       	sub.a %sp,24
8000a7d0:	09 a2 58 09 	ld.d %e2,[%sp]24
8000a7d4:	d9 a4 04 00 	lea %a4,[%sp]4
8000a7d8:	e9 a4 04 00 	st.b [%sp]4,%d4
8000a7dc:	59 a5 08 00 	st.w [%sp]8,%d5
8000a7e0:	59 a6 0c 00 	st.w [%sp]12,%d6
8000a7e4:	89 a2 50 09 	st.d [%sp]16,%e2
8000a7e8:	1d 00 8e 00 	j 8000a904 <__pack_d>

8000a7ec <__truncdfsf2>:
8000a7ec:	20 20       	sub.a %sp,32
8000a7ee:	d9 a4 20 00 	lea %a4,[%sp]32
8000a7f2:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000a7f6:	d9 a5 0c 00 	lea %a5,[%sp]12
8000a7fa:	6d 00 0e 01 	call 8000aa16 <__unpack_d>
8000a7fe:	19 a7 18 00 	ld.w %d7,[%sp]24
8000a802:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000a806:	39 a4 0c 00 	ld.bu %d4,[%sp]12
8000a80a:	77 72 00 21 	dextr %d2,%d2,%d7,2
8000a80e:	b7 07 02 7f 	insert %d7,%d7,0,30,2
8000a812:	02 23       	mov %d3,%d2
8000a814:	8f 12 40 21 	or %d2,%d2,1
8000a818:	19 a5 10 00 	ld.w %d5,[%sp]16
8000a81c:	19 a6 14 00 	ld.w %d6,[%sp]20
8000a820:	2b 32 40 77 	sel %d7,%d7,%d2,%d3
8000a824:	1d 00 65 00 	j 8000a8ee <__make_fp>

8000a828 <__floatunsidf>:
8000a828:	20 18       	sub.a %sp,24
8000a82a:	82 0f       	mov %d15,0
8000a82c:	78 02       	st.w [%sp]8,%d15
8000a82e:	f6 44       	jnz %d4,8000a836 <__floatunsidf+0xe>
8000a830:	82 2f       	mov %d15,2
8000a832:	2c a4       	st.b [%sp]4,%d15
8000a834:	3c 0f       	j 8000a852 <__floatunsidf+0x2a>
8000a836:	82 3f       	mov %d15,3
8000a838:	2c a4       	st.b [%sp]4,%d15
8000a83a:	0f 04 b0 f1 	clz %d15,%d4
8000a83e:	1b df 01 60 	addi %d6,%d15,29
8000a842:	82 05       	mov %d5,0
8000a844:	6d 00 0b 00 	call 8000a85a <__ashldi3>
8000a848:	8b ff 01 f1 	rsub %d15,%d15,31
8000a84c:	89 a2 50 09 	st.d [%sp]16,%e2
8000a850:	78 03       	st.w [%sp]12,%d15
8000a852:	d9 a4 04 00 	lea %a4,[%sp]4
8000a856:	1d 00 57 00 	j 8000a904 <__pack_d>

8000a85a <__ashldi3>:
8000a85a:	6f 56 07 80 	jnz.t %d6,5,8000a868 <__ashldi3+0xe>
8000a85e:	0f 64 00 20 	sh %d2,%d4,%d6
8000a862:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
8000a866:	00 90       	ret 
8000a868:	8b 06 1e 60 	add %d6,%d6,-32
8000a86c:	82 02       	mov %d2,0
8000a86e:	0f 64 00 30 	sh %d3,%d4,%d6
8000a872:	00 90       	ret 

8000a874 <__unpack_f>:
8000a874:	54 43       	ld.w %d3,[%a4]
8000a876:	37 03 77 f0 	extr.u %d15,%d3,0,23
8000a87a:	37 03 e8 2b 	extr.u %d2,%d3,23,8
8000a87e:	8f 13 1e 30 	sh %d3,%d3,-31
8000a882:	59 53 04 00 	st.w [%a5]4,%d3
8000a886:	df 02 18 80 	jne %d2,0,8000a8b6 <__unpack_f+0x42>
8000a88a:	ee 03       	jnz %d15,8000a890 <__unpack_f+0x1c>
8000a88c:	82 2f       	mov %d15,2
8000a88e:	3c 19       	j 8000a8c0 <__unpack_f+0x4c>
8000a890:	3b 20 f8 2f 	mov %d2,-126
8000a894:	59 52 08 00 	st.w [%a5]8,%d2
8000a898:	82 32       	mov %d2,3
8000a89a:	34 52       	st.b [%a5],%d2
8000a89c:	06 7f       	sh %d15,7
8000a89e:	3b 10 f8 2f 	mov %d2,-127
8000a8a2:	7b 00 00 44 	movh %d4,16384
8000a8a6:	06 1f       	sh %d15,1
8000a8a8:	02 23       	mov %d3,%d2
8000a8aa:	c2 f2       	add %d2,-1
8000a8ac:	3f 4f fd ff 	jlt.u %d15,%d4,8000a8a6 <__unpack_f+0x32>
8000a8b0:	59 53 08 00 	st.w [%a5]8,%d3
8000a8b4:	3c 1b       	j 8000a8ea <__unpack_f+0x76>
8000a8b6:	8b f2 2f 32 	ne %d3,%d2,255
8000a8ba:	f6 3f       	jnz %d3,8000a8d8 <__unpack_f+0x64>
8000a8bc:	ee 04       	jnz %d15,8000a8c4 <__unpack_f+0x50>
8000a8be:	82 4f       	mov %d15,4
8000a8c0:	2c 50       	st.b [%a5]0,%d15
8000a8c2:	00 90       	ret 
8000a8c4:	7b 00 04 20 	movh %d2,64
8000a8c8:	26 f2       	and %d2,%d15
8000a8ca:	76 22       	jz %d2,8000a8ce <__unpack_f+0x5a>
8000a8cc:	82 12       	mov %d2,1
8000a8ce:	b7 0f 01 fb 	insert %d15,%d15,0,22,1
8000a8d2:	34 52       	st.b [%a5],%d2
8000a8d4:	06 7f       	sh %d15,7
8000a8d6:	3c 0a       	j 8000a8ea <__unpack_f+0x76>
8000a8d8:	1b 12 f8 2f 	addi %d2,%d2,-127
8000a8dc:	06 7f       	sh %d15,7
8000a8de:	59 52 08 00 	st.w [%a5]8,%d2
8000a8e2:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000a8e6:	82 32       	mov %d2,3
8000a8e8:	34 52       	st.b [%a5],%d2
8000a8ea:	6c 53       	st.w [%a5]12,%d15
8000a8ec:	00 90       	ret 

8000a8ee <__make_fp>:
8000a8ee:	20 10       	sub.a %sp,16
8000a8f0:	40 a4       	mov.aa %a4,%sp
8000a8f2:	34 a4       	st.b [%sp],%d4
8000a8f4:	59 a5 04 00 	st.w [%sp]4,%d5
8000a8f8:	59 a6 08 00 	st.w [%sp]8,%d6
8000a8fc:	59 a7 0c 00 	st.w [%sp]12,%d7
8000a900:	1d 00 e1 00 	j 8000aac2 <__pack_f>

8000a904 <__pack_d>:
8000a904:	14 42       	ld.bu %d2,[%a4]
8000a906:	19 49 0c 00 	ld.w %d9,[%a4]12
8000a90a:	19 48 10 00 	ld.w %d8,[%a4]16
8000a90e:	19 4c 04 00 	ld.w %d12,[%a4]4
8000a912:	ff 22 0b 80 	jge.u %d2,2,8000a928 <__pack_d+0x24>
8000a916:	77 98 00 9c 	dextr %d9,%d8,%d9,24
8000a91a:	06 88       	sh %d8,-8
8000a91c:	02 95       	mov %d5,%d9
8000a91e:	b7 18 8d 49 	insert %d4,%d8,1,19,13
8000a922:	3b f0 7f f0 	mov %d15,2047
8000a926:	3c 6f       	j 8000aa04 <__pack_d+0x100>
8000a928:	3b f0 7f f0 	mov %d15,2047
8000a92c:	d2 04       	mov %e4,0
8000a92e:	df 42 6b 00 	jeq %d2,4,8000aa04 <__pack_d+0x100>
8000a932:	0f 89 a0 f0 	or %d15,%d9,%d8
8000a936:	8b 22 00 32 	eq %d3,%d2,2
8000a93a:	8b 0f e0 34 	or.eq %d3,%d15,0
8000a93e:	82 0f       	mov %d15,0
8000a940:	df 03 62 80 	jne %d3,0,8000aa04 <__pack_d+0x100>
8000a944:	19 42 08 00 	ld.w %d2,[%a4]8
8000a948:	3b 20 c0 ff 	mov %d15,-1022
8000a94c:	7f f2 36 00 	jge %d2,%d15,8000a9b8 <__pack_d+0xb4>
8000a950:	a2 2f       	sub %d15,%d2
8000a952:	8b 9f 83 42 	ge %d4,%d15,57
8000a956:	82 02       	mov %d2,0
8000a958:	df 04 18 80 	jne %d4,0,8000a988 <__pack_d+0x84>
8000a95c:	0b 98 10 48 	mov %e4,%d8,%d9
8000a960:	02 f6       	mov %d6,%d15
8000a962:	6d ff 58 fc 	call 8000a212 <__lshrdi3>
8000a966:	d2 14       	mov %e4,1
8000a968:	02 f6       	mov %d6,%d15
8000a96a:	0b 32 10 a8 	mov %e10,%d2,%d3
8000a96e:	6d ff 76 ff 	call 8000a85a <__ashldi3>
8000a972:	8b f2 9f 20 	addx %d2,%d2,-1
8000a976:	8b f3 bf 30 	addc %d3,%d3,-1
8000a97a:	26 29       	and %d9,%d2
8000a97c:	26 38       	and %d8,%d3
8000a97e:	a6 98       	or %d8,%d9
8000a980:	02 b2       	mov %d2,%d11
8000a982:	8b 08 00 25 	or.ne %d2,%d8,0
8000a986:	02 a3       	mov %d3,%d10
8000a988:	02 2f       	mov %d15,%d2
8000a98a:	16 ff       	and %d15,255
8000a98c:	8b 0f 28 f2 	ne %d15,%d15,128
8000a990:	ee 07       	jnz %d15,8000a99e <__pack_d+0x9a>
8000a992:	8f 02 10 f1 	and %d15,%d2,256
8000a996:	6e 08       	jz %d15,8000a9a6 <__pack_d+0xa2>
8000a998:	8b 02 88 20 	addx %d2,%d2,128
8000a99c:	3c 03       	j 8000a9a2 <__pack_d+0x9e>
8000a99e:	8b f2 87 20 	addx %d2,%d2,127
8000a9a2:	8b 03 a0 30 	addc %d3,%d3,0
8000a9a6:	7b 00 00 41 	movh %d4,4096
8000a9aa:	0b 43 50 f1 	ge.u %d15,%d3,%d4
8000a9ae:	77 23 00 5c 	dextr %d5,%d3,%d2,24
8000a9b2:	8f 83 1f 40 	sh %d4,%d3,-8
8000a9b6:	3c 27       	j 8000aa04 <__pack_d+0x100>
8000a9b8:	3b 00 40 30 	mov %d3,1024
8000a9bc:	3b f0 7f f0 	mov %d15,2047
8000a9c0:	7f 32 22 00 	jge %d2,%d3,8000aa04 <__pack_d+0x100>
8000a9c4:	02 9f       	mov %d15,%d9
8000a9c6:	16 ff       	and %d15,255
8000a9c8:	8b 0f 28 f2 	ne %d15,%d15,128
8000a9cc:	ee 07       	jnz %d15,8000a9da <__pack_d+0xd6>
8000a9ce:	8f 09 10 f1 	and %d15,%d9,256
8000a9d2:	6e 08       	jz %d15,8000a9e2 <__pack_d+0xde>
8000a9d4:	8b 09 88 90 	addx %d9,%d9,128
8000a9d8:	3c 03       	j 8000a9de <__pack_d+0xda>
8000a9da:	8b f9 87 90 	addx %d9,%d9,127
8000a9de:	8b 08 a0 80 	addc %d8,%d8,0
8000a9e2:	7b 00 00 32 	movh %d3,8192
8000a9e6:	0b 38 50 f1 	ge.u %d15,%d8,%d3
8000a9ea:	ee 04       	jnz %d15,8000a9f2 <__pack_d+0xee>
8000a9ec:	1b f2 3f f0 	addi %d15,%d2,1023
8000a9f0:	3c 06       	j 8000a9fc <__pack_d+0xf8>
8000a9f2:	77 98 80 9f 	dextr %d9,%d8,%d9,31
8000a9f6:	1b 02 40 f0 	addi %d15,%d2,1024
8000a9fa:	06 f8       	sh %d8,-1
8000a9fc:	77 98 00 5c 	dextr %d5,%d8,%d9,24
8000aa00:	8f 88 1f 40 	sh %d4,%d8,-8
8000aa04:	d2 02       	mov %e2,0
8000aa06:	37 43 14 40 	insert %d4,%d3,%d4,0,20
8000aa0a:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
8000aa0e:	02 52       	mov %d2,%d5
8000aa10:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
8000aa14:	00 90       	ret 

8000aa16 <__unpack_d>:
8000aa16:	19 44 04 00 	ld.w %d4,[%a4]4
8000aa1a:	54 42       	ld.w %d2,[%a4]
8000aa1c:	37 04 74 50 	extr.u %d5,%d4,0,20
8000aa20:	37 04 6b fa 	extr.u %d15,%d4,20,11
8000aa24:	8f 14 1e 40 	sh %d4,%d4,-31
8000aa28:	59 54 04 00 	st.w [%a5]4,%d4
8000aa2c:	02 53       	mov %d3,%d5
8000aa2e:	ee 21       	jnz %d15,8000aa70 <__unpack_d+0x5a>
8000aa30:	0f 25 a0 f0 	or %d15,%d5,%d2
8000aa34:	ee 03       	jnz %d15,8000aa3a <__unpack_d+0x24>
8000aa36:	82 2f       	mov %d15,2
8000aa38:	3c 23       	j 8000aa7e <__unpack_d+0x68>
8000aa3a:	3b 20 c0 ff 	mov %d15,-1022
8000aa3e:	6c 52       	st.w [%a5]8,%d15
8000aa40:	82 3f       	mov %d15,3
8000aa42:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000aa46:	2c 50       	st.b [%a5]0,%d15
8000aa48:	8f 82 00 20 	sh %d2,%d2,8
8000aa4c:	3b 10 c0 ff 	mov %d15,-1023
8000aa50:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000aa54:	7b 00 00 61 	movh %d6,4096
8000aa58:	0b 63 30 51 	lt.u %d5,%d3,%d6
8000aa5c:	02 f4       	mov %d4,%d15
8000aa5e:	06 12       	sh %d2,1
8000aa60:	c2 ff       	add %d15,-1
8000aa62:	df 05 f7 ff 	jne %d5,0,8000aa50 <__unpack_d+0x3a>
8000aa66:	59 54 08 00 	st.w [%a5]8,%d4
8000aa6a:	59 52 0c 00 	st.w [%a5]12,%d2
8000aa6e:	3c 27       	j 8000aabc <__unpack_d+0xa6>
8000aa70:	3b f0 7f 40 	mov %d4,2047
8000aa74:	fe 47       	jne %d15,%d4,8000aaa2 <__unpack_d+0x8c>
8000aa76:	0f 25 a0 f0 	or %d15,%d5,%d2
8000aa7a:	ee 04       	jnz %d15,8000aa82 <__unpack_d+0x6c>
8000aa7c:	82 4f       	mov %d15,4
8000aa7e:	2c 50       	st.b [%a5]0,%d15
8000aa80:	00 90       	ret 
8000aa82:	7b 80 00 f0 	movh %d15,8
8000aa86:	26 5f       	and %d15,%d5
8000aa88:	6e 02       	jz %d15,8000aa8c <__unpack_d+0x76>
8000aa8a:	82 1f       	mov %d15,1
8000aa8c:	2c 50       	st.b [%a5]0,%d15
8000aa8e:	b7 03 81 f9 	insert %d15,%d3,0,19,1
8000aa92:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
8000aa96:	8f 82 00 40 	sh %d4,%d2,8
8000aa9a:	59 54 0c 00 	st.w [%a5]12,%d4
8000aa9e:	6c 54       	st.w [%a5]16,%d15
8000aaa0:	00 90       	ret 
8000aaa2:	1b 1f c0 ff 	addi %d15,%d15,-1023
8000aaa6:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000aaaa:	6c 52       	st.w [%a5]8,%d15
8000aaac:	8f 82 00 20 	sh %d2,%d2,8
8000aab0:	82 3f       	mov %d15,3
8000aab2:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
8000aab6:	2c 50       	st.b [%a5]0,%d15
8000aab8:	59 52 0c 00 	st.w [%a5]12,%d2
8000aabc:	59 53 10 00 	st.w [%a5]16,%d3
8000aac0:	00 90       	ret 

8000aac2 <__pack_f>:
8000aac2:	14 45       	ld.bu %d5,[%a4]
8000aac4:	4c 43       	ld.w %d15,[%a4]12
8000aac6:	19 47 04 00 	ld.w %d7,[%a4]4
8000aaca:	ff 25 09 80 	jge.u %d5,2,8000aadc <__pack_f+0x1a>
8000aace:	37 0f f6 33 	extr.u %d3,%d15,7,22
8000aad2:	b7 f3 01 3b 	insert %d3,%d3,15,22,1
8000aad6:	3b f0 0f 40 	mov %d4,255
8000aada:	3c 4f       	j 8000ab78 <__pack_f+0xb6>
8000aadc:	3b f0 0f 40 	mov %d4,255
8000aae0:	82 03       	mov %d3,0
8000aae2:	df 45 4b 00 	jeq %d5,4,8000ab78 <__pack_f+0xb6>
8000aae6:	8b 25 00 62 	eq %d6,%d5,2
8000aaea:	8b 0f e0 64 	or.eq %d6,%d15,0
8000aaee:	82 04       	mov %d4,0
8000aaf0:	df 06 44 80 	jne %d6,0,8000ab78 <__pack_f+0xb6>
8000aaf4:	19 45 08 00 	ld.w %d5,[%a4]8
8000aaf8:	8b 25 98 42 	ge %d4,%d5,-126
8000aafc:	df 04 24 80 	jne %d4,0,8000ab44 <__pack_f+0x82>
8000ab00:	8b 25 18 51 	rsub %d5,%d5,-126
8000ab04:	8b a5 81 42 	ge %d4,%d5,26
8000ab08:	f6 4c       	jnz %d4,8000ab20 <__pack_f+0x5e>
8000ab0a:	82 12       	mov %d2,1
8000ab0c:	0f 52 00 20 	sh %d2,%d2,%d5
8000ab10:	8b 05 00 31 	rsub %d3,%d5,0
8000ab14:	c2 f2       	add %d2,-1
8000ab16:	0f 3f 00 30 	sh %d3,%d15,%d3
8000ab1a:	26 2f       	and %d15,%d2
8000ab1c:	8b 0f 00 35 	or.ne %d3,%d15,0
8000ab20:	8f f3 07 f1 	and %d15,%d3,127
8000ab24:	8b 0f 24 f2 	ne %d15,%d15,64
8000ab28:	ee 06       	jnz %d15,8000ab34 <__pack_f+0x72>
8000ab2a:	8f 03 08 f1 	and %d15,%d3,128
8000ab2e:	ab 03 04 3f 	cadd %d3,%d15,%d3,64
8000ab32:	3c 03       	j 8000ab38 <__pack_f+0x76>
8000ab34:	1b f3 03 30 	addi %d3,%d3,63
8000ab38:	7b 00 00 f4 	movh %d15,16384
8000ab3c:	0b f3 50 41 	ge.u %d4,%d3,%d15
8000ab40:	06 93       	sh %d3,-7
8000ab42:	3c 1b       	j 8000ab78 <__pack_f+0xb6>
8000ab44:	8b 05 88 62 	ge %d6,%d5,128
8000ab48:	3b f0 0f 40 	mov %d4,255
8000ab4c:	df 06 16 80 	jne %d6,0,8000ab78 <__pack_f+0xb6>
8000ab50:	8f ff 07 31 	and %d3,%d15,127
8000ab54:	8b 03 24 32 	ne %d3,%d3,64
8000ab58:	f6 36       	jnz %d3,8000ab64 <__pack_f+0xa2>
8000ab5a:	8f 0f 08 31 	and %d3,%d15,128
8000ab5e:	ab 0f 04 f3 	cadd %d15,%d3,%d15,64
8000ab62:	3c 03       	j 8000ab68 <__pack_f+0xa6>
8000ab64:	1b ff 03 f0 	addi %d15,%d15,63
8000ab68:	1b f5 07 40 	addi %d4,%d5,127
8000ab6c:	ce f4       	jgez %d15,8000ab74 <__pack_f+0xb2>
8000ab6e:	06 ff       	sh %d15,-1
8000ab70:	1b 05 08 40 	addi %d4,%d5,128
8000ab74:	8f 9f 1f 30 	sh %d3,%d15,-7
8000ab78:	82 02       	mov %d2,0
8000ab7a:	37 32 17 20 	insert %d2,%d2,%d3,0,23
8000ab7e:	37 42 88 2b 	insert %d2,%d2,%d4,23,8
8000ab82:	37 72 81 2f 	insert %d2,%d2,%d7,31,1
8000ab86:	00 90       	ret 

8000ab88 <malloc>:
8000ab88:	91 00 00 f7 	movh.a %a15,28672
8000ab8c:	99 f4 68 30 	ld.a %a4,[%a15]1256 <700004e8 <_impure_ptr>>
8000ab90:	1d 00 09 00 	j 8000aba2 <_malloc_r>

8000ab94 <free>:
8000ab94:	91 00 00 f7 	movh.a %a15,28672
8000ab98:	40 45       	mov.aa %a5,%a4
8000ab9a:	99 f4 68 30 	ld.a %a4,[%a15]1256 <700004e8 <_impure_ptr>>
8000ab9e:	1d 00 dc 12 	j 8000d156 <_free_r>

8000aba2 <_malloc_r>:
8000aba2:	1b b4 00 f0 	addi %d15,%d4,11
8000aba6:	8b 7f 61 82 	lt.u %d8,%d15,23
8000abaa:	8f 7f c0 f1 	andn %d15,%d15,7
8000abae:	ab 0f a1 88 	seln %d8,%d8,%d15,16
8000abb2:	0b 48 30 41 	lt.u %d4,%d8,%d4
8000abb6:	8b 08 20 45 	or.lt %d4,%d8,0
8000abba:	40 4d       	mov.aa %a13,%a4
8000abbc:	76 45       	jz %d4,8000abc6 <_malloc_r+0x24>
8000abbe:	da 0c       	mov %d15,12
8000abc0:	6c 40       	st.w [%a4]0,%d15
8000abc2:	1d 00 2a 02 	j 8000b016 <_malloc_r+0x474>
8000abc6:	91 00 00 f7 	movh.a %a15,28672
8000abca:	8b 88 bf f2 	ge.u %d15,%d8,504
8000abce:	6d 00 37 02 	call 8000b03c <__malloc_lock>
8000abd2:	d9 ff 20 30 	lea %a15,[%a15]224 <700000e0 <__malloc_av_>>
8000abd6:	ee 19       	jnz %d15,8000ac08 <_malloc_r+0x66>
8000abd8:	8f d8 1f 20 	sh %d2,%d8,-3
8000abdc:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000abe0:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000abe4:	7d 2c 09 80 	jne.a %a12,%a2,8000abf6 <_malloc_r+0x54>
8000abe8:	d9 c2 08 00 	lea %a2,[%a12]8
8000abec:	99 cc 14 00 	ld.a %a12,[%a12]20
8000abf0:	c2 22       	add %d2,2
8000abf2:	7d 2c 58 00 	jeq.a %a12,%a2,8000aca2 <_malloc_r+0x100>
8000abf6:	cc c3       	ld.a %a15,[%a12]12
8000abf8:	99 c2 08 00 	ld.a %a2,[%a12]8
8000abfc:	4c c1       	ld.w %d15,[%a12]4
8000abfe:	ec 23       	st.a [%a2]12,%a15
8000ac00:	8f 3f c0 f1 	andn %d15,%d15,3
8000ac04:	e8 22       	st.a [%a15]8,%a2
8000ac06:	3c 74       	j 8000acee <_malloc_r+0x14c>
8000ac08:	8f 78 1f f0 	sh %d15,%d8,-9
8000ac0c:	3b f0 03 20 	mov %d2,63
8000ac10:	6e 27       	jz %d15,8000ac5e <_malloc_r+0xbc>
8000ac12:	8f a8 1f 20 	sh %d2,%d8,-6
8000ac16:	1b 82 03 20 	addi %d2,%d2,56
8000ac1a:	bf 5f 22 80 	jlt.u %d15,5,8000ac5e <_malloc_r+0xbc>
8000ac1e:	8b 5f a1 22 	ge.u %d2,%d15,21
8000ac22:	f6 24       	jnz %d2,8000ac2a <_malloc_r+0x88>
8000ac24:	1b bf 05 20 	addi %d2,%d15,91
8000ac28:	3c 1b       	j 8000ac5e <_malloc_r+0xbc>
8000ac2a:	8b 5f a5 22 	ge.u %d2,%d15,85
8000ac2e:	f6 26       	jnz %d2,8000ac3a <_malloc_r+0x98>
8000ac30:	8f 48 1f 20 	sh %d2,%d8,-12
8000ac34:	1b e2 06 20 	addi %d2,%d2,110
8000ac38:	3c 13       	j 8000ac5e <_malloc_r+0xbc>
8000ac3a:	8b 5f b5 22 	ge.u %d2,%d15,341
8000ac3e:	f6 26       	jnz %d2,8000ac4a <_malloc_r+0xa8>
8000ac40:	8f 18 1f 20 	sh %d2,%d8,-15
8000ac44:	1b 72 07 20 	addi %d2,%d2,119
8000ac48:	3c 0b       	j 8000ac5e <_malloc_r+0xbc>
8000ac4a:	3b 50 55 30 	mov %d3,1365
8000ac4e:	3b e0 07 20 	mov %d2,126
8000ac52:	7f 3f 06 80 	jge.u %d15,%d3,8000ac5e <_malloc_r+0xbc>
8000ac56:	8f e8 1e 20 	sh %d2,%d8,-18
8000ac5a:	1b c2 07 20 	addi %d2,%d2,124
8000ac5e:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000ac62:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000ac66:	7d 2c 1d 00 	jeq.a %a12,%a2,8000aca0 <_malloc_r+0xfe>
8000ac6a:	19 c4 04 00 	ld.w %d4,[%a12]4
8000ac6e:	8f 34 c0 41 	andn %d4,%d4,3
8000ac72:	5a 84       	sub %d15,%d4,%d8
8000ac74:	8b 0f 41 32 	lt %d3,%d15,16
8000ac78:	f6 33       	jnz %d3,8000ac7e <_malloc_r+0xdc>
8000ac7a:	c2 f2       	add %d2,-1
8000ac7c:	3c 12       	j 8000aca0 <_malloc_r+0xfe>
8000ac7e:	0e fe       	jltz %d15,8000ac9a <_malloc_r+0xf8>
8000ac80:	cc c3       	ld.a %a15,[%a12]12
8000ac82:	99 c2 08 00 	ld.a %a2,[%a12]8
8000ac86:	ec 23       	st.a [%a2]12,%a15
8000ac88:	e8 22       	st.a [%a15]8,%a2
8000ac8a:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
8000ac8e:	b7 10 21 20 	imask %e2,1,0,1
8000ac92:	49 f2 44 08 	ldmst [%a15]4,%e2
8000ac96:	1d 00 cc 01 	j 8000b02e <_malloc_r+0x48c>
8000ac9a:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000ac9e:	3c e4       	j 8000ac66 <_malloc_r+0xc4>
8000aca0:	c2 12       	add %d2,1
8000aca2:	c8 4c       	ld.a %a12,[%a15]16
8000aca4:	91 00 00 37 	movh.a %a3,28672
8000aca8:	d9 33 28 30 	lea %a3,[%a3]232 <700000e8 <__malloc_av_+0x8>>
8000acac:	7d 3c 83 00 	jeq.a %a12,%a3,8000adb2 <_malloc_r+0x210>
8000acb0:	4c c1       	ld.w %d15,[%a12]4
8000acb2:	8f 3f c0 f1 	andn %d15,%d15,3
8000acb6:	52 83       	sub %d3,%d15,%d8
8000acb8:	8b 03 41 42 	lt %d4,%d3,16
8000acbc:	df 04 16 80 	jne %d4,0,8000ace8 <_malloc_r+0x146>
8000acc0:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000acc4:	8f 18 40 81 	or %d8,%d8,1
8000acc8:	59 c8 04 00 	st.w [%a12]4,%d8
8000accc:	e8 52       	st.a [%a15]20,%a2
8000acce:	e8 42       	st.a [%a15]16,%a2
8000acd0:	8f 13 40 f1 	or %d15,%d3,1
8000acd4:	b5 23 0c 00 	st.a [%a2]12,%a3
8000acd8:	b5 23 08 00 	st.a [%a2]8,%a3
8000acdc:	6c 21       	st.w [%a2]4,%d15
8000acde:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000ace2:	74 23       	st.w [%a2],%d3
8000ace4:	1d 00 a5 01 	j 8000b02e <_malloc_r+0x48c>
8000ace8:	e8 53       	st.a [%a15]20,%a3
8000acea:	e8 43       	st.a [%a15]16,%a3
8000acec:	0e 33       	jltz %d3,8000acf2 <_malloc_r+0x150>
8000acee:	10 cf       	addsc.a %a15,%a12,%d15,0
8000acf0:	3c cf       	j 8000ac8e <_malloc_r+0xec>
8000acf2:	3b 00 20 30 	mov %d3,512
8000acf6:	7f 3f 15 80 	jge.u %d15,%d3,8000ad20 <_malloc_r+0x17e>
8000acfa:	06 df       	sh %d15,-3
8000acfc:	d0 f2       	addsc.a %a2,%a15,%d15,3
8000acfe:	48 14       	ld.w %d4,[%a15]4
8000ad00:	99 24 08 00 	ld.a %a4,[%a2]8
8000ad04:	8f ef 3f 30 	sha %d3,%d15,-2
8000ad08:	b5 c2 0c 00 	st.a [%a12]12,%a2
8000ad0c:	b5 c4 08 00 	st.a [%a12]8,%a4
8000ad10:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
8000ad14:	b5 2c 08 00 	st.a [%a2]8,%a12
8000ad18:	68 13       	st.w [%a15]4,%d3
8000ad1a:	b5 4c 0c 00 	st.a [%a4]12,%a12
8000ad1e:	3c 4a       	j 8000adb2 <_malloc_r+0x210>
8000ad20:	8f af 1f 40 	sh %d4,%d15,-6
8000ad24:	8f 7f 1f 30 	sh %d3,%d15,-9
8000ad28:	1b 84 03 40 	addi %d4,%d4,56
8000ad2c:	bf 53 22 80 	jlt.u %d3,5,8000ad70 <_malloc_r+0x1ce>
8000ad30:	8b 53 a1 42 	ge.u %d4,%d3,21
8000ad34:	f6 44       	jnz %d4,8000ad3c <_malloc_r+0x19a>
8000ad36:	1b b3 05 40 	addi %d4,%d3,91
8000ad3a:	3c 1b       	j 8000ad70 <_malloc_r+0x1ce>
8000ad3c:	8b 53 a5 42 	ge.u %d4,%d3,85
8000ad40:	f6 46       	jnz %d4,8000ad4c <_malloc_r+0x1aa>
8000ad42:	8f 4f 1f 40 	sh %d4,%d15,-12
8000ad46:	1b e4 06 40 	addi %d4,%d4,110
8000ad4a:	3c 13       	j 8000ad70 <_malloc_r+0x1ce>
8000ad4c:	8b 53 b5 42 	ge.u %d4,%d3,341
8000ad50:	f6 46       	jnz %d4,8000ad5c <_malloc_r+0x1ba>
8000ad52:	8f 1f 1f 40 	sh %d4,%d15,-15
8000ad56:	1b 74 07 40 	addi %d4,%d4,119
8000ad5a:	3c 0b       	j 8000ad70 <_malloc_r+0x1ce>
8000ad5c:	3b 50 55 50 	mov %d5,1365
8000ad60:	3b e0 07 40 	mov %d4,126
8000ad64:	7f 53 06 80 	jge.u %d3,%d5,8000ad70 <_malloc_r+0x1ce>
8000ad68:	8f ef 1e 40 	sh %d4,%d15,-18
8000ad6c:	1b c4 07 40 	addi %d4,%d4,124
8000ad70:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
8000ad74:	99 42 08 00 	ld.a %a2,[%a4]8
8000ad78:	7d 42 0d 80 	jne.a %a2,%a4,8000ad92 <_malloc_r+0x1f0>
8000ad7c:	4c f1       	ld.w %d15,[%a15]4
8000ad7e:	86 e4       	sha %d4,-2
8000ad80:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
8000ad84:	40 24       	mov.aa %a4,%a2
8000ad86:	68 14       	st.w [%a15]4,%d4
8000ad88:	3c 0d       	j 8000ada2 <_malloc_r+0x200>
8000ad8a:	99 22 08 00 	ld.a %a2,[%a2]8
8000ad8e:	7d 42 08 00 	jeq.a %a2,%a4,8000ad9e <_malloc_r+0x1fc>
8000ad92:	19 23 04 00 	ld.w %d3,[%a2]4
8000ad96:	8f 33 c0 31 	andn %d3,%d3,3
8000ad9a:	3f 3f f8 ff 	jlt.u %d15,%d3,8000ad8a <_malloc_r+0x1e8>
8000ad9e:	99 24 0c 00 	ld.a %a4,[%a2]12
8000ada2:	b5 c4 0c 00 	st.a [%a12]12,%a4
8000ada6:	b5 c2 08 00 	st.a [%a12]8,%a2
8000adaa:	b5 4c 08 00 	st.a [%a4]8,%a12
8000adae:	b5 2c 0c 00 	st.a [%a2]12,%a12
8000adb2:	8f e2 3f 30 	sha %d3,%d2,-2
8000adb6:	82 1f       	mov %d15,1
8000adb8:	0f 3f 00 f0 	sh %d15,%d15,%d3
8000adbc:	48 13       	ld.w %d3,[%a15]4
8000adbe:	3f f3 73 80 	jlt.u %d3,%d15,8000aea4 <_malloc_r+0x302>
8000adc2:	0f 3f 80 40 	and %d4,%d15,%d3
8000adc6:	f6 49       	jnz %d4,8000add8 <_malloc_r+0x236>
8000adc8:	8f 32 c0 21 	andn %d2,%d2,3
8000adcc:	06 1f       	sh %d15,1
8000adce:	0f 3f 80 40 	and %d4,%d15,%d3
8000add2:	c2 42       	add %d2,4
8000add4:	df 04 fc 7f 	jeq %d4,0,8000adcc <_malloc_r+0x22a>
8000add8:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000addc:	02 24       	mov %d4,%d2
8000adde:	40 24       	mov.aa %a4,%a2
8000ade0:	99 4c 0c 00 	ld.a %a12,[%a4]12
8000ade4:	7d 4c 3c 00 	jeq.a %a12,%a4,8000ae5c <_malloc_r+0x2ba>
8000ade8:	19 c6 04 00 	ld.w %d6,[%a12]4
8000adec:	8f 36 c0 61 	andn %d6,%d6,3
8000adf0:	0b 86 80 30 	sub %d3,%d6,%d8
8000adf4:	8b 03 41 52 	lt %d5,%d3,16
8000adf8:	df 05 1d 80 	jne %d5,0,8000ae32 <_malloc_r+0x290>
8000adfc:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000ae00:	8f 18 40 81 	or %d8,%d8,1
8000ae04:	59 c8 04 00 	st.w [%a12]4,%d8
8000ae08:	99 c4 0c 00 	ld.a %a4,[%a12]12
8000ae0c:	09 c5 88 05 	ld.a %a5,[+%a12]8
8000ae10:	8f 13 40 f1 	or %d15,%d3,1
8000ae14:	b5 54 0c 00 	st.a [%a5]12,%a4
8000ae18:	b5 45 08 00 	st.a [%a4]8,%a5
8000ae1c:	e8 52       	st.a [%a15]20,%a2
8000ae1e:	e8 42       	st.a [%a15]16,%a2
8000ae20:	b5 23 0c 00 	st.a [%a2]12,%a3
8000ae24:	b5 23 08 00 	st.a [%a2]8,%a3
8000ae28:	6c 21       	st.w [%a2]4,%d15
8000ae2a:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000ae2e:	74 23       	st.w [%a2],%d3
8000ae30:	3c 0e       	j 8000ae4c <_malloc_r+0x2aa>
8000ae32:	bf 03 12 00 	jlt %d3,0,8000ae56 <_malloc_r+0x2b4>
8000ae36:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
8000ae3a:	b7 10 21 20 	imask %e2,1,0,1
8000ae3e:	49 f2 44 08 	ldmst [%a15]4,%e2
8000ae42:	cc c3       	ld.a %a15,[%a12]12
8000ae44:	09 c2 88 05 	ld.a %a2,[+%a12]8
8000ae48:	ec 23       	st.a [%a2]12,%a15
8000ae4a:	e8 22       	st.a [%a15]8,%a2
8000ae4c:	40 d4       	mov.aa %a4,%a13
8000ae4e:	6d 00 f8 00 	call 8000b03e <__malloc_unlock>
8000ae52:	1d 00 f3 00 	j 8000b038 <_malloc_r+0x496>
8000ae56:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000ae5a:	3c c5       	j 8000ade4 <_malloc_r+0x242>
8000ae5c:	c2 14       	add %d4,1
8000ae5e:	8f 34 00 31 	and %d3,%d4,3
8000ae62:	d9 44 08 00 	lea %a4,[%a4]8
8000ae66:	df 03 bd ff 	jne %d3,0,8000ade0 <_malloc_r+0x23e>
8000ae6a:	8f 32 00 31 	and %d3,%d2,3
8000ae6e:	f6 36       	jnz %d3,8000ae7a <_malloc_r+0x2d8>
8000ae70:	48 12       	ld.w %d2,[%a15]4
8000ae72:	0f f2 e0 20 	andn %d2,%d2,%d15
8000ae76:	68 12       	st.w [%a15]4,%d2
8000ae78:	3c 07       	j 8000ae86 <_malloc_r+0x2e4>
8000ae7a:	d9 24 f8 ff 	lea %a4,[%a2]-8
8000ae7e:	d4 22       	ld.a %a2,[%a2]
8000ae80:	c2 f2       	add %d2,-1
8000ae82:	7d 42 f4 7f 	jeq.a %a2,%a4,8000ae6a <_malloc_r+0x2c8>
8000ae86:	06 1f       	sh %d15,1
8000ae88:	48 12       	ld.w %d2,[%a15]4
8000ae8a:	8b 0f 20 32 	ne %d3,%d15,0
8000ae8e:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
8000ae92:	76 39       	jz %d3,8000aea4 <_malloc_r+0x302>
8000ae94:	0f 2f 80 30 	and %d3,%d15,%d2
8000ae98:	f6 34       	jnz %d3,8000aea0 <_malloc_r+0x2fe>
8000ae9a:	c2 44       	add %d4,4
8000ae9c:	06 1f       	sh %d15,1
8000ae9e:	3c fb       	j 8000ae94 <_malloc_r+0x2f2>
8000aea0:	02 42       	mov %d2,%d4
8000aea2:	3c 9b       	j 8000add8 <_malloc_r+0x236>
8000aea4:	c8 2c       	ld.a %a12,[%a15]8
8000aea6:	19 ca 04 00 	ld.w %d10,[%a12]4
8000aeaa:	8f 3a c0 a1 	andn %d10,%d10,3
8000aeae:	5a 8a       	sub %d15,%d10,%d8
8000aeb0:	8b 0f 41 22 	lt %d2,%d15,16
8000aeb4:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
8000aeb8:	df 02 b1 00 	jeq %d2,0,8000b01a <_malloc_r+0x478>
8000aebc:	91 00 00 27 	movh.a %a2,28672
8000aec0:	19 2b e0 00 	ld.w %d11,[%a2]3104 <70000c20 <__malloc_top_pad>>
8000aec4:	91 00 00 27 	movh.a %a2,28672
8000aec8:	42 8b       	add %d11,%d8
8000aeca:	19 23 18 30 	ld.w %d3,[%a2]216 <700000d8 <__malloc_sbrk_base>>
8000aece:	1b fb 00 f1 	addi %d15,%d11,4111
8000aed2:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000aed6:	1b 0b 01 20 	addi %d2,%d11,16
8000aeda:	8b f3 3f b2 	ne %d11,%d3,-1
8000aede:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
8000aee2:	40 d4       	mov.aa %a4,%a13
8000aee4:	02 b4       	mov %d4,%d11
8000aee6:	80 2c       	mov.d %d12,%a2
8000aee8:	6d 00 ac 00 	call 8000b040 <_sbrk_r>
8000aeec:	80 29       	mov.d %d9,%a2
8000aeee:	df f9 86 00 	jeq %d9,-1,8000affa <_malloc_r+0x458>
8000aef2:	80 c2       	mov.d %d2,%a12
8000aef4:	80 c3       	mov.d %d3,%a12
8000aef6:	42 a2       	add %d2,%d10
8000aef8:	80 f4       	mov.d %d4,%a15
8000aefa:	0b 29 30 f1 	lt.u %d15,%d9,%d2
8000aefe:	0b 43 10 f2 	and.ne %d15,%d3,%d4
8000af02:	01 fc 10 d4 	ne.a %d13,%a12,%a15
8000af06:	ee 7a       	jnz %d15,8000affa <_malloc_r+0x458>
8000af08:	91 00 00 e7 	movh.a %a14,28672
8000af0c:	19 e3 b0 f0 	ld.w %d3,[%a14]3056 <70000bf0 <__malloc_current_mallinfo>>
8000af10:	42 b3       	add %d3,%d11
8000af12:	59 e3 b0 f0 	st.w [%a14]3056 <70000bf0 <__malloc_current_mallinfo>>,%d3
8000af16:	5f 29 0c 80 	jne %d9,%d2,8000af2e <_malloc_r+0x38c>
8000af1a:	b7 09 14 f6 	insert %d15,%d9,0,12,20
8000af1e:	ee 08       	jnz %d15,8000af2e <_malloc_r+0x38c>
8000af20:	c8 22       	ld.a %a2,[%a15]8
8000af22:	42 ba       	add %d10,%d11
8000af24:	8f 1a 40 a1 	or %d10,%d10,1
8000af28:	59 2a 04 00 	st.w [%a2]4,%d10
8000af2c:	3c 55       	j 8000afd6 <_malloc_r+0x434>
8000af2e:	60 c2       	mov.a %a2,%d12
8000af30:	19 2f 18 30 	ld.w %d15,[%a2]216
8000af34:	5e f6       	jne %d15,-1,8000af40 <_malloc_r+0x39e>
8000af36:	91 00 00 27 	movh.a %a2,28672
8000af3a:	59 29 18 30 	st.w [%a2]216 <700000d8 <__malloc_sbrk_base>>,%d9
8000af3e:	3c 06       	j 8000af4a <_malloc_r+0x3a8>
8000af40:	0b 29 80 20 	sub %d2,%d9,%d2
8000af44:	42 23       	add %d3,%d2
8000af46:	59 e3 b0 f0 	st.w [%a14]3056 <70000bf0 <__malloc_current_mallinfo>>,%d3
8000af4a:	8f 79 00 21 	and %d2,%d9,7
8000af4e:	82 0f       	mov %d15,0
8000af50:	76 24       	jz %d2,8000af58 <_malloc_r+0x3b6>
8000af52:	8b 82 00 f1 	rsub %d15,%d2,8
8000af56:	42 f9       	add %d9,%d15
8000af58:	42 9b       	add %d11,%d9
8000af5a:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
8000af5e:	1b 0f 00 21 	addi %d2,%d15,4096
8000af62:	5a b2       	sub %d15,%d2,%d11
8000af64:	40 d4       	mov.aa %a4,%a13
8000af66:	02 f4       	mov %d4,%d15
8000af68:	6d 00 6c 00 	call 8000b040 <_sbrk_r>
8000af6c:	80 22       	mov.d %d2,%a2
8000af6e:	df f2 04 80 	jne %d2,-1,8000af76 <_malloc_r+0x3d4>
8000af72:	60 92       	mov.a %a2,%d9
8000af74:	82 0f       	mov %d15,0
8000af76:	80 2b       	mov.d %d11,%a2
8000af78:	19 e2 b0 f0 	ld.w %d2,[%a14]3056 <70000bf0 <__malloc_current_mallinfo>>
8000af7c:	a2 9b       	sub %d11,%d9
8000af7e:	42 f2       	add %d2,%d15
8000af80:	60 92       	mov.a %a2,%d9
8000af82:	42 bf       	add %d15,%d11
8000af84:	68 29       	st.w [%a15]8,%d9
8000af86:	8f 1f 40 31 	or %d3,%d15,1
8000af8a:	59 e2 b0 f0 	st.w [%a14]3056 <70000bf0 <__malloc_current_mallinfo>>,%d2
8000af8e:	59 23 04 00 	st.w [%a2]4 <70000bf0 <__malloc_current_mallinfo>>,%d3
8000af92:	df 0d 22 00 	jeq %d13,0,8000afd6 <_malloc_r+0x434>
8000af96:	8b 0a a1 f2 	ge.u %d15,%d10,16
8000af9a:	ee 05       	jnz %d15,8000afa4 <_malloc_r+0x402>
8000af9c:	82 12       	mov %d2,1
8000af9e:	59 22 04 00 	st.w [%a2]4,%d2
8000afa2:	3c 2c       	j 8000affa <_malloc_r+0x458>
8000afa4:	1b 4a ff af 	addi %d10,%d10,-12
8000afa8:	8f 7a c0 f1 	andn %d15,%d10,7
8000afac:	10 c2       	addsc.a %a2,%a12,%d15,0
8000afae:	82 52       	mov %d2,5
8000afb0:	59 22 04 00 	st.w [%a2]4,%d2
8000afb4:	59 22 08 00 	st.w [%a2]8,%d2
8000afb8:	19 c2 04 00 	ld.w %d2,[%a12]4
8000afbc:	8f 12 00 21 	and %d2,%d2,1
8000afc0:	a6 f2       	or %d2,%d15
8000afc2:	59 c2 04 00 	st.w [%a12]4,%d2
8000afc6:	8b 0f 61 f2 	lt.u %d15,%d15,16
8000afca:	ee 06       	jnz %d15,8000afd6 <_malloc_r+0x434>
8000afcc:	40 d4       	mov.aa %a4,%a13
8000afce:	d9 c5 08 00 	lea %a5,[%a12]8
8000afd2:	6d 00 c2 10 	call 8000d156 <_free_r>
8000afd6:	91 00 00 27 	movh.a %a2,28672
8000afda:	19 ef b0 f0 	ld.w %d15,[%a14]3056 <70000bf0 <__malloc_current_mallinfo>>
8000afde:	19 22 dc 00 	ld.w %d2,[%a2]3100 <70000c1c <__malloc_max_sbrked_mem>>
8000afe2:	7f f2 04 80 	jge.u %d2,%d15,8000afea <_malloc_r+0x448>
8000afe6:	59 2f dc 00 	st.w [%a2]3100 <70000c1c <__malloc_max_sbrked_mem>>,%d15
8000afea:	91 00 00 27 	movh.a %a2,28672
8000afee:	19 22 d8 00 	ld.w %d2,[%a2]3096 <70000c18 <__malloc_max_total_mem>>
8000aff2:	7f f2 04 80 	jge.u %d2,%d15,8000affa <_malloc_r+0x458>
8000aff6:	59 2f d8 00 	st.w [%a2]3096 <70000c18 <__malloc_max_total_mem>>,%d15
8000affa:	c8 22       	ld.a %a2,[%a15]8
8000affc:	19 22 04 00 	ld.w %d2,[%a2]4 <70000c18 <__malloc_max_total_mem>>
8000b000:	8f 32 c0 21 	andn %d2,%d2,3
8000b004:	5a 82       	sub %d15,%d2,%d8
8000b006:	8b 0f 41 32 	lt %d3,%d15,16
8000b00a:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
8000b00e:	76 36       	jz %d3,8000b01a <_malloc_r+0x478>
8000b010:	40 d4       	mov.aa %a4,%a13
8000b012:	6d 00 16 00 	call 8000b03e <__malloc_unlock>
8000b016:	a0 0c       	mov.a %a12,0
8000b018:	3c 10       	j 8000b038 <_malloc_r+0x496>
8000b01a:	c8 2c       	ld.a %a12,[%a15]8
8000b01c:	8f 18 40 21 	or %d2,%d8,1
8000b020:	96 01       	or %d15,1
8000b022:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000b026:	59 c2 04 00 	st.w [%a12]4,%d2
8000b02a:	e8 22       	st.a [%a15]8,%a2
8000b02c:	6c 21       	st.w [%a2]4,%d15
8000b02e:	40 d4       	mov.aa %a4,%a13
8000b030:	6d 00 07 00 	call 8000b03e <__malloc_unlock>
8000b034:	d9 cc 08 00 	lea %a12,[%a12]8
8000b038:	40 c2       	mov.aa %a2,%a12
8000b03a:	00 90       	ret 

8000b03c <__malloc_lock>:
8000b03c:	00 90       	ret 

8000b03e <__malloc_unlock>:
8000b03e:	00 90       	ret 

8000b040 <_sbrk_r>:
8000b040:	82 0f       	mov %d15,0
8000b042:	91 00 00 c7 	movh.a %a12,28672
8000b046:	59 cf e8 00 	st.w [%a12]3112 <70000c28 <errno>>,%d15
8000b04a:	40 4f       	mov.aa %a15,%a4
8000b04c:	6d 00 47 17 	call 8000deda <sbrk>
8000b050:	80 2f       	mov.d %d15,%a2
8000b052:	5e f5       	jne %d15,-1,8000b05c <_sbrk_r+0x1c>
8000b054:	19 cf e8 00 	ld.w %d15,[%a12]3112 <70000c28 <errno>>
8000b058:	6e 02       	jz %d15,8000b05c <_sbrk_r+0x1c>
8000b05a:	68 0f       	st.w [%a15]0,%d15
8000b05c:	00 90       	ret 

8000b05e <sprintf>:
8000b05e:	20 68       	sub.a %sp,104
8000b060:	3b 80 20 f0 	mov %d15,520
8000b064:	91 00 00 f7 	movh.a %a15,28672
8000b068:	ac a6       	st.h [%sp]12,%d15
8000b06a:	f4 a4       	st.a [%sp],%a4
8000b06c:	b5 a4 10 00 	st.a [%sp]16,%a4
8000b070:	82 ff       	mov %d15,-1
8000b072:	99 f4 68 30 	ld.a %a4,[%a15]1256 <700004e8 <_impure_ptr>>
8000b076:	06 ff       	sh %d15,-1
8000b078:	40 56       	mov.aa %a6,%a5
8000b07a:	78 02       	st.w [%sp]8,%d15
8000b07c:	78 05       	st.w [%sp]20,%d15
8000b07e:	40 a5       	mov.aa %a5,%sp
8000b080:	82 ff       	mov %d15,-1
8000b082:	d9 a7 28 10 	lea %a7,[%sp]104
8000b086:	ac a7       	st.h [%sp]14,%d15
8000b088:	6d 00 10 00 	call 8000b0a8 <_svfprintf_r>
8000b08c:	d8 00       	ld.a %a15,[%sp]0
8000b08e:	82 0f       	mov %d15,0
8000b090:	28 0f       	st.b [%a15]0,%d15
8000b092:	00 90       	ret 

8000b094 <strlen>:
8000b094:	80 42       	mov.d %d2,%a4
8000b096:	80 4f       	mov.d %d15,%a4
8000b098:	60 ff       	mov.a %a15,%d15
8000b09a:	79 f3 00 00 	ld.b %d3,[%a15]0
8000b09e:	76 33       	jz %d3,8000b0a4 <strlen+0x10>
8000b0a0:	c2 1f       	add %d15,1
8000b0a2:	3c fb       	j 8000b098 <strlen+0x4>
8000b0a4:	52 22       	sub %d2,%d15,%d2
8000b0a6:	00 90       	ret 

8000b0a8 <_svfprintf_r>:
8000b0a8:	20 d0       	sub.a %sp,208
8000b0aa:	80 5b       	mov.d %d11,%a5
8000b0ac:	80 4c       	mov.d %d12,%a4
8000b0ae:	b5 a6 18 00 	st.a [%sp]24,%a6
8000b0b2:	40 7f       	mov.aa %a15,%a7
8000b0b4:	6d 00 27 11 	call 8000d302 <_localeconv_r>
8000b0b8:	d4 22       	ld.a %a2,[%a2]
8000b0ba:	40 24       	mov.aa %a4,%a2
8000b0bc:	b5 a2 34 00 	st.a [%sp]52,%a2
8000b0c0:	6d ff ea ff 	call 8000b094 <strlen>
8000b0c4:	60 b2       	mov.a %a2,%d11
8000b0c6:	59 a2 20 00 	st.w [%sp]32,%d2
8000b0ca:	8c 26       	ld.h %d15,[%a2]12
8000b0cc:	6f 7f 16 00 	jz.t %d15,7,8000b0f8 <_svfprintf_r+0x50>
8000b0d0:	4c 24       	ld.w %d15,[%a2]16
8000b0d2:	ee 13       	jnz %d15,8000b0f8 <_svfprintf_r+0x50>
8000b0d4:	60 c4       	mov.a %a4,%d12
8000b0d6:	3b 00 04 40 	mov %d4,64
8000b0da:	6d ff 64 fd 	call 8000aba2 <_malloc_r>
8000b0de:	60 b3       	mov.a %a3,%d11
8000b0e0:	f4 32       	st.a [%a3],%a2
8000b0e2:	b5 32 10 00 	st.a [%a3]16,%a2
8000b0e6:	7c 26       	jnz.a %a2,8000b0f2 <_svfprintf_r+0x4a>
8000b0e8:	60 cf       	mov.a %a15,%d12
8000b0ea:	da 0c       	mov %d15,12
8000b0ec:	68 0f       	st.w [%a15]0,%d15
8000b0ee:	82 f2       	mov %d2,-1
8000b0f0:	00 90       	ret 
8000b0f2:	60 b2       	mov.a %a2,%d11
8000b0f4:	da 40       	mov %d15,64
8000b0f6:	6c 25       	st.w [%a2]20,%d15
8000b0f8:	82 0f       	mov %d15,0
8000b0fa:	d9 a2 10 20 	lea %a2,[%sp]144
8000b0fe:	a0 03       	mov.a %a3,0
8000b100:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000b104:	78 19       	st.w [%sp]100,%d15
8000b106:	78 18       	st.w [%sp]96,%d15
8000b108:	78 05       	st.w [%sp]20,%d15
8000b10a:	78 0b       	st.w [%sp]44,%d15
8000b10c:	78 0c       	st.w [%sp]48,%d15
8000b10e:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000b112:	78 0e       	st.w [%sp]56,%d15
8000b114:	78 0a       	st.w [%sp]40,%d15
8000b116:	40 2e       	mov.aa %a14,%a2
8000b118:	99 ac 18 00 	ld.a %a12,[%sp]24
8000b11c:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b120:	8b 0f 20 32 	ne %d3,%d15,0
8000b124:	8b 5f 22 34 	and.ne %d3,%d15,37
8000b128:	76 33       	jz %d3,8000b12e <_svfprintf_r+0x86>
8000b12a:	b0 1c       	add.a %a12,1
8000b12c:	3c f8       	j 8000b11c <_svfprintf_r+0x74>
8000b12e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b132:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000b136:	80 3f       	mov.d %d15,%a3
8000b138:	6e 23       	jz %d15,8000b17e <_svfprintf_r+0xd6>
8000b13a:	19 a3 24 10 	ld.w %d3,[%sp]100
8000b13e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b142:	42 f3       	add %d3,%d15
8000b144:	59 a3 24 10 	st.w [%sp]100,%d3
8000b148:	19 a3 20 10 	ld.w %d3,[%sp]96
8000b14c:	f4 e3       	st.a [%a14],%a3
8000b14e:	c2 13       	add %d3,1
8000b150:	6c e1       	st.w [%a14]4,%d15
8000b152:	59 a3 20 10 	st.w [%sp]96,%d3
8000b156:	8b 83 80 32 	ge %d3,%d3,8
8000b15a:	d9 ee 08 00 	lea %a14,[%a14]8
8000b15e:	76 3b       	jz %d3,8000b174 <_svfprintf_r+0xcc>
8000b160:	60 c4       	mov.a %a4,%d12
8000b162:	60 b5       	mov.a %a5,%d11
8000b164:	d9 a6 1c 10 	lea %a6,[%sp]92
8000b168:	6d 00 e0 13 	call 8000d928 <__ssprint_r>
8000b16c:	df 02 69 88 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000b170:	d9 ae 10 20 	lea %a14,[%sp]144
8000b174:	19 a2 28 00 	ld.w %d2,[%sp]40
8000b178:	42 f2       	add %d2,%d15
8000b17a:	59 a2 28 00 	st.w [%sp]40,%d2
8000b17e:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b182:	df 0f 56 08 	jeq %d15,0,8000c22e <_svfprintf_r+0x1186>
8000b186:	82 0f       	mov %d15,0
8000b188:	82 02       	mov %d2,0
8000b18a:	e9 af 01 10 	st.b [%sp]65,%d15
8000b18e:	d9 c2 01 00 	lea %a2,[%a12]1
8000b192:	82 0f       	mov %d15,0
8000b194:	82 fe       	mov %d14,-1
8000b196:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b19a:	82 0a       	mov %d10,0
8000b19c:	79 22 00 00 	ld.b %d2,[%a2]0
8000b1a0:	d9 23 01 00 	lea %a3,[%a2]1
8000b1a4:	b5 a3 18 00 	st.a [%sp]24,%a3
8000b1a8:	59 a2 10 00 	st.w [%sp]16,%d2
8000b1ac:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b1b0:	1b 02 fe 3f 	addi %d3,%d2,-32
8000b1b4:	8b 93 a5 42 	ge.u %d4,%d3,89
8000b1b8:	df 04 19 84 	jne %d4,0,8000b9ea <_svfprintf_r+0x942>
8000b1bc:	91 10 00 28 	movh.a %a2,32769
8000b1c0:	d9 22 0c 7b 	lea %a2,[%a2]-20020 <8000b1cc <_svfprintf_r+0x124>>
8000b1c4:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000b1c8:	dc 07       	ji %a7
8000b1ca:	00 00       	nop 
8000b1cc:	1d 00 c3 00 	j 8000b352 <_svfprintf_r+0x2aa>
8000b1d0:	1d 00 0d 04 	j 8000b9ea <_svfprintf_r+0x942>
8000b1d4:	1d 00 0b 04 	j 8000b9ea <_svfprintf_r+0x942>
8000b1d8:	1d 00 c0 00 	j 8000b358 <_svfprintf_r+0x2b0>
8000b1dc:	1d 00 07 04 	j 8000b9ea <_svfprintf_r+0x942>
8000b1e0:	1d 00 05 04 	j 8000b9ea <_svfprintf_r+0x942>
8000b1e4:	1d 00 03 04 	j 8000b9ea <_svfprintf_r+0x942>
8000b1e8:	1d 00 01 04 	j 8000b9ea <_svfprintf_r+0x942>
8000b1ec:	1d 00 ff 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b1f0:	1d 00 fd 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b1f4:	1d 00 b5 00 	j 8000b35e <_svfprintf_r+0x2b6>
8000b1f8:	1d 00 9c 00 	j 8000b330 <_svfprintf_r+0x288>
8000b1fc:	1d 00 f7 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b200:	1d 00 b8 00 	j 8000b370 <_svfprintf_r+0x2c8>
8000b204:	1d 00 b9 00 	j 8000b376 <_svfprintf_r+0x2ce>
8000b208:	1d 00 f1 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b20c:	1d 00 de 00 	j 8000b3c8 <_svfprintf_r+0x320>
8000b210:	1d 00 df 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b214:	1d 00 dd 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b218:	1d 00 db 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b21c:	1d 00 d9 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b220:	1d 00 d7 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b224:	1d 00 d5 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b228:	1d 00 d3 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b22c:	1d 00 d1 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b230:	1d 00 cf 00 	j 8000b3ce <_svfprintf_r+0x326>
8000b234:	1d 00 db 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b238:	1d 00 d9 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b23c:	1d 00 d7 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b240:	1d 00 d5 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b244:	1d 00 d3 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b248:	1d 00 d1 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b24c:	1d 00 cf 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b250:	1d 00 cd 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b254:	1d 00 cb 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b258:	1d 00 c9 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b25c:	1d 00 f9 00 	j 8000b44e <_svfprintf_r+0x3a6>
8000b260:	1d 00 21 01 	j 8000b4a2 <_svfprintf_r+0x3fa>
8000b264:	1d 00 c3 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b268:	1d 00 1d 01 	j 8000b4a2 <_svfprintf_r+0x3fa>
8000b26c:	1d 00 bf 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b270:	1d 00 bd 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b274:	1d 00 bb 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b278:	1d 00 b9 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b27c:	1d 00 c6 00 	j 8000b408 <_svfprintf_r+0x360>
8000b280:	1d 00 b5 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b284:	1d 00 b3 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b288:	1d 00 92 02 	j 8000b7ac <_svfprintf_r+0x704>
8000b28c:	1d 00 af 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b290:	1d 00 ad 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b294:	1d 00 ab 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b298:	1d 00 a9 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b29c:	1d 00 a7 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2a0:	1d 00 d0 02 	j 8000b840 <_svfprintf_r+0x798>
8000b2a4:	1d 00 a3 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2a8:	1d 00 a1 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2ac:	1d 00 4b 00 	j 8000b342 <_svfprintf_r+0x29a>
8000b2b0:	1d 00 9d 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2b4:	1d 00 9b 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2b8:	1d 00 99 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2bc:	1d 00 97 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2c0:	1d 00 95 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2c4:	1d 00 93 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2c8:	1d 00 91 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2cc:	1d 00 8f 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2d0:	1d 00 8d 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2d4:	1d 00 8b 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2d8:	1d 00 b0 00 	j 8000b438 <_svfprintf_r+0x390>
8000b2dc:	1d 00 2f 00 	j 8000b33a <_svfprintf_r+0x292>
8000b2e0:	1d 00 e1 00 	j 8000b4a2 <_svfprintf_r+0x3fa>
8000b2e4:	1d 00 df 00 	j 8000b4a2 <_svfprintf_r+0x3fa>
8000b2e8:	1d 00 dd 00 	j 8000b4a2 <_svfprintf_r+0x3fa>
8000b2ec:	1d 00 91 00 	j 8000b40e <_svfprintf_r+0x366>
8000b2f0:	1d 00 25 00 	j 8000b33a <_svfprintf_r+0x292>
8000b2f4:	1d 00 7b 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2f8:	1d 00 79 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b2fc:	1d 00 8c 00 	j 8000b414 <_svfprintf_r+0x36c>
8000b300:	1d 00 75 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b304:	1d 00 39 02 	j 8000b776 <_svfprintf_r+0x6ce>
8000b308:	1d 00 54 02 	j 8000b7b0 <_svfprintf_r+0x708>
8000b30c:	1d 00 66 02 	j 8000b7d8 <_svfprintf_r+0x730>
8000b310:	1d 00 90 00 	j 8000b430 <_svfprintf_r+0x388>
8000b314:	1d 00 6b 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b318:	1d 00 77 02 	j 8000b806 <_svfprintf_r+0x75e>
8000b31c:	1d 00 67 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b320:	1d 00 92 02 	j 8000b844 <_svfprintf_r+0x79c>
8000b324:	1d 00 63 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b328:	1d 00 61 03 	j 8000b9ea <_svfprintf_r+0x942>
8000b32c:	1d 00 a0 02 	j 8000b86c <_svfprintf_r+0x7c4>
8000b330:	da 2b       	mov %d15,43
8000b332:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b336:	1d ff 33 ff 	j 8000b19c <_svfprintf_r+0xf4>
8000b33a:	e9 af 01 10 	st.b [%sp]65,%d15
8000b33e:	1d 00 8c 00 	j 8000b456 <_svfprintf_r+0x3ae>
8000b342:	e9 af 01 10 	st.b [%sp]65,%d15
8000b346:	7b 00 00 f8 	movh %d15,32768
8000b34a:	1b cf d9 f0 	addi %d15,%d15,3484
8000b34e:	1d 00 95 02 	j 8000b878 <_svfprintf_r+0x7d0>
8000b352:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000b356:	3c ee       	j 8000b332 <_svfprintf_r+0x28a>
8000b358:	8f 1a 40 a1 	or %d10,%d10,1
8000b35c:	3c eb       	j 8000b332 <_svfprintf_r+0x28a>
8000b35e:	48 02       	ld.w %d2,[%a15]0
8000b360:	b0 4f       	add.a %a15,4
8000b362:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b366:	ff 02 e6 7f 	jge %d2,0,8000b332 <_svfprintf_r+0x28a>
8000b36a:	32 52       	rsub %d2
8000b36c:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b370:	8f 4a 40 a1 	or %d10,%d10,4
8000b374:	3c df       	j 8000b332 <_svfprintf_r+0x28a>
8000b376:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b37a:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b37e:	79 32 00 00 	ld.b %d2,[%a3]0
8000b382:	b0 12       	add.a %a2,1
8000b384:	59 a2 10 00 	st.w [%sp]16,%d2
8000b388:	8b a2 02 32 	eq %d3,%d2,42
8000b38c:	f6 33       	jnz %d3,8000b392 <_svfprintf_r+0x2ea>
8000b38e:	82 05       	mov %d5,0
8000b390:	3c 08       	j 8000b3a0 <_svfprintf_r+0x2f8>
8000b392:	48 0e       	ld.w %d14,[%a15]0
8000b394:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b398:	b0 4f       	add.a %a15,4
8000b39a:	8b fe 5f e3 	max %d14,%d14,-1
8000b39e:	3c ca       	j 8000b332 <_svfprintf_r+0x28a>
8000b3a0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b3a4:	1b 02 fd 3f 	addi %d3,%d2,-48
8000b3a8:	ff a3 0a 80 	jge.u %d3,10,8000b3bc <_svfprintf_r+0x314>
8000b3ac:	79 22 00 00 	ld.b %d2,[%a2]0
8000b3b0:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000b3b4:	59 a2 10 00 	st.w [%sp]16,%d2
8000b3b8:	b0 12       	add.a %a2,1
8000b3ba:	3c f3       	j 8000b3a0 <_svfprintf_r+0x2f8>
8000b3bc:	8b f5 5f e3 	max %d14,%d5,-1
8000b3c0:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b3c4:	1d ff f4 fe 	j 8000b1ac <_svfprintf_r+0x104>
8000b3c8:	8f 0a 48 a1 	or %d10,%d10,128
8000b3cc:	3c b3       	j 8000b332 <_svfprintf_r+0x28a>
8000b3ce:	82 02       	mov %d2,0
8000b3d0:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b3d4:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b3d8:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b3dc:	1b 02 fd 4f 	addi %d4,%d2,-48
8000b3e0:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000b3e4:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b3e8:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000b3ec:	b0 12       	add.a %a2,1
8000b3ee:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b3f2:	79 32 00 00 	ld.b %d2,[%a3]0
8000b3f6:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b3fa:	59 a2 10 00 	st.w [%sp]16,%d2
8000b3fe:	1b 02 fd 4f 	addi %d4,%d2,-48
8000b402:	bf a4 e9 ff 	jlt.u %d4,10,8000b3d4 <_svfprintf_r+0x32c>
8000b406:	3c dd       	j 8000b3c0 <_svfprintf_r+0x318>
8000b408:	8f 8a 40 a1 	or %d10,%d10,8
8000b40c:	3c 93       	j 8000b332 <_svfprintf_r+0x28a>
8000b40e:	8f 0a 44 a1 	or %d10,%d10,64
8000b412:	3c 90       	j 8000b332 <_svfprintf_r+0x28a>
8000b414:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b418:	79 33 00 00 	ld.b %d3,[%a3]0
8000b41c:	8b c3 26 32 	ne %d3,%d3,108
8000b420:	f6 35       	jnz %d3,8000b42a <_svfprintf_r+0x382>
8000b422:	b0 13       	add.a %a3,1
8000b424:	b5 a3 18 00 	st.a [%sp]24,%a3
8000b428:	3c 04       	j 8000b430 <_svfprintf_r+0x388>
8000b42a:	8f 0a 41 a1 	or %d10,%d10,16
8000b42e:	3c 82       	j 8000b332 <_svfprintf_r+0x28a>
8000b430:	8f 0a 42 a1 	or %d10,%d10,32
8000b434:	1d ff 7f ff 	j 8000b332 <_svfprintf_r+0x28a>
8000b438:	48 03       	ld.w %d3,[%a15]0
8000b43a:	d9 fc 04 00 	lea %a12,[%a15]4
8000b43e:	e9 a3 28 10 	st.b [%sp]104,%d3
8000b442:	82 03       	mov %d3,0
8000b444:	e9 a3 01 10 	st.b [%sp]65,%d3
8000b448:	60 ad       	mov.a %a13,%d10
8000b44a:	1d 00 dc 02 	j 8000ba02 <_svfprintf_r+0x95a>
8000b44e:	e9 af 01 10 	st.b [%sp]65,%d15
8000b452:	8f 0a 41 a1 	or %d10,%d10,16
8000b456:	60 ad       	mov.a %a13,%d10
8000b458:	6f 5a 07 00 	jz.t %d10,5,8000b466 <_svfprintf_r+0x3be>
8000b45c:	d9 fc 08 00 	lea %a12,[%a15]8
8000b460:	09 f8 40 09 	ld.d %e8,[%a15]
8000b464:	3c 12       	j 8000b488 <_svfprintf_r+0x3e0>
8000b466:	d9 f2 04 00 	lea %a2,[%a15]4
8000b46a:	6f 4a 05 00 	jz.t %d10,4,8000b474 <_svfprintf_r+0x3cc>
8000b46e:	40 2c       	mov.aa %a12,%a2
8000b470:	48 08       	ld.w %d8,[%a15]0
8000b472:	3c 09       	j 8000b484 <_svfprintf_r+0x3dc>
8000b474:	48 03       	ld.w %d3,[%a15]0
8000b476:	40 2c       	mov.aa %a12,%a2
8000b478:	0b 30 00 88 	mov %e8,%d3
8000b47c:	6f 6a 06 00 	jz.t %d10,6,8000b488 <_svfprintf_r+0x3e0>
8000b480:	37 03 50 80 	extr %d8,%d3,0,16
8000b484:	0b 80 00 88 	mov %e8,%d8
8000b488:	82 13       	mov %d3,1
8000b48a:	ff 09 1d 02 	jge %d9,0,8000b8c4 <_svfprintf_r+0x81c>
8000b48e:	32 59       	rsub %d9
8000b490:	32 58       	rsub %d8
8000b492:	3b d0 02 70 	mov %d7,45
8000b496:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000b49a:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b49e:	1d 00 13 02 	j 8000b8c4 <_svfprintf_r+0x81c>
8000b4a2:	e9 af 01 10 	st.b [%sp]65,%d15
8000b4a6:	4c f0       	ld.w %d15,[%a15]0
8000b4a8:	d9 fc 08 00 	lea %a12,[%a15]8
8000b4ac:	78 0b       	st.w [%sp]44,%d15
8000b4ae:	4c f1       	ld.w %d15,[%a15]4
8000b4b0:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000b4b4:	78 0c       	st.w [%sp]48,%d15
8000b4b6:	19 a5 30 00 	ld.w %d5,[%sp]48
8000b4ba:	6d 00 16 12 	call 8000d8e6 <__fpclassifyd>
8000b4be:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000b4c2:	19 a5 30 00 	ld.w %d5,[%sp]48
8000b4c6:	df 12 18 80 	jne %d2,1,8000b4f6 <_svfprintf_r+0x44e>
8000b4ca:	d2 06       	mov %e6,0
8000b4cc:	6d 00 b3 15 	call 8000e032 <__ltdf2>
8000b4d0:	ce 25       	jgez %d2,8000b4da <_svfprintf_r+0x432>
8000b4d2:	3b d0 02 30 	mov %d3,45
8000b4d6:	e9 a3 01 10 	st.b [%sp]65,%d3
8000b4da:	58 04       	ld.w %d15,[%sp]16
8000b4dc:	7b 00 00 78 	movh %d7,32768
8000b4e0:	8b 8f 84 32 	ge %d3,%d15,72
8000b4e4:	1b 07 d9 d0 	addi %d13,%d7,3472
8000b4e8:	df 03 17 80 	jne %d3,0,8000b516 <_svfprintf_r+0x46e>
8000b4ec:	7b 00 00 78 	movh %d7,32768
8000b4f0:	1b c7 d8 d0 	addi %d13,%d7,3468
8000b4f4:	3c 11       	j 8000b516 <_svfprintf_r+0x46e>
8000b4f6:	6d 00 f8 11 	call 8000d8e6 <__fpclassifyd>
8000b4fa:	58 04       	ld.w %d15,[%sp]16
8000b4fc:	df 02 13 80 	jne %d2,0,8000b522 <_svfprintf_r+0x47a>
8000b500:	7b 00 00 78 	movh %d7,32768
8000b504:	8b 8f 84 32 	ge %d3,%d15,72
8000b508:	1b 87 d9 d0 	addi %d13,%d7,3480
8000b50c:	f6 35       	jnz %d3,8000b516 <_svfprintf_r+0x46e>
8000b50e:	7b 00 00 78 	movh %d7,32768
8000b512:	1b 47 d9 d0 	addi %d13,%d7,3476
8000b516:	8f 0a c8 a1 	andn %d10,%d10,128
8000b51a:	60 ad       	mov.a %a13,%d10
8000b51c:	82 39       	mov %d9,3
8000b51e:	1d 00 78 02 	j 8000ba0e <_svfprintf_r+0x966>
8000b522:	8f 0f c2 f1 	andn %d15,%d15,32
8000b526:	78 01       	st.w [%sp]4,%d15
8000b528:	df fe 09 00 	jeq %d14,-1,8000b53a <_svfprintf_r+0x492>
8000b52c:	8b 0e 00 72 	eq %d7,%d14,0
8000b530:	8b 7f 04 74 	and.eq %d7,%d15,71
8000b534:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000b538:	3c 02       	j 8000b53c <_svfprintf_r+0x494>
8000b53a:	82 6e       	mov %d14,6
8000b53c:	19 a3 30 00 	ld.w %d3,[%sp]48
8000b540:	8f 0a 50 21 	or %d2,%d10,256
8000b544:	60 2d       	mov.a %a13,%d2
8000b546:	d8 0b       	ld.a %a15,[%sp]44
8000b548:	82 0f       	mov %d15,0
8000b54a:	ce 34       	jgez %d3,8000b552 <_svfprintf_r+0x4aa>
8000b54c:	9b 03 00 38 	addih %d3,%d3,32768
8000b550:	da 2d       	mov %d15,45
8000b552:	78 09       	st.w [%sp]36,%d15
8000b554:	58 01       	ld.w %d15,[%sp]4
8000b556:	02 e9       	mov %d9,%d14
8000b558:	8b 6f 04 22 	eq %d2,%d15,70
8000b55c:	82 36       	mov %d6,3
8000b55e:	f6 28       	jnz %d2,8000b56e <_svfprintf_r+0x4c6>
8000b560:	8b 5f 24 12 	ne %d1,%d15,69
8000b564:	1b 1e 00 50 	addi %d5,%d14,1
8000b568:	82 26       	mov %d6,2
8000b56a:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000b56e:	60 c4       	mov.a %a4,%d12
8000b570:	80 f4       	mov.d %d4,%a15
8000b572:	02 35       	mov %d5,%d3
8000b574:	02 97       	mov %d7,%d9
8000b576:	d9 a5 04 10 	lea %a5,[%sp]68
8000b57a:	d9 a6 08 10 	lea %a6,[%sp]72
8000b57e:	d9 a7 14 10 	lea %a7,[%sp]84
8000b582:	59 a2 0c 00 	st.w [%sp]12,%d2
8000b586:	59 a3 08 00 	st.w [%sp]8,%d3
8000b58a:	6d 00 1f 07 	call 8000c3c8 <_dtoa_r>
8000b58e:	58 01       	ld.w %d15,[%sp]4
8000b590:	80 2d       	mov.d %d13,%a2
8000b592:	8b 7f 24 12 	ne %d1,%d15,71
8000b596:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000b59a:	19 a3 08 00 	ld.w %d3,[%sp]8
8000b59e:	df 01 11 80 	jne %d1,0,8000b5c0 <_svfprintf_r+0x518>
8000b5a2:	6f 0a 0f 80 	jnz.t %d10,0,8000b5c0 <_svfprintf_r+0x518>
8000b5a6:	19 a2 14 10 	ld.w %d2,[%sp]84
8000b5aa:	58 01       	ld.w %d15,[%sp]4
8000b5ac:	a2 d2       	sub %d2,%d13
8000b5ae:	59 a2 14 00 	st.w [%sp]20,%d2
8000b5b2:	8b 7f 04 42 	eq %d4,%d15,71
8000b5b6:	19 a5 04 10 	ld.w %d5,[%sp]68
8000b5ba:	df 04 36 80 	jne %d4,0,8000b626 <_svfprintf_r+0x57e>
8000b5be:	3c 3e       	j 8000b63a <_svfprintf_r+0x592>
8000b5c0:	0b 9d 00 80 	add %d8,%d13,%d9
8000b5c4:	df 02 1c 00 	jeq %d2,0,8000b5fc <_svfprintf_r+0x554>
8000b5c8:	60 d2       	mov.a %a2,%d13
8000b5ca:	80 f4       	mov.d %d4,%a15
8000b5cc:	79 20 00 00 	ld.b %d0,[%a2]0
8000b5d0:	d2 06       	mov %e6,0
8000b5d2:	02 35       	mov %d5,%d3
8000b5d4:	8b 00 03 f2 	eq %d15,%d0,48
8000b5d8:	59 a3 08 00 	st.w [%sp]8,%d3
8000b5dc:	6d 00 cb 14 	call 8000df72 <__nedf2>
8000b5e0:	8b 02 20 22 	ne %d2,%d2,0
8000b5e4:	0f 2f 80 00 	and %d0,%d15,%d2
8000b5e8:	19 a3 08 00 	ld.w %d3,[%sp]8
8000b5ec:	76 05       	jz %d0,8000b5f6 <_svfprintf_r+0x54e>
8000b5ee:	8b 19 00 01 	rsub %d0,%d9,1
8000b5f2:	59 a0 04 10 	st.w [%sp]68,%d0
8000b5f6:	19 a2 04 10 	ld.w %d2,[%sp]68
8000b5fa:	42 28       	add %d8,%d2
8000b5fc:	80 f4       	mov.d %d4,%a15
8000b5fe:	d2 06       	mov %e6,0
8000b600:	02 35       	mov %d5,%d3
8000b602:	6d 00 98 14 	call 8000df32 <__eqdf2>
8000b606:	f6 23       	jnz %d2,8000b60c <_svfprintf_r+0x564>
8000b608:	59 a8 14 10 	st.w [%sp]84,%d8
8000b60c:	3b 00 03 00 	mov %d0,48
8000b610:	19 a3 14 10 	ld.w %d3,[%sp]84
8000b614:	7f 83 c9 ff 	jge.u %d3,%d8,8000b5a6 <_svfprintf_r+0x4fe>
8000b618:	1b 13 00 10 	addi %d1,%d3,1
8000b61c:	60 32       	mov.a %a2,%d3
8000b61e:	59 a1 14 10 	st.w [%sp]84,%d1
8000b622:	34 20       	st.b [%a2],%d0
8000b624:	3c f6       	j 8000b610 <_svfprintf_r+0x568>
8000b626:	0b 5e 20 31 	lt %d3,%d14,%d5
8000b62a:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000b62e:	df 03 88 00 	jeq %d3,0,8000b73e <_svfprintf_r+0x696>
8000b632:	58 04       	ld.w %d15,[%sp]16
8000b634:	c2 ef       	add %d15,-2
8000b636:	78 04       	st.w [%sp]16,%d15
8000b638:	3c 06       	j 8000b644 <_svfprintf_r+0x59c>
8000b63a:	58 04       	ld.w %d15,[%sp]16
8000b63c:	8b 6f 86 32 	ge %d3,%d15,102
8000b640:	df 03 69 80 	jne %d3,0,8000b712 <_svfprintf_r+0x66a>
8000b644:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b648:	9a f5       	add %d15,%d5,-1
8000b64a:	78 11       	st.w [%sp]68,%d15
8000b64c:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000b650:	3b b0 02 30 	mov %d3,43
8000b654:	ce f4       	jgez %d15,8000b65c <_svfprintf_r+0x5b4>
8000b656:	32 5f       	rsub %d15
8000b658:	3b d0 02 30 	mov %d3,45
8000b65c:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000b660:	8b af 40 32 	lt %d3,%d15,10
8000b664:	df 03 3e 80 	jne %d3,0,8000b6e0 <_svfprintf_r+0x638>
8000b668:	82 06       	mov %d6,0
8000b66a:	3b a0 00 00 	mov %d0,10
8000b66e:	4b 0f 01 42 	div %e4,%d15,%d0
8000b672:	8b 66 00 71 	rsub %d7,%d6,6
8000b676:	60 72       	mov.a %a2,%d7
8000b678:	d9 af 14 10 	lea %a15,[%sp]84
8000b67c:	1b 05 03 30 	addi %d3,%d5,48
8000b680:	30 2f       	add.a %a15,%a2
8000b682:	28 03       	st.b [%a15]0,%d3
8000b684:	8b a4 80 32 	ge %d3,%d4,10
8000b688:	02 4f       	mov %d15,%d4
8000b68a:	c2 16       	add %d6,1
8000b68c:	df 03 f1 ff 	jne %d3,0,8000b66e <_svfprintf_r+0x5c6>
8000b690:	60 74       	mov.a %a4,%d7
8000b692:	d9 a2 10 30 	lea %a2,[%sp]208
8000b696:	1b 04 03 f0 	addi %d15,%d4,48
8000b69a:	30 42       	add.a %a2,%a4
8000b69c:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000b6a0:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000b6a4:	80 22       	mov.d %d2,%a2
8000b6a6:	d9 af 1b 10 	lea %a15,[%sp]91
8000b6aa:	80 ff       	mov.d %d15,%a15
8000b6ac:	1b 32 f8 4f 	addi %d4,%d2,-125
8000b6b0:	82 03       	mov %d3,0
8000b6b2:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000b6b6:	3f 4f 08 80 	jlt.u %d15,%d4,8000b6c6 <_svfprintf_r+0x61e>
8000b6ba:	80 a2       	mov.d %d2,%sp
8000b6bc:	1b 02 0d 20 	addi %d2,%d2,208
8000b6c0:	8b 52 07 42 	eq %d4,%d2,117
8000b6c4:	76 46       	jz %d4,8000b6d0 <_svfprintf_r+0x628>
8000b6c6:	a0 03       	mov.a %a3,0
8000b6c8:	3c 04       	j 8000b6d0 <_svfprintf_r+0x628>
8000b6ca:	0c 70       	ld.bu %d15,[%a7]0
8000b6cc:	b0 17       	add.a %a7,1
8000b6ce:	28 0f       	st.b [%a15]0,%d15
8000b6d0:	60 3f       	mov.a %a15,%d3
8000b6d2:	d9 a2 0d 10 	lea %a2,[%sp]77
8000b6d6:	b0 2f       	add.a %a15,2
8000b6d8:	30 2f       	add.a %a15,%a2
8000b6da:	c2 13       	add %d3,1
8000b6dc:	fc 37       	loop %a3,8000b6ca <_svfprintf_r+0x622>
8000b6de:	3c 0b       	j 8000b6f4 <_svfprintf_r+0x64c>
8000b6e0:	3b 00 03 30 	mov %d3,48
8000b6e4:	1b 0f 03 f0 	addi %d15,%d15,48
8000b6e8:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000b6ec:	e9 af 10 10 	st.b [%sp]80,%d15
8000b6f0:	d9 af 11 10 	lea %a15,[%sp]81
8000b6f4:	d9 a7 0d 10 	lea %a7,[%sp]77
8000b6f8:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000b6fc:	80 79       	mov.d %d9,%a7
8000b6fe:	58 05       	ld.w %d15,[%sp]20
8000b700:	b5 a7 38 00 	st.a [%sp]56,%a7
8000b704:	42 f9       	add %d9,%d15
8000b706:	ff 2f 04 00 	jge %d15,2,8000b70e <_svfprintf_r+0x666>
8000b70a:	6f 0a 2c 00 	jz.t %d10,0,8000b762 <_svfprintf_r+0x6ba>
8000b70e:	c2 19       	add %d9,1
8000b710:	3c 29       	j 8000b762 <_svfprintf_r+0x6ba>
8000b712:	58 04       	ld.w %d15,[%sp]16
8000b714:	8b 6f 26 42 	ne %d4,%d15,102
8000b718:	df 04 15 80 	jne %d4,0,8000b742 <_svfprintf_r+0x69a>
8000b71c:	02 59       	mov %d9,%d5
8000b71e:	8e 59       	jlez %d5,8000b730 <_svfprintf_r+0x688>
8000b720:	f6 e3       	jnz %d14,8000b726 <_svfprintf_r+0x67e>
8000b722:	6f 0a 20 00 	jz.t %d10,0,8000b762 <_svfprintf_r+0x6ba>
8000b726:	1b 1e 00 30 	addi %d3,%d14,1
8000b72a:	0b 35 00 90 	add %d9,%d5,%d3
8000b72e:	3c 1a       	j 8000b762 <_svfprintf_r+0x6ba>
8000b730:	f6 e4       	jnz %d14,8000b738 <_svfprintf_r+0x690>
8000b732:	82 19       	mov %d9,1
8000b734:	6f 0a 17 00 	jz.t %d10,0,8000b762 <_svfprintf_r+0x6ba>
8000b738:	1b 2e 00 90 	addi %d9,%d14,2
8000b73c:	3c 13       	j 8000b762 <_svfprintf_r+0x6ba>
8000b73e:	da 67       	mov %d15,103
8000b740:	78 04       	st.w [%sp]16,%d15
8000b742:	58 05       	ld.w %d15,[%sp]20
8000b744:	8f 1a 00 a1 	and %d10,%d10,1
8000b748:	0b a5 00 90 	add %d9,%d5,%d10
8000b74c:	7f f5 0b 00 	jge %d5,%d15,8000b762 <_svfprintf_r+0x6ba>
8000b750:	8b 15 40 92 	lt %d9,%d5,1
8000b754:	8b 25 00 31 	rsub %d3,%d5,2
8000b758:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000b75c:	19 a9 14 00 	ld.w %d9,[%sp]20
8000b760:	42 39       	add %d9,%d3
8000b762:	58 09       	ld.w %d15,[%sp]36
8000b764:	82 0e       	mov %d14,0
8000b766:	df 0f 55 01 	jeq %d15,0,8000ba10 <_svfprintf_r+0x968>
8000b76a:	3b d0 02 70 	mov %d7,45
8000b76e:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b772:	1d 00 4f 01 	j 8000ba10 <_svfprintf_r+0x968>
8000b776:	e9 af 01 10 	st.b [%sp]65,%d15
8000b77a:	d9 f2 04 00 	lea %a2,[%a15]4
8000b77e:	6f 5a 09 00 	jz.t %d10,5,8000b790 <_svfprintf_r+0x6e8>
8000b782:	58 0a       	ld.w %d15,[%sp]40
8000b784:	c8 03       	ld.a %a3,[%a15]0
8000b786:	0b f0 00 48 	mov %e4,%d15
8000b78a:	89 34 40 09 	st.d [%a3],%e4
8000b78e:	3c 0c       	j 8000b7a6 <_svfprintf_r+0x6fe>
8000b790:	6f 4a 08 80 	jnz.t %d10,4,8000b7a0 <_svfprintf_r+0x6f8>
8000b794:	6f 6a 06 00 	jz.t %d10,6,8000b7a0 <_svfprintf_r+0x6f8>
8000b798:	c8 03       	ld.a %a3,[%a15]0
8000b79a:	58 0a       	ld.w %d15,[%sp]40
8000b79c:	ac 30       	st.h [%a3]0,%d15
8000b79e:	3c 04       	j 8000b7a6 <_svfprintf_r+0x6fe>
8000b7a0:	c8 03       	ld.a %a3,[%a15]0
8000b7a2:	58 0a       	ld.w %d15,[%sp]40
8000b7a4:	6c 30       	st.w [%a3]0,%d15
8000b7a6:	40 2f       	mov.aa %a15,%a2
8000b7a8:	1d ff b8 fc 	j 8000b118 <_svfprintf_r+0x70>
8000b7ac:	8f 0a 41 a1 	or %d10,%d10,16
8000b7b0:	6f 5a 07 00 	jz.t %d10,5,8000b7be <_svfprintf_r+0x716>
8000b7b4:	d9 fc 08 00 	lea %a12,[%a15]8
8000b7b8:	09 f8 40 09 	ld.d %e8,[%a15]
8000b7bc:	3c 0c       	j 8000b7d4 <_svfprintf_r+0x72c>
8000b7be:	d9 fc 04 00 	lea %a12,[%a15]4
8000b7c2:	6f 4a 07 80 	jnz.t %d10,4,8000b7d0 <_svfprintf_r+0x728>
8000b7c6:	6f 6a 05 00 	jz.t %d10,6,8000b7d0 <_svfprintf_r+0x728>
8000b7ca:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000b7ce:	3c 02       	j 8000b7d2 <_svfprintf_r+0x72a>
8000b7d0:	48 08       	ld.w %d8,[%a15]0
8000b7d2:	82 09       	mov %d9,0
8000b7d4:	82 03       	mov %d3,0
8000b7d6:	3c 73       	j 8000b8bc <_svfprintf_r+0x814>
8000b7d8:	3b 00 03 40 	mov %d4,48
8000b7dc:	7b 00 00 f8 	movh %d15,32768
8000b7e0:	1b df da f0 	addi %d15,%d15,3501
8000b7e4:	e9 a4 02 10 	st.b [%sp]66,%d4
8000b7e8:	3b 80 07 40 	mov %d4,120
8000b7ec:	78 0f       	st.w [%sp]60,%d15
8000b7ee:	02 4f       	mov %d15,%d4
8000b7f0:	d9 fc 04 00 	lea %a12,[%a15]4
8000b7f4:	48 08       	ld.w %d8,[%a15]0
8000b7f6:	82 09       	mov %d9,0
8000b7f8:	8f 2a 40 a1 	or %d10,%d10,2
8000b7fc:	e9 a4 03 10 	st.b [%sp]67,%d4
8000b800:	82 23       	mov %d3,2
8000b802:	78 04       	st.w [%sp]16,%d15
8000b804:	3c 5c       	j 8000b8bc <_svfprintf_r+0x814>
8000b806:	82 07       	mov %d7,0
8000b808:	48 0d       	ld.w %d13,[%a15]0
8000b80a:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b80e:	02 e9       	mov %d9,%d14
8000b810:	60 ad       	mov.a %a13,%d10
8000b812:	d9 fc 04 00 	lea %a12,[%a15]4
8000b816:	60 d4       	mov.a %a4,%d13
8000b818:	0e ef       	jltz %d14,8000b836 <_svfprintf_r+0x78e>
8000b81a:	82 04       	mov %d4,0
8000b81c:	02 e5       	mov %d5,%d14
8000b81e:	6d 00 77 0d 	call 8000d30c <memchr>
8000b822:	bd 02 f6 00 	jz.a %a2,8000ba0e <_svfprintf_r+0x966>
8000b826:	60 d4       	mov.a %a4,%d13
8000b828:	01 42 20 30 	sub.a %a3,%a2,%a4
8000b82c:	80 32       	mov.d %d2,%a3
8000b82e:	0b e2 80 91 	min %d9,%d2,%d14
8000b832:	1d 00 ee 00 	j 8000ba0e <_svfprintf_r+0x966>
8000b836:	6d ff 2f fc 	call 8000b094 <strlen>
8000b83a:	02 29       	mov %d9,%d2
8000b83c:	1d 00 e9 00 	j 8000ba0e <_svfprintf_r+0x966>
8000b840:	8f 0a 41 a1 	or %d10,%d10,16
8000b844:	6f 5a 07 00 	jz.t %d10,5,8000b852 <_svfprintf_r+0x7aa>
8000b848:	d9 fc 08 00 	lea %a12,[%a15]8
8000b84c:	09 f8 40 09 	ld.d %e8,[%a15]
8000b850:	3c 0c       	j 8000b868 <_svfprintf_r+0x7c0>
8000b852:	d9 fc 04 00 	lea %a12,[%a15]4
8000b856:	6f 4a 07 80 	jnz.t %d10,4,8000b864 <_svfprintf_r+0x7bc>
8000b85a:	6f 6a 05 00 	jz.t %d10,6,8000b864 <_svfprintf_r+0x7bc>
8000b85e:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000b862:	3c 02       	j 8000b866 <_svfprintf_r+0x7be>
8000b864:	48 08       	ld.w %d8,[%a15]0
8000b866:	82 09       	mov %d9,0
8000b868:	82 13       	mov %d3,1
8000b86a:	3c 29       	j 8000b8bc <_svfprintf_r+0x814>
8000b86c:	e9 af 01 10 	st.b [%sp]65,%d15
8000b870:	7b 00 00 f8 	movh %d15,32768
8000b874:	1b df da f0 	addi %d15,%d15,3501
8000b878:	78 0f       	st.w [%sp]60,%d15
8000b87a:	6f 5a 07 00 	jz.t %d10,5,8000b888 <_svfprintf_r+0x7e0>
8000b87e:	d9 fc 08 00 	lea %a12,[%a15]8
8000b882:	09 f8 40 09 	ld.d %e8,[%a15]
8000b886:	3c 0c       	j 8000b89e <_svfprintf_r+0x7f6>
8000b888:	d9 fc 04 00 	lea %a12,[%a15]4
8000b88c:	6f 4a 07 80 	jnz.t %d10,4,8000b89a <_svfprintf_r+0x7f2>
8000b890:	6f 6a 05 00 	jz.t %d10,6,8000b89a <_svfprintf_r+0x7f2>
8000b894:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000b898:	3c 02       	j 8000b89c <_svfprintf_r+0x7f4>
8000b89a:	48 08       	ld.w %d8,[%a15]0
8000b89c:	82 09       	mov %d9,0
8000b89e:	82 23       	mov %d3,2
8000b8a0:	6f 0a 0e 00 	jz.t %d10,0,8000b8bc <_svfprintf_r+0x814>
8000b8a4:	0f 89 a0 40 	or %d4,%d9,%d8
8000b8a8:	76 4a       	jz %d4,8000b8bc <_svfprintf_r+0x814>
8000b8aa:	58 04       	ld.w %d15,[%sp]16
8000b8ac:	3b 00 03 70 	mov %d7,48
8000b8b0:	e9 a7 02 10 	st.b [%sp]66,%d7
8000b8b4:	e9 af 03 10 	st.b [%sp]67,%d15
8000b8b8:	8f 2a 40 a1 	or %d10,%d10,2
8000b8bc:	82 07       	mov %d7,0
8000b8be:	60 ad       	mov.a %a13,%d10
8000b8c0:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b8c4:	80 d2       	mov.d %d2,%a13
8000b8c6:	8b 0e 80 72 	ge %d7,%d14,0
8000b8ca:	8f 02 c8 41 	andn %d4,%d2,128
8000b8ce:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000b8d2:	0f 98 a0 60 	or %d6,%d8,%d9
8000b8d6:	8b 0e 20 42 	ne %d4,%d14,0
8000b8da:	8b 06 00 45 	or.ne %d4,%d6,0
8000b8de:	60 2d       	mov.a %a13,%d2
8000b8e0:	df 04 72 00 	jeq %d4,0,8000b9c4 <_svfprintf_r+0x91c>
8000b8e4:	df 13 06 00 	jeq %d3,1,8000b8f0 <_svfprintf_r+0x848>
8000b8e8:	df 23 57 00 	jeq %d3,2,8000b996 <_svfprintf_r+0x8ee>
8000b8ec:	82 03       	mov %d3,0
8000b8ee:	3c 03       	j 8000b8f4 <_svfprintf_r+0x84c>
8000b8f0:	82 04       	mov %d4,0
8000b8f2:	3c 22       	j 8000b936 <_svfprintf_r+0x88e>
8000b8f4:	8b 73 02 71 	rsub %d7,%d3,39
8000b8f8:	60 72       	mov.a %a2,%d7
8000b8fa:	8f 78 00 41 	and %d4,%d8,7
8000b8fe:	d9 a3 28 10 	lea %a3,[%sp]104
8000b902:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000b906:	30 23       	add.a %a3,%a2
8000b908:	1b 04 03 40 	addi %d4,%d4,48
8000b90c:	06 d9       	sh %d9,-3
8000b90e:	34 34       	st.b [%a3],%d4
8000b910:	0f 89 a0 60 	or %d6,%d9,%d8
8000b914:	c2 13       	add %d3,1
8000b916:	df 06 ef ff 	jne %d6,0,8000b8f4 <_svfprintf_r+0x84c>
8000b91a:	80 d2       	mov.d %d2,%a13
8000b91c:	80 3d       	mov.d %d13,%a3
8000b91e:	6f 02 61 00 	jz.t %d2,0,8000b9e0 <_svfprintf_r+0x938>
8000b922:	8b 04 03 42 	eq %d4,%d4,48
8000b926:	df 04 5d 80 	jne %d4,0,8000b9e0 <_svfprintf_r+0x938>
8000b92a:	3b 00 03 70 	mov %d7,48
8000b92e:	c2 fd       	add %d13,-1
8000b930:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000b934:	3c 56       	j 8000b9e0 <_svfprintf_r+0x938>
8000b936:	8b 84 02 71 	rsub %d7,%d4,40
8000b93a:	8b 09 00 32 	eq %d3,%d9,0
8000b93e:	60 73       	mov.a %a3,%d7
8000b940:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000b944:	d9 a7 28 10 	lea %a7,[%sp]104
8000b948:	8b 09 00 35 	or.ne %d3,%d9,0
8000b94c:	30 37       	add.a %a7,%a3
8000b94e:	1b 14 00 d0 	addi %d13,%d4,1
8000b952:	df 03 1b 00 	jeq %d3,0,8000b988 <_svfprintf_r+0x8e0>
8000b956:	8b 74 02 41 	rsub %d4,%d4,39
8000b95a:	60 42       	mov.a %a2,%d4
8000b95c:	fb a0 00 60 	mov %e6,10
8000b960:	0b 89 10 48 	mov %e4,%d9,%d8
8000b964:	d9 af 28 10 	lea %a15,[%sp]104
8000b968:	30 2f       	add.a %a15,%a2
8000b96a:	6d 00 fb 13 	call 8000e160 <__umoddi3>
8000b96e:	0b 89 10 48 	mov %e4,%d9,%d8
8000b972:	1b 02 03 20 	addi %d2,%d2,48
8000b976:	fb a0 00 60 	mov %e6,10
8000b97a:	28 02       	st.b [%a15]0,%d2
8000b97c:	6d 00 a2 13 	call 8000e0c0 <__udivdi3>
8000b980:	02 d4       	mov %d4,%d13
8000b982:	0b 23 10 88 	mov %e8,%d3,%d2
8000b986:	3c d8       	j 8000b936 <_svfprintf_r+0x88e>
8000b988:	80 7d       	mov.d %d13,%a7
8000b98a:	1b 08 03 80 	addi %d8,%d8,48
8000b98e:	c2 fd       	add %d13,-1
8000b990:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000b994:	3c 26       	j 8000b9e0 <_svfprintf_r+0x938>
8000b996:	82 03       	mov %d3,0
8000b998:	d8 0f       	ld.a %a15,[%sp]60
8000b99a:	80 ad       	mov.d %d13,%sp
8000b99c:	8f f8 00 f1 	and %d15,%d8,15
8000b9a0:	8b 73 02 71 	rsub %d7,%d3,39
8000b9a4:	1b 8d 06 d0 	addi %d13,%d13,104
8000b9a8:	10 f7       	addsc.a %a7,%a15,%d15,0
8000b9aa:	42 7d       	add %d13,%d7
8000b9ac:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000b9b0:	0c 70       	ld.bu %d15,[%a7]0
8000b9b2:	60 d2       	mov.a %a2,%d13
8000b9b4:	06 c9       	sh %d9,-4
8000b9b6:	2c 20       	st.b [%a2]0,%d15
8000b9b8:	0f 89 a0 40 	or %d4,%d9,%d8
8000b9bc:	c2 13       	add %d3,1
8000b9be:	df 04 ed ff 	jne %d4,0,8000b998 <_svfprintf_r+0x8f0>
8000b9c2:	3c 0f       	j 8000b9e0 <_svfprintf_r+0x938>
8000b9c4:	80 a2       	mov.d %d2,%sp
8000b9c6:	1b 02 09 d0 	addi %d13,%d2,144
8000b9ca:	f6 3b       	jnz %d3,8000b9e0 <_svfprintf_r+0x938>
8000b9cc:	80 df       	mov.d %d15,%a13
8000b9ce:	2e 09       	jz.t %d15,0,8000b9e0 <_svfprintf_r+0x938>
8000b9d0:	1b 02 0d d0 	addi %d13,%d2,208
8000b9d4:	60 d2       	mov.a %a2,%d13
8000b9d6:	3b 00 03 70 	mov %d7,48
8000b9da:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000b9de:	80 2d       	mov.d %d13,%a2
8000b9e0:	d9 a3 10 20 	lea %a3,[%sp]144
8000b9e4:	80 39       	mov.d %d9,%a3
8000b9e6:	a2 d9       	sub %d9,%d13
8000b9e8:	3c 14       	j 8000ba10 <_svfprintf_r+0x968>
8000b9ea:	e9 af 01 10 	st.b [%sp]65,%d15
8000b9ee:	58 04       	ld.w %d15,[%sp]16
8000b9f0:	df 0f 1f 04 	jeq %d15,0,8000c22e <_svfprintf_r+0x1186>
8000b9f4:	82 03       	mov %d3,0
8000b9f6:	60 ad       	mov.a %a13,%d10
8000b9f8:	e9 af 28 10 	st.b [%sp]104,%d15
8000b9fc:	e9 a3 01 10 	st.b [%sp]65,%d3
8000ba00:	40 fc       	mov.aa %a12,%a15
8000ba02:	80 a2       	mov.d %d2,%sp
8000ba04:	82 19       	mov %d9,1
8000ba06:	82 0e       	mov %d14,0
8000ba08:	1b 82 06 d0 	addi %d13,%d2,104
8000ba0c:	3c 02       	j 8000ba10 <_svfprintf_r+0x968>
8000ba0e:	82 0e       	mov %d14,0
8000ba10:	79 a7 01 10 	ld.b %d7,[%sp]65
8000ba14:	80 df       	mov.d %d15,%a13
8000ba16:	0b e9 a0 a1 	max %d10,%d9,%d14
8000ba1a:	80 d2       	mov.d %d2,%a13
8000ba1c:	16 02       	and %d15,2
8000ba1e:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000ba22:	60 ff       	mov.a %a15,%d15
8000ba24:	8a 2a       	cadd %d10,%d15,2
8000ba26:	8f 42 08 f1 	and %d15,%d2,132
8000ba2a:	ee 48       	jnz %d15,8000baba <_svfprintf_r+0xa12>
8000ba2c:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000ba30:	a2 a8       	sub %d8,%d10
8000ba32:	bf 18 44 00 	jlt %d8,1,8000baba <_svfprintf_r+0xa12>
8000ba36:	91 00 00 28 	movh.a %a2,32768
8000ba3a:	d9 22 d0 70 	lea %a2,[%a2]3536 <80000dd0 <blanks.4035>>
8000ba3e:	19 a1 24 10 	ld.w %d1,[%sp]100 <80000dd0 <blanks.4035>>
8000ba42:	19 a4 20 10 	ld.w %d4,[%sp]96 <80000dd0 <blanks.4035>>
8000ba46:	8b 18 81 72 	ge %d7,%d8,17
8000ba4a:	f4 e2       	st.a [%a14],%a2
8000ba4c:	df 07 20 00 	jeq %d7,0,8000ba8c <_svfprintf_r+0x9e4>
8000ba50:	1b 14 00 00 	addi %d0,%d4,1
8000ba54:	3b 00 01 20 	mov %d2,16
8000ba58:	1b 01 01 10 	addi %d1,%d1,16
8000ba5c:	59 e2 04 00 	st.w [%a14]4,%d2
8000ba60:	59 a0 20 10 	st.w [%sp]96,%d0
8000ba64:	59 a1 24 10 	st.w [%sp]100,%d1
8000ba68:	8b 80 80 02 	ge %d0,%d0,8
8000ba6c:	d9 ee 08 00 	lea %a14,[%a14]8
8000ba70:	76 0b       	jz %d0,8000ba86 <_svfprintf_r+0x9de>
8000ba72:	60 c4       	mov.a %a4,%d12
8000ba74:	60 b5       	mov.a %a5,%d11
8000ba76:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ba7a:	6d 00 57 0f 	call 8000d928 <__ssprint_r>
8000ba7e:	df 02 e0 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000ba82:	d9 ae 10 20 	lea %a14,[%sp]144
8000ba86:	1b 08 ff 8f 	addi %d8,%d8,-16
8000ba8a:	3c d6       	j 8000ba36 <_svfprintf_r+0x98e>
8000ba8c:	c2 14       	add %d4,1
8000ba8e:	42 81       	add %d1,%d8
8000ba90:	59 e8 04 00 	st.w [%a14]4,%d8
8000ba94:	59 a4 20 10 	st.w [%sp]96,%d4
8000ba98:	59 a1 24 10 	st.w [%sp]100,%d1
8000ba9c:	8b 84 80 42 	ge %d4,%d4,8
8000baa0:	d9 ee 08 00 	lea %a14,[%a14]8
8000baa4:	76 4b       	jz %d4,8000baba <_svfprintf_r+0xa12>
8000baa6:	60 c4       	mov.a %a4,%d12
8000baa8:	60 b5       	mov.a %a5,%d11
8000baaa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000baae:	6d 00 3d 0f 	call 8000d928 <__ssprint_r>
8000bab2:	df 02 c6 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bab6:	d9 ae 10 20 	lea %a14,[%sp]144
8000baba:	79 a4 01 10 	ld.b %d4,[%sp]65
8000babe:	df 04 21 00 	jeq %d4,0,8000bb00 <_svfprintf_r+0xa58>
8000bac2:	19 a4 24 10 	ld.w %d4,[%sp]100
8000bac6:	d9 a7 01 10 	lea %a7,[%sp]65
8000baca:	c2 14       	add %d4,1
8000bacc:	59 a4 24 10 	st.w [%sp]100,%d4
8000bad0:	19 a4 20 10 	ld.w %d4,[%sp]96
8000bad4:	82 17       	mov %d7,1
8000bad6:	c2 14       	add %d4,1
8000bad8:	f4 e7       	st.a [%a14],%a7
8000bada:	59 e7 04 00 	st.w [%a14]4,%d7
8000bade:	59 a4 20 10 	st.w [%sp]96,%d4
8000bae2:	8b 84 80 42 	ge %d4,%d4,8
8000bae6:	d9 ee 08 00 	lea %a14,[%a14]8
8000baea:	76 4b       	jz %d4,8000bb00 <_svfprintf_r+0xa58>
8000baec:	60 c4       	mov.a %a4,%d12
8000baee:	60 b5       	mov.a %a5,%d11
8000baf0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000baf4:	6d 00 1a 0f 	call 8000d928 <__ssprint_r>
8000baf8:	df 02 a3 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bafc:	d9 ae 10 20 	lea %a14,[%sp]144
8000bb00:	bd 0f 21 00 	jz.a %a15,8000bb42 <_svfprintf_r+0xa9a>
8000bb04:	19 a4 24 10 	ld.w %d4,[%sp]100
8000bb08:	d9 a7 02 10 	lea %a7,[%sp]66
8000bb0c:	c2 24       	add %d4,2
8000bb0e:	59 a4 24 10 	st.w [%sp]100,%d4
8000bb12:	19 a4 20 10 	ld.w %d4,[%sp]96
8000bb16:	82 27       	mov %d7,2
8000bb18:	c2 14       	add %d4,1
8000bb1a:	f4 e7       	st.a [%a14],%a7
8000bb1c:	59 e7 04 00 	st.w [%a14]4,%d7
8000bb20:	59 a4 20 10 	st.w [%sp]96,%d4
8000bb24:	8b 84 80 42 	ge %d4,%d4,8
8000bb28:	d9 ee 08 00 	lea %a14,[%a14]8
8000bb2c:	76 4b       	jz %d4,8000bb42 <_svfprintf_r+0xa9a>
8000bb2e:	60 c4       	mov.a %a4,%d12
8000bb30:	60 b5       	mov.a %a5,%d11
8000bb32:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bb36:	6d 00 f9 0e 	call 8000d928 <__ssprint_r>
8000bb3a:	df 02 82 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bb3e:	d9 ae 10 20 	lea %a14,[%sp]144
8000bb42:	8b 0f 28 42 	ne %d4,%d15,128
8000bb46:	df 04 48 80 	jne %d4,0,8000bbd6 <_svfprintf_r+0xb2e>
8000bb4a:	58 07       	ld.w %d15,[%sp]28
8000bb4c:	7b 00 00 28 	movh %d2,32768
8000bb50:	60 23       	mov.a %a3,%d2
8000bb52:	a2 af       	sub %d15,%d10
8000bb54:	d9 3f c0 70 	lea %a15,[%a3]3520
8000bb58:	bf 1f 3f 00 	jlt %d15,1,8000bbd6 <_svfprintf_r+0xb2e>
8000bb5c:	19 a7 24 10 	ld.w %d7,[%sp]100
8000bb60:	19 a4 20 10 	ld.w %d4,[%sp]96
8000bb64:	8b 1f 81 82 	ge %d8,%d15,17
8000bb68:	ec e0       	st.a [%a14]0,%a15
8000bb6a:	df 08 20 00 	jeq %d8,0,8000bbaa <_svfprintf_r+0xb02>
8000bb6e:	1b 14 00 00 	addi %d0,%d4,1
8000bb72:	3b 00 01 20 	mov %d2,16
8000bb76:	1b 07 01 10 	addi %d1,%d7,16
8000bb7a:	59 e2 04 00 	st.w [%a14]4,%d2
8000bb7e:	59 a0 20 10 	st.w [%sp]96,%d0
8000bb82:	59 a1 24 10 	st.w [%sp]100,%d1
8000bb86:	8b 80 80 02 	ge %d0,%d0,8
8000bb8a:	d9 ee 08 00 	lea %a14,[%a14]8
8000bb8e:	76 0b       	jz %d0,8000bba4 <_svfprintf_r+0xafc>
8000bb90:	60 c4       	mov.a %a4,%d12
8000bb92:	60 b5       	mov.a %a5,%d11
8000bb94:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bb98:	6d 00 c8 0e 	call 8000d928 <__ssprint_r>
8000bb9c:	df 02 51 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bba0:	d9 ae 10 20 	lea %a14,[%sp]144
8000bba4:	1b 0f ff ff 	addi %d15,%d15,-16
8000bba8:	3c da       	j 8000bb5c <_svfprintf_r+0xab4>
8000bbaa:	c2 14       	add %d4,1
8000bbac:	42 f7       	add %d7,%d15
8000bbae:	6c e1       	st.w [%a14]4,%d15
8000bbb0:	59 a4 20 10 	st.w [%sp]96,%d4
8000bbb4:	59 a7 24 10 	st.w [%sp]100,%d7
8000bbb8:	8b 84 80 42 	ge %d4,%d4,8
8000bbbc:	d9 ee 08 00 	lea %a14,[%a14]8
8000bbc0:	76 4b       	jz %d4,8000bbd6 <_svfprintf_r+0xb2e>
8000bbc2:	60 c4       	mov.a %a4,%d12
8000bbc4:	60 b5       	mov.a %a5,%d11
8000bbc6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bbca:	6d 00 af 0e 	call 8000d928 <__ssprint_r>
8000bbce:	df 02 38 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bbd2:	d9 ae 10 20 	lea %a14,[%sp]144
8000bbd6:	7b 00 00 88 	movh %d8,32768
8000bbda:	a2 9e       	sub %d14,%d9
8000bbdc:	1b 08 dc 80 	addi %d8,%d8,3520
8000bbe0:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000bbe4:	bf 1e 3c 00 	jlt %d14,1,8000bc5c <_svfprintf_r+0xbb4>
8000bbe8:	19 a6 24 10 	ld.w %d6,[%sp]100
8000bbec:	19 a4 20 10 	ld.w %d4,[%sp]96
8000bbf0:	8b 1e 81 02 	ge %d0,%d14,17
8000bbf4:	74 e8       	st.w [%a14],%d8
8000bbf6:	df 00 1c 00 	jeq %d0,0,8000bc2e <_svfprintf_r+0xb86>
8000bbfa:	c2 14       	add %d4,1
8000bbfc:	1b 06 01 00 	addi %d0,%d6,16
8000bc00:	ec e1       	st.a [%a14]4,%a15
8000bc02:	59 a4 20 10 	st.w [%sp]96,%d4
8000bc06:	59 a0 24 10 	st.w [%sp]100,%d0
8000bc0a:	8b 84 80 42 	ge %d4,%d4,8
8000bc0e:	d9 ee 08 00 	lea %a14,[%a14]8
8000bc12:	76 4b       	jz %d4,8000bc28 <_svfprintf_r+0xb80>
8000bc14:	60 c4       	mov.a %a4,%d12
8000bc16:	60 b5       	mov.a %a5,%d11
8000bc18:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bc1c:	6d 00 86 0e 	call 8000d928 <__ssprint_r>
8000bc20:	df 02 0f 83 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bc24:	d9 ae 10 20 	lea %a14,[%sp]144
8000bc28:	1b 0e ff ef 	addi %d14,%d14,-16
8000bc2c:	3c de       	j 8000bbe8 <_svfprintf_r+0xb40>
8000bc2e:	c2 14       	add %d4,1
8000bc30:	42 e6       	add %d6,%d14
8000bc32:	59 ee 04 00 	st.w [%a14]4,%d14
8000bc36:	59 a4 20 10 	st.w [%sp]96,%d4
8000bc3a:	59 a6 24 10 	st.w [%sp]100,%d6
8000bc3e:	8b 84 80 42 	ge %d4,%d4,8
8000bc42:	d9 ee 08 00 	lea %a14,[%a14]8
8000bc46:	76 4b       	jz %d4,8000bc5c <_svfprintf_r+0xbb4>
8000bc48:	60 c4       	mov.a %a4,%d12
8000bc4a:	60 b5       	mov.a %a5,%d11
8000bc4c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bc50:	6d 00 6c 0e 	call 8000d928 <__ssprint_r>
8000bc54:	df 02 f5 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bc58:	d9 ae 10 20 	lea %a14,[%sp]144
8000bc5c:	80 df       	mov.d %d15,%a13
8000bc5e:	19 ae 24 10 	ld.w %d14,[%sp]100
8000bc62:	19 a8 20 10 	ld.w %d8,[%sp]96
8000bc66:	6f 8f 1d 80 	jnz.t %d15,8,8000bca0 <_svfprintf_r+0xbf8>
8000bc6a:	c2 18       	add %d8,1
8000bc6c:	59 e9 04 00 	st.w [%a14]4,%d9
8000bc70:	42 e9       	add %d9,%d14
8000bc72:	59 a8 20 10 	st.w [%sp]96,%d8
8000bc76:	74 ed       	st.w [%a14],%d13
8000bc78:	59 a9 24 10 	st.w [%sp]100,%d9
8000bc7c:	8b 88 80 82 	ge %d8,%d8,8
8000bc80:	d9 ef 08 00 	lea %a15,[%a14]8
8000bc84:	df 08 79 02 	jeq %d8,0,8000c176 <_svfprintf_r+0x10ce>
8000bc88:	60 c4       	mov.a %a4,%d12
8000bc8a:	60 b5       	mov.a %a5,%d11
8000bc8c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bc90:	6d 00 4c 0e 	call 8000d928 <__ssprint_r>
8000bc94:	df 02 d5 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bc98:	d9 af 10 20 	lea %a15,[%sp]144
8000bc9c:	1d 00 6d 02 	j 8000c176 <_svfprintf_r+0x10ce>
8000bca0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000bca4:	8b 62 46 f2 	lt %d15,%d2,102
8000bca8:	df 0f be 81 	jne %d15,0,8000c024 <_svfprintf_r+0xf7c>
8000bcac:	d2 06       	mov %e6,0
8000bcae:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000bcb2:	19 a5 30 00 	ld.w %d5,[%sp]48
8000bcb6:	6d 00 3e 11 	call 8000df32 <__eqdf2>
8000bcba:	df 02 78 80 	jne %d2,0,8000bdaa <_svfprintf_r+0xd02>
8000bcbe:	7b 00 00 38 	movh %d3,32768
8000bcc2:	1b e3 db 30 	addi %d3,%d3,3518
8000bcc6:	c2 18       	add %d8,1
8000bcc8:	74 e3       	st.w [%a14],%d3
8000bcca:	1b 1e 00 90 	addi %d9,%d14,1
8000bcce:	82 13       	mov %d3,1
8000bcd0:	59 a8 20 10 	st.w [%sp]96,%d8
8000bcd4:	59 e3 04 00 	st.w [%a14]4,%d3
8000bcd8:	59 a9 24 10 	st.w [%sp]100,%d9
8000bcdc:	8b 88 80 82 	ge %d8,%d8,8
8000bce0:	d9 ef 08 00 	lea %a15,[%a14]8
8000bce4:	76 8b       	jz %d8,8000bcfa <_svfprintf_r+0xc52>
8000bce6:	60 c4       	mov.a %a4,%d12
8000bce8:	60 b5       	mov.a %a5,%d11
8000bcea:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bcee:	6d 00 1d 0e 	call 8000d928 <__ssprint_r>
8000bcf2:	df 02 a6 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bcf6:	d9 af 10 20 	lea %a15,[%sp]144
8000bcfa:	58 11       	ld.w %d15,[%sp]68
8000bcfc:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bd00:	3f 2f 05 00 	jlt %d15,%d2,8000bd0a <_svfprintf_r+0xc62>
8000bd04:	80 df       	mov.d %d15,%a13
8000bd06:	6f 0f 38 02 	jz.t %d15,0,8000c176 <_svfprintf_r+0x10ce>
8000bd0a:	58 08       	ld.w %d15,[%sp]32
8000bd0c:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bd10:	68 1f       	st.w [%a15]4,%d15
8000bd12:	58 19       	ld.w %d15,[%sp]100
8000bd14:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bd18:	42 2f       	add %d15,%d2
8000bd1a:	78 19       	st.w [%sp]100,%d15
8000bd1c:	58 18       	ld.w %d15,[%sp]96
8000bd1e:	e8 03       	st.a [%a15]0,%a3
8000bd20:	c2 1f       	add %d15,1
8000bd22:	78 18       	st.w [%sp]96,%d15
8000bd24:	8b 8f 80 f2 	ge %d15,%d15,8
8000bd28:	d9 ff 08 00 	lea %a15,[%a15]8
8000bd2c:	6e 0b       	jz %d15,8000bd42 <_svfprintf_r+0xc9a>
8000bd2e:	60 c4       	mov.a %a4,%d12
8000bd30:	60 b5       	mov.a %a5,%d11
8000bd32:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bd36:	6d 00 f9 0d 	call 8000d928 <__ssprint_r>
8000bd3a:	df 02 82 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bd3e:	d9 af 10 20 	lea %a15,[%sp]144
8000bd42:	58 05       	ld.w %d15,[%sp]20
8000bd44:	7b 00 00 88 	movh %d8,32768
8000bd48:	c2 ff       	add %d15,-1
8000bd4a:	1b 08 dc 80 	addi %d8,%d8,3520
8000bd4e:	3b 00 01 90 	mov %d9,16
8000bd52:	bf 1f 12 02 	jlt %d15,1,8000c176 <_svfprintf_r+0x10ce>
8000bd56:	19 a5 24 10 	ld.w %d5,[%sp]100
8000bd5a:	19 a3 20 10 	ld.w %d3,[%sp]96
8000bd5e:	8b 1f 81 42 	ge %d4,%d15,17
8000bd62:	68 08       	st.w [%a15]0,%d8
8000bd64:	df 04 1c 00 	jeq %d4,0,8000bd9c <_svfprintf_r+0xcf4>
8000bd68:	c2 13       	add %d3,1
8000bd6a:	1b 05 01 40 	addi %d4,%d5,16
8000bd6e:	68 19       	st.w [%a15]4,%d9
8000bd70:	59 a3 20 10 	st.w [%sp]96,%d3
8000bd74:	59 a4 24 10 	st.w [%sp]100,%d4
8000bd78:	8b 83 80 32 	ge %d3,%d3,8
8000bd7c:	d9 ff 08 00 	lea %a15,[%a15]8
8000bd80:	76 3b       	jz %d3,8000bd96 <_svfprintf_r+0xcee>
8000bd82:	60 c4       	mov.a %a4,%d12
8000bd84:	60 b5       	mov.a %a5,%d11
8000bd86:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bd8a:	6d 00 cf 0d 	call 8000d928 <__ssprint_r>
8000bd8e:	df 02 58 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bd92:	d9 af 10 20 	lea %a15,[%sp]144
8000bd96:	1b 0f ff ff 	addi %d15,%d15,-16
8000bd9a:	3c de       	j 8000bd56 <_svfprintf_r+0xcae>
8000bd9c:	12 54       	add %d4,%d15,%d5
8000bd9e:	68 1f       	st.w [%a15]4,%d15
8000bda0:	59 a4 24 10 	st.w [%sp]100,%d4
8000bda4:	9a 13       	add %d15,%d3,1
8000bda6:	1d 00 e1 01 	j 8000c168 <_svfprintf_r+0x10c0>
8000bdaa:	19 a3 04 10 	ld.w %d3,[%sp]68
8000bdae:	ff 13 8e 00 	jge %d3,1,8000beca <_svfprintf_r+0xe22>
8000bdb2:	7b 00 00 38 	movh %d3,32768
8000bdb6:	1b e3 db 30 	addi %d3,%d3,3518
8000bdba:	c2 18       	add %d8,1
8000bdbc:	74 e3       	st.w [%a14],%d3
8000bdbe:	1b 1e 00 90 	addi %d9,%d14,1
8000bdc2:	82 13       	mov %d3,1
8000bdc4:	59 a8 20 10 	st.w [%sp]96,%d8
8000bdc8:	59 e3 04 00 	st.w [%a14]4,%d3
8000bdcc:	59 a9 24 10 	st.w [%sp]100,%d9
8000bdd0:	8b 88 80 82 	ge %d8,%d8,8
8000bdd4:	d9 ef 08 00 	lea %a15,[%a14]8
8000bdd8:	76 8b       	jz %d8,8000bdee <_svfprintf_r+0xd46>
8000bdda:	60 c4       	mov.a %a4,%d12
8000bddc:	60 b5       	mov.a %a5,%d11
8000bdde:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bde2:	6d 00 a3 0d 	call 8000d928 <__ssprint_r>
8000bde6:	df 02 2c 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bdea:	d9 af 10 20 	lea %a15,[%sp]144
8000bdee:	58 11       	ld.w %d15,[%sp]68
8000bdf0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bdf4:	a6 2f       	or %d15,%d2
8000bdf6:	ee 04       	jnz %d15,8000bdfe <_svfprintf_r+0xd56>
8000bdf8:	80 df       	mov.d %d15,%a13
8000bdfa:	6f 0f be 01 	jz.t %d15,0,8000c176 <_svfprintf_r+0x10ce>
8000bdfe:	58 08       	ld.w %d15,[%sp]32
8000be00:	19 a2 20 00 	ld.w %d2,[%sp]32
8000be04:	68 1f       	st.w [%a15]4,%d15
8000be06:	58 19       	ld.w %d15,[%sp]100
8000be08:	99 a3 34 00 	ld.a %a3,[%sp]52
8000be0c:	42 2f       	add %d15,%d2
8000be0e:	78 19       	st.w [%sp]100,%d15
8000be10:	58 18       	ld.w %d15,[%sp]96
8000be12:	e8 03       	st.a [%a15]0,%a3
8000be14:	c2 1f       	add %d15,1
8000be16:	78 18       	st.w [%sp]96,%d15
8000be18:	8b 8f 80 f2 	ge %d15,%d15,8
8000be1c:	d9 ff 08 00 	lea %a15,[%a15]8
8000be20:	6e 0b       	jz %d15,8000be36 <_svfprintf_r+0xd8e>
8000be22:	60 c4       	mov.a %a4,%d12
8000be24:	60 b5       	mov.a %a5,%d11
8000be26:	d9 a6 1c 10 	lea %a6,[%sp]92
8000be2a:	6d 00 7f 0d 	call 8000d928 <__ssprint_r>
8000be2e:	df 02 08 82 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000be32:	d9 af 10 20 	lea %a15,[%sp]144
8000be36:	58 11       	ld.w %d15,[%sp]68
8000be38:	7b 00 00 88 	movh %d8,32768
8000be3c:	32 5f       	rsub %d15
8000be3e:	1b 08 dc 80 	addi %d8,%d8,3520
8000be42:	3b 00 01 90 	mov %d9,16
8000be46:	bf 1f 3a 00 	jlt %d15,1,8000beba <_svfprintf_r+0xe12>
8000be4a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000be4e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000be52:	8b 1f 81 42 	ge %d4,%d15,17
8000be56:	68 08       	st.w [%a15]0,%d8
8000be58:	df 04 1c 00 	jeq %d4,0,8000be90 <_svfprintf_r+0xde8>
8000be5c:	c2 13       	add %d3,1
8000be5e:	1b 05 01 40 	addi %d4,%d5,16
8000be62:	68 19       	st.w [%a15]4,%d9
8000be64:	59 a3 20 10 	st.w [%sp]96,%d3
8000be68:	59 a4 24 10 	st.w [%sp]100,%d4
8000be6c:	8b 83 80 32 	ge %d3,%d3,8
8000be70:	d9 ff 08 00 	lea %a15,[%a15]8
8000be74:	76 3b       	jz %d3,8000be8a <_svfprintf_r+0xde2>
8000be76:	60 c4       	mov.a %a4,%d12
8000be78:	60 b5       	mov.a %a5,%d11
8000be7a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000be7e:	6d 00 55 0d 	call 8000d928 <__ssprint_r>
8000be82:	df 02 de 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000be86:	d9 af 10 20 	lea %a15,[%sp]144
8000be8a:	1b 0f ff ff 	addi %d15,%d15,-16
8000be8e:	3c de       	j 8000be4a <_svfprintf_r+0xda2>
8000be90:	68 1f       	st.w [%a15]4,%d15
8000be92:	12 54       	add %d4,%d15,%d5
8000be94:	9a 13       	add %d15,%d3,1
8000be96:	78 18       	st.w [%sp]96,%d15
8000be98:	59 a4 24 10 	st.w [%sp]100,%d4
8000be9c:	8b 8f 80 f2 	ge %d15,%d15,8
8000bea0:	d9 ff 08 00 	lea %a15,[%a15]8
8000bea4:	6e 0b       	jz %d15,8000beba <_svfprintf_r+0xe12>
8000bea6:	60 c4       	mov.a %a4,%d12
8000bea8:	60 b5       	mov.a %a5,%d11
8000beaa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000beae:	6d 00 3d 0d 	call 8000d928 <__ssprint_r>
8000beb2:	df 02 c6 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000beb6:	d9 af 10 20 	lea %a15,[%sp]144
8000beba:	58 05       	ld.w %d15,[%sp]20
8000bebc:	68 0d       	st.w [%a15]0,%d13
8000bebe:	68 1f       	st.w [%a15]4,%d15
8000bec0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bec4:	58 19       	ld.w %d15,[%sp]100
8000bec6:	1d 00 4d 01 	j 8000c160 <_svfprintf_r+0x10b8>
8000beca:	58 05       	ld.w %d15,[%sp]20
8000becc:	74 ed       	st.w [%a14],%d13
8000bece:	3f f3 6a 00 	jlt %d3,%d15,8000bfa2 <_svfprintf_r+0xefa>
8000bed2:	02 f9       	mov %d9,%d15
8000bed4:	c2 18       	add %d8,1
8000bed6:	42 e9       	add %d9,%d14
8000bed8:	59 a8 20 10 	st.w [%sp]96,%d8
8000bedc:	6c e1       	st.w [%a14]4,%d15
8000bede:	59 a9 24 10 	st.w [%sp]100,%d9
8000bee2:	8b 88 80 82 	ge %d8,%d8,8
8000bee6:	d9 ef 08 00 	lea %a15,[%a14]8
8000beea:	76 8b       	jz %d8,8000bf00 <_svfprintf_r+0xe58>
8000beec:	60 c4       	mov.a %a4,%d12
8000beee:	60 b5       	mov.a %a5,%d11
8000bef0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bef4:	6d 00 1a 0d 	call 8000d928 <__ssprint_r>
8000bef8:	df 02 a3 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000befc:	d9 af 10 20 	lea %a15,[%sp]144
8000bf00:	58 11       	ld.w %d15,[%sp]68
8000bf02:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bf06:	7b 00 00 88 	movh %d8,32768
8000bf0a:	a2 2f       	sub %d15,%d2
8000bf0c:	1b 08 dc 80 	addi %d8,%d8,3520
8000bf10:	3b 00 01 90 	mov %d9,16
8000bf14:	bf 1f 3a 00 	jlt %d15,1,8000bf88 <_svfprintf_r+0xee0>
8000bf18:	19 a5 24 10 	ld.w %d5,[%sp]100
8000bf1c:	19 a3 20 10 	ld.w %d3,[%sp]96
8000bf20:	8b 1f 81 42 	ge %d4,%d15,17
8000bf24:	68 08       	st.w [%a15]0,%d8
8000bf26:	df 04 1c 00 	jeq %d4,0,8000bf5e <_svfprintf_r+0xeb6>
8000bf2a:	c2 13       	add %d3,1
8000bf2c:	1b 05 01 40 	addi %d4,%d5,16
8000bf30:	68 19       	st.w [%a15]4,%d9
8000bf32:	59 a3 20 10 	st.w [%sp]96,%d3
8000bf36:	59 a4 24 10 	st.w [%sp]100,%d4
8000bf3a:	8b 83 80 32 	ge %d3,%d3,8
8000bf3e:	d9 ff 08 00 	lea %a15,[%a15]8
8000bf42:	76 3b       	jz %d3,8000bf58 <_svfprintf_r+0xeb0>
8000bf44:	60 c4       	mov.a %a4,%d12
8000bf46:	60 b5       	mov.a %a5,%d11
8000bf48:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bf4c:	6d 00 ee 0c 	call 8000d928 <__ssprint_r>
8000bf50:	df 02 77 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bf54:	d9 af 10 20 	lea %a15,[%sp]144
8000bf58:	1b 0f ff ff 	addi %d15,%d15,-16
8000bf5c:	3c de       	j 8000bf18 <_svfprintf_r+0xe70>
8000bf5e:	68 1f       	st.w [%a15]4,%d15
8000bf60:	12 54       	add %d4,%d15,%d5
8000bf62:	9a 13       	add %d15,%d3,1
8000bf64:	78 18       	st.w [%sp]96,%d15
8000bf66:	59 a4 24 10 	st.w [%sp]100,%d4
8000bf6a:	8b 8f 80 f2 	ge %d15,%d15,8
8000bf6e:	d9 ff 08 00 	lea %a15,[%a15]8
8000bf72:	6e 0b       	jz %d15,8000bf88 <_svfprintf_r+0xee0>
8000bf74:	60 c4       	mov.a %a4,%d12
8000bf76:	60 b5       	mov.a %a5,%d11
8000bf78:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bf7c:	6d 00 d6 0c 	call 8000d928 <__ssprint_r>
8000bf80:	df 02 5f 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bf84:	d9 af 10 20 	lea %a15,[%sp]144
8000bf88:	80 df       	mov.d %d15,%a13
8000bf8a:	6f 0f f6 00 	jz.t %d15,0,8000c176 <_svfprintf_r+0x10ce>
8000bf8e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bf92:	58 08       	ld.w %d15,[%sp]32
8000bf94:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bf98:	68 1f       	st.w [%a15]4,%d15
8000bf9a:	e8 03       	st.a [%a15]0,%a3
8000bf9c:	58 19       	ld.w %d15,[%sp]100
8000bf9e:	1d 00 e1 00 	j 8000c160 <_svfprintf_r+0x10b8>
8000bfa2:	c2 18       	add %d8,1
8000bfa4:	59 e3 04 00 	st.w [%a14]4,%d3
8000bfa8:	42 e3       	add %d3,%d14
8000bfaa:	59 a8 20 10 	st.w [%sp]96,%d8
8000bfae:	59 a3 24 10 	st.w [%sp]100,%d3
8000bfb2:	8b 88 80 82 	ge %d8,%d8,8
8000bfb6:	d9 ef 08 00 	lea %a15,[%a14]8
8000bfba:	76 8b       	jz %d8,8000bfd0 <_svfprintf_r+0xf28>
8000bfbc:	60 c4       	mov.a %a4,%d12
8000bfbe:	60 b5       	mov.a %a5,%d11
8000bfc0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bfc4:	6d 00 b2 0c 	call 8000d928 <__ssprint_r>
8000bfc8:	df 02 3b 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000bfcc:	d9 af 10 20 	lea %a15,[%sp]144
8000bfd0:	58 08       	ld.w %d15,[%sp]32
8000bfd2:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bfd6:	68 1f       	st.w [%a15]4,%d15
8000bfd8:	58 19       	ld.w %d15,[%sp]100
8000bfda:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bfde:	42 2f       	add %d15,%d2
8000bfe0:	78 19       	st.w [%sp]100,%d15
8000bfe2:	58 18       	ld.w %d15,[%sp]96
8000bfe4:	99 ae 04 10 	ld.a %a14,[%sp]68
8000bfe8:	c2 1f       	add %d15,1
8000bfea:	60 d2       	mov.a %a2,%d13
8000bfec:	e8 03       	st.a [%a15]0,%a3
8000bfee:	78 18       	st.w [%sp]96,%d15
8000bff0:	8b 8f 80 f2 	ge %d15,%d15,8
8000bff4:	30 2e       	add.a %a14,%a2
8000bff6:	d9 ff 08 00 	lea %a15,[%a15]8
8000bffa:	6e 0b       	jz %d15,8000c010 <_svfprintf_r+0xf68>
8000bffc:	60 c4       	mov.a %a4,%d12
8000bffe:	60 b5       	mov.a %a5,%d11
8000c000:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c004:	6d 00 92 0c 	call 8000d928 <__ssprint_r>
8000c008:	df 02 1b 81 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c00c:	d9 af 10 20 	lea %a15,[%sp]144
8000c010:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c014:	58 11       	ld.w %d15,[%sp]68
8000c016:	e8 0e       	st.a [%a15]0,%a14
8000c018:	5a f2       	sub %d15,%d2,%d15
8000c01a:	68 1f       	st.w [%a15]4,%d15
8000c01c:	19 a2 24 10 	ld.w %d2,[%sp]100
8000c020:	1d 00 a0 00 	j 8000c160 <_svfprintf_r+0x10b8>
8000c024:	c2 18       	add %d8,1
8000c026:	82 13       	mov %d3,1
8000c028:	1b 1e 00 90 	addi %d9,%d14,1
8000c02c:	58 05       	ld.w %d15,[%sp]20
8000c02e:	59 a8 20 10 	st.w [%sp]96,%d8
8000c032:	74 ed       	st.w [%a14],%d13
8000c034:	59 e3 04 00 	st.w [%a14]4,%d3
8000c038:	59 a9 24 10 	st.w [%sp]100,%d9
8000c03c:	8b 88 80 82 	ge %d8,%d8,8
8000c040:	ff 2f 05 00 	jge %d15,2,8000c04a <_svfprintf_r+0xfa2>
8000c044:	80 d2       	mov.d %d2,%a13
8000c046:	6f 02 81 00 	jz.t %d2,0,8000c148 <_svfprintf_r+0x10a0>
8000c04a:	d9 ef 08 00 	lea %a15,[%a14]8
8000c04e:	76 8b       	jz %d8,8000c064 <_svfprintf_r+0xfbc>
8000c050:	60 c4       	mov.a %a4,%d12
8000c052:	60 b5       	mov.a %a5,%d11
8000c054:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c058:	6d 00 68 0c 	call 8000d928 <__ssprint_r>
8000c05c:	df 02 f1 80 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c060:	d9 af 10 20 	lea %a15,[%sp]144
8000c064:	58 08       	ld.w %d15,[%sp]32
8000c066:	19 a2 20 00 	ld.w %d2,[%sp]32
8000c06a:	68 1f       	st.w [%a15]4,%d15
8000c06c:	58 19       	ld.w %d15,[%sp]100
8000c06e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000c072:	42 2f       	add %d15,%d2
8000c074:	78 19       	st.w [%sp]100,%d15
8000c076:	58 18       	ld.w %d15,[%sp]96
8000c078:	e8 03       	st.a [%a15]0,%a3
8000c07a:	c2 1f       	add %d15,1
8000c07c:	78 18       	st.w [%sp]96,%d15
8000c07e:	8b 8f 80 f2 	ge %d15,%d15,8
8000c082:	d9 ff 08 00 	lea %a15,[%a15]8
8000c086:	6e 0b       	jz %d15,8000c09c <_svfprintf_r+0xff4>
8000c088:	60 c4       	mov.a %a4,%d12
8000c08a:	60 b5       	mov.a %a5,%d11
8000c08c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c090:	6d 00 4c 0c 	call 8000d928 <__ssprint_r>
8000c094:	df 02 d5 80 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c098:	d9 af 10 20 	lea %a15,[%sp]144
8000c09c:	d2 06       	mov %e6,0
8000c09e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000c0a2:	19 a5 30 00 	ld.w %d5,[%sp]48
8000c0a6:	6d 00 66 0f 	call 8000df72 <__nedf2>
8000c0aa:	58 05       	ld.w %d15,[%sp]20
8000c0ac:	c2 ff       	add %d15,-1
8000c0ae:	76 2c       	jz %d2,8000c0c6 <_svfprintf_r+0x101e>
8000c0b0:	19 a2 24 10 	ld.w %d2,[%sp]100
8000c0b4:	60 de       	mov.a %a14,%d13
8000c0b6:	68 1f       	st.w [%a15]4,%d15
8000c0b8:	42 2f       	add %d15,%d2
8000c0ba:	78 19       	st.w [%sp]100,%d15
8000c0bc:	58 18       	ld.w %d15,[%sp]96
8000c0be:	b0 1e       	add.a %a14,1
8000c0c0:	e8 0e       	st.a [%a15]0,%a14
8000c0c2:	c2 1f       	add %d15,1
8000c0c4:	3c 31       	j 8000c126 <_svfprintf_r+0x107e>
8000c0c6:	7b 00 00 88 	movh %d8,32768
8000c0ca:	1b 08 dc 80 	addi %d8,%d8,3520
8000c0ce:	3b 00 01 90 	mov %d9,16
8000c0d2:	bf 1f 3f 00 	jlt %d15,1,8000c150 <_svfprintf_r+0x10a8>
8000c0d6:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c0da:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c0de:	8b 1f 81 42 	ge %d4,%d15,17
8000c0e2:	68 08       	st.w [%a15]0,%d8
8000c0e4:	df 04 1c 00 	jeq %d4,0,8000c11c <_svfprintf_r+0x1074>
8000c0e8:	c2 13       	add %d3,1
8000c0ea:	1b 05 01 40 	addi %d4,%d5,16
8000c0ee:	68 19       	st.w [%a15]4,%d9
8000c0f0:	59 a3 20 10 	st.w [%sp]96,%d3
8000c0f4:	59 a4 24 10 	st.w [%sp]100,%d4
8000c0f8:	8b 83 80 32 	ge %d3,%d3,8
8000c0fc:	d9 ff 08 00 	lea %a15,[%a15]8
8000c100:	76 3b       	jz %d3,8000c116 <_svfprintf_r+0x106e>
8000c102:	60 c4       	mov.a %a4,%d12
8000c104:	60 b5       	mov.a %a5,%d11
8000c106:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c10a:	6d 00 0f 0c 	call 8000d928 <__ssprint_r>
8000c10e:	df 02 98 80 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c112:	d9 af 10 20 	lea %a15,[%sp]144
8000c116:	1b 0f ff ff 	addi %d15,%d15,-16
8000c11a:	3c de       	j 8000c0d6 <_svfprintf_r+0x102e>
8000c11c:	12 54       	add %d4,%d15,%d5
8000c11e:	68 1f       	st.w [%a15]4,%d15
8000c120:	59 a4 24 10 	st.w [%sp]100,%d4
8000c124:	9a 13       	add %d15,%d3,1
8000c126:	78 18       	st.w [%sp]96,%d15
8000c128:	8b 8f 80 f2 	ge %d15,%d15,8
8000c12c:	d9 ff 08 00 	lea %a15,[%a15]8
8000c130:	6e 10       	jz %d15,8000c150 <_svfprintf_r+0x10a8>
8000c132:	60 c4       	mov.a %a4,%d12
8000c134:	60 b5       	mov.a %a5,%d11
8000c136:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c13a:	6d 00 f7 0b 	call 8000d928 <__ssprint_r>
8000c13e:	df 02 80 80 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c142:	d9 af 10 20 	lea %a15,[%sp]144
8000c146:	3c 05       	j 8000c150 <_svfprintf_r+0x10a8>
8000c148:	df 08 f5 ff 	jne %d8,0,8000c132 <_svfprintf_r+0x108a>
8000c14c:	d9 ef 08 00 	lea %a15,[%a14]8
8000c150:	58 0e       	ld.w %d15,[%sp]56
8000c152:	d9 a3 0d 10 	lea %a3,[%sp]77
8000c156:	68 1f       	st.w [%a15]4,%d15
8000c158:	19 a2 38 00 	ld.w %d2,[%sp]56
8000c15c:	58 19       	ld.w %d15,[%sp]100
8000c15e:	e8 03       	st.a [%a15]0,%a3
8000c160:	42 2f       	add %d15,%d2
8000c162:	78 19       	st.w [%sp]100,%d15
8000c164:	58 18       	ld.w %d15,[%sp]96
8000c166:	c2 1f       	add %d15,1
8000c168:	78 18       	st.w [%sp]96,%d15
8000c16a:	8b 8f 80 f2 	ge %d15,%d15,8
8000c16e:	df 0f 8d fd 	jne %d15,0,8000bc88 <_svfprintf_r+0xbe0>
8000c172:	d9 ff 08 00 	lea %a15,[%a15]8
8000c176:	80 df       	mov.d %d15,%a13
8000c178:	ae 2d       	jnz.t %d15,2,8000c192 <_svfprintf_r+0x10ea>
8000c17a:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000c17e:	0b 2a a0 f1 	max %d15,%d10,%d2
8000c182:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c186:	42 f2       	add %d2,%d15
8000c188:	58 19       	ld.w %d15,[%sp]100
8000c18a:	59 a2 28 00 	st.w [%sp]40,%d2
8000c18e:	6e 49       	jz %d15,8000c220 <_svfprintf_r+0x1178>
8000c190:	3c 40       	j 8000c210 <_svfprintf_r+0x1168>
8000c192:	58 07       	ld.w %d15,[%sp]28
8000c194:	3b 00 01 80 	mov %d8,16
8000c198:	a2 af       	sub %d15,%d10
8000c19a:	bf 1f f0 7f 	jlt %d15,1,8000c17a <_svfprintf_r+0x10d2>
8000c19e:	91 00 00 28 	movh.a %a2,32768
8000c1a2:	d9 22 d0 70 	lea %a2,[%a2]3536 <80000dd0 <blanks.4035>>
8000c1a6:	19 a5 24 10 	ld.w %d5,[%sp]100 <80000dd0 <blanks.4035>>
8000c1aa:	19 a3 20 10 	ld.w %d3,[%sp]96 <80000dd0 <blanks.4035>>
8000c1ae:	8b 1f 81 42 	ge %d4,%d15,17
8000c1b2:	e8 02       	st.a [%a15]0,%a2
8000c1b4:	df 04 1c 00 	jeq %d4,0,8000c1ec <_svfprintf_r+0x1144>
8000c1b8:	c2 13       	add %d3,1
8000c1ba:	1b 05 01 40 	addi %d4,%d5,16
8000c1be:	68 18       	st.w [%a15]4,%d8
8000c1c0:	59 a3 20 10 	st.w [%sp]96,%d3
8000c1c4:	59 a4 24 10 	st.w [%sp]100,%d4
8000c1c8:	8b 83 80 32 	ge %d3,%d3,8
8000c1cc:	d9 ff 08 00 	lea %a15,[%a15]8
8000c1d0:	76 3b       	jz %d3,8000c1e6 <_svfprintf_r+0x113e>
8000c1d2:	60 c4       	mov.a %a4,%d12
8000c1d4:	60 b5       	mov.a %a5,%d11
8000c1d6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c1da:	6d 00 a7 0b 	call 8000d928 <__ssprint_r>
8000c1de:	df 02 30 80 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c1e2:	d9 af 10 20 	lea %a15,[%sp]144
8000c1e6:	1b 0f ff ff 	addi %d15,%d15,-16
8000c1ea:	3c da       	j 8000c19e <_svfprintf_r+0x10f6>
8000c1ec:	12 54       	add %d4,%d15,%d5
8000c1ee:	68 1f       	st.w [%a15]4,%d15
8000c1f0:	9a 13       	add %d15,%d3,1
8000c1f2:	78 18       	st.w [%sp]96,%d15
8000c1f4:	59 a4 24 10 	st.w [%sp]100,%d4
8000c1f8:	8b 8f 40 f2 	lt %d15,%d15,8
8000c1fc:	ee bf       	jnz %d15,8000c17a <_svfprintf_r+0x10d2>
8000c1fe:	60 c4       	mov.a %a4,%d12
8000c200:	60 b5       	mov.a %a5,%d11
8000c202:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c206:	6d 00 91 0b 	call 8000d928 <__ssprint_r>
8000c20a:	df 02 b8 7f 	jeq %d2,0,8000c17a <_svfprintf_r+0x10d2>
8000c20e:	3c 18       	j 8000c23e <_svfprintf_r+0x1196>
8000c210:	60 c4       	mov.a %a4,%d12
8000c212:	60 b5       	mov.a %a5,%d11
8000c214:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c218:	6d 00 88 0b 	call 8000d928 <__ssprint_r>
8000c21c:	df 02 11 80 	jne %d2,0,8000c23e <_svfprintf_r+0x1196>
8000c220:	82 0f       	mov %d15,0
8000c222:	78 18       	st.w [%sp]96,%d15
8000c224:	40 cf       	mov.aa %a15,%a12
8000c226:	d9 ae 10 20 	lea %a14,[%sp]144
8000c22a:	1d ff 77 f7 	j 8000b118 <_svfprintf_r+0x70>
8000c22e:	58 19       	ld.w %d15,[%sp]100
8000c230:	6e 07       	jz %d15,8000c23e <_svfprintf_r+0x1196>
8000c232:	60 c4       	mov.a %a4,%d12
8000c234:	60 b5       	mov.a %a5,%d11
8000c236:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c23a:	6d 00 77 0b 	call 8000d928 <__ssprint_r>
8000c23e:	60 b3       	mov.a %a3,%d11
8000c240:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c244:	8c 36       	ld.h %d15,[%a3]12
8000c246:	16 40       	and %d15,64
8000c248:	aa f2       	cmov %d2,%d15,-1
8000c24a:	00 90       	ret 

8000c24c <_vsnprintf_r>:
8000c24c:	20 68       	sub.a %sp,104
8000c24e:	40 4f       	mov.aa %a15,%a4
8000c250:	ce 45       	jgez %d4,8000c25a <_vsnprintf_r+0xe>
8000c252:	da 8b       	mov %d15,139
8000c254:	6c 40       	st.w [%a4]0,%d15
8000c256:	82 f2       	mov %d2,-1
8000c258:	00 90       	ret 
8000c25a:	02 4f       	mov %d15,%d4
8000c25c:	3b 80 20 20 	mov %d2,520
8000c260:	f9 a2 0c 00 	st.h [%sp]12,%d2
8000c264:	92 f2       	add %d2,%d15,-1
8000c266:	ea 02       	cmovn %d2,%d15,0
8000c268:	f4 a5       	st.a [%sp],%a5
8000c26a:	b5 a5 10 00 	st.a [%sp]16,%a5
8000c26e:	59 a2 08 00 	st.w [%sp]8,%d2
8000c272:	59 a2 14 00 	st.w [%sp]20,%d2
8000c276:	40 a5       	mov.aa %a5,%sp
8000c278:	82 f2       	mov %d2,-1
8000c27a:	f9 a2 0e 00 	st.h [%sp]14,%d2
8000c27e:	6d ff 15 f7 	call 8000b0a8 <_svfprintf_r>
8000c282:	ff f2 05 00 	jge %d2,-1,8000c28c <_vsnprintf_r+0x40>
8000c286:	3b b0 08 30 	mov %d3,139
8000c28a:	68 03       	st.w [%a15]0,%d3
8000c28c:	6e 04       	jz %d15,8000c294 <_vsnprintf_r+0x48>
8000c28e:	d8 00       	ld.a %a15,[%sp]0
8000c290:	82 0f       	mov %d15,0
8000c292:	28 0f       	st.b [%a15]0,%d15
8000c294:	00 90       	ret 

8000c296 <vsnprintf>:
8000c296:	91 00 00 37 	movh.a %a3,28672
8000c29a:	40 42       	mov.aa %a2,%a4
8000c29c:	99 34 68 30 	ld.a %a4,[%a3]1256 <700004e8 <_impure_ptr>>
8000c2a0:	40 5f       	mov.aa %a15,%a5
8000c2a2:	40 67       	mov.aa %a7,%a6
8000c2a4:	40 25       	mov.aa %a5,%a2
8000c2a6:	40 f6       	mov.aa %a6,%a15
8000c2a8:	1d ff d2 ff 	j 8000c24c <_vsnprintf_r>

8000c2ac <quorem>:
8000c2ac:	19 58 10 00 	ld.w %d8,[%a5]16
8000c2b0:	4c 44       	ld.w %d15,[%a4]16
8000c2b2:	82 02       	mov %d2,0
8000c2b4:	3f 8f 88 00 	jlt %d15,%d8,8000c3c4 <quorem+0x118>
8000c2b8:	c2 f8       	add %d8,-1
8000c2ba:	80 4f       	mov.d %d15,%a4
8000c2bc:	8f 28 00 20 	sh %d2,%d8,2
8000c2c0:	60 2f       	mov.a %a15,%d2
8000c2c2:	1b 4f 01 90 	addi %d9,%d15,20
8000c2c6:	d9 5c 14 00 	lea %a12,[%a5]20
8000c2ca:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000c2ce:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000c2d2:	54 dc       	ld.w %d12,[%a13]
8000c2d4:	4c f0       	ld.w %d15,[%a15]0
8000c2d6:	c2 1c       	add %d12,1
8000c2d8:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000c2dc:	02 ca       	mov %d10,%d12
8000c2de:	df 0c 3d 00 	jeq %d12,0,8000c358 <quorem+0xac>
8000c2e2:	60 96       	mov.a %a6,%d9
8000c2e4:	40 c2       	mov.aa %a2,%a12
8000c2e6:	82 05       	mov %d5,0
8000c2e8:	82 06       	mov %d6,0
8000c2ea:	54 22       	ld.w %d2,[%a2]
8000c2ec:	40 63       	mov.aa %a3,%a6
8000c2ee:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000c2f2:	8f 02 1f 20 	sh %d2,%d2,-16
8000c2f6:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000c2fa:	b0 42       	add.a %a2,4
8000c2fc:	8f 03 1f 40 	sh %d4,%d3,-16
8000c300:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000c304:	44 34       	ld.w %d4,[%a3+]
8000c306:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000c30a:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000c30e:	8f 02 1f 50 	sh %d5,%d2,-16
8000c312:	42 f6       	add %d6,%d15
8000c314:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000c318:	0b 36 80 30 	sub %d3,%d6,%d3
8000c31c:	8f 04 1f 40 	sh %d4,%d4,-16
8000c320:	8f 03 3f f0 	sha %d15,%d3,-16
8000c324:	0b 24 80 20 	sub %d2,%d4,%d2
8000c328:	42 f2       	add %d2,%d15
8000c32a:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000c32e:	8f 02 3f 60 	sha %d6,%d2,-16
8000c332:	80 2f       	mov.d %d15,%a2
8000c334:	80 d2       	mov.d %d2,%a13
8000c336:	74 63       	st.w [%a6],%d3
8000c338:	40 36       	mov.aa %a6,%a3
8000c33a:	7f f2 d8 ff 	jge.u %d2,%d15,8000c2ea <quorem+0x3e>
8000c33e:	4c f0       	ld.w %d15,[%a15]0
8000c340:	ee 0c       	jnz %d15,8000c358 <quorem+0xac>
8000c342:	b0 cf       	add.a %a15,-4
8000c344:	80 f2       	mov.d %d2,%a15
8000c346:	3f 29 05 80 	jlt.u %d9,%d2,8000c350 <quorem+0xa4>
8000c34a:	59 48 10 00 	st.w [%a4]16,%d8
8000c34e:	3c 05       	j 8000c358 <quorem+0xac>
8000c350:	4c f0       	ld.w %d15,[%a15]0
8000c352:	ee fc       	jnz %d15,8000c34a <quorem+0x9e>
8000c354:	c2 f8       	add %d8,-1
8000c356:	3c f6       	j 8000c342 <quorem+0x96>
8000c358:	40 4e       	mov.aa %a14,%a4
8000c35a:	6d 00 ec 09 	call 8000d732 <__mcmp>
8000c35e:	bf 02 32 00 	jlt %d2,0,8000c3c2 <quorem+0x116>
8000c362:	60 92       	mov.a %a2,%d9
8000c364:	1b 1c 00 a0 	addi %d10,%d12,1
8000c368:	82 04       	mov %d4,0
8000c36a:	40 2f       	mov.aa %a15,%a2
8000c36c:	44 f3       	ld.w %d3,[%a15+]
8000c36e:	54 c5       	ld.w %d5,[%a12]
8000c370:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000c374:	8f 05 1f f0 	sh %d15,%d5,-16
8000c378:	42 42       	add %d2,%d4
8000c37a:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000c37e:	8f 03 1f 30 	sh %d3,%d3,-16
8000c382:	a2 42       	sub %d2,%d4
8000c384:	8f 02 3f 40 	sha %d4,%d2,-16
8000c388:	a2 f3       	sub %d3,%d15
8000c38a:	42 43       	add %d3,%d4
8000c38c:	8f 03 3f 40 	sha %d4,%d3,-16
8000c390:	b0 4c       	add.a %a12,4
8000c392:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000c396:	80 df       	mov.d %d15,%a13
8000c398:	80 c2       	mov.d %d2,%a12
8000c39a:	74 23       	st.w [%a2],%d3
8000c39c:	40 f2       	mov.aa %a2,%a15
8000c39e:	7f 2f e6 ff 	jge.u %d15,%d2,8000c36a <quorem+0xbe>
8000c3a2:	60 92       	mov.a %a2,%d9
8000c3a4:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000c3a8:	4c f0       	ld.w %d15,[%a15]0
8000c3aa:	ee 0c       	jnz %d15,8000c3c2 <quorem+0x116>
8000c3ac:	b0 cf       	add.a %a15,-4
8000c3ae:	80 f2       	mov.d %d2,%a15
8000c3b0:	3f 29 05 80 	jlt.u %d9,%d2,8000c3ba <quorem+0x10e>
8000c3b4:	59 e8 10 00 	st.w [%a14]16,%d8
8000c3b8:	3c 05       	j 8000c3c2 <quorem+0x116>
8000c3ba:	4c f0       	ld.w %d15,[%a15]0
8000c3bc:	ee fc       	jnz %d15,8000c3b4 <quorem+0x108>
8000c3be:	c2 f8       	add %d8,-1
8000c3c0:	3c f6       	j 8000c3ac <quorem+0x100>
8000c3c2:	02 a2       	mov %d2,%d10
8000c3c4:	00 90       	ret 
	...

8000c3c8 <_dtoa_r>:
8000c3c8:	20 58       	sub.a %sp,88
8000c3ca:	b5 a5 08 10 	st.a [%sp]72,%a5
8000c3ce:	99 45 00 10 	ld.a %a5,[%a4]64
8000c3d2:	59 a6 1c 00 	st.w [%sp]28,%d6
8000c3d6:	59 a7 28 00 	st.w [%sp]40,%d7
8000c3da:	b5 a7 38 00 	st.a [%sp]56,%a7
8000c3de:	40 4d       	mov.aa %a13,%a4
8000c3e0:	0b 45 10 88 	mov %e8,%d5,%d4
8000c3e4:	40 6c       	mov.aa %a12,%a6
8000c3e6:	0b 45 10 c8 	mov %e12,%d5,%d4
8000c3ea:	bc 5e       	jz.a %a5,8000c406 <_dtoa_r+0x3e>
8000c3ec:	19 4f 04 10 	ld.w %d15,[%a4]68
8000c3f0:	82 12       	mov %d2,1
8000c3f2:	0f f2 00 20 	sh %d2,%d2,%d15
8000c3f6:	6c 51       	st.w [%a5]4,%d15
8000c3f8:	59 52 08 00 	st.w [%a5]8,%d2
8000c3fc:	82 0f       	mov %d15,0
8000c3fe:	6d 00 cc 07 	call 8000d396 <_Bfree>
8000c402:	59 df 00 10 	st.w [%a13]64,%d15
8000c406:	ce 96       	jgez %d9,8000c412 <_dtoa_r+0x4a>
8000c408:	82 1f       	mov %d15,1
8000c40a:	6c c0       	st.w [%a12]0,%d15
8000c40c:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000c410:	3c 03       	j 8000c416 <_dtoa_r+0x4e>
8000c412:	82 0f       	mov %d15,0
8000c414:	6c c0       	st.w [%a12]0,%d15
8000c416:	7b 00 ff 27 	movh %d2,32752
8000c41a:	26 d2       	and %d2,%d13
8000c41c:	7b 00 ff 37 	movh %d3,32752
8000c420:	5f 32 22 80 	jne %d2,%d3,8000c464 <_dtoa_r+0x9c>
8000c424:	99 a3 08 10 	ld.a %a3,[%sp]72
8000c428:	3b f0 70 22 	mov %d2,9999
8000c42c:	91 00 00 f8 	movh.a %a15,32768
8000c430:	74 32       	st.w [%a3],%d2
8000c432:	d9 ff e9 70 	lea %a15,[%a15]3561 <80000de9 <blanks.4035+0x19>>
8000c436:	f6 c8       	jnz %d12,8000c446 <_dtoa_r+0x7e>
8000c438:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000c43c:	ee 05       	jnz %d15,8000c446 <_dtoa_r+0x7e>
8000c43e:	91 00 00 f8 	movh.a %a15,32768
8000c442:	d9 ff e0 70 	lea %a15,[%a15]3552 <80000de0 <blanks.4035+0x10>>
8000c446:	99 a3 38 00 	ld.a %a3,[%sp]56 <80000de0 <blanks.4035+0x10>>
8000c44a:	40 f2       	mov.aa %a2,%a15
8000c44c:	bd 03 26 06 	jz.a %a3,8000d098 <_dtoa_r+0xcd0>
8000c450:	80 ff       	mov.d %d15,%a15
8000c452:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000c456:	1b 8f 00 20 	addi %d2,%d15,8
8000c45a:	c2 3f       	add %d15,3
8000c45c:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000c460:	6c 30       	st.w [%a3]0,%d15
8000c462:	00 90       	ret 
8000c464:	0b cd 10 48 	mov %e4,%d13,%d12
8000c468:	d2 06       	mov %e6,0
8000c46a:	0b cd 10 88 	mov %e8,%d13,%d12
8000c46e:	6d 00 62 0d 	call 8000df32 <__eqdf2>
8000c472:	df 02 13 80 	jne %d2,0,8000c498 <_dtoa_r+0xd0>
8000c476:	99 a3 08 10 	ld.a %a3,[%sp]72
8000c47a:	d8 0e       	ld.a %a15,[%sp]56
8000c47c:	82 1f       	mov %d15,1
8000c47e:	91 00 00 28 	movh.a %a2,32768
8000c482:	6c 30       	st.w [%a3]0,%d15
8000c484:	d9 22 ed 70 	lea %a2,[%a2]3565 <80000ded <blanks.4035+0x1d>>
8000c488:	bd 0f 08 06 	jz.a %a15,8000d098 <_dtoa_r+0xcd0>
8000c48c:	7b 00 00 f8 	movh %d15,32768
8000c490:	1b ef de f0 	addi %d15,%d15,3566
8000c494:	68 0f       	st.w [%a15]0,%d15
8000c496:	00 90       	ret 
8000c498:	0b cd 10 48 	mov %e4,%d13,%d12
8000c49c:	40 d4       	mov.aa %a4,%a13
8000c49e:	d9 a5 14 10 	lea %a5,[%sp]84
8000c4a2:	d9 a6 10 10 	lea %a6,[%sp]80
8000c4a6:	6d 00 cc 09 	call 8000d83e <__d2b>
8000c4aa:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000c4ae:	40 2e       	mov.aa %a14,%a2
8000c4b0:	19 aa 10 10 	ld.w %d10,[%sp]80
8000c4b4:	76 bd       	jz %d11,8000c4ce <_dtoa_r+0x106>
8000c4b6:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000c4ba:	0b cd 10 48 	mov %e4,%d13,%d12
8000c4be:	7b 00 ff 23 	movh %d2,16368
8000c4c2:	0f 2f a0 50 	or %d5,%d15,%d2
8000c4c6:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000c4ca:	82 0f       	mov %d15,0
8000c4cc:	3c 22       	j 8000c510 <_dtoa_r+0x148>
8000c4ce:	19 ab 14 10 	ld.w %d11,[%sp]84
8000c4d2:	3b e0 be 4f 	mov %d4,-1042
8000c4d6:	42 ab       	add %d11,%d10
8000c4d8:	a2 b4       	sub %d4,%d11
8000c4da:	3b f0 be 2f 	mov %d2,-1041
8000c4de:	0f 4c 00 40 	sh %d4,%d12,%d4
8000c4e2:	3f 2b 0f 00 	jlt %d11,%d2,8000c500 <_dtoa_r+0x138>
8000c4e6:	1b 2b 41 30 	addi %d3,%d11,1042
8000c4ea:	3b e0 c0 4f 	mov %d4,-1010
8000c4ee:	a2 b4       	sub %d4,%d11
8000c4f0:	8b 03 00 21 	rsub %d2,%d3,0
8000c4f4:	0f 2c 00 20 	sh %d2,%d12,%d2
8000c4f8:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000c4fc:	0f f2 a0 40 	or %d4,%d2,%d15
8000c500:	6d ff 94 f1 	call 8000a828 <__floatunsidf>
8000c504:	0b 23 10 48 	mov %e4,%d3,%d2
8000c508:	9b 03 e1 5f 	addih %d5,%d3,65040
8000c50c:	c2 fb       	add %d11,-1
8000c50e:	82 1f       	mov %d15,1
8000c510:	b7 00 ab 69 	imask %e6,0,19,11
8000c514:	78 13       	st.w [%sp]76,%d15
8000c516:	6d ff ba ef 	call 8000a48a <__subdf3>
8000c51a:	7b 30 fd 73 	movh %d7,16339
8000c51e:	0b 23 10 48 	mov %e4,%d3,%d2
8000c522:	7b f0 36 66 	movh %d6,25455
8000c526:	1b 77 7a 78 	addi %d7,%d7,-30809
8000c52a:	1b 16 36 64 	addi %d6,%d6,17249
8000c52e:	6d ff ce ef 	call 8000a4ca <__muldf3>
8000c532:	7b 70 fc 73 	movh %d7,16327
8000c536:	0b 23 10 48 	mov %e4,%d3,%d2
8000c53a:	7b 10 b6 68 	movh %d6,35681
8000c53e:	1b 87 a2 78 	addi %d7,%d7,-30168
8000c542:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000c546:	6d ff 86 ef 	call 8000a452 <__adddf3>
8000c54a:	02 b4       	mov %d4,%d11
8000c54c:	0b 23 10 88 	mov %e8,%d3,%d2
8000c550:	6d ff 1b f1 	call 8000a786 <__floatsidf>
8000c554:	7b 30 fd 73 	movh %d7,16339
8000c558:	0b 23 10 48 	mov %e4,%d3,%d2
8000c55c:	7b f0 09 65 	movh %d6,20639
8000c560:	1b 37 41 74 	addi %d7,%d7,17427
8000c564:	1b b6 9f 67 	addi %d6,%d6,31227
8000c568:	6d ff b1 ef 	call 8000a4ca <__muldf3>
8000c56c:	0b 89 10 48 	mov %e4,%d9,%d8
8000c570:	0b 23 10 68 	mov %e6,%d3,%d2
8000c574:	6d ff 6f ef 	call 8000a452 <__adddf3>
8000c578:	0b 23 10 48 	mov %e4,%d3,%d2
8000c57c:	0b 23 10 88 	mov %e8,%d3,%d2
8000c580:	6d 00 79 0d 	call 8000e072 <__fixdfsi>
8000c584:	0b 89 10 48 	mov %e4,%d9,%d8
8000c588:	d2 06       	mov %e6,0
8000c58a:	59 a2 08 00 	st.w [%sp]8,%d2
8000c58e:	6d 00 52 0d 	call 8000e032 <__ltdf2>
8000c592:	ff 02 12 00 	jge %d2,0,8000c5b6 <_dtoa_r+0x1ee>
8000c596:	19 a4 08 00 	ld.w %d4,[%sp]8
8000c59a:	6d ff f6 f0 	call 8000a786 <__floatsidf>
8000c59e:	0b 89 10 48 	mov %e4,%d9,%d8
8000c5a2:	0b 23 10 68 	mov %e6,%d3,%d2
8000c5a6:	6d 00 e6 0c 	call 8000df72 <__nedf2>
8000c5aa:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c5ae:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000c5b2:	59 a3 08 00 	st.w [%sp]8,%d3
8000c5b6:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c5ba:	82 13       	mov %d3,1
8000c5bc:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000c5c0:	59 a3 3c 00 	st.w [%sp]60,%d3
8000c5c4:	ee 18       	jnz %d15,8000c5f4 <_dtoa_r+0x22c>
8000c5c6:	91 00 00 f8 	movh.a %a15,32768
8000c5ca:	d9 ff d8 a0 	lea %a15,[%a15]3736 <80000e98 <__mprec_tens>>
8000c5ce:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000c5d2:	0b cd 10 68 	mov %e6,%d13,%d12
8000c5d6:	09 f4 40 09 	ld.d %e4,[%a15]
8000c5da:	6d 00 ec 0c 	call 8000dfb2 <__gtdf2>
8000c5de:	8e 28       	jlez %d2,8000c5ee <_dtoa_r+0x226>
8000c5e0:	58 02       	ld.w %d15,[%sp]8
8000c5e2:	82 02       	mov %d2,0
8000c5e4:	c2 ff       	add %d15,-1
8000c5e6:	78 02       	st.w [%sp]8,%d15
8000c5e8:	59 a2 3c 00 	st.w [%sp]60,%d2
8000c5ec:	3c 04       	j 8000c5f4 <_dtoa_r+0x22c>
8000c5ee:	82 03       	mov %d3,0
8000c5f0:	59 a3 3c 00 	st.w [%sp]60,%d3
8000c5f4:	0b ba 80 b0 	sub %d11,%d10,%d11
8000c5f8:	9a fb       	add %d15,%d11,-1
8000c5fa:	82 02       	mov %d2,0
8000c5fc:	78 06       	st.w [%sp]24,%d15
8000c5fe:	59 a2 14 00 	st.w [%sp]20,%d2
8000c602:	ce f6       	jgez %d15,8000c60e <_dtoa_r+0x246>
8000c604:	32 5f       	rsub %d15
8000c606:	82 03       	mov %d3,0
8000c608:	78 05       	st.w [%sp]20,%d15
8000c60a:	59 a3 18 00 	st.w [%sp]24,%d3
8000c60e:	58 02       	ld.w %d15,[%sp]8
8000c610:	0e fa       	jltz %d15,8000c624 <_dtoa_r+0x25c>
8000c612:	19 a2 18 00 	ld.w %d2,[%sp]24
8000c616:	78 0d       	st.w [%sp]52,%d15
8000c618:	42 f2       	add %d2,%d15
8000c61a:	82 0f       	mov %d15,0
8000c61c:	59 a2 18 00 	st.w [%sp]24,%d2
8000c620:	78 08       	st.w [%sp]32,%d15
8000c622:	3c 0d       	j 8000c63c <_dtoa_r+0x274>
8000c624:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c628:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c62c:	82 0f       	mov %d15,0
8000c62e:	a2 32       	sub %d2,%d3
8000c630:	32 53       	rsub %d3
8000c632:	59 a2 14 00 	st.w [%sp]20,%d2
8000c636:	59 a3 20 00 	st.w [%sp]32,%d3
8000c63a:	78 0d       	st.w [%sp]52,%d15
8000c63c:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000c640:	82 18       	mov %d8,1
8000c642:	ff a2 46 80 	jge.u %d2,10,8000c6ce <_dtoa_r+0x306>
8000c646:	bf 62 06 00 	jlt %d2,6,8000c652 <_dtoa_r+0x28a>
8000c64a:	c2 c2       	add %d2,-4
8000c64c:	59 a2 1c 00 	st.w [%sp]28,%d2
8000c650:	82 08       	mov %d8,0
8000c652:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000c656:	c2 e3       	add %d3,-2
8000c658:	ff 43 4b 80 	jge.u %d3,4,8000c6ee <_dtoa_r+0x326>
8000c65c:	91 10 00 f8 	movh.a %a15,32769
8000c660:	d9 ff 6c 9c 	lea %a15,[%a15]-14740 <8000c66c <_dtoa_r+0x2a4>>
8000c664:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000c668:	dc 0f       	ji %a15
8000c66a:	00 00       	nop 
8000c66c:	1d 00 08 00 	j 8000c67c <_dtoa_r+0x2b4>
8000c670:	1d 00 1c 00 	j 8000c6a8 <_dtoa_r+0x2e0>
8000c674:	1d 00 08 00 	j 8000c684 <_dtoa_r+0x2bc>
8000c678:	1d 00 1c 00 	j 8000c6b0 <_dtoa_r+0x2e8>
8000c67c:	82 03       	mov %d3,0
8000c67e:	59 a3 24 00 	st.w [%sp]36,%d3
8000c682:	3c 03       	j 8000c688 <_dtoa_r+0x2c0>
8000c684:	82 1f       	mov %d15,1
8000c686:	78 09       	st.w [%sp]36,%d15
8000c688:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c68c:	59 a2 2c 00 	st.w [%sp]44,%d2
8000c690:	59 a2 10 00 	st.w [%sp]16,%d2
8000c694:	02 23       	mov %d3,%d2
8000c696:	ff 12 38 00 	jge %d2,1,8000c706 <_dtoa_r+0x33e>
8000c69a:	82 13       	mov %d3,1
8000c69c:	82 1f       	mov %d15,1
8000c69e:	59 a3 2c 00 	st.w [%sp]44,%d3
8000c6a2:	78 04       	st.w [%sp]16,%d15
8000c6a4:	82 12       	mov %d2,1
8000c6a6:	3c 21       	j 8000c6e8 <_dtoa_r+0x320>
8000c6a8:	82 03       	mov %d3,0
8000c6aa:	59 a3 24 00 	st.w [%sp]36,%d3
8000c6ae:	3c 03       	j 8000c6b4 <_dtoa_r+0x2ec>
8000c6b0:	82 1f       	mov %d15,1
8000c6b2:	78 09       	st.w [%sp]36,%d15
8000c6b4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c6b8:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c6bc:	42 32       	add %d2,%d3
8000c6be:	59 a2 2c 00 	st.w [%sp]44,%d2
8000c6c2:	c2 12       	add %d2,1
8000c6c4:	59 a2 10 00 	st.w [%sp]16,%d2
8000c6c8:	8b 12 40 33 	max %d3,%d2,1
8000c6cc:	3c 1d       	j 8000c706 <_dtoa_r+0x33e>
8000c6ce:	82 0f       	mov %d15,0
8000c6d0:	82 12       	mov %d2,1
8000c6d2:	82 f3       	mov %d3,-1
8000c6d4:	78 07       	st.w [%sp]28,%d15
8000c6d6:	82 ff       	mov %d15,-1
8000c6d8:	59 a2 24 00 	st.w [%sp]36,%d2
8000c6dc:	59 a3 2c 00 	st.w [%sp]44,%d3
8000c6e0:	78 04       	st.w [%sp]16,%d15
8000c6e2:	3b 20 01 30 	mov %d3,18
8000c6e6:	82 02       	mov %d2,0
8000c6e8:	59 a2 28 00 	st.w [%sp]40,%d2
8000c6ec:	3c 0d       	j 8000c706 <_dtoa_r+0x33e>
8000c6ee:	82 ff       	mov %d15,-1
8000c6f0:	82 13       	mov %d3,1
8000c6f2:	78 0b       	st.w [%sp]44,%d15
8000c6f4:	82 f2       	mov %d2,-1
8000c6f6:	82 0f       	mov %d15,0
8000c6f8:	59 a3 24 00 	st.w [%sp]36,%d3
8000c6fc:	59 a2 10 00 	st.w [%sp]16,%d2
8000c700:	3b 20 01 30 	mov %d3,18
8000c704:	78 0a       	st.w [%sp]40,%d15
8000c706:	82 05       	mov %d5,0
8000c708:	59 d5 04 10 	st.w [%a13]68,%d5
8000c70c:	82 45       	mov %d5,4
8000c70e:	1b 45 01 00 	addi %d0,%d5,20
8000c712:	3f 03 09 80 	jlt.u %d3,%d0,8000c724 <_dtoa_r+0x35c>
8000c716:	19 d0 04 10 	ld.w %d0,[%a13]68
8000c71a:	06 15       	sh %d5,1
8000c71c:	c2 10       	add %d0,1
8000c71e:	59 d0 04 10 	st.w [%a13]68,%d0
8000c722:	3c f6       	j 8000c70e <_dtoa_r+0x346>
8000c724:	40 d4       	mov.aa %a4,%a13
8000c726:	19 d4 04 10 	ld.w %d4,[%a13]68
8000c72a:	6d 00 0b 06 	call 8000d340 <_Balloc>
8000c72e:	19 a2 10 00 	ld.w %d2,[%sp]16
8000c732:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000c736:	8b f2 60 32 	lt.u %d3,%d2,15
8000c73a:	b5 d2 00 10 	st.a [%a13]64,%a2
8000c73e:	26 38       	and %d8,%d3
8000c740:	df 08 97 01 	jeq %d8,0,8000ca6e <_dtoa_r+0x6a6>
8000c744:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c748:	89 ac 40 19 	st.d [%sp]64,%e12
8000c74c:	bf 13 3f 00 	jlt %d3,1,8000c7ca <_dtoa_r+0x402>
8000c750:	91 00 00 f8 	movh.a %a15,32768
8000c754:	8f f3 00 31 	and %d3,%d3,15
8000c758:	d9 ff d8 a0 	lea %a15,[%a15]3736 <80000e98 <__mprec_tens>>
8000c75c:	19 ae 08 00 	ld.w %d14,[%sp]8 <80000e98 <__mprec_tens>>
8000c760:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000c764:	86 ce       	sha %d14,-4
8000c766:	09 f8 40 09 	ld.d %e8,[%a15]
8000c76a:	82 2a       	mov %d10,2
8000c76c:	6f 4e 11 00 	jz.t %d14,4,8000c78e <_dtoa_r+0x3c6>
8000c770:	91 00 00 f8 	movh.a %a15,32768
8000c774:	0b cd 10 48 	mov %e4,%d13,%d12
8000c778:	d9 ff f0 90 	lea %a15,[%a15]3696 <80000e70 <__mprec_bigtens>>
8000c77c:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000c780:	6d ff 77 ef 	call 8000a66e <__divdf3>
8000c784:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c788:	8f fe 00 e1 	and %d14,%d14,15
8000c78c:	82 3a       	mov %d10,3
8000c78e:	7b 00 00 b8 	movh %d11,32768
8000c792:	82 0f       	mov %d15,0
8000c794:	1b 0b e7 b0 	addi %d11,%d11,3696
8000c798:	df 0e 12 00 	jeq %d14,0,8000c7bc <_dtoa_r+0x3f4>
8000c79c:	6f 0e 0d 00 	jz.t %d14,0,8000c7b6 <_dtoa_r+0x3ee>
8000c7a0:	60 b2       	mov.a %a2,%d11
8000c7a2:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000c7a4:	0b 89 10 48 	mov %e4,%d9,%d8
8000c7a8:	09 f6 40 09 	ld.d %e6,[%a15]
8000c7ac:	6d ff 8f ee 	call 8000a4ca <__muldf3>
8000c7b0:	0b 23 10 88 	mov %e8,%d3,%d2
8000c7b4:	c2 1a       	add %d10,1
8000c7b6:	86 fe       	sha %d14,-1
8000c7b8:	c2 1f       	add %d15,1
8000c7ba:	3c ef       	j 8000c798 <_dtoa_r+0x3d0>
8000c7bc:	0b cd 10 48 	mov %e4,%d13,%d12
8000c7c0:	0b 89 10 68 	mov %e6,%d9,%d8
8000c7c4:	6d ff 55 ef 	call 8000a66e <__divdf3>
8000c7c8:	3c 2c       	j 8000c820 <_dtoa_r+0x458>
8000c7ca:	19 a8 08 00 	ld.w %d8,[%sp]8
8000c7ce:	82 2a       	mov %d10,2
8000c7d0:	32 58       	rsub %d8
8000c7d2:	df 08 29 00 	jeq %d8,0,8000c824 <_dtoa_r+0x45c>
8000c7d6:	91 00 00 f8 	movh.a %a15,32768
8000c7da:	8f f8 00 31 	and %d3,%d8,15
8000c7de:	d9 ff d8 a0 	lea %a15,[%a15]3736 <80000e98 <__mprec_tens>>
8000c7e2:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000c7e6:	09 a4 40 19 	ld.d %e4,[%sp]64
8000c7ea:	09 f6 40 09 	ld.d %e6,[%a15]
8000c7ee:	7b 00 00 c8 	movh %d12,32768
8000c7f2:	6d ff 6c ee 	call 8000a4ca <__muldf3>
8000c7f6:	82 09       	mov %d9,0
8000c7f8:	86 c8       	sha %d8,-4
8000c7fa:	1b 0c e7 c0 	addi %d12,%d12,3696
8000c7fe:	df 08 11 00 	jeq %d8,0,8000c820 <_dtoa_r+0x458>
8000c802:	6f 08 0c 00 	jz.t %d8,0,8000c81a <_dtoa_r+0x452>
8000c806:	60 c3       	mov.a %a3,%d12
8000c808:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000c80c:	0b 23 10 48 	mov %e4,%d3,%d2
8000c810:	09 f6 40 09 	ld.d %e6,[%a15]
8000c814:	c2 1a       	add %d10,1
8000c816:	6d ff 5a ee 	call 8000a4ca <__muldf3>
8000c81a:	86 f8       	sha %d8,-1
8000c81c:	c2 19       	add %d9,1
8000c81e:	3c f0       	j 8000c7fe <_dtoa_r+0x436>
8000c820:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c824:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000c828:	df 02 23 00 	jeq %d2,0,8000c86e <_dtoa_r+0x4a6>
8000c82c:	0b cd 10 48 	mov %e4,%d13,%d12
8000c830:	b7 00 2a 6a 	imask %e6,0,20,10
8000c834:	6d 00 ff 0b 	call 8000e032 <__ltdf2>
8000c838:	ff 02 20 00 	jge %d2,0,8000c878 <_dtoa_r+0x4b0>
8000c83c:	19 a3 10 00 	ld.w %d3,[%sp]16
8000c840:	df 03 21 00 	jeq %d3,0,8000c882 <_dtoa_r+0x4ba>
8000c844:	58 0b       	ld.w %d15,[%sp]44
8000c846:	bf 1f 12 01 	jlt %d15,1,8000ca6a <_dtoa_r+0x6a2>
8000c84a:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c84e:	0b cd 10 48 	mov %e4,%d13,%d12
8000c852:	c2 f2       	add %d2,-1
8000c854:	82 06       	mov %d6,0
8000c856:	7b 40 02 74 	movh %d7,16420
8000c85a:	59 a2 30 00 	st.w [%sp]48,%d2
8000c85e:	6d ff 36 ee 	call 8000a4ca <__muldf3>
8000c862:	c2 1a       	add %d10,1
8000c864:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c868:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000c86c:	3c 10       	j 8000c88c <_dtoa_r+0x4c4>
8000c86e:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c872:	59 a3 30 00 	st.w [%sp]48,%d3
8000c876:	3c 03       	j 8000c87c <_dtoa_r+0x4b4>
8000c878:	58 02       	ld.w %d15,[%sp]8
8000c87a:	78 0c       	st.w [%sp]48,%d15
8000c87c:	99 ac 10 00 	ld.a %a12,[%sp]16
8000c880:	3c 06       	j 8000c88c <_dtoa_r+0x4c4>
8000c882:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c886:	a0 0c       	mov.a %a12,0
8000c888:	59 a2 30 00 	st.w [%sp]48,%d2
8000c88c:	02 a4       	mov %d4,%d10
8000c88e:	6d ff 7c ef 	call 8000a786 <__floatsidf>
8000c892:	0b cd 10 68 	mov %e6,%d13,%d12
8000c896:	0b 23 10 48 	mov %e4,%d3,%d2
8000c89a:	6d ff 18 ee 	call 8000a4ca <__muldf3>
8000c89e:	0b 23 10 48 	mov %e4,%d3,%d2
8000c8a2:	82 06       	mov %d6,0
8000c8a4:	7b c0 01 74 	movh %d7,16412
8000c8a8:	6d ff d5 ed 	call 8000a452 <__adddf3>
8000c8ac:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c8b0:	0b 23 10 e8 	mov %e14,%d3,%d2
8000c8b4:	60 b2       	mov.a %a2,%d11
8000c8b6:	11 02 cc ff 	addih.a %a15,%a2,64704
8000c8ba:	80 ff       	mov.d %d15,%a15
8000c8bc:	bd 0c 1e 80 	jnz.a %a12,8000c8f8 <_dtoa_r+0x530>
8000c8c0:	0b cd 10 48 	mov %e4,%d13,%d12
8000c8c4:	82 06       	mov %d6,0
8000c8c6:	7b 40 01 74 	movh %d7,16404
8000c8ca:	6d ff e0 ed 	call 8000a48a <__subdf3>
8000c8ce:	80 f7       	mov.d %d7,%a15
8000c8d0:	0b 23 10 48 	mov %e4,%d3,%d2
8000c8d4:	02 e6       	mov %d6,%d14
8000c8d6:	0b 23 10 88 	mov %e8,%d3,%d2
8000c8da:	6d 00 6c 0b 	call 8000dfb2 <__gtdf2>
8000c8de:	ff 12 8e 02 	jge %d2,1,8000cdfa <_dtoa_r+0xa32>
8000c8e2:	0b 89 10 48 	mov %e4,%d9,%d8
8000c8e6:	02 e6       	mov %d6,%d14
8000c8e8:	9b 0b cc 77 	addih %d7,%d11,31936
8000c8ec:	6d 00 a3 0b 	call 8000e032 <__ltdf2>
8000c8f0:	bf 02 7d 02 	jlt %d2,0,8000cdea <_dtoa_r+0xa22>
8000c8f4:	1d 00 bb 00 	j 8000ca6a <_dtoa_r+0x6a2>
8000c8f8:	80 c5       	mov.d %d5,%a12
8000c8fa:	91 00 00 f8 	movh.a %a15,32768
8000c8fe:	19 a2 24 00 	ld.w %d2,[%sp]36
8000c902:	d9 ff d8 a0 	lea %a15,[%a15]3736 <80000e98 <__mprec_tens>>
8000c906:	c2 f5       	add %d5,-1
8000c908:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000c90c:	df 02 57 00 	jeq %d2,0,8000c9ba <_dtoa_r+0x5f2>
8000c910:	b7 00 a9 4a 	imask %e4,0,21,9
8000c914:	09 f6 40 09 	ld.d %e6,[%a15]
8000c918:	6d ff ab ee 	call 8000a66e <__divdf3>
8000c91c:	0b ef 10 68 	mov %e6,%d15,%d14
8000c920:	0b 23 10 48 	mov %e4,%d3,%d2
8000c924:	6d ff b3 ed 	call 8000a48a <__subdf3>
8000c928:	d8 03       	ld.a %a15,[%sp]12
8000c92a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c92e:	0b cd 10 48 	mov %e4,%d13,%d12
8000c932:	80 fe       	mov.d %d14,%a15
8000c934:	6d 00 9f 0b 	call 8000e072 <__fixdfsi>
8000c938:	02 24       	mov %d4,%d2
8000c93a:	02 2f       	mov %d15,%d2
8000c93c:	6d ff 25 ef 	call 8000a786 <__floatsidf>
8000c940:	0b cd 10 48 	mov %e4,%d13,%d12
8000c944:	0b 23 10 68 	mov %e6,%d3,%d2
8000c948:	c2 1e       	add %d14,1
8000c94a:	6d ff a0 ed 	call 8000a48a <__subdf3>
8000c94e:	1b 0f 03 50 	addi %d5,%d15,48
8000c952:	28 05       	st.b [%a15]0,%d5
8000c954:	0b ab 10 68 	mov %e6,%d11,%d10
8000c958:	0b 23 10 48 	mov %e4,%d3,%d2
8000c95c:	0b 23 10 88 	mov %e8,%d3,%d2
8000c960:	6d 00 69 0b 	call 8000e032 <__ltdf2>
8000c964:	bf 02 86 03 	jlt %d2,0,8000d070 <_dtoa_r+0xca8>
8000c968:	b7 00 2a 4a 	imask %e4,0,20,10
8000c96c:	0b 89 10 68 	mov %e6,%d9,%d8
8000c970:	6d ff 8d ed 	call 8000a48a <__subdf3>
8000c974:	0b ab 10 68 	mov %e6,%d11,%d10
8000c978:	0b 23 10 48 	mov %e4,%d3,%d2
8000c97c:	6d 00 5b 0b 	call 8000e032 <__ltdf2>
8000c980:	bf 02 ea 00 	jlt %d2,0,8000cb54 <_dtoa_r+0x78c>
8000c984:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000c988:	02 e5       	mov %d5,%d14
8000c98a:	80 cf       	mov.d %d15,%a12
8000c98c:	a2 35       	sub %d5,%d3
8000c98e:	7f f5 6e 00 	jge %d5,%d15,8000ca6a <_dtoa_r+0x6a2>
8000c992:	0b ab 10 48 	mov %e4,%d11,%d10
8000c996:	82 06       	mov %d6,0
8000c998:	7b 40 02 74 	movh %d7,16420
8000c99c:	6d ff 97 ed 	call 8000a4ca <__muldf3>
8000c9a0:	0b 89 10 48 	mov %e4,%d9,%d8
8000c9a4:	82 06       	mov %d6,0
8000c9a6:	7b 40 02 74 	movh %d7,16420
8000c9aa:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c9ae:	6d ff 8e ed 	call 8000a4ca <__muldf3>
8000c9b2:	60 ef       	mov.a %a15,%d14
8000c9b4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c9b8:	3c bb       	j 8000c92e <_dtoa_r+0x566>
8000c9ba:	0b ef 10 68 	mov %e6,%d15,%d14
8000c9be:	09 f4 40 09 	ld.d %e4,[%a15]
8000c9c2:	6d ff 84 ed 	call 8000a4ca <__muldf3>
8000c9c6:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000c9ca:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c9ce:	30 c3       	add.a %a3,%a12
8000c9d0:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000c9d4:	80 3e       	mov.d %d14,%a3
8000c9d6:	0b cd 10 48 	mov %e4,%d13,%d12
8000c9da:	d9 cf 01 00 	lea %a15,[%a12]1
8000c9de:	6d 00 4a 0b 	call 8000e072 <__fixdfsi>
8000c9e2:	02 24       	mov %d4,%d2
8000c9e4:	02 2f       	mov %d15,%d2
8000c9e6:	6d ff d0 ee 	call 8000a786 <__floatsidf>
8000c9ea:	0b cd 10 48 	mov %e4,%d13,%d12
8000c9ee:	0b 23 10 68 	mov %e6,%d3,%d2
8000c9f2:	6d ff 4c ed 	call 8000a48a <__subdf3>
8000c9f6:	1b 0f 03 50 	addi %d5,%d15,48
8000c9fa:	0b 23 10 88 	mov %e8,%d3,%d2
8000c9fe:	80 f2       	mov.d %d2,%a15
8000ca00:	34 c5       	st.b [%a12],%d5
8000ca02:	5f e2 29 80 	jne %d2,%d14,8000ca54 <_dtoa_r+0x68c>
8000ca06:	0b ab 10 48 	mov %e4,%d11,%d10
8000ca0a:	b7 00 a9 6a 	imask %e6,0,21,9
8000ca0e:	6d ff 22 ed 	call 8000a452 <__adddf3>
8000ca12:	0b 89 10 48 	mov %e4,%d9,%d8
8000ca16:	0b 23 10 68 	mov %e6,%d3,%d2
8000ca1a:	6d 00 cc 0a 	call 8000dfb2 <__gtdf2>
8000ca1e:	ff 12 9b 00 	jge %d2,1,8000cb54 <_dtoa_r+0x78c>
8000ca22:	b7 00 a9 4a 	imask %e4,0,21,9
8000ca26:	0b ab 10 68 	mov %e6,%d11,%d10
8000ca2a:	6d ff 30 ed 	call 8000a48a <__subdf3>
8000ca2e:	0b 89 10 48 	mov %e4,%d9,%d8
8000ca32:	0b 23 10 68 	mov %e6,%d3,%d2
8000ca36:	6d 00 fe 0a 	call 8000e032 <__ltdf2>
8000ca3a:	ff 02 18 00 	jge %d2,0,8000ca6a <_dtoa_r+0x6a2>
8000ca3e:	60 e2       	mov.a %a2,%d14
8000ca40:	60 ef       	mov.a %a15,%d14
8000ca42:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000ca46:	b0 ff       	add.a %a15,-1
8000ca48:	8b 0f 03 f2 	eq %d15,%d15,48
8000ca4c:	df 0f 12 03 	jeq %d15,0,8000d070 <_dtoa_r+0xca8>
8000ca50:	80 fe       	mov.d %d14,%a15
8000ca52:	3c f6       	j 8000ca3e <_dtoa_r+0x676>
8000ca54:	0b 89 10 48 	mov %e4,%d9,%d8
8000ca58:	82 06       	mov %d6,0
8000ca5a:	7b 40 02 74 	movh %d7,16420
8000ca5e:	6d ff 36 ed 	call 8000a4ca <__muldf3>
8000ca62:	40 fc       	mov.aa %a12,%a15
8000ca64:	0b 23 10 c8 	mov %e12,%d3,%d2
8000ca68:	3c b7       	j 8000c9d6 <_dtoa_r+0x60e>
8000ca6a:	09 ac 40 19 	ld.d %e12,[%sp]64
8000ca6e:	19 a3 14 10 	ld.w %d3,[%sp]84
8000ca72:	19 a2 08 00 	ld.w %d2,[%sp]8
8000ca76:	8b 03 80 52 	ge %d5,%d3,0
8000ca7a:	8b f2 40 54 	and.lt %d5,%d2,15
8000ca7e:	df 05 9e 00 	jeq %d5,0,8000cbba <_dtoa_r+0x7f2>
8000ca82:	91 00 00 f8 	movh.a %a15,32768
8000ca86:	d9 ff d8 a0 	lea %a15,[%a15]3736 <80000e98 <__mprec_tens>>
8000ca8a:	19 a3 10 00 	ld.w %d3,[%sp]16 <80000e98 <__mprec_tens>>
8000ca8e:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000ca92:	19 a2 28 00 	ld.w %d2,[%sp]40
8000ca96:	fa 13       	lt %d15,%d3,1
8000ca98:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000ca9c:	09 f8 40 09 	ld.d %e8,[%a15]
8000caa0:	6e 16       	jz %d15,8000cacc <_dtoa_r+0x704>
8000caa2:	df 03 a4 81 	jne %d3,0,8000cdea <_dtoa_r+0xa22>
8000caa6:	0b 89 10 48 	mov %e4,%d9,%d8
8000caaa:	82 06       	mov %d6,0
8000caac:	7b 40 01 74 	movh %d7,16404
8000cab0:	6d ff 0d ed 	call 8000a4ca <__muldf3>
8000cab4:	0b cd 10 68 	mov %e6,%d13,%d12
8000cab8:	0b 23 10 48 	mov %e4,%d3,%d2
8000cabc:	a0 0c       	mov.a %a12,0
8000cabe:	6d 00 9a 0a 	call 8000dff2 <__gedf2>
8000cac2:	a0 0f       	mov.a %a15,0
8000cac4:	ff 02 95 01 	jge %d2,0,8000cdee <_dtoa_r+0xa26>
8000cac8:	1d 00 9d 01 	j 8000ce02 <_dtoa_r+0xa3a>
8000cacc:	d8 03       	ld.a %a15,[%sp]12
8000cace:	0b cd 10 a8 	mov %e10,%d13,%d12
8000cad2:	0b 89 10 68 	mov %e6,%d9,%d8
8000cad6:	0b ab 10 48 	mov %e4,%d11,%d10
8000cada:	80 fe       	mov.d %d14,%a15
8000cadc:	6d ff c9 ed 	call 8000a66e <__divdf3>
8000cae0:	0b 23 10 48 	mov %e4,%d3,%d2
8000cae4:	c2 1e       	add %d14,1
8000cae6:	6d 00 c6 0a 	call 8000e072 <__fixdfsi>
8000caea:	02 24       	mov %d4,%d2
8000caec:	02 2f       	mov %d15,%d2
8000caee:	6d ff 4c ee 	call 8000a786 <__floatsidf>
8000caf2:	0b 89 10 68 	mov %e6,%d9,%d8
8000caf6:	0b 23 10 48 	mov %e4,%d3,%d2
8000cafa:	6d ff e8 ec 	call 8000a4ca <__muldf3>
8000cafe:	0b ab 10 48 	mov %e4,%d11,%d10
8000cb02:	0b 23 10 68 	mov %e6,%d3,%d2
8000cb06:	6d ff c2 ec 	call 8000a48a <__subdf3>
8000cb0a:	0b 23 10 48 	mov %e4,%d3,%d2
8000cb0e:	1b 0f 03 30 	addi %d3,%d15,48
8000cb12:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000cb16:	28 03       	st.b [%a15]0,%d3
8000cb18:	02 e3       	mov %d3,%d14
8000cb1a:	a2 23       	sub %d3,%d2
8000cb1c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000cb20:	5f 23 3c 80 	jne %d3,%d2,8000cb98 <_dtoa_r+0x7d0>
8000cb24:	0b 45 10 68 	mov %e6,%d5,%d4
8000cb28:	6d ff 95 ec 	call 8000a452 <__adddf3>
8000cb2c:	0b 89 10 68 	mov %e6,%d9,%d8
8000cb30:	0b 23 10 48 	mov %e4,%d3,%d2
8000cb34:	0b 23 10 a8 	mov %e10,%d3,%d2
8000cb38:	6d 00 3d 0a 	call 8000dfb2 <__gtdf2>
8000cb3c:	4e 2e       	jgtz %d2,8000cb58 <_dtoa_r+0x790>
8000cb3e:	0b ab 10 48 	mov %e4,%d11,%d10
8000cb42:	0b 89 10 68 	mov %e6,%d9,%d8
8000cb46:	6d 00 f6 09 	call 8000df32 <__eqdf2>
8000cb4a:	df 02 95 82 	jne %d2,0,8000d074 <_dtoa_r+0xcac>
8000cb4e:	ae 05       	jnz.t %d15,0,8000cb58 <_dtoa_r+0x790>
8000cb50:	1d 00 92 02 	j 8000d074 <_dtoa_r+0xcac>
8000cb54:	58 0c       	ld.w %d15,[%sp]48
8000cb56:	78 02       	st.w [%sp]8,%d15
8000cb58:	58 03       	ld.w %d15,[%sp]12
8000cb5a:	a2 ef       	sub %d15,%d14
8000cb5c:	46 0f       	not %d15
8000cb5e:	60 e2       	mov.a %a2,%d14
8000cb60:	60 ef       	mov.a %a15,%d14
8000cb62:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000cb66:	b0 ff       	add.a %a15,-1
8000cb68:	8b 93 03 32 	eq %d3,%d3,57
8000cb6c:	df 03 11 00 	jeq %d3,0,8000cb8e <_dtoa_r+0x7c6>
8000cb70:	9f 0f 0d 80 	jned %d15,0,8000cb8a <_dtoa_r+0x7c2>
8000cb74:	19 a3 08 00 	ld.w %d3,[%sp]8
8000cb78:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000cb7c:	c2 13       	add %d3,1
8000cb7e:	da 30       	mov %d15,48
8000cb80:	59 a3 08 00 	st.w [%sp]8,%d3
8000cb84:	2c 30       	st.b [%a3]0,%d15
8000cb86:	40 3f       	mov.aa %a15,%a3
8000cb88:	3c 03       	j 8000cb8e <_dtoa_r+0x7c6>
8000cb8a:	80 fe       	mov.d %d14,%a15
8000cb8c:	3c e9       	j 8000cb5e <_dtoa_r+0x796>
8000cb8e:	0c f0       	ld.bu %d15,[%a15]0
8000cb90:	c2 1f       	add %d15,1
8000cb92:	28 0f       	st.b [%a15]0,%d15
8000cb94:	1d 00 70 02 	j 8000d074 <_dtoa_r+0xcac>
8000cb98:	82 06       	mov %d6,0
8000cb9a:	7b 40 02 74 	movh %d7,16420
8000cb9e:	6d ff 96 ec 	call 8000a4ca <__muldf3>
8000cba2:	d2 06       	mov %e6,0
8000cba4:	0b 23 10 48 	mov %e4,%d3,%d2
8000cba8:	0b 23 10 a8 	mov %e10,%d3,%d2
8000cbac:	60 ef       	mov.a %a15,%d14
8000cbae:	6d 00 c2 09 	call 8000df32 <__eqdf2>
8000cbb2:	df 02 90 ff 	jne %d2,0,8000cad2 <_dtoa_r+0x70a>
8000cbb6:	1d 00 5f 02 	j 8000d074 <_dtoa_r+0xcac>
8000cbba:	19 a2 24 00 	ld.w %d2,[%sp]36
8000cbbe:	58 08       	ld.w %d15,[%sp]32
8000cbc0:	19 a8 14 00 	ld.w %d8,[%sp]20
8000cbc4:	a0 0f       	mov.a %a15,0
8000cbc6:	df 02 3b 00 	jeq %d2,0,8000cc3c <_dtoa_r+0x874>
8000cbca:	58 07       	ld.w %d15,[%sp]28
8000cbcc:	ff 2f 10 00 	jge %d15,2,8000cbec <_dtoa_r+0x824>
8000cbd0:	58 13       	ld.w %d15,[%sp]76
8000cbd2:	6e 05       	jz %d15,8000cbdc <_dtoa_r+0x814>
8000cbd4:	1b 33 43 30 	addi %d3,%d3,1075
8000cbd8:	58 08       	ld.w %d15,[%sp]32
8000cbda:	3c 22       	j 8000cc1e <_dtoa_r+0x856>
8000cbdc:	19 a3 10 10 	ld.w %d3,[%sp]80
8000cbe0:	58 08       	ld.w %d15,[%sp]32
8000cbe2:	8b 63 03 31 	rsub %d3,%d3,54
8000cbe6:	19 a8 14 00 	ld.w %d8,[%sp]20
8000cbea:	3c 1a       	j 8000cc1e <_dtoa_r+0x856>
8000cbec:	58 04       	ld.w %d15,[%sp]16
8000cbee:	19 a2 20 00 	ld.w %d2,[%sp]32
8000cbf2:	c2 ff       	add %d15,-1
8000cbf4:	3f f2 04 00 	jlt %d2,%d15,8000cbfc <_dtoa_r+0x834>
8000cbf8:	5a f2       	sub %d15,%d2,%d15
8000cbfa:	3c 0b       	j 8000cc10 <_dtoa_r+0x848>
8000cbfc:	19 a3 20 00 	ld.w %d3,[%sp]32
8000cc00:	78 08       	st.w [%sp]32,%d15
8000cc02:	52 32       	sub %d2,%d15,%d3
8000cc04:	19 a3 34 00 	ld.w %d3,[%sp]52
8000cc08:	82 0f       	mov %d15,0
8000cc0a:	42 23       	add %d3,%d2
8000cc0c:	59 a3 34 00 	st.w [%sp]52,%d3
8000cc10:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cc14:	19 a8 14 00 	ld.w %d8,[%sp]20
8000cc18:	ce 33       	jgez %d3,8000cc1e <_dtoa_r+0x856>
8000cc1a:	a2 38       	sub %d8,%d3
8000cc1c:	82 03       	mov %d3,0
8000cc1e:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cc22:	40 d4       	mov.aa %a4,%a13
8000cc24:	42 32       	add %d2,%d3
8000cc26:	59 a2 14 00 	st.w [%sp]20,%d2
8000cc2a:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cc2e:	82 14       	mov %d4,1
8000cc30:	42 32       	add %d2,%d3
8000cc32:	59 a2 18 00 	st.w [%sp]24,%d2
8000cc36:	6d 00 4e 04 	call 8000d4d2 <__i2b>
8000cc3a:	40 2f       	mov.aa %a15,%a2
8000cc3c:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cc40:	8b 18 80 32 	ge %d3,%d8,1
8000cc44:	8b 12 80 34 	and.ge %d3,%d2,1
8000cc48:	76 3e       	jz %d3,8000cc64 <_dtoa_r+0x89c>
8000cc4a:	0b 82 80 31 	min %d3,%d2,%d8
8000cc4e:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cc52:	a2 38       	sub %d8,%d3
8000cc54:	a2 32       	sub %d2,%d3
8000cc56:	59 a2 14 00 	st.w [%sp]20,%d2
8000cc5a:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cc5e:	a2 32       	sub %d2,%d3
8000cc60:	59 a2 18 00 	st.w [%sp]24,%d2
8000cc64:	19 a3 20 00 	ld.w %d3,[%sp]32
8000cc68:	bf 13 27 00 	jlt %d3,1,8000ccb6 <_dtoa_r+0x8ee>
8000cc6c:	19 a2 24 00 	ld.w %d2,[%sp]36
8000cc70:	df 02 1c 00 	jeq %d2,0,8000cca8 <_dtoa_r+0x8e0>
8000cc74:	bf 1f 13 00 	jlt %d15,1,8000cc9a <_dtoa_r+0x8d2>
8000cc78:	40 f5       	mov.aa %a5,%a15
8000cc7a:	02 f4       	mov %d4,%d15
8000cc7c:	40 d4       	mov.aa %a4,%a13
8000cc7e:	6d 00 bf 04 	call 8000d5fc <__pow5mult>
8000cc82:	40 e6       	mov.aa %a6,%a14
8000cc84:	40 d4       	mov.aa %a4,%a13
8000cc86:	40 25       	mov.aa %a5,%a2
8000cc88:	40 2f       	mov.aa %a15,%a2
8000cc8a:	6d 00 2c 04 	call 8000d4e2 <__multiply>
8000cc8e:	40 e5       	mov.aa %a5,%a14
8000cc90:	40 2c       	mov.aa %a12,%a2
8000cc92:	40 d4       	mov.aa %a4,%a13
8000cc94:	6d 00 81 03 	call 8000d396 <_Bfree>
8000cc98:	40 ce       	mov.aa %a14,%a12
8000cc9a:	19 a4 20 00 	ld.w %d4,[%sp]32
8000cc9e:	40 d4       	mov.aa %a4,%a13
8000cca0:	a2 f4       	sub %d4,%d15
8000cca2:	40 e5       	mov.aa %a5,%a14
8000cca4:	76 49       	jz %d4,8000ccb6 <_dtoa_r+0x8ee>
8000cca6:	3c 05       	j 8000ccb0 <_dtoa_r+0x8e8>
8000cca8:	19 a4 20 00 	ld.w %d4,[%sp]32
8000ccac:	40 d4       	mov.aa %a4,%a13
8000ccae:	40 e5       	mov.aa %a5,%a14
8000ccb0:	6d 00 a6 04 	call 8000d5fc <__pow5mult>
8000ccb4:	40 2e       	mov.aa %a14,%a2
8000ccb6:	40 d4       	mov.aa %a4,%a13
8000ccb8:	82 14       	mov %d4,1
8000ccba:	6d 00 0c 04 	call 8000d4d2 <__i2b>
8000ccbe:	19 a3 34 00 	ld.w %d3,[%sp]52
8000ccc2:	40 2c       	mov.aa %a12,%a2
8000ccc4:	8e 3c       	jlez %d3,8000ccdc <_dtoa_r+0x914>
8000ccc6:	40 d4       	mov.aa %a4,%a13
8000ccc8:	40 25       	mov.aa %a5,%a2
8000ccca:	02 34       	mov %d4,%d3
8000cccc:	6d 00 98 04 	call 8000d5fc <__pow5mult>
8000ccd0:	58 07       	ld.w %d15,[%sp]28
8000ccd2:	40 2c       	mov.aa %a12,%a2
8000ccd4:	82 09       	mov %d9,0
8000ccd6:	ff 2f 1f 00 	jge %d15,2,8000cd14 <_dtoa_r+0x94c>
8000ccda:	3c 06       	j 8000cce6 <_dtoa_r+0x91e>
8000ccdc:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cce0:	82 09       	mov %d9,0
8000cce2:	ff 22 15 00 	jge %d2,2,8000cd0c <_dtoa_r+0x944>
8000cce6:	82 09       	mov %d9,0
8000cce8:	df 0c 12 80 	jne %d12,0,8000cd0c <_dtoa_r+0x944>
8000ccec:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000ccf0:	ee 0e       	jnz %d15,8000cd0c <_dtoa_r+0x944>
8000ccf2:	7b 00 ff f7 	movh %d15,32752
8000ccf6:	26 df       	and %d15,%d13
8000ccf8:	6e 0a       	jz %d15,8000cd0c <_dtoa_r+0x944>
8000ccfa:	19 a3 14 00 	ld.w %d3,[%sp]20
8000ccfe:	58 06       	ld.w %d15,[%sp]24
8000cd00:	c2 13       	add %d3,1
8000cd02:	c2 1f       	add %d15,1
8000cd04:	59 a3 14 00 	st.w [%sp]20,%d3
8000cd08:	78 06       	st.w [%sp]24,%d15
8000cd0a:	82 19       	mov %d9,1
8000cd0c:	19 a3 34 00 	ld.w %d3,[%sp]52
8000cd10:	82 12       	mov %d2,1
8000cd12:	76 39       	jz %d3,8000cd24 <_dtoa_r+0x95c>
8000cd14:	4c c4       	ld.w %d15,[%a12]16
8000cd16:	90 c3       	addsc.a %a3,%a12,%d15,2
8000cd18:	19 34 10 00 	ld.w %d4,[%a3]16
8000cd1c:	6d 00 87 03 	call 8000d42a <__hi0bits>
8000cd20:	8b 02 02 21 	rsub %d2,%d2,32
8000cd24:	58 06       	ld.w %d15,[%sp]24
8000cd26:	42 2f       	add %d15,%d2
8000cd28:	16 1f       	and %d15,31
8000cd2a:	6e 0a       	jz %d15,8000cd3e <_dtoa_r+0x976>
8000cd2c:	8b 0f 02 31 	rsub %d3,%d15,32
8000cd30:	8b cf 01 f1 	rsub %d15,%d15,28
8000cd34:	ff 53 07 00 	jge %d3,5,8000cd42 <_dtoa_r+0x97a>
8000cd38:	df 43 10 00 	jeq %d3,4,8000cd58 <_dtoa_r+0x990>
8000cd3c:	02 3f       	mov %d15,%d3
8000cd3e:	1b cf 01 f0 	addi %d15,%d15,28
8000cd42:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cd46:	19 a3 18 00 	ld.w %d3,[%sp]24
8000cd4a:	42 f2       	add %d2,%d15
8000cd4c:	42 f3       	add %d3,%d15
8000cd4e:	59 a2 14 00 	st.w [%sp]20,%d2
8000cd52:	42 f8       	add %d8,%d15
8000cd54:	59 a3 18 00 	st.w [%sp]24,%d3
8000cd58:	58 05       	ld.w %d15,[%sp]20
8000cd5a:	8e f7       	jlez %d15,8000cd68 <_dtoa_r+0x9a0>
8000cd5c:	40 e5       	mov.aa %a5,%a14
8000cd5e:	40 d4       	mov.aa %a4,%a13
8000cd60:	02 f4       	mov %d4,%d15
8000cd62:	6d 00 8b 04 	call 8000d678 <__lshift>
8000cd66:	40 2e       	mov.aa %a14,%a2
8000cd68:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cd6c:	8e 27       	jlez %d2,8000cd7a <_dtoa_r+0x9b2>
8000cd6e:	40 c5       	mov.aa %a5,%a12
8000cd70:	40 d4       	mov.aa %a4,%a13
8000cd72:	02 24       	mov %d4,%d2
8000cd74:	6d 00 82 04 	call 8000d678 <__lshift>
8000cd78:	40 2c       	mov.aa %a12,%a2
8000cd7a:	19 a3 3c 00 	ld.w %d3,[%sp]60
8000cd7e:	df 03 20 00 	jeq %d3,0,8000cdbe <_dtoa_r+0x9f6>
8000cd82:	40 e4       	mov.aa %a4,%a14
8000cd84:	40 c5       	mov.aa %a5,%a12
8000cd86:	6d 00 d6 04 	call 8000d732 <__mcmp>
8000cd8a:	ff 02 1a 00 	jge %d2,0,8000cdbe <_dtoa_r+0x9f6>
8000cd8e:	58 02       	ld.w %d15,[%sp]8
8000cd90:	40 e5       	mov.aa %a5,%a14
8000cd92:	c2 ff       	add %d15,-1
8000cd94:	40 d4       	mov.aa %a4,%a13
8000cd96:	fb a0 00 40 	mov %e4,10
8000cd9a:	78 02       	st.w [%sp]8,%d15
8000cd9c:	6d 00 06 03 	call 8000d3a8 <__multadd>
8000cda0:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000cda4:	19 a3 24 00 	ld.w %d3,[%sp]36
8000cda8:	59 a2 10 00 	st.w [%sp]16,%d2
8000cdac:	40 2e       	mov.aa %a14,%a2
8000cdae:	76 38       	jz %d3,8000cdbe <_dtoa_r+0x9f6>
8000cdb0:	40 f5       	mov.aa %a5,%a15
8000cdb2:	40 d4       	mov.aa %a4,%a13
8000cdb4:	fb a0 00 40 	mov %e4,10
8000cdb8:	6d 00 f8 02 	call 8000d3a8 <__multadd>
8000cdbc:	40 2f       	mov.aa %a15,%a2
8000cdbe:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cdc2:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cdc6:	8b 32 80 f2 	ge %d15,%d2,3
8000cdca:	8b 13 40 f4 	and.lt %d15,%d3,1
8000cdce:	6e 2a       	jz %d15,8000ce22 <_dtoa_r+0xa5a>
8000cdd0:	f6 3f       	jnz %d3,8000cdee <_dtoa_r+0xa26>
8000cdd2:	40 c5       	mov.aa %a5,%a12
8000cdd4:	40 d4       	mov.aa %a4,%a13
8000cdd6:	d2 54       	mov %e4,5
8000cdd8:	6d 00 e8 02 	call 8000d3a8 <__multadd>
8000cddc:	40 e4       	mov.aa %a4,%a14
8000cdde:	40 25       	mov.aa %a5,%a2
8000cde0:	40 2c       	mov.aa %a12,%a2
8000cde2:	6d 00 a8 04 	call 8000d732 <__mcmp>
8000cde6:	4e 2e       	jgtz %d2,8000ce02 <_dtoa_r+0xa3a>
8000cde8:	3c 03       	j 8000cdee <_dtoa_r+0xa26>
8000cdea:	a0 0c       	mov.a %a12,0
8000cdec:	a0 0f       	mov.a %a15,0
8000cdee:	58 0a       	ld.w %d15,[%sp]40
8000cdf0:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000cdf4:	46 0f       	not %d15
8000cdf6:	78 02       	st.w [%sp]8,%d15
8000cdf8:	3c 11       	j 8000ce1a <_dtoa_r+0xa52>
8000cdfa:	58 0c       	ld.w %d15,[%sp]48
8000cdfc:	a0 0c       	mov.a %a12,0
8000cdfe:	78 02       	st.w [%sp]8,%d15
8000ce00:	a0 0f       	mov.a %a15,0
8000ce02:	19 a2 08 00 	ld.w %d2,[%sp]8
8000ce06:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000ce0a:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000ce0e:	da 31       	mov %d15,49
8000ce10:	c2 12       	add %d2,1
8000ce12:	c2 1e       	add %d14,1
8000ce14:	2c 30       	st.b [%a3]0,%d15
8000ce16:	59 a2 08 00 	st.w [%sp]8,%d2
8000ce1a:	80 f8       	mov.d %d8,%a15
8000ce1c:	a0 0f       	mov.a %a15,0
8000ce1e:	1d 00 14 01 	j 8000d046 <_dtoa_r+0xc7e>
8000ce22:	19 a3 24 00 	ld.w %d3,[%sp]36
8000ce26:	f6 35       	jnz %d3,8000ce30 <_dtoa_r+0xa68>
8000ce28:	19 a8 0c 00 	ld.w %d8,[%sp]12
8000ce2c:	1d 00 c2 00 	j 8000cfb0 <_dtoa_r+0xbe8>
8000ce30:	8e 87       	jlez %d8,8000ce3e <_dtoa_r+0xa76>
8000ce32:	40 f5       	mov.aa %a5,%a15
8000ce34:	40 d4       	mov.aa %a4,%a13
8000ce36:	02 84       	mov %d4,%d8
8000ce38:	6d 00 20 04 	call 8000d678 <__lshift>
8000ce3c:	40 2f       	mov.aa %a15,%a2
8000ce3e:	80 f8       	mov.d %d8,%a15
8000ce40:	df 09 16 00 	jeq %d9,0,8000ce6c <_dtoa_r+0xaa4>
8000ce44:	40 d4       	mov.aa %a4,%a13
8000ce46:	48 14       	ld.w %d4,[%a15]4
8000ce48:	6d 00 7c 02 	call 8000d340 <_Balloc>
8000ce4c:	48 44       	ld.w %d4,[%a15]16
8000ce4e:	d9 24 0c 00 	lea %a4,[%a2]12
8000ce52:	c2 24       	add %d4,2
8000ce54:	d9 f5 0c 00 	lea %a5,[%a15]12
8000ce58:	06 24       	sh %d4,2
8000ce5a:	80 2f       	mov.d %d15,%a2
8000ce5c:	6d 00 64 02 	call 8000d324 <memcpy>
8000ce60:	60 f5       	mov.a %a5,%d15
8000ce62:	40 d4       	mov.aa %a4,%a13
8000ce64:	82 14       	mov %d4,1
8000ce66:	6d 00 09 04 	call 8000d678 <__lshift>
8000ce6a:	80 28       	mov.d %d8,%a2
8000ce6c:	19 a9 0c 00 	ld.w %d9,[%sp]12
8000ce70:	8f 1c 00 a1 	and %d10,%d12,1
8000ce74:	40 e4       	mov.aa %a4,%a14
8000ce76:	40 c5       	mov.aa %a5,%a12
8000ce78:	6d ff 1a fa 	call 8000c2ac <quorem>
8000ce7c:	40 e4       	mov.aa %a4,%a14
8000ce7e:	40 f5       	mov.aa %a5,%a15
8000ce80:	02 2e       	mov %d14,%d2
8000ce82:	1b 02 03 f0 	addi %d15,%d2,48
8000ce86:	6d 00 56 04 	call 8000d732 <__mcmp>
8000ce8a:	60 86       	mov.a %a6,%d8
8000ce8c:	40 d4       	mov.aa %a4,%a13
8000ce8e:	40 c5       	mov.aa %a5,%a12
8000ce90:	02 2b       	mov %d11,%d2
8000ce92:	6d 00 71 04 	call 8000d774 <__mdiff>
8000ce96:	19 22 0c 00 	ld.w %d2,[%a2]12
8000ce9a:	80 2d       	mov.d %d13,%a2
8000ce9c:	82 1c       	mov %d12,1
8000ce9e:	f6 26       	jnz %d2,8000ceaa <_dtoa_r+0xae2>
8000cea0:	40 e4       	mov.aa %a4,%a14
8000cea2:	40 25       	mov.aa %a5,%a2
8000cea4:	6d 00 47 04 	call 8000d732 <__mcmp>
8000cea8:	02 2c       	mov %d12,%d2
8000ceaa:	60 d5       	mov.a %a5,%d13
8000ceac:	40 d4       	mov.aa %a4,%a13
8000ceae:	6d 00 74 02 	call 8000d396 <_Bfree>
8000ceb2:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000ceb6:	1b 19 00 d0 	addi %d13,%d9,1
8000ceba:	a6 c3       	or %d3,%d12
8000cebc:	f6 3f       	jnz %d3,8000ceda <_dtoa_r+0xb12>
8000cebe:	f6 ae       	jnz %d10,8000ceda <_dtoa_r+0xb12>
8000cec0:	8b 9f 03 32 	eq %d3,%d15,57
8000cec4:	40 e2       	mov.aa %a2,%a14
8000cec6:	df 03 3a 80 	jne %d3,0,8000cf3a <_dtoa_r+0xb72>
8000ceca:	1b 1e 03 20 	addi %d2,%d14,49
8000cece:	8b 1b 80 b2 	ge %d11,%d11,1
8000ced2:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
8000ced6:	02 de       	mov %d14,%d13
8000ced8:	3c 37       	j 8000cf46 <_dtoa_r+0xb7e>
8000ceda:	ce b5       	jgez %d11,8000cee4 <_dtoa_r+0xb1c>
8000cedc:	02 fa       	mov %d10,%d15
8000cede:	40 e2       	mov.aa %a2,%a14
8000cee0:	4e ca       	jgtz %d12,8000cef4 <_dtoa_r+0xb2c>
8000cee2:	3c 1e       	j 8000cf1e <_dtoa_r+0xb56>
8000cee4:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cee8:	a6 2b       	or %d11,%d2
8000ceea:	df 0b 20 80 	jne %d11,0,8000cf2a <_dtoa_r+0xb62>
8000ceee:	df 0a 1e 80 	jne %d10,0,8000cf2a <_dtoa_r+0xb62>
8000cef2:	3c f5       	j 8000cedc <_dtoa_r+0xb14>
8000cef4:	40 d4       	mov.aa %a4,%a13
8000cef6:	40 e5       	mov.aa %a5,%a14
8000cef8:	82 14       	mov %d4,1
8000cefa:	6d 00 bf 03 	call 8000d678 <__lshift>
8000cefe:	40 c5       	mov.aa %a5,%a12
8000cf00:	40 24       	mov.aa %a4,%a2
8000cf02:	b5 a2 04 00 	st.a [%sp]4,%a2
8000cf06:	6d 00 16 04 	call 8000d732 <__mcmp>
8000cf0a:	99 a2 04 00 	ld.a %a2,[%sp]4
8000cf0e:	4e 23       	jgtz %d2,8000cf14 <_dtoa_r+0xb4c>
8000cf10:	f6 27       	jnz %d2,8000cf1e <_dtoa_r+0xb56>
8000cf12:	2e 06       	jz.t %d15,0,8000cf1e <_dtoa_r+0xb56>
8000cf14:	8b 9f 03 32 	eq %d3,%d15,57
8000cf18:	df 03 11 80 	jne %d3,0,8000cf3a <_dtoa_r+0xb72>
8000cf1c:	92 1a       	add %d10,%d15,1
8000cf1e:	60 93       	mov.a %a3,%d9
8000cf20:	02 de       	mov %d14,%d13
8000cf22:	34 3a       	st.b [%a3],%d10
8000cf24:	40 2e       	mov.aa %a14,%a2
8000cf26:	1d 00 90 00 	j 8000d046 <_dtoa_r+0xc7e>
8000cf2a:	bf 1c 11 00 	jlt %d12,1,8000cf4c <_dtoa_r+0xb84>
8000cf2e:	8b 9f 23 32 	ne %d3,%d15,57
8000cf32:	40 e2       	mov.aa %a2,%a14
8000cf34:	02 de       	mov %d14,%d13
8000cf36:	c2 1f       	add %d15,1
8000cf38:	f6 37       	jnz %d3,8000cf46 <_dtoa_r+0xb7e>
8000cf3a:	60 93       	mov.a %a3,%d9
8000cf3c:	da 39       	mov %d15,57
8000cf3e:	02 de       	mov %d14,%d13
8000cf40:	2c 30       	st.b [%a3]0,%d15
8000cf42:	40 2e       	mov.aa %a14,%a2
8000cf44:	3c 5d       	j 8000cffe <_dtoa_r+0xc36>
8000cf46:	60 92       	mov.a %a2,%d9
8000cf48:	2c 20       	st.b [%a2]0,%d15
8000cf4a:	3c 7e       	j 8000d046 <_dtoa_r+0xc7e>
8000cf4c:	60 93       	mov.a %a3,%d9
8000cf4e:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000cf52:	02 d5       	mov %d5,%d13
8000cf54:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cf58:	2c 30       	st.b [%a3]0,%d15
8000cf5a:	a2 25       	sub %d5,%d2
8000cf5c:	02 de       	mov %d14,%d13
8000cf5e:	5f 35 41 00 	jeq %d5,%d3,8000cfe0 <_dtoa_r+0xc18>
8000cf62:	40 e5       	mov.aa %a5,%a14
8000cf64:	40 d4       	mov.aa %a4,%a13
8000cf66:	fb a0 00 40 	mov %e4,10
8000cf6a:	6d 00 1f 02 	call 8000d3a8 <__multadd>
8000cf6e:	80 ff       	mov.d %d15,%a15
8000cf70:	40 2e       	mov.aa %a14,%a2
8000cf72:	40 d4       	mov.aa %a4,%a13
8000cf74:	40 f5       	mov.aa %a5,%a15
8000cf76:	fb a0 00 40 	mov %e4,10
8000cf7a:	7e 86       	jne %d15,%d8,8000cf86 <_dtoa_r+0xbbe>
8000cf7c:	6d 00 16 02 	call 8000d3a8 <__multadd>
8000cf80:	40 2f       	mov.aa %a15,%a2
8000cf82:	80 28       	mov.d %d8,%a2
8000cf84:	3c 0b       	j 8000cf9a <_dtoa_r+0xbd2>
8000cf86:	6d 00 11 02 	call 8000d3a8 <__multadd>
8000cf8a:	60 85       	mov.a %a5,%d8
8000cf8c:	40 d4       	mov.aa %a4,%a13
8000cf8e:	fb a0 00 40 	mov %e4,10
8000cf92:	40 2f       	mov.aa %a15,%a2
8000cf94:	6d 00 0a 02 	call 8000d3a8 <__multadd>
8000cf98:	80 28       	mov.d %d8,%a2
8000cf9a:	02 d9       	mov %d9,%d13
8000cf9c:	1d ff 6c ff 	j 8000ce74 <_dtoa_r+0xaac>
8000cfa0:	40 e5       	mov.aa %a5,%a14
8000cfa2:	40 d4       	mov.aa %a4,%a13
8000cfa4:	fb a0 00 40 	mov %e4,10
8000cfa8:	6d 00 00 02 	call 8000d3a8 <__multadd>
8000cfac:	02 98       	mov %d8,%d9
8000cfae:	40 2e       	mov.aa %a14,%a2
8000cfb0:	40 e4       	mov.aa %a4,%a14
8000cfb2:	40 c5       	mov.aa %a5,%a12
8000cfb4:	6d ff 7c f9 	call 8000c2ac <quorem>
8000cfb8:	1b 18 00 90 	addi %d9,%d8,1
8000cfbc:	1b 02 03 f0 	addi %d15,%d2,48
8000cfc0:	60 82       	mov.a %a2,%d8
8000cfc2:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000cfc6:	02 95       	mov %d5,%d9
8000cfc8:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cfcc:	2c 20       	st.b [%a2]0,%d15
8000cfce:	a2 25       	sub %d5,%d2
8000cfd0:	3f 35 e8 7f 	jlt %d5,%d3,8000cfa0 <_dtoa_r+0xbd8>
8000cfd4:	8b 13 40 33 	max %d3,%d3,1
8000cfd8:	02 2e       	mov %d14,%d2
8000cfda:	80 f8       	mov.d %d8,%a15
8000cfdc:	42 3e       	add %d14,%d3
8000cfde:	a0 0f       	mov.a %a15,0
8000cfe0:	40 e5       	mov.aa %a5,%a14
8000cfe2:	40 d4       	mov.aa %a4,%a13
8000cfe4:	82 14       	mov %d4,1
8000cfe6:	6d 00 49 03 	call 8000d678 <__lshift>
8000cfea:	40 c5       	mov.aa %a5,%a12
8000cfec:	40 2e       	mov.aa %a14,%a2
8000cfee:	40 24       	mov.aa %a4,%a2
8000cff0:	6d 00 a1 03 	call 8000d732 <__mcmp>
8000cff4:	4e 25       	jgtz %d2,8000cffe <_dtoa_r+0xc36>
8000cff6:	df 02 1e 80 	jne %d2,0,8000d032 <_dtoa_r+0xc6a>
8000cffa:	6f 0f 1c 00 	jz.t %d15,0,8000d032 <_dtoa_r+0xc6a>
8000cffe:	58 03       	ld.w %d15,[%sp]12
8000d000:	a2 ef       	sub %d15,%d14
8000d002:	46 0f       	not %d15
8000d004:	60 e2       	mov.a %a2,%d14
8000d006:	60 e3       	mov.a %a3,%d14
8000d008:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000d00c:	b0 f3       	add.a %a3,-1
8000d00e:	8b 93 03 52 	eq %d5,%d3,57
8000d012:	76 5d       	jz %d5,8000d02c <_dtoa_r+0xc64>
8000d014:	9f 0f 0a 80 	jned %d15,0,8000d028 <_dtoa_r+0xc60>
8000d018:	58 02       	ld.w %d15,[%sp]8
8000d01a:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000d01e:	c2 1f       	add %d15,1
8000d020:	78 02       	st.w [%sp]8,%d15
8000d022:	da 31       	mov %d15,49
8000d024:	2c 30       	st.b [%a3]0,%d15
8000d026:	3c 10       	j 8000d046 <_dtoa_r+0xc7e>
8000d028:	80 3e       	mov.d %d14,%a3
8000d02a:	3c ed       	j 8000d004 <_dtoa_r+0xc3c>
8000d02c:	c2 13       	add %d3,1
8000d02e:	34 33       	st.b [%a3],%d3
8000d030:	3c 0b       	j 8000d046 <_dtoa_r+0xc7e>
8000d032:	60 e2       	mov.a %a2,%d14
8000d034:	60 e3       	mov.a %a3,%d14
8000d036:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000d03a:	b0 f3       	add.a %a3,-1
8000d03c:	8b 0f 03 f2 	eq %d15,%d15,48
8000d040:	6e 03       	jz %d15,8000d046 <_dtoa_r+0xc7e>
8000d042:	80 3e       	mov.d %d14,%a3
8000d044:	3c f7       	j 8000d032 <_dtoa_r+0xc6a>
8000d046:	40 d4       	mov.aa %a4,%a13
8000d048:	40 c5       	mov.aa %a5,%a12
8000d04a:	6d 00 a6 01 	call 8000d396 <_Bfree>
8000d04e:	df 08 13 00 	jeq %d8,0,8000d074 <_dtoa_r+0xcac>
8000d052:	80 f2       	mov.d %d2,%a15
8000d054:	8b 02 20 f2 	ne %d15,%d2,0
8000d058:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8000d05c:	6e 05       	jz %d15,8000d066 <_dtoa_r+0xc9e>
8000d05e:	40 d4       	mov.aa %a4,%a13
8000d060:	40 f5       	mov.aa %a5,%a15
8000d062:	6d 00 9a 01 	call 8000d396 <_Bfree>
8000d066:	60 85       	mov.a %a5,%d8
8000d068:	40 d4       	mov.aa %a4,%a13
8000d06a:	6d 00 96 01 	call 8000d396 <_Bfree>
8000d06e:	3c 03       	j 8000d074 <_dtoa_r+0xcac>
8000d070:	58 0c       	ld.w %d15,[%sp]48
8000d072:	78 02       	st.w [%sp]8,%d15
8000d074:	40 d4       	mov.aa %a4,%a13
8000d076:	40 e5       	mov.aa %a5,%a14
8000d078:	6d 00 8f 01 	call 8000d396 <_Bfree>
8000d07c:	60 e2       	mov.a %a2,%d14
8000d07e:	19 a2 08 00 	ld.w %d2,[%sp]8
8000d082:	99 a3 08 10 	ld.a %a3,[%sp]72
8000d086:	82 0f       	mov %d15,0
8000d088:	d8 0e       	ld.a %a15,[%sp]56
8000d08a:	2c 20       	st.b [%a2]0,%d15
8000d08c:	c2 12       	add %d2,1
8000d08e:	74 32       	st.w [%a3],%d2
8000d090:	99 a2 0c 00 	ld.a %a2,[%sp]12
8000d094:	bc f2       	jz.a %a15,8000d098 <_dtoa_r+0xcd0>
8000d096:	68 0e       	st.w [%a15]0,%d14
8000d098:	00 90       	ret 
	...

8000d09c <_malloc_trim_r>:
8000d09c:	02 4f       	mov %d15,%d4
8000d09e:	40 4f       	mov.aa %a15,%a4
8000d0a0:	6d ff ce ef 	call 8000b03c <__malloc_lock>
8000d0a4:	91 00 00 c7 	movh.a %a12,28672
8000d0a8:	d9 cc 20 30 	lea %a12,[%a12]224 <700000e0 <__malloc_av_>>
8000d0ac:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <g_vadcChannelIDs>>
8000d0b0:	3b 00 00 21 	mov %d2,4096
8000d0b4:	19 28 04 00 	ld.w %d8,[%a2]4
8000d0b8:	8f 38 c0 81 	andn %d8,%d8,3
8000d0bc:	5a f8       	sub %d15,%d8,%d15
8000d0be:	1b ff fe f0 	addi %d15,%d15,4079
8000d0c2:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000d0c6:	1b 0f 00 ff 	addi %d15,%d15,-4096
8000d0ca:	7f 2f 07 00 	jge %d15,%d2,8000d0d8 <_malloc_trim_r+0x3c>
8000d0ce:	40 f4       	mov.aa %a4,%a15
8000d0d0:	6d ff b7 ef 	call 8000b03e <__malloc_unlock>
8000d0d4:	82 02       	mov %d2,0
8000d0d6:	00 90       	ret 
8000d0d8:	40 f4       	mov.aa %a4,%a15
8000d0da:	82 04       	mov %d4,0
8000d0dc:	6d ff b2 ef 	call 8000b040 <_sbrk_r>
8000d0e0:	99 c3 08 00 	ld.a %a3,[%a12]8
8000d0e4:	60 84       	mov.a %a4,%d8
8000d0e6:	30 43       	add.a %a3,%a4
8000d0e8:	7d 32 f3 ff 	jne.a %a2,%a3,8000d0ce <_malloc_trim_r+0x32>
8000d0ec:	40 f4       	mov.aa %a4,%a15
8000d0ee:	8b 0f 00 41 	rsub %d4,%d15,0
8000d0f2:	6d ff a7 ef 	call 8000b040 <_sbrk_r>
8000d0f6:	80 22       	mov.d %d2,%a2
8000d0f8:	df f2 1c 80 	jne %d2,-1,8000d130 <_malloc_trim_r+0x94>
8000d0fc:	40 f4       	mov.aa %a4,%a15
8000d0fe:	82 04       	mov %d4,0
8000d100:	6d ff a0 ef 	call 8000b040 <_sbrk_r>
8000d104:	99 c3 08 00 	ld.a %a3,[%a12]8
8000d108:	01 32 20 40 	sub.a %a4,%a2,%a3
8000d10c:	80 4f       	mov.d %d15,%a4
8000d10e:	8b 0f 41 22 	lt %d2,%d15,16
8000d112:	df 02 de ff 	jne %d2,0,8000d0ce <_malloc_trim_r+0x32>
8000d116:	91 00 00 47 	movh.a %a4,28672
8000d11a:	99 44 18 30 	ld.a %a4,[%a4]216 <700000d8 <__malloc_sbrk_base>>
8000d11e:	96 01       	or %d15,1
8000d120:	6c 31       	st.w [%a3]4,%d15
8000d122:	01 42 20 20 	sub.a %a2,%a2,%a4
8000d126:	91 00 00 47 	movh.a %a4,28672
8000d12a:	b5 42 b0 f0 	st.a [%a4]3056 <70000bf0 <__malloc_current_mallinfo>>,%a2
8000d12e:	3c d0       	j 8000d0ce <_malloc_trim_r+0x32>
8000d130:	99 c2 08 00 	ld.a %a2,[%a12]8
8000d134:	a2 f8       	sub %d8,%d15
8000d136:	8f 18 40 81 	or %d8,%d8,1
8000d13a:	59 28 04 00 	st.w [%a2]4,%d8
8000d13e:	91 00 00 27 	movh.a %a2,28672
8000d142:	19 22 b0 f0 	ld.w %d2,[%a2]3056 <70000bf0 <__malloc_current_mallinfo>>
8000d146:	40 f4       	mov.aa %a4,%a15
8000d148:	5a f2       	sub %d15,%d2,%d15
8000d14a:	59 2f b0 f0 	st.w [%a2]3056 <70000bf0 <__malloc_current_mallinfo>>,%d15
8000d14e:	6d ff 78 ef 	call 8000b03e <__malloc_unlock>
8000d152:	82 12       	mov %d2,1
8000d154:	00 90       	ret 

8000d156 <_free_r>:
8000d156:	40 4d       	mov.aa %a13,%a4
8000d158:	bd 05 d4 00 	jz.a %a5,8000d300 <_free_r+0x1aa>
8000d15c:	40 5c       	mov.aa %a12,%a5
8000d15e:	6d ff 6f ef 	call 8000b03c <__malloc_lock>
8000d162:	19 c4 fc ff 	ld.w %d4,[%a12]-4
8000d166:	d9 cf f8 ff 	lea %a15,[%a12]-8
8000d16a:	8f 14 c0 f1 	andn %d15,%d4,1
8000d16e:	91 00 00 27 	movh.a %a2,28672
8000d172:	10 f3       	addsc.a %a3,%a15,%d15,0
8000d174:	d9 22 20 30 	lea %a2,[%a2]224 <700000e0 <__malloc_av_>>
8000d178:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <g_vadcChannelIDs>>
8000d17c:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <g_vadcChannelIDs>>
8000d180:	8f 14 00 41 	and %d4,%d4,1
8000d184:	8f 33 c0 31 	andn %d3,%d3,3
8000d188:	7d 43 24 80 	jne.a %a3,%a4,8000d1d0 <_free_r+0x7a>
8000d18c:	42 3f       	add %d15,%d3
8000d18e:	f6 4d       	jnz %d4,8000d1a8 <_free_r+0x52>
8000d190:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000d194:	60 23       	mov.a %a3,%d2
8000d196:	42 2f       	add %d15,%d2
8000d198:	01 3f 20 f0 	sub.a %a15,%a15,%a3
8000d19c:	c8 33       	ld.a %a3,[%a15]12
8000d19e:	c8 24       	ld.a %a4,[%a15]8
8000d1a0:	b5 43 0c 00 	st.a [%a4]12,%a3
8000d1a4:	b5 34 08 00 	st.a [%a3]8,%a4
8000d1a8:	8f 1f 40 21 	or %d2,%d15,1
8000d1ac:	68 12       	st.w [%a15]4,%d2
8000d1ae:	ec 22       	st.a [%a2]8,%a15
8000d1b0:	91 00 00 f7 	movh.a %a15,28672
8000d1b4:	19 f2 1c 30 	ld.w %d2,[%a15]220 <700000dc <__malloc_trim_threshold>>
8000d1b8:	3f 2f 09 80 	jlt.u %d15,%d2,8000d1ca <_free_r+0x74>
8000d1bc:	91 00 00 f7 	movh.a %a15,28672
8000d1c0:	40 d4       	mov.aa %a4,%a13
8000d1c2:	19 f4 e0 00 	ld.w %d4,[%a15]3104 <70000c20 <__malloc_top_pad>>
8000d1c6:	6d ff 6b ff 	call 8000d09c <_malloc_trim_r>
8000d1ca:	40 d4       	mov.aa %a4,%a13
8000d1cc:	1d ff 39 ef 	j 8000b03e <__malloc_unlock>
8000d1d0:	59 33 04 00 	st.w [%a3]4,%d3
8000d1d4:	82 02       	mov %d2,0
8000d1d6:	df 04 16 80 	jne %d4,0,8000d202 <_free_r+0xac>
8000d1da:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000d1de:	60 24       	mov.a %a4,%d2
8000d1e0:	42 2f       	add %d15,%d2
8000d1e2:	01 4f 20 f0 	sub.a %a15,%a15,%a4
8000d1e6:	c8 25       	ld.a %a5,[%a15]8
8000d1e8:	91 00 00 47 	movh.a %a4,28672
8000d1ec:	d9 44 28 30 	lea %a4,[%a4]232 <700000e8 <__malloc_av_+0x8>>
8000d1f0:	82 12       	mov %d2,1
8000d1f2:	7d 45 08 00 	jeq.a %a5,%a4,8000d202 <_free_r+0xac>
8000d1f6:	c8 34       	ld.a %a4,[%a15]12
8000d1f8:	82 02       	mov %d2,0
8000d1fa:	b5 54 0c 00 	st.a [%a5]12,%a4
8000d1fe:	b5 45 08 00 	st.a [%a4]8,%a5
8000d202:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
8000d206:	19 44 04 00 	ld.w %d4,[%a4]4
8000d20a:	6f 04 18 80 	jnz.t %d4,0,8000d23a <_free_r+0xe4>
8000d20e:	42 3f       	add %d15,%d3
8000d210:	99 35 08 00 	ld.a %a5,[%a3]8
8000d214:	f6 2d       	jnz %d2,8000d22e <_free_r+0xd8>
8000d216:	91 00 00 47 	movh.a %a4,28672
8000d21a:	d9 44 28 30 	lea %a4,[%a4]232 <700000e8 <__malloc_av_+0x8>>
8000d21e:	7d 45 08 80 	jne.a %a5,%a4,8000d22e <_free_r+0xd8>
8000d222:	ec 25       	st.a [%a2]20,%a15
8000d224:	ec 24       	st.a [%a2]16,%a15
8000d226:	e8 35       	st.a [%a15]12,%a5
8000d228:	e8 25       	st.a [%a15]8,%a5
8000d22a:	82 12       	mov %d2,1
8000d22c:	3c 07       	j 8000d23a <_free_r+0xe4>
8000d22e:	99 33 0c 00 	ld.a %a3,[%a3]12
8000d232:	b5 53 0c 00 	st.a [%a5]12,%a3
8000d236:	b5 35 08 00 	st.a [%a3]8,%a5
8000d23a:	8f 1f 40 31 	or %d3,%d15,1
8000d23e:	10 f3       	addsc.a %a3,%a15,%d15,0
8000d240:	68 13       	st.w [%a15]4,%d3
8000d242:	6c 30       	st.w [%a3]0,%d15
8000d244:	df 02 c3 ff 	jne %d2,0,8000d1ca <_free_r+0x74>
8000d248:	3b 00 20 20 	mov %d2,512
8000d24c:	7f 2f 12 80 	jge.u %d15,%d2,8000d270 <_free_r+0x11a>
8000d250:	19 23 04 00 	ld.w %d3,[%a2]4
8000d254:	06 df       	sh %d15,-3
8000d256:	8f ef 3f 20 	sha %d2,%d15,-2
8000d25a:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
8000d25e:	59 22 04 00 	st.w [%a2]4,%d2
8000d262:	d0 22       	addsc.a %a2,%a2,%d15,3
8000d264:	99 23 08 00 	ld.a %a3,[%a2]8
8000d268:	e8 32       	st.a [%a15]12,%a2
8000d26a:	e8 23       	st.a [%a15]8,%a3
8000d26c:	ec 22       	st.a [%a2]8,%a15
8000d26e:	3c 46       	j 8000d2fa <_free_r+0x1a4>
8000d270:	8f af 1f 30 	sh %d3,%d15,-6
8000d274:	8f 7f 1f 20 	sh %d2,%d15,-9
8000d278:	1b 83 03 30 	addi %d3,%d3,56
8000d27c:	bf 52 22 80 	jlt.u %d2,5,8000d2c0 <_free_r+0x16a>
8000d280:	8b 52 a1 32 	ge.u %d3,%d2,21
8000d284:	f6 34       	jnz %d3,8000d28c <_free_r+0x136>
8000d286:	1b b2 05 30 	addi %d3,%d2,91
8000d28a:	3c 1b       	j 8000d2c0 <_free_r+0x16a>
8000d28c:	8b 52 a5 32 	ge.u %d3,%d2,85
8000d290:	f6 36       	jnz %d3,8000d29c <_free_r+0x146>
8000d292:	8f 4f 1f 30 	sh %d3,%d15,-12
8000d296:	1b e3 06 30 	addi %d3,%d3,110
8000d29a:	3c 13       	j 8000d2c0 <_free_r+0x16a>
8000d29c:	8b 52 b5 32 	ge.u %d3,%d2,341
8000d2a0:	f6 36       	jnz %d3,8000d2ac <_free_r+0x156>
8000d2a2:	8f 1f 1f 30 	sh %d3,%d15,-15
8000d2a6:	1b 73 07 30 	addi %d3,%d3,119
8000d2aa:	3c 0b       	j 8000d2c0 <_free_r+0x16a>
8000d2ac:	3b 50 55 40 	mov %d4,1365
8000d2b0:	3b e0 07 30 	mov %d3,126
8000d2b4:	7f 42 06 80 	jge.u %d2,%d4,8000d2c0 <_free_r+0x16a>
8000d2b8:	8f ef 1e 30 	sh %d3,%d15,-18
8000d2bc:	1b c3 07 30 	addi %d3,%d3,124
8000d2c0:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
8000d2c4:	99 65 08 00 	ld.a %a5,[%a6]8
8000d2c8:	40 53       	mov.aa %a3,%a5
8000d2ca:	7d 65 0d 80 	jne.a %a5,%a6,8000d2e4 <_free_r+0x18e>
8000d2ce:	4c 21       	ld.w %d15,[%a2]4
8000d2d0:	86 e3       	sha %d3,-2
8000d2d2:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
8000d2d6:	59 23 04 00 	st.w [%a2]4,%d3
8000d2da:	3c 0d       	j 8000d2f4 <_free_r+0x19e>
8000d2dc:	99 33 08 00 	ld.a %a3,[%a3]8
8000d2e0:	7d 63 08 00 	jeq.a %a3,%a6,8000d2f0 <_free_r+0x19a>
8000d2e4:	19 32 04 00 	ld.w %d2,[%a3]4
8000d2e8:	8f 32 c0 21 	andn %d2,%d2,3
8000d2ec:	3f 2f f8 ff 	jlt.u %d15,%d2,8000d2dc <_free_r+0x186>
8000d2f0:	99 35 0c 00 	ld.a %a5,[%a3]12
8000d2f4:	e8 35       	st.a [%a15]12,%a5
8000d2f6:	e8 23       	st.a [%a15]8,%a3
8000d2f8:	ec 52       	st.a [%a5]8,%a15
8000d2fa:	ec 33       	st.a [%a3]12,%a15
8000d2fc:	1d ff 67 ff 	j 8000d1ca <_free_r+0x74>
8000d300:	00 90       	ret 

8000d302 <_localeconv_r>:
8000d302:	91 00 00 28 	movh.a %a2,32768
8000d306:	d9 22 c4 80 	lea %a2,[%a2]3588 <80000e04 <lconv>>
8000d30a:	00 90       	ret 

8000d30c <memchr>:
8000d30c:	8f f4 0f 41 	and %d4,%d4,255
8000d310:	9f 05 04 80 	jned %d5,0,8000d318 <memchr+0xc>
8000d314:	a0 02       	mov.a %a2,0
8000d316:	00 90       	ret 
8000d318:	0c 40       	ld.bu %d15,[%a4]0
8000d31a:	3e 43       	jeq %d15,%d4,8000d320 <memchr+0x14>
8000d31c:	b0 14       	add.a %a4,1
8000d31e:	3c f9       	j 8000d310 <memchr+0x4>
8000d320:	40 42       	mov.aa %a2,%a4
8000d322:	00 90       	ret 

8000d324 <memcpy>:
8000d324:	40 42       	mov.aa %a2,%a4
8000d326:	a0 0f       	mov.a %a15,0
8000d328:	01 f2 10 40 	add.a %a4,%a2,%a15
8000d32c:	01 f5 10 30 	add.a %a3,%a5,%a15
8000d330:	9f 04 03 80 	jned %d4,0,8000d336 <memcpy+0x12>
8000d334:	00 90       	ret 
8000d336:	79 3f 00 00 	ld.b %d15,[%a3]0
8000d33a:	b0 1f       	add.a %a15,1
8000d33c:	2c 40       	st.b [%a4]0,%d15
8000d33e:	3c f5       	j 8000d328 <memcpy+0x4>

8000d340 <_Balloc>:
8000d340:	19 42 0c 10 	ld.w %d2,[%a4]76
8000d344:	40 4f       	mov.aa %a15,%a4
8000d346:	02 4f       	mov %d15,%d4
8000d348:	76 29       	jz %d2,8000d35a <_Balloc+0x1a>
8000d34a:	99 f3 0c 10 	ld.a %a3,[%a15]76
8000d34e:	90 33       	addsc.a %a3,%a3,%d15,2
8000d350:	d4 32       	ld.a %a2,[%a3]
8000d352:	bc 2f       	jz.a %a2,8000d370 <_Balloc+0x30>
8000d354:	4c 20       	ld.w %d15,[%a2]0
8000d356:	6c 30       	st.w [%a3]0,%d15
8000d358:	3c 1b       	j 8000d38e <_Balloc+0x4e>
8000d35a:	82 44       	mov %d4,4
8000d35c:	3b 10 02 50 	mov %d5,33
8000d360:	6d 00 5c 03 	call 8000da18 <_calloc_r>
8000d364:	b5 f2 0c 10 	st.a [%a15]76,%a2
8000d368:	bd 02 f1 ff 	jnz.a %a2,8000d34a <_Balloc+0xa>
8000d36c:	a0 02       	mov.a %a2,0
8000d36e:	00 90       	ret 
8000d370:	82 18       	mov %d8,1
8000d372:	0f f8 00 80 	sh %d8,%d8,%d15
8000d376:	1b 58 00 50 	addi %d5,%d8,5
8000d37a:	40 f4       	mov.aa %a4,%a15
8000d37c:	82 14       	mov %d4,1
8000d37e:	06 25       	sh %d5,2
8000d380:	6d 00 4c 03 	call 8000da18 <_calloc_r>
8000d384:	bd 02 f4 7f 	jz.a %a2,8000d36c <_Balloc+0x2c>
8000d388:	6c 21       	st.w [%a2]4,%d15
8000d38a:	59 28 08 00 	st.w [%a2]8,%d8
8000d38e:	82 0f       	mov %d15,0
8000d390:	6c 24       	st.w [%a2]16,%d15
8000d392:	6c 23       	st.w [%a2]12,%d15
8000d394:	00 90       	ret 

8000d396 <_Bfree>:
8000d396:	bc 58       	jz.a %a5,8000d3a6 <_Bfree+0x10>
8000d398:	99 4f 0c 10 	ld.a %a15,[%a4]76
8000d39c:	4c 51       	ld.w %d15,[%a5]4
8000d39e:	90 ff       	addsc.a %a15,%a15,%d15,2
8000d3a0:	4c f0       	ld.w %d15,[%a15]0
8000d3a2:	6c 50       	st.w [%a5]0,%d15
8000d3a4:	e8 05       	st.a [%a15]0,%a5
8000d3a6:	00 90       	ret 

8000d3a8 <__multadd>:
8000d3a8:	19 59 10 00 	ld.w %d9,[%a5]16
8000d3ac:	40 4c       	mov.aa %a12,%a4
8000d3ae:	9a f9       	add %d15,%d9,-1
8000d3b0:	8b 19 80 22 	ge %d2,%d9,1
8000d3b4:	40 5f       	mov.aa %a15,%a5
8000d3b6:	02 58       	mov %d8,%d5
8000d3b8:	d9 53 14 00 	lea %a3,[%a5]20
8000d3bc:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000d3c0:	40 32       	mov.aa %a2,%a3
8000d3c2:	44 25       	ld.w %d5,[%a2+]
8000d3c4:	b7 05 10 38 	insert %d3,%d5,0,16,16
8000d3c8:	8f 05 1f f0 	sh %d15,%d5,-16
8000d3cc:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
8000d3d0:	8f 03 1f 60 	sh %d6,%d3,-16
8000d3d4:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
8000d3d8:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000d3dc:	8f 0f 1f 80 	sh %d8,%d15,-16
8000d3e0:	74 33       	st.w [%a3],%d3
8000d3e2:	40 23       	mov.aa %a3,%a2
8000d3e4:	9f 02 ee ff 	jned %d2,0,8000d3c0 <__multadd+0x18>
8000d3e8:	df 08 1f 00 	jeq %d8,0,8000d426 <__multadd+0x7e>
8000d3ec:	4c f2       	ld.w %d15,[%a15]8
8000d3ee:	3f f9 16 00 	jlt %d9,%d15,8000d41a <__multadd+0x72>
8000d3f2:	48 14       	ld.w %d4,[%a15]4
8000d3f4:	40 c4       	mov.aa %a4,%a12
8000d3f6:	c2 14       	add %d4,1
8000d3f8:	6d ff a4 ff 	call 8000d340 <_Balloc>
8000d3fc:	48 44       	ld.w %d4,[%a15]16
8000d3fe:	d9 f5 0c 00 	lea %a5,[%a15]12
8000d402:	c2 24       	add %d4,2
8000d404:	d9 24 0c 00 	lea %a4,[%a2]12
8000d408:	06 24       	sh %d4,2
8000d40a:	40 2d       	mov.aa %a13,%a2
8000d40c:	6d ff 8c ff 	call 8000d324 <memcpy>
8000d410:	40 f5       	mov.aa %a5,%a15
8000d412:	40 c4       	mov.aa %a4,%a12
8000d414:	6d ff c1 ff 	call 8000d396 <_Bfree>
8000d418:	40 df       	mov.aa %a15,%a13
8000d41a:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
8000d41e:	c2 19       	add %d9,1
8000d420:	59 28 14 00 	st.w [%a2]20,%d8
8000d424:	68 49       	st.w [%a15]16,%d9
8000d426:	40 f2       	mov.aa %a2,%a15
8000d428:	00 90       	ret 

8000d42a <__hi0bits>:
8000d42a:	b7 04 10 f0 	insert %d15,%d4,0,0,16
8000d42e:	82 02       	mov %d2,0
8000d430:	ee 05       	jnz %d15,8000d43a <__hi0bits+0x10>
8000d432:	8f 04 01 40 	sh %d4,%d4,16
8000d436:	3b 00 01 20 	mov %d2,16
8000d43a:	b7 04 18 f0 	insert %d15,%d4,0,0,24
8000d43e:	ee 05       	jnz %d15,8000d448 <__hi0bits+0x1e>
8000d440:	1b 82 00 20 	addi %d2,%d2,8
8000d444:	8f 84 00 40 	sh %d4,%d4,8
8000d448:	b7 04 1c f0 	insert %d15,%d4,0,0,28
8000d44c:	ee 03       	jnz %d15,8000d452 <__hi0bits+0x28>
8000d44e:	c2 42       	add %d2,4
8000d450:	06 44       	sh %d4,4
8000d452:	b7 04 1e f0 	insert %d15,%d4,0,0,30
8000d456:	ee 03       	jnz %d15,8000d45c <__hi0bits+0x32>
8000d458:	c2 22       	add %d2,2
8000d45a:	06 24       	sh %d4,2
8000d45c:	0e 47       	jltz %d4,8000d46a <__hi0bits+0x40>
8000d45e:	7b 00 00 f4 	movh %d15,16384
8000d462:	26 f4       	and %d4,%d15
8000d464:	c2 12       	add %d2,1
8000d466:	ab 02 82 24 	sel %d2,%d4,%d2,32
8000d46a:	00 90       	ret 

8000d46c <__lo0bits>:
8000d46c:	54 43       	ld.w %d3,[%a4]
8000d46e:	8f 73 00 f1 	and %d15,%d3,7
8000d472:	6e 0e       	jz %d15,8000d48e <__lo0bits+0x22>
8000d474:	82 02       	mov %d2,0
8000d476:	6f 03 2d 80 	jnz.t %d3,0,8000d4d0 <__lo0bits+0x64>
8000d47a:	6f 13 06 00 	jz.t %d3,1,8000d486 <__lo0bits+0x1a>
8000d47e:	06 f3       	sh %d3,-1
8000d480:	74 43       	st.w [%a4],%d3
8000d482:	82 12       	mov %d2,1
8000d484:	00 90       	ret 
8000d486:	06 e3       	sh %d3,-2
8000d488:	74 43       	st.w [%a4],%d3
8000d48a:	82 22       	mov %d2,2
8000d48c:	00 90       	ret 
8000d48e:	b7 03 10 f8 	insert %d15,%d3,0,16,16
8000d492:	82 04       	mov %d4,0
8000d494:	ee 05       	jnz %d15,8000d49e <__lo0bits+0x32>
8000d496:	8f 03 1f 30 	sh %d3,%d3,-16
8000d49a:	3b 00 01 40 	mov %d4,16
8000d49e:	02 3f       	mov %d15,%d3
8000d4a0:	16 ff       	and %d15,255
8000d4a2:	ee 04       	jnz %d15,8000d4aa <__lo0bits+0x3e>
8000d4a4:	1b 84 00 40 	addi %d4,%d4,8
8000d4a8:	06 83       	sh %d3,-8
8000d4aa:	8f f3 00 f1 	and %d15,%d3,15
8000d4ae:	ee 03       	jnz %d15,8000d4b4 <__lo0bits+0x48>
8000d4b0:	c2 44       	add %d4,4
8000d4b2:	06 c3       	sh %d3,-4
8000d4b4:	8f 33 00 f1 	and %d15,%d3,3
8000d4b8:	ee 03       	jnz %d15,8000d4be <__lo0bits+0x52>
8000d4ba:	c2 24       	add %d4,2
8000d4bc:	06 e3       	sh %d3,-2
8000d4be:	6f 03 07 80 	jnz.t %d3,0,8000d4cc <__lo0bits+0x60>
8000d4c2:	06 f3       	sh %d3,-1
8000d4c4:	3b 00 02 20 	mov %d2,32
8000d4c8:	76 34       	jz %d3,8000d4d0 <__lo0bits+0x64>
8000d4ca:	c2 14       	add %d4,1
8000d4cc:	74 43       	st.w [%a4],%d3
8000d4ce:	02 42       	mov %d2,%d4
8000d4d0:	00 90       	ret 

8000d4d2 <__i2b>:
8000d4d2:	02 4f       	mov %d15,%d4
8000d4d4:	82 14       	mov %d4,1
8000d4d6:	6d ff 35 ff 	call 8000d340 <_Balloc>
8000d4da:	6c 25       	st.w [%a2]20,%d15
8000d4dc:	82 1f       	mov %d15,1
8000d4de:	6c 24       	st.w [%a2]16,%d15
8000d4e0:	00 90       	ret 

8000d4e2 <__multiply>:
8000d4e2:	19 52 10 00 	ld.w %d2,[%a5]16
8000d4e6:	4c 64       	ld.w %d15,[%a6]16
8000d4e8:	40 5f       	mov.aa %a15,%a5
8000d4ea:	40 6c       	mov.aa %a12,%a6
8000d4ec:	7f f2 04 00 	jge %d2,%d15,8000d4f4 <__multiply+0x12>
8000d4f0:	40 6f       	mov.aa %a15,%a6
8000d4f2:	40 5c       	mov.aa %a12,%a5
8000d4f4:	48 4a       	ld.w %d10,[%a15]16
8000d4f6:	19 c9 10 00 	ld.w %d9,[%a12]16
8000d4fa:	4c f2       	ld.w %d15,[%a15]8
8000d4fc:	0b 9a 00 80 	add %d8,%d10,%d9
8000d500:	48 12       	ld.w %d2,[%a15]4
8000d502:	0b 8f 20 41 	lt %d4,%d15,%d8
8000d506:	42 24       	add %d4,%d2
8000d508:	6d ff 1c ff 	call 8000d340 <_Balloc>
8000d50c:	d9 23 14 00 	lea %a3,[%a2]20
8000d510:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
8000d514:	40 34       	mov.aa %a4,%a3
8000d516:	82 0f       	mov %d15,0
8000d518:	80 43       	mov.d %d3,%a4
8000d51a:	80 d2       	mov.d %d2,%a13
8000d51c:	7f 23 04 80 	jge.u %d3,%d2,8000d524 <__multiply+0x42>
8000d520:	64 4f       	st.w [%a4+],%d15
8000d522:	3c fb       	j 8000d518 <__multiply+0x36>
8000d524:	d9 ff 14 00 	lea %a15,[%a15]20
8000d528:	d9 cc 14 00 	lea %a12,[%a12]20
8000d52c:	80 f3       	mov.d %d3,%a15
8000d52e:	80 cf       	mov.d %d15,%a12
8000d530:	13 4a 20 43 	madd %d4,%d3,%d10,4
8000d534:	13 49 20 0f 	madd %d0,%d15,%d9,4
8000d538:	80 c2       	mov.d %d2,%a12
8000d53a:	7f 02 54 80 	jge.u %d2,%d0,8000d5e2 <__multiply+0x100>
8000d53e:	b9 c2 00 00 	ld.hu %d2,[%a12]0
8000d542:	40 34       	mov.aa %a4,%a3
8000d544:	40 f6       	mov.aa %a6,%a15
8000d546:	82 03       	mov %d3,0
8000d548:	df 02 21 00 	jeq %d2,0,8000d58a <__multiply+0xa8>
8000d54c:	40 45       	mov.aa %a5,%a4
8000d54e:	44 67       	ld.w %d7,[%a6+]
8000d550:	44 56       	ld.w %d6,[%a5+]
8000d552:	b7 07 10 18 	insert %d1,%d7,0,16,16
8000d556:	b7 06 10 58 	insert %d5,%d6,0,16,16
8000d55a:	8f 07 1f 70 	sh %d7,%d7,-16
8000d55e:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
8000d562:	8f 06 1f 60 	sh %d6,%d6,-16
8000d566:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
8000d56a:	42 35       	add %d5,%d3
8000d56c:	8f 05 1f 30 	sh %d3,%d5,-16
8000d570:	1a 36       	add %d15,%d6,%d3
8000d572:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
8000d576:	8f 0f 1f 30 	sh %d3,%d15,-16
8000d57a:	80 6f       	mov.d %d15,%a6
8000d57c:	74 45       	st.w [%a4],%d5
8000d57e:	7f 4f 04 80 	jge.u %d15,%d4,8000d586 <__multiply+0xa4>
8000d582:	40 54       	mov.aa %a4,%a5
8000d584:	3c e4       	j 8000d54c <__multiply+0x6a>
8000d586:	59 43 04 00 	st.w [%a4]4,%d3
8000d58a:	b9 c2 02 00 	ld.hu %d2,[%a12]2
8000d58e:	df 02 27 00 	jeq %d2,0,8000d5dc <__multiply+0xfa>
8000d592:	54 33       	ld.w %d3,[%a3]
8000d594:	40 34       	mov.aa %a4,%a3
8000d596:	40 f5       	mov.aa %a5,%a15
8000d598:	82 07       	mov %d7,0
8000d59a:	40 56       	mov.aa %a6,%a5
8000d59c:	44 66       	ld.w %d6,[%a6+]
8000d59e:	40 47       	mov.aa %a7,%a4
8000d5a0:	44 75       	ld.w %d5,[%a7+]
8000d5a2:	b7 06 10 68 	insert %d6,%d6,0,16,16
8000d5a6:	8f 05 1f 50 	sh %d5,%d5,-16
8000d5aa:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
8000d5ae:	42 7f       	add %d15,%d7
8000d5b0:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000d5b4:	8f 0f 1f f0 	sh %d15,%d15,-16
8000d5b8:	74 43       	st.w [%a4],%d3
8000d5ba:	b9 55 02 00 	ld.hu %d5,[%a5]2
8000d5be:	b9 43 04 00 	ld.hu %d3,[%a4]4
8000d5c2:	40 65       	mov.aa %a5,%a6
8000d5c4:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
8000d5c8:	42 f3       	add %d3,%d15
8000d5ca:	80 6f       	mov.d %d15,%a6
8000d5cc:	8f 03 1f 70 	sh %d7,%d3,-16
8000d5d0:	7f 4f 04 80 	jge.u %d15,%d4,8000d5d8 <__multiply+0xf6>
8000d5d4:	40 74       	mov.aa %a4,%a7
8000d5d6:	3c e2       	j 8000d59a <__multiply+0xb8>
8000d5d8:	59 43 04 00 	st.w [%a4]4,%d3
8000d5dc:	b0 4c       	add.a %a12,4
8000d5de:	b0 43       	add.a %a3,4
8000d5e0:	3c ac       	j 8000d538 <__multiply+0x56>
8000d5e2:	8b 08 40 f3 	max %d15,%d8,0
8000d5e6:	9f 0f 05 80 	jned %d15,0,8000d5f0 <__multiply+0x10e>
8000d5ea:	59 28 10 00 	st.w [%a2]16,%d8
8000d5ee:	00 90       	ret 
8000d5f0:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
8000d5f4:	df 02 fb ff 	jne %d2,0,8000d5ea <__multiply+0x108>
8000d5f8:	c2 f8       	add %d8,-1
8000d5fa:	3c f6       	j 8000d5e6 <__multiply+0x104>

8000d5fc <__pow5mult>:
8000d5fc:	8f 34 00 21 	and %d2,%d4,3
8000d600:	40 4c       	mov.aa %a12,%a4
8000d602:	40 5d       	mov.aa %a13,%a5
8000d604:	02 4f       	mov %d15,%d4
8000d606:	76 2d       	jz %d2,8000d620 <__pow5mult+0x24>
8000d608:	91 00 00 f8 	movh.a %a15,32768
8000d60c:	d9 ff fc 80 	lea %a15,[%a15]3644 <80000e3c <p05.2553>>
8000d610:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
8000d614:	82 05       	mov %d5,0
8000d616:	19 f4 fc ff 	ld.w %d4,[%a15]-4
8000d61a:	6d ff c7 fe 	call 8000d3a8 <__multadd>
8000d61e:	40 2d       	mov.aa %a13,%a2
8000d620:	86 ef       	sha %d15,-2
8000d622:	6e 29       	jz %d15,8000d674 <__pow5mult+0x78>
8000d624:	99 cf 08 10 	ld.a %a15,[%a12]72
8000d628:	7c fb       	jnz.a %a15,8000d63e <__pow5mult+0x42>
8000d62a:	40 c4       	mov.aa %a4,%a12
8000d62c:	3b 10 27 40 	mov %d4,625
8000d630:	6d ff 51 ff 	call 8000d4d2 <__i2b>
8000d634:	82 02       	mov %d2,0
8000d636:	b5 c2 08 10 	st.a [%a12]72,%a2
8000d63a:	40 2f       	mov.aa %a15,%a2
8000d63c:	74 22       	st.w [%a2],%d2
8000d63e:	82 08       	mov %d8,0
8000d640:	2e 0c       	jz.t %d15,0,8000d658 <__pow5mult+0x5c>
8000d642:	40 d5       	mov.aa %a5,%a13
8000d644:	40 c4       	mov.aa %a4,%a12
8000d646:	40 f6       	mov.aa %a6,%a15
8000d648:	6d ff 4d ff 	call 8000d4e2 <__multiply>
8000d64c:	40 d5       	mov.aa %a5,%a13
8000d64e:	40 2e       	mov.aa %a14,%a2
8000d650:	40 c4       	mov.aa %a4,%a12
8000d652:	6d ff a2 fe 	call 8000d396 <_Bfree>
8000d656:	40 ed       	mov.aa %a13,%a14
8000d658:	86 ff       	sha %d15,-1
8000d65a:	6e 0d       	jz %d15,8000d674 <__pow5mult+0x78>
8000d65c:	c8 02       	ld.a %a2,[%a15]0
8000d65e:	bc 23       	jz.a %a2,8000d664 <__pow5mult+0x68>
8000d660:	40 2f       	mov.aa %a15,%a2
8000d662:	3c ef       	j 8000d640 <__pow5mult+0x44>
8000d664:	40 c4       	mov.aa %a4,%a12
8000d666:	40 f5       	mov.aa %a5,%a15
8000d668:	40 f6       	mov.aa %a6,%a15
8000d66a:	6d ff 3c ff 	call 8000d4e2 <__multiply>
8000d66e:	e8 02       	st.a [%a15]0,%a2
8000d670:	74 28       	st.w [%a2],%d8
8000d672:	3c f7       	j 8000d660 <__pow5mult+0x64>
8000d674:	40 d2       	mov.aa %a2,%a13
8000d676:	00 90       	ret 

8000d678 <__lshift>:
8000d678:	19 5b 10 00 	ld.w %d11,[%a5]16
8000d67c:	8f b4 3f 80 	sha %d8,%d4,-5
8000d680:	02 4a       	mov %d10,%d4
8000d682:	42 8b       	add %d11,%d8
8000d684:	19 54 04 00 	ld.w %d4,[%a5]4
8000d688:	4c 52       	ld.w %d15,[%a5]8
8000d68a:	40 4e       	mov.aa %a14,%a4
8000d68c:	40 5c       	mov.aa %a12,%a5
8000d68e:	1b 1b 00 90 	addi %d9,%d11,1
8000d692:	7f 9f 05 00 	jge %d15,%d9,8000d69c <__lshift+0x24>
8000d696:	c2 14       	add %d4,1
8000d698:	06 1f       	sh %d15,1
8000d69a:	3c fc       	j 8000d692 <__lshift+0x1a>
8000d69c:	40 e4       	mov.aa %a4,%a14
8000d69e:	6d ff 51 fe 	call 8000d340 <_Balloc>
8000d6a2:	8b 08 40 f3 	max %d15,%d8,0
8000d6a6:	40 2d       	mov.aa %a13,%a2
8000d6a8:	d9 2f 14 00 	lea %a15,[%a2]20
8000d6ac:	d2 02       	mov %e2,0
8000d6ae:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
8000d6b2:	9f 0f 03 80 	jned %d15,0,8000d6b8 <__lshift+0x40>
8000d6b6:	3c 04       	j 8000d6be <__lshift+0x46>
8000d6b8:	74 23       	st.w [%a2],%d3
8000d6ba:	c2 12       	add %d2,1
8000d6bc:	3c f9       	j 8000d6ae <__lshift+0x36>
8000d6be:	8b 08 40 83 	max %d8,%d8,0
8000d6c2:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
8000d6c6:	d9 cf 14 00 	lea %a15,[%a12]20
8000d6ca:	19 c2 10 00 	ld.w %d2,[%a12]16
8000d6ce:	80 f3       	mov.d %d3,%a15
8000d6d0:	8f fa 01 41 	and %d4,%d10,31
8000d6d4:	13 42 20 23 	madd %d2,%d3,%d2,4
8000d6d8:	8b 04 02 51 	rsub %d5,%d4,32
8000d6dc:	82 0f       	mov %d15,0
8000d6de:	df 04 1a 00 	jeq %d4,0,8000d712 <__lshift+0x9a>
8000d6e2:	40 f5       	mov.aa %a5,%a15
8000d6e4:	44 53       	ld.w %d3,[%a5+]
8000d6e6:	d9 32 04 00 	lea %a2,[%a3]4
8000d6ea:	0f 43 00 30 	sh %d3,%d3,%d4
8000d6ee:	a6 3f       	or %d15,%d3
8000d6f0:	6c 30       	st.w [%a3]0,%d15
8000d6f2:	4c f0       	ld.w %d15,[%a15]0
8000d6f4:	8b 05 00 31 	rsub %d3,%d5,0
8000d6f8:	0f 3f 00 30 	sh %d3,%d15,%d3
8000d6fc:	02 3f       	mov %d15,%d3
8000d6fe:	80 53       	mov.d %d3,%a5
8000d700:	40 5f       	mov.aa %a15,%a5
8000d702:	7f 23 04 80 	jge.u %d3,%d2,8000d70a <__lshift+0x92>
8000d706:	40 23       	mov.aa %a3,%a2
8000d708:	3c ed       	j 8000d6e2 <__lshift+0x6a>
8000d70a:	c2 2b       	add %d11,2
8000d70c:	6c 31       	st.w [%a3]4,%d15
8000d70e:	2a b9       	cmov %d9,%d15,%d11
8000d710:	3c 08       	j 8000d720 <__lshift+0xa8>
8000d712:	4c f0       	ld.w %d15,[%a15]0
8000d714:	b0 4f       	add.a %a15,4
8000d716:	80 f3       	mov.d %d3,%a15
8000d718:	6c 30       	st.w [%a3]0,%d15
8000d71a:	b0 43       	add.a %a3,4
8000d71c:	3f 23 fb ff 	jlt.u %d3,%d2,8000d712 <__lshift+0x9a>
8000d720:	c2 f9       	add %d9,-1
8000d722:	59 d9 10 00 	st.w [%a13]16,%d9
8000d726:	40 e4       	mov.aa %a4,%a14
8000d728:	40 c5       	mov.aa %a5,%a12
8000d72a:	6d ff 36 fe 	call 8000d396 <_Bfree>
8000d72e:	40 d2       	mov.aa %a2,%a13
8000d730:	00 90       	ret 

8000d732 <__mcmp>:
8000d732:	4c 54       	ld.w %d15,[%a5]16
8000d734:	19 42 10 00 	ld.w %d2,[%a4]16
8000d738:	a2 f2       	sub %d2,%d15
8000d73a:	df 02 1c 80 	jne %d2,0,8000d772 <__mcmp+0x40>
8000d73e:	80 42       	mov.d %d2,%a4
8000d740:	06 2f       	sh %d15,2
8000d742:	60 f2       	mov.a %a2,%d15
8000d744:	1b 42 01 30 	addi %d3,%d2,20
8000d748:	d9 55 14 00 	lea %a5,[%a5]20
8000d74c:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
8000d750:	30 25       	add.a %a5,%a2
8000d752:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
8000d756:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
8000d75a:	5f f2 08 00 	jeq %d2,%d15,8000d76a <__mcmp+0x38>
8000d75e:	0b f2 30 21 	lt.u %d2,%d2,%d15
8000d762:	82 f3       	mov %d3,-1
8000d764:	ab 13 80 22 	sel %d2,%d2,%d3,1
8000d768:	00 90       	ret 
8000d76a:	80 ff       	mov.d %d15,%a15
8000d76c:	3f f3 f3 ff 	jlt.u %d3,%d15,8000d752 <__mcmp+0x20>
8000d770:	82 02       	mov %d2,0
8000d772:	00 90       	ret 

8000d774 <__mdiff>:
8000d774:	40 4d       	mov.aa %a13,%a4
8000d776:	40 5f       	mov.aa %a15,%a5
8000d778:	40 54       	mov.aa %a4,%a5
8000d77a:	40 65       	mov.aa %a5,%a6
8000d77c:	40 6c       	mov.aa %a12,%a6
8000d77e:	6d ff da ff 	call 8000d732 <__mcmp>
8000d782:	02 2f       	mov %d15,%d2
8000d784:	f6 2a       	jnz %d2,8000d798 <__mdiff+0x24>
8000d786:	40 d4       	mov.aa %a4,%a13
8000d788:	82 04       	mov %d4,0
8000d78a:	6d ff db fd 	call 8000d340 <_Balloc>
8000d78e:	82 12       	mov %d2,1
8000d790:	59 22 10 00 	st.w [%a2]16,%d2
8000d794:	6c 25       	st.w [%a2]20,%d15
8000d796:	00 90       	ret 
8000d798:	82 08       	mov %d8,0
8000d79a:	ce 25       	jgez %d2,8000d7a4 <__mdiff+0x30>
8000d79c:	40 f2       	mov.aa %a2,%a15
8000d79e:	82 18       	mov %d8,1
8000d7a0:	40 cf       	mov.aa %a15,%a12
8000d7a2:	40 2c       	mov.aa %a12,%a2
8000d7a4:	40 d4       	mov.aa %a4,%a13
8000d7a6:	48 14       	ld.w %d4,[%a15]4
8000d7a8:	6d ff cc fd 	call 8000d340 <_Balloc>
8000d7ac:	48 42       	ld.w %d2,[%a15]16
8000d7ae:	d9 ff 14 00 	lea %a15,[%a15]20
8000d7b2:	80 ff       	mov.d %d15,%a15
8000d7b4:	d9 c4 14 00 	lea %a4,[%a12]20
8000d7b8:	13 42 20 7f 	madd %d7,%d15,%d2,4
8000d7bc:	19 c0 10 00 	ld.w %d0,[%a12]16
8000d7c0:	80 4f       	mov.d %d15,%a4
8000d7c2:	59 28 0c 00 	st.w [%a2]12,%d8
8000d7c6:	13 40 20 0f 	madd %d0,%d15,%d0,4
8000d7ca:	d9 25 14 00 	lea %a5,[%a2]20
8000d7ce:	82 03       	mov %d3,0
8000d7d0:	44 f6       	ld.w %d6,[%a15+]
8000d7d2:	44 45       	ld.w %d5,[%a4+]
8000d7d4:	b7 06 10 48 	insert %d4,%d6,0,16,16
8000d7d8:	b7 05 10 18 	insert %d1,%d5,0,16,16
8000d7dc:	42 34       	add %d4,%d3
8000d7de:	a2 14       	sub %d4,%d1
8000d7e0:	8f 06 1f 60 	sh %d6,%d6,-16
8000d7e4:	8f 05 1f 50 	sh %d5,%d5,-16
8000d7e8:	8f 04 3f 30 	sha %d3,%d4,-16
8000d7ec:	0b 56 80 50 	sub %d5,%d6,%d5
8000d7f0:	1a 35       	add %d15,%d5,%d3
8000d7f2:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000d7f6:	8f 0f 3f 30 	sha %d3,%d15,-16
8000d7fa:	80 4f       	mov.d %d15,%a4
8000d7fc:	d9 53 04 00 	lea %a3,[%a5]4
8000d800:	74 54       	st.w [%a5],%d4
8000d802:	40 35       	mov.aa %a5,%a3
8000d804:	3f 0f e6 ff 	jlt.u %d15,%d0,8000d7d0 <__mdiff+0x5c>
8000d808:	80 ff       	mov.d %d15,%a15
8000d80a:	7f 7f 12 80 	jge.u %d15,%d7,8000d82e <__mdiff+0xba>
8000d80e:	44 f5       	ld.w %d5,[%a15+]
8000d810:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000d814:	8f 05 1f 50 	sh %d5,%d5,-16
8000d818:	42 34       	add %d4,%d3
8000d81a:	8f 04 3f f0 	sha %d15,%d4,-16
8000d81e:	42 5f       	add %d15,%d5
8000d820:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000d824:	8f 0f 3f 30 	sha %d3,%d15,-16
8000d828:	74 34       	st.w [%a3],%d4
8000d82a:	b0 43       	add.a %a3,4
8000d82c:	3c ee       	j 8000d808 <__mdiff+0x94>
8000d82e:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
8000d832:	ee 03       	jnz %d15,8000d838 <__mdiff+0xc4>
8000d834:	c2 f2       	add %d2,-1
8000d836:	3c fc       	j 8000d82e <__mdiff+0xba>
8000d838:	59 22 10 00 	st.w [%a2]16,%d2
8000d83c:	00 90       	ret 

8000d83e <__d2b>:
8000d83e:	20 08       	sub.a %sp,8
8000d840:	02 48       	mov %d8,%d4
8000d842:	82 14       	mov %d4,1
8000d844:	02 59       	mov %d9,%d5
8000d846:	40 5d       	mov.aa %a13,%a5
8000d848:	40 6c       	mov.aa %a12,%a6
8000d84a:	6d ff 7b fd 	call 8000d340 <_Balloc>
8000d84e:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
8000d852:	37 09 6b 9a 	extr.u %d9,%d9,20,11
8000d856:	40 2f       	mov.aa %a15,%a2
8000d858:	76 93       	jz %d9,8000d85e <__d2b+0x20>
8000d85a:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
8000d85e:	59 a2 04 00 	st.w [%sp]4,%d2
8000d862:	df 08 20 00 	jeq %d8,0,8000d8a2 <__d2b+0x64>
8000d866:	d9 a4 08 00 	lea %a4,[%sp]8
8000d86a:	89 48 38 f5 	st.w [+%a4]-8,%d8
8000d86e:	40 a4       	mov.aa %a4,%sp
8000d870:	6d ff fe fd 	call 8000d46c <__lo0bits>
8000d874:	58 00       	ld.w %d15,[%sp]0
8000d876:	76 2f       	jz %d2,8000d894 <__d2b+0x56>
8000d878:	19 a4 04 00 	ld.w %d4,[%sp]4
8000d87c:	8b 02 02 31 	rsub %d3,%d2,32
8000d880:	0f 34 00 30 	sh %d3,%d4,%d3
8000d884:	a6 3f       	or %d15,%d3
8000d886:	68 5f       	st.w [%a15]20,%d15
8000d888:	8b 02 00 f1 	rsub %d15,%d2,0
8000d88c:	0f f4 00 f0 	sh %d15,%d4,%d15
8000d890:	78 01       	st.w [%sp]4,%d15
8000d892:	3c 02       	j 8000d896 <__d2b+0x58>
8000d894:	68 5f       	st.w [%a15]20,%d15
8000d896:	58 01       	ld.w %d15,[%sp]4
8000d898:	82 28       	mov %d8,2
8000d89a:	ea 18       	cmovn %d8,%d15,1
8000d89c:	68 6f       	st.w [%a15]24,%d15
8000d89e:	68 48       	st.w [%a15]16,%d8
8000d8a0:	3c 0c       	j 8000d8b8 <__d2b+0x7a>
8000d8a2:	d9 a4 04 00 	lea %a4,[%sp]4
8000d8a6:	6d ff e3 fd 	call 8000d46c <__lo0bits>
8000d8aa:	58 01       	ld.w %d15,[%sp]4
8000d8ac:	1b 02 02 20 	addi %d2,%d2,32
8000d8b0:	68 5f       	st.w [%a15]20,%d15
8000d8b2:	82 1f       	mov %d15,1
8000d8b4:	68 4f       	st.w [%a15]16,%d15
8000d8b6:	82 18       	mov %d8,1
8000d8b8:	76 98       	jz %d9,8000d8c8 <__d2b+0x8a>
8000d8ba:	1b d9 bc 9f 	addi %d9,%d9,-1075
8000d8be:	42 29       	add %d9,%d2
8000d8c0:	74 d9       	st.w [%a13],%d9
8000d8c2:	8b 52 03 21 	rsub %d2,%d2,53
8000d8c6:	3c 0d       	j 8000d8e0 <__d2b+0xa2>
8000d8c8:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
8000d8cc:	1b e2 bc 2f 	addi %d2,%d2,-1074
8000d8d0:	74 d2       	st.w [%a13],%d2
8000d8d2:	19 24 10 00 	ld.w %d4,[%a2]16
8000d8d6:	6d ff aa fd 	call 8000d42a <__hi0bits>
8000d8da:	06 58       	sh %d8,5
8000d8dc:	0b 28 80 20 	sub %d2,%d8,%d2
8000d8e0:	74 c2       	st.w [%a12],%d2
8000d8e2:	40 f2       	mov.aa %a2,%a15
8000d8e4:	00 90       	ret 

8000d8e6 <__fpclassifyd>:
8000d8e6:	0f 45 a0 f0 	or %d15,%d5,%d4
8000d8ea:	82 22       	mov %d2,2
8000d8ec:	6e 1d       	jz %d15,8000d926 <__fpclassifyd+0x40>
8000d8ee:	7b 00 00 38 	movh %d3,32768
8000d8f2:	3a 53       	eq %d15,%d3,%d5
8000d8f4:	8b 04 00 f4 	and.eq %d15,%d4,0
8000d8f8:	8b 04 00 62 	eq %d6,%d4,0
8000d8fc:	ee 15       	jnz %d15,8000d926 <__fpclassifyd+0x40>
8000d8fe:	b7 05 81 5f 	insert %d5,%d5,0,31,1
8000d902:	7b 00 fe f7 	movh %d15,32736
8000d906:	9b 05 ff 3f 	addih %d3,%d5,65520
8000d90a:	82 42       	mov %d2,4
8000d90c:	3f f3 0d 80 	jlt.u %d3,%d15,8000d926 <__fpclassifyd+0x40>
8000d910:	7b 00 01 f0 	movh %d15,16
8000d914:	82 32       	mov %d2,3
8000d916:	3f f5 08 80 	jlt.u %d5,%d15,8000d926 <__fpclassifyd+0x40>
8000d91a:	7b 00 ff 27 	movh %d2,32752
8000d91e:	0b 25 00 51 	eq %d5,%d5,%d2
8000d922:	0f 56 80 20 	and %d2,%d6,%d5
8000d926:	00 90       	ret 

8000d928 <__ssprint_r>:
8000d928:	4c 62       	ld.w %d15,[%a6]8
8000d92a:	20 08       	sub.a %sp,8
8000d92c:	40 4e       	mov.aa %a14,%a4
8000d92e:	40 5f       	mov.aa %a15,%a5
8000d930:	40 6c       	mov.aa %a12,%a6
8000d932:	54 6c       	ld.w %d12,[%a6]
8000d934:	6e 30       	jz %d15,8000d994 <__ssprint_r+0x6c>
8000d936:	a0 02       	mov.a %a2,0
8000d938:	b5 a2 04 00 	st.a [%sp]4,%a2
8000d93c:	82 09       	mov %d9,0
8000d93e:	3b 00 48 e0 	mov %d14,1152
8000d942:	3b f0 b7 df 	mov %d13,-1153
8000d946:	3c 0a       	j 8000d95a <__ssprint_r+0x32>
8000d948:	60 c2       	mov.a %a2,%d12
8000d94a:	d4 22       	ld.a %a2,[%a2]
8000d94c:	b5 a2 04 00 	st.a [%sp]4,%a2
8000d950:	60 c2       	mov.a %a2,%d12
8000d952:	1b 8c 00 c0 	addi %d12,%d12,8
8000d956:	19 29 04 00 	ld.w %d9,[%a2]4
8000d95a:	df 09 f7 7f 	jeq %d9,0,8000d948 <__ssprint_r+0x20>
8000d95e:	48 28       	ld.w %d8,[%a15]8
8000d960:	3f 89 5a 80 	jlt.u %d9,%d8,8000da14 <__ssprint_r+0xec>
8000d964:	88 62       	ld.h %d2,[%a15]12
8000d966:	0f e2 80 f0 	and %d15,%d2,%d14
8000d96a:	ee 19       	jnz %d15,8000d99c <__ssprint_r+0x74>
8000d96c:	3f 89 54 80 	jlt.u %d9,%d8,8000da14 <__ssprint_r+0xec>
8000d970:	c8 04       	ld.a %a4,[%a15]0
8000d972:	99 a5 04 00 	ld.a %a5,[%sp]4 <0 <NULL>>
8000d976:	02 84       	mov %d4,%d8
8000d978:	6d 00 81 00 	call 8000da7a <memmove>
8000d97c:	4c f2       	ld.w %d15,[%a15]8
8000d97e:	a2 8f       	sub %d15,%d8
8000d980:	68 2f       	st.w [%a15]8,%d15
8000d982:	4c f0       	ld.w %d15,[%a15]0
8000d984:	42 f8       	add %d8,%d15
8000d986:	4c c2       	ld.w %d15,[%a12]8
8000d988:	68 08       	st.w [%a15]0,%d8
8000d98a:	52 99       	sub %d9,%d15,%d9
8000d98c:	59 c9 08 00 	st.w [%a12]8,%d9
8000d990:	df 09 dc ff 	jne %d9,0,8000d948 <__ssprint_r+0x20>
8000d994:	82 0f       	mov %d15,0
8000d996:	6c c1       	st.w [%a12]4,%d15
8000d998:	82 02       	mov %d2,0
8000d99a:	00 90       	ret 
8000d99c:	c8 45       	ld.a %a5,[%a15]16
8000d99e:	48 5a       	ld.w %d10,[%a15]20
8000d9a0:	4c f0       	ld.w %d15,[%a15]0
8000d9a2:	80 53       	mov.d %d3,%a5
8000d9a4:	53 3a 20 a0 	mul %d10,%d10,3
8000d9a8:	a2 3f       	sub %d15,%d3
8000d9aa:	82 23       	mov %d3,2
8000d9ac:	4b 3a 01 a2 	div %e10,%d10,%d3
8000d9b0:	92 13       	add %d3,%d15,1
8000d9b2:	42 93       	add %d3,%d9
8000d9b4:	0b 3a b0 a1 	max.u %d10,%d10,%d3
8000d9b8:	40 e4       	mov.aa %a4,%a14
8000d9ba:	02 a4       	mov %d4,%d10
8000d9bc:	6f a2 12 00 	jz.t %d2,10,8000d9e0 <__ssprint_r+0xb8>
8000d9c0:	6d ff f1 e8 	call 8000aba2 <_malloc_r>
8000d9c4:	40 2d       	mov.aa %a13,%a2
8000d9c6:	bd 02 15 00 	jz.a %a2,8000d9f0 <__ssprint_r+0xc8>
8000d9ca:	c8 45       	ld.a %a5,[%a15]16
8000d9cc:	40 24       	mov.aa %a4,%a2
8000d9ce:	02 f4       	mov %d4,%d15
8000d9d0:	6d ff aa fc 	call 8000d324 <memcpy>
8000d9d4:	88 62       	ld.h %d2,[%a15]12
8000d9d6:	26 d2       	and %d2,%d13
8000d9d8:	8f 02 48 21 	or %d2,%d2,128
8000d9dc:	a8 62       	st.h [%a15]12,%d2
8000d9de:	3c 13       	j 8000da04 <__ssprint_r+0xdc>
8000d9e0:	6d 00 7d 00 	call 8000dada <_realloc_r>
8000d9e4:	40 2d       	mov.aa %a13,%a2
8000d9e6:	7c 2f       	jnz.a %a2,8000da04 <__ssprint_r+0xdc>
8000d9e8:	c8 45       	ld.a %a5,[%a15]16
8000d9ea:	40 e4       	mov.aa %a4,%a14
8000d9ec:	6d ff b5 fb 	call 8000d156 <_free_r>
8000d9f0:	da 0c       	mov %d15,12
8000d9f2:	6c e0       	st.w [%a14]0,%d15
8000d9f4:	8c f6       	ld.h %d15,[%a15]12
8000d9f6:	82 f2       	mov %d2,-1
8000d9f8:	96 40       	or %d15,64
8000d9fa:	a8 6f       	st.h [%a15]12,%d15
8000d9fc:	82 0f       	mov %d15,0
8000d9fe:	6c c2       	st.w [%a12]8,%d15
8000da00:	6c c1       	st.w [%a12]4,%d15
8000da02:	00 90       	ret 
8000da04:	e8 4d       	st.a [%a15]16,%a13
8000da06:	10 dd       	addsc.a %a13,%a13,%d15,0
8000da08:	68 5a       	st.w [%a15]20,%d10
8000da0a:	a2 fa       	sub %d10,%d15
8000da0c:	e8 0d       	st.a [%a15]0,%a13
8000da0e:	02 98       	mov %d8,%d9
8000da10:	68 2a       	st.w [%a15]8,%d10
8000da12:	3c ad       	j 8000d96c <__ssprint_r+0x44>
8000da14:	02 98       	mov %d8,%d9
8000da16:	3c ad       	j 8000d970 <__ssprint_r+0x48>

8000da18 <_calloc_r>:
8000da18:	e2 54       	mul %d4,%d5
8000da1a:	6d ff c4 e8 	call 8000aba2 <_malloc_r>
8000da1e:	40 2f       	mov.aa %a15,%a2
8000da20:	a0 02       	mov.a %a2,0
8000da22:	bd 0f 2b 00 	jz.a %a15,8000da78 <_calloc_r+0x60>
8000da26:	19 f5 fc ff 	ld.w %d5,[%a15]-4
8000da2a:	8f 35 c0 51 	andn %d5,%d5,3
8000da2e:	c2 c5       	add %d5,-4
8000da30:	8b 55 a2 f2 	ge.u %d15,%d5,37
8000da34:	ee 1d       	jnz %d15,8000da6e <_calloc_r+0x56>
8000da36:	8b 45 61 f2 	lt.u %d15,%d5,20
8000da3a:	40 f2       	mov.aa %a2,%a15
8000da3c:	ee 14       	jnz %d15,8000da64 <_calloc_r+0x4c>
8000da3e:	82 0f       	mov %d15,0
8000da40:	68 0f       	st.w [%a15]0,%d15
8000da42:	68 1f       	st.w [%a15]4,%d15
8000da44:	8b c5 a1 22 	ge.u %d2,%d5,28
8000da48:	d9 f2 08 00 	lea %a2,[%a15]8
8000da4c:	76 2c       	jz %d2,8000da64 <_calloc_r+0x4c>
8000da4e:	68 2f       	st.w [%a15]8,%d15
8000da50:	68 3f       	st.w [%a15]12,%d15
8000da52:	8b 45 02 52 	eq %d5,%d5,36
8000da56:	d9 f2 10 00 	lea %a2,[%a15]16
8000da5a:	76 55       	jz %d5,8000da64 <_calloc_r+0x4c>
8000da5c:	68 4f       	st.w [%a15]16,%d15
8000da5e:	d9 f2 18 00 	lea %a2,[%a15]24
8000da62:	68 5f       	st.w [%a15]20,%d15
8000da64:	82 0f       	mov %d15,0
8000da66:	6c 20       	st.w [%a2]0,%d15
8000da68:	6c 21       	st.w [%a2]4,%d15
8000da6a:	6c 22       	st.w [%a2]8,%d15
8000da6c:	3c 05       	j 8000da76 <_calloc_r+0x5e>
8000da6e:	40 f4       	mov.aa %a4,%a15
8000da70:	82 04       	mov %d4,0
8000da72:	6d 00 2c 00 	call 8000daca <memset>
8000da76:	40 f2       	mov.aa %a2,%a15
8000da78:	00 90       	ret 

8000da7a <memmove>:
8000da7a:	80 46       	mov.d %d6,%a4
8000da7c:	80 52       	mov.d %d2,%a5
8000da7e:	7f 62 16 80 	jge.u %d2,%d6,8000daaa <memmove+0x30>
8000da82:	0b 42 00 50 	add %d5,%d2,%d4
8000da86:	7f 56 12 80 	jge.u %d6,%d5,8000daaa <memmove+0x30>
8000da8a:	60 4f       	mov.a %a15,%d4
8000da8c:	02 42       	mov %d2,%d4
8000da8e:	c2 f2       	add %d2,-1
8000da90:	fd f0 03 00 	loop %a15,8000da96 <memmove+0x1c>
8000da94:	3c 19       	j 8000dac6 <memmove+0x4c>
8000da96:	5a 42       	sub %d15,%d2,%d4
8000da98:	60 f2       	mov.a %a2,%d15
8000da9a:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
8000da9e:	1a 62       	add %d15,%d2,%d6
8000daa0:	79 23 00 00 	ld.b %d3,[%a2]0
8000daa4:	60 f2       	mov.a %a2,%d15
8000daa6:	34 23       	st.b [%a2],%d3
8000daa8:	3c f3       	j 8000da8e <memmove+0x14>
8000daaa:	60 4f       	mov.a %a15,%d4
8000daac:	a0 02       	mov.a %a2,0
8000daae:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
8000dab2:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
8000dab6:	fd f0 03 00 	loop %a15,8000dabc <memmove+0x42>
8000daba:	3c 06       	j 8000dac6 <memmove+0x4c>
8000dabc:	79 33 00 00 	ld.b %d3,[%a3]0
8000dac0:	b0 12       	add.a %a2,1
8000dac2:	34 43       	st.b [%a4],%d3
8000dac4:	3c f5       	j 8000daae <memmove+0x34>
8000dac6:	60 62       	mov.a %a2,%d6
8000dac8:	00 90       	ret 

8000daca <memset>:
8000daca:	40 42       	mov.aa %a2,%a4
8000dacc:	40 4f       	mov.aa %a15,%a4
8000dace:	9f 05 03 80 	jned %d5,0,8000dad4 <memset+0xa>
8000dad2:	00 90       	ret 
8000dad4:	28 04       	st.b [%a15]0,%d4
8000dad6:	b0 1f       	add.a %a15,1
8000dad8:	3c fb       	j 8000dace <memset+0x4>

8000dada <_realloc_r>:
8000dada:	40 4d       	mov.aa %a13,%a4
8000dadc:	40 5f       	mov.aa %a15,%a5
8000dade:	02 49       	mov %d9,%d4
8000dae0:	7c 53       	jnz.a %a5,8000dae6 <_realloc_r+0xc>
8000dae2:	1d ff 60 e8 	j 8000aba2 <_malloc_r>
8000dae6:	6d ff ab ea 	call 8000b03c <__malloc_lock>
8000daea:	1b b9 00 20 	addi %d2,%d9,11
8000daee:	8b 72 61 f2 	lt.u %d15,%d2,23
8000daf2:	8f 72 c0 21 	andn %d2,%d2,7
8000daf6:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
8000dafa:	19 f3 fc ff 	ld.w %d3,[%a15]-4
8000dafe:	0b 9f 30 21 	lt.u %d2,%d15,%d9
8000db02:	8b 0f 20 25 	or.lt %d2,%d15,0
8000db06:	d9 fe f8 ff 	lea %a14,[%a15]-8
8000db0a:	8f 33 c0 81 	andn %d8,%d3,3
8000db0e:	76 25       	jz %d2,8000db18 <_realloc_r+0x3e>
8000db10:	da 0c       	mov %d15,12
8000db12:	6c d0       	st.w [%a13]0,%d15
8000db14:	1d 00 56 01 	j 8000ddc0 <_realloc_r+0x2e6>
8000db18:	7f f8 ac 01 	jge %d8,%d15,8000de70 <_realloc_r+0x396>
8000db1c:	7b 00 00 c7 	movh %d12,28672
8000db20:	60 c3       	mov.a %a3,%d12
8000db22:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
8000db26:	d9 34 20 30 	lea %a4,[%a3]224
8000db2a:	99 43 08 00 	ld.a %a3,[%a4]8
8000db2e:	80 4c       	mov.d %d12,%a4
8000db30:	19 2b 04 00 	ld.w %d11,[%a2]4
8000db34:	7d 32 0a 00 	jeq.a %a2,%a3,8000db48 <_realloc_r+0x6e>
8000db38:	8f 1b c0 21 	andn %d2,%d11,1
8000db3c:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
8000db40:	19 42 04 00 	ld.w %d2,[%a4]4
8000db44:	6f 02 2b 80 	jnz.t %d2,0,8000db9a <_realloc_r+0xc0>
8000db48:	8f 3b c0 b1 	andn %d11,%d11,3
8000db4c:	0b 8b 00 20 	add %d2,%d11,%d8
8000db50:	7d 32 1b 80 	jne.a %a2,%a3,8000db86 <_realloc_r+0xac>
8000db54:	1b 0f 01 40 	addi %d4,%d15,16
8000db58:	3f 42 23 00 	jlt %d2,%d4,8000db9e <_realloc_r+0xc4>
8000db5c:	10 ee       	addsc.a %a14,%a14,%d15,0
8000db5e:	60 c2       	mov.a %a2,%d12
8000db60:	a2 f2       	sub %d2,%d15
8000db62:	b5 2e 08 00 	st.a [%a2]8,%a14
8000db66:	8f 12 40 21 	or %d2,%d2,1
8000db6a:	59 e2 04 00 	st.w [%a14]4,%d2
8000db6e:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000db72:	40 d4       	mov.aa %a4,%a13
8000db74:	8f 12 00 21 	and %d2,%d2,1
8000db78:	a6 2f       	or %d15,%d2
8000db7a:	59 ff fc ff 	st.w [%a15]-4,%d15
8000db7e:	6d ff 60 ea 	call 8000b03e <__malloc_unlock>
8000db82:	40 f2       	mov.aa %a2,%a15
8000db84:	00 90       	ret 
8000db86:	3f f2 0c 00 	jlt %d2,%d15,8000db9e <_realloc_r+0xc4>
8000db8a:	cc 23       	ld.a %a15,[%a2]12
8000db8c:	99 22 08 00 	ld.a %a2,[%a2]8
8000db90:	02 28       	mov %d8,%d2
8000db92:	ec 23       	st.a [%a2]12,%a15
8000db94:	e8 22       	st.a [%a15]8,%a2
8000db96:	1d 00 6d 01 	j 8000de70 <_realloc_r+0x396>
8000db9a:	82 0b       	mov %d11,0
8000db9c:	a0 02       	mov.a %a2,0
8000db9e:	6f 03 08 81 	jnz.t %d3,0,8000ddae <_realloc_r+0x2d4>
8000dba2:	99 fc f8 ff 	ld.a %a12,[%a15]-8
8000dba6:	01 ce 20 c0 	sub.a %a12,%a14,%a12
8000dbaa:	19 ca 04 00 	ld.w %d10,[%a12]4
8000dbae:	8f 3a c0 a1 	andn %d10,%d10,3
8000dbb2:	42 8a       	add %d10,%d8
8000dbb4:	bd 02 b3 00 	jz.a %a2,8000dd1a <_realloc_r+0x240>
8000dbb8:	42 ab       	add %d11,%d10
8000dbba:	7d 32 5f 80 	jne.a %a2,%a3,8000dc78 <_realloc_r+0x19e>
8000dbbe:	1b 0f 01 20 	addi %d2,%d15,16
8000dbc2:	3f 2b ac 00 	jlt %d11,%d2,8000dd1a <_realloc_r+0x240>
8000dbc6:	40 ce       	mov.aa %a14,%a12
8000dbc8:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000dbcc:	09 e3 88 05 	ld.a %a3,[+%a14]8
8000dbd0:	1b c8 ff 4f 	addi %d4,%d8,-4
8000dbd4:	8b 54 a2 22 	ge.u %d2,%d4,37
8000dbd8:	b5 32 0c 00 	st.a [%a3]12,%a2
8000dbdc:	b5 23 08 00 	st.a [%a2]8,%a3
8000dbe0:	df 02 36 80 	jne %d2,0,8000dc4c <_realloc_r+0x172>
8000dbe4:	8b 44 61 22 	lt.u %d2,%d4,20
8000dbe8:	40 e3       	mov.aa %a3,%a14
8000dbea:	df 02 28 80 	jne %d2,0,8000dc3a <_realloc_r+0x160>
8000dbee:	48 02       	ld.w %d2,[%a15]0
8000dbf0:	59 c2 08 00 	st.w [%a12]8,%d2
8000dbf4:	48 13       	ld.w %d3,[%a15]4
8000dbf6:	8b c4 a1 22 	ge.u %d2,%d4,28
8000dbfa:	59 c3 0c 00 	st.w [%a12]12,%d3
8000dbfe:	f6 26       	jnz %d2,8000dc0a <_realloc_r+0x130>
8000dc00:	d9 c3 10 00 	lea %a3,[%a12]16
8000dc04:	d9 ff 08 00 	lea %a15,[%a15]8
8000dc08:	3c 19       	j 8000dc3a <_realloc_r+0x160>
8000dc0a:	48 22       	ld.w %d2,[%a15]8
8000dc0c:	8b 44 02 82 	eq %d8,%d4,36
8000dc10:	59 c2 10 00 	st.w [%a12]16,%d2
8000dc14:	48 33       	ld.w %d3,[%a15]12
8000dc16:	59 c3 14 00 	st.w [%a12]20,%d3
8000dc1a:	f6 86       	jnz %d8,8000dc26 <_realloc_r+0x14c>
8000dc1c:	d9 c3 18 00 	lea %a3,[%a12]24
8000dc20:	d9 ff 10 00 	lea %a15,[%a15]16
8000dc24:	3c 0b       	j 8000dc3a <_realloc_r+0x160>
8000dc26:	48 42       	ld.w %d2,[%a15]16
8000dc28:	d9 c3 20 00 	lea %a3,[%a12]32
8000dc2c:	59 c2 18 00 	st.w [%a12]24,%d2
8000dc30:	48 53       	ld.w %d3,[%a15]20
8000dc32:	d9 ff 18 00 	lea %a15,[%a15]24
8000dc36:	59 c3 1c 00 	st.w [%a12]28,%d3
8000dc3a:	48 02       	ld.w %d2,[%a15]0
8000dc3c:	74 32       	st.w [%a3],%d2
8000dc3e:	48 13       	ld.w %d3,[%a15]4
8000dc40:	59 33 04 00 	st.w [%a3]4,%d3
8000dc44:	48 22       	ld.w %d2,[%a15]8
8000dc46:	59 32 08 00 	st.w [%a3]8,%d2
8000dc4a:	3c 05       	j 8000dc54 <_realloc_r+0x17a>
8000dc4c:	40 e4       	mov.aa %a4,%a14
8000dc4e:	40 f5       	mov.aa %a5,%a15
8000dc50:	6d ff 15 ff 	call 8000da7a <memmove>
8000dc54:	10 cf       	addsc.a %a15,%a12,%d15,0
8000dc56:	60 c2       	mov.a %a2,%d12
8000dc58:	a2 fb       	sub %d11,%d15
8000dc5a:	ec 22       	st.a [%a2]8,%a15
8000dc5c:	8f 1b 40 b1 	or %d11,%d11,1
8000dc60:	68 1b       	st.w [%a15]4,%d11
8000dc62:	19 c2 04 00 	ld.w %d2,[%a12]4
8000dc66:	40 d4       	mov.aa %a4,%a13
8000dc68:	8f 12 00 21 	and %d2,%d2,1
8000dc6c:	a6 2f       	or %d15,%d2
8000dc6e:	6c c1       	st.w [%a12]4,%d15
8000dc70:	6d ff e7 e9 	call 8000b03e <__malloc_unlock>
8000dc74:	40 e2       	mov.aa %a2,%a14
8000dc76:	00 90       	ret 
8000dc78:	3f fb 51 00 	jlt %d11,%d15,8000dd1a <_realloc_r+0x240>
8000dc7c:	99 23 0c 00 	ld.a %a3,[%a2]12
8000dc80:	99 22 08 00 	ld.a %a2,[%a2]8
8000dc84:	40 c4       	mov.aa %a4,%a12
8000dc86:	1b c8 ff 4f 	addi %d4,%d8,-4
8000dc8a:	b5 23 0c 00 	st.a [%a2]12,%a3
8000dc8e:	b5 32 08 00 	st.a [%a3]8,%a2
8000dc92:	09 43 88 05 	ld.a %a3,[+%a4]8
8000dc96:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000dc9a:	8b 54 a2 22 	ge.u %d2,%d4,37
8000dc9e:	b5 32 0c 00 	st.a [%a3]12,%a2
8000dca2:	b5 23 08 00 	st.a [%a2]8,%a3
8000dca6:	df 02 35 80 	jne %d2,0,8000dd10 <_realloc_r+0x236>
8000dcaa:	8b 44 61 22 	lt.u %d2,%d4,20
8000dcae:	df 02 28 80 	jne %d2,0,8000dcfe <_realloc_r+0x224>
8000dcb2:	48 02       	ld.w %d2,[%a15]0
8000dcb4:	59 c2 08 00 	st.w [%a12]8,%d2
8000dcb8:	48 13       	ld.w %d3,[%a15]4
8000dcba:	8b c4 a1 22 	ge.u %d2,%d4,28
8000dcbe:	59 c3 0c 00 	st.w [%a12]12,%d3
8000dcc2:	f6 26       	jnz %d2,8000dcce <_realloc_r+0x1f4>
8000dcc4:	d9 c4 10 00 	lea %a4,[%a12]16
8000dcc8:	d9 ff 08 00 	lea %a15,[%a15]8
8000dccc:	3c 19       	j 8000dcfe <_realloc_r+0x224>
8000dcce:	48 22       	ld.w %d2,[%a15]8
8000dcd0:	8b 44 02 82 	eq %d8,%d4,36
8000dcd4:	59 c2 10 00 	st.w [%a12]16,%d2
8000dcd8:	48 33       	ld.w %d3,[%a15]12
8000dcda:	59 c3 14 00 	st.w [%a12]20,%d3
8000dcde:	f6 86       	jnz %d8,8000dcea <_realloc_r+0x210>
8000dce0:	d9 c4 18 00 	lea %a4,[%a12]24
8000dce4:	d9 ff 10 00 	lea %a15,[%a15]16
8000dce8:	3c 0b       	j 8000dcfe <_realloc_r+0x224>
8000dcea:	48 42       	ld.w %d2,[%a15]16
8000dcec:	d9 c4 20 00 	lea %a4,[%a12]32
8000dcf0:	59 c2 18 00 	st.w [%a12]24,%d2
8000dcf4:	48 53       	ld.w %d3,[%a15]20
8000dcf6:	d9 ff 18 00 	lea %a15,[%a15]24
8000dcfa:	59 c3 1c 00 	st.w [%a12]28,%d3
8000dcfe:	48 02       	ld.w %d2,[%a15]0
8000dd00:	74 42       	st.w [%a4],%d2
8000dd02:	48 13       	ld.w %d3,[%a15]4
8000dd04:	59 43 04 00 	st.w [%a4]4,%d3
8000dd08:	48 22       	ld.w %d2,[%a15]8
8000dd0a:	59 42 08 00 	st.w [%a4]8,%d2
8000dd0e:	3c 04       	j 8000dd16 <_realloc_r+0x23c>
8000dd10:	40 f5       	mov.aa %a5,%a15
8000dd12:	6d ff b4 fe 	call 8000da7a <memmove>
8000dd16:	02 b8       	mov %d8,%d11
8000dd18:	3c 45       	j 8000dda2 <_realloc_r+0x2c8>
8000dd1a:	3f fa 4a 00 	jlt %d10,%d15,8000ddae <_realloc_r+0x2d4>
8000dd1e:	40 c4       	mov.aa %a4,%a12
8000dd20:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000dd24:	09 43 88 05 	ld.a %a3,[+%a4]8
8000dd28:	1b c8 ff 4f 	addi %d4,%d8,-4
8000dd2c:	8b 54 a2 22 	ge.u %d2,%d4,37
8000dd30:	b5 32 0c 00 	st.a [%a3]12,%a2
8000dd34:	b5 23 08 00 	st.a [%a2]8,%a3
8000dd38:	df 02 37 80 	jne %d2,0,8000dda6 <_realloc_r+0x2cc>
8000dd3c:	8b 44 61 22 	lt.u %d2,%d4,20
8000dd40:	df 02 28 80 	jne %d2,0,8000dd90 <_realloc_r+0x2b6>
8000dd44:	48 03       	ld.w %d3,[%a15]0
8000dd46:	59 c3 08 00 	st.w [%a12]8,%d3
8000dd4a:	48 12       	ld.w %d2,[%a15]4
8000dd4c:	59 c2 0c 00 	st.w [%a12]12,%d2
8000dd50:	8b c4 a1 22 	ge.u %d2,%d4,28
8000dd54:	f6 26       	jnz %d2,8000dd60 <_realloc_r+0x286>
8000dd56:	d9 c4 10 00 	lea %a4,[%a12]16
8000dd5a:	d9 ff 08 00 	lea %a15,[%a15]8
8000dd5e:	3c 19       	j 8000dd90 <_realloc_r+0x2b6>
8000dd60:	48 23       	ld.w %d3,[%a15]8
8000dd62:	8b 44 02 82 	eq %d8,%d4,36
8000dd66:	59 c3 10 00 	st.w [%a12]16,%d3
8000dd6a:	48 32       	ld.w %d2,[%a15]12
8000dd6c:	59 c2 14 00 	st.w [%a12]20,%d2
8000dd70:	f6 86       	jnz %d8,8000dd7c <_realloc_r+0x2a2>
8000dd72:	d9 c4 18 00 	lea %a4,[%a12]24
8000dd76:	d9 ff 10 00 	lea %a15,[%a15]16
8000dd7a:	3c 0b       	j 8000dd90 <_realloc_r+0x2b6>
8000dd7c:	48 43       	ld.w %d3,[%a15]16
8000dd7e:	d9 c4 20 00 	lea %a4,[%a12]32
8000dd82:	59 c3 18 00 	st.w [%a12]24,%d3
8000dd86:	48 52       	ld.w %d2,[%a15]20
8000dd88:	d9 ff 18 00 	lea %a15,[%a15]24
8000dd8c:	59 c2 1c 00 	st.w [%a12]28,%d2
8000dd90:	48 03       	ld.w %d3,[%a15]0
8000dd92:	74 43       	st.w [%a4],%d3
8000dd94:	48 12       	ld.w %d2,[%a15]4
8000dd96:	59 42 04 00 	st.w [%a4]4,%d2
8000dd9a:	48 23       	ld.w %d3,[%a15]8
8000dd9c:	59 43 08 00 	st.w [%a4]8,%d3
8000dda0:	02 a8       	mov %d8,%d10
8000dda2:	40 ce       	mov.aa %a14,%a12
8000dda4:	3c 66       	j 8000de70 <_realloc_r+0x396>
8000dda6:	40 f5       	mov.aa %a5,%a15
8000dda8:	6d ff 69 fe 	call 8000da7a <memmove>
8000ddac:	3c fa       	j 8000dda0 <_realloc_r+0x2c6>
8000ddae:	40 d4       	mov.aa %a4,%a13
8000ddb0:	02 94       	mov %d4,%d9
8000ddb2:	6d ff f8 e6 	call 8000aba2 <_malloc_r>
8000ddb6:	40 2c       	mov.aa %a12,%a2
8000ddb8:	7c 26       	jnz.a %a2,8000ddc4 <_realloc_r+0x2ea>
8000ddba:	40 d4       	mov.aa %a4,%a13
8000ddbc:	6d ff 41 e9 	call 8000b03e <__malloc_unlock>
8000ddc0:	a0 02       	mov.a %a2,0
8000ddc2:	00 90       	ret 
8000ddc4:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000ddc8:	d9 23 f8 ff 	lea %a3,[%a2]-8
8000ddcc:	8f 12 c0 21 	andn %d2,%d2,1
8000ddd0:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
8000ddd4:	80 32       	mov.d %d2,%a3
8000ddd6:	80 23       	mov.d %d3,%a2
8000ddd8:	5f 32 08 80 	jne %d2,%d3,8000dde8 <_realloc_r+0x30e>
8000dddc:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8000dde0:	8f 32 c0 21 	andn %d2,%d2,3
8000dde4:	42 28       	add %d8,%d2
8000dde6:	3c 45       	j 8000de70 <_realloc_r+0x396>
8000dde8:	1b c8 ff 4f 	addi %d4,%d8,-4
8000ddec:	8b 54 a2 f2 	ge.u %d15,%d4,37
8000ddf0:	ee 33       	jnz %d15,8000de56 <_realloc_r+0x37c>
8000ddf2:	8b 44 61 f2 	lt.u %d15,%d4,20
8000ddf6:	40 c3       	mov.aa %a3,%a12
8000ddf8:	40 f2       	mov.aa %a2,%a15
8000ddfa:	ee 23       	jnz %d15,8000de40 <_realloc_r+0x366>
8000ddfc:	4c f0       	ld.w %d15,[%a15]0
8000ddfe:	d9 c3 08 00 	lea %a3,[%a12]8
8000de02:	6c c0       	st.w [%a12]0,%d15
8000de04:	48 12       	ld.w %d2,[%a15]4
8000de06:	8b c4 a1 f2 	ge.u %d15,%d4,28
8000de0a:	59 c2 04 00 	st.w [%a12]4,%d2
8000de0e:	d9 f2 08 00 	lea %a2,[%a15]8
8000de12:	6e 17       	jz %d15,8000de40 <_realloc_r+0x366>
8000de14:	48 23       	ld.w %d3,[%a15]8
8000de16:	8b 44 02 82 	eq %d8,%d4,36
8000de1a:	59 c3 08 00 	st.w [%a12]8,%d3
8000de1e:	4c f3       	ld.w %d15,[%a15]12
8000de20:	d9 c3 10 00 	lea %a3,[%a12]16
8000de24:	6c c3       	st.w [%a12]12,%d15
8000de26:	d9 f2 10 00 	lea %a2,[%a15]16
8000de2a:	76 8b       	jz %d8,8000de40 <_realloc_r+0x366>
8000de2c:	48 42       	ld.w %d2,[%a15]16
8000de2e:	d9 c3 18 00 	lea %a3,[%a12]24
8000de32:	59 c2 10 00 	st.w [%a12]16,%d2
8000de36:	48 53       	ld.w %d3,[%a15]20
8000de38:	d9 f2 18 00 	lea %a2,[%a15]24
8000de3c:	59 c3 14 00 	st.w [%a12]20,%d3
8000de40:	4c 20       	ld.w %d15,[%a2]0
8000de42:	6c 30       	st.w [%a3]0,%d15
8000de44:	19 22 04 00 	ld.w %d2,[%a2]4
8000de48:	59 32 04 00 	st.w [%a3]4,%d2
8000de4c:	19 23 08 00 	ld.w %d3,[%a2]8
8000de50:	59 33 08 00 	st.w [%a3]8,%d3
8000de54:	3c 05       	j 8000de5e <_realloc_r+0x384>
8000de56:	40 c4       	mov.aa %a4,%a12
8000de58:	40 f5       	mov.aa %a5,%a15
8000de5a:	6d ff 10 fe 	call 8000da7a <memmove>
8000de5e:	40 d4       	mov.aa %a4,%a13
8000de60:	40 f5       	mov.aa %a5,%a15
8000de62:	6d ff 7a f9 	call 8000d156 <_free_r>
8000de66:	40 d4       	mov.aa %a4,%a13
8000de68:	6d ff eb e8 	call 8000b03e <__malloc_unlock>
8000de6c:	40 c2       	mov.aa %a2,%a12
8000de6e:	00 90       	ret 
8000de70:	0b f8 80 20 	sub %d2,%d8,%d15
8000de74:	8b 02 61 42 	lt.u %d4,%d2,16
8000de78:	19 e3 04 00 	ld.w %d3,[%a14]4
8000de7c:	df 04 16 80 	jne %d4,0,8000dea8 <_realloc_r+0x3ce>
8000de80:	8f 13 00 31 	and %d3,%d3,1
8000de84:	10 e5       	addsc.a %a5,%a14,%d15,0
8000de86:	a6 3f       	or %d15,%d3
8000de88:	6c e1       	st.w [%a14]4,%d15
8000de8a:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
8000de8e:	8f 12 40 f1 	or %d15,%d2,1
8000de92:	b7 10 21 20 	imask %e2,1,0,1
8000de96:	6c 51       	st.w [%a5]4,%d15
8000de98:	49 f2 44 08 	ldmst [%a15]4,%e2
8000de9c:	40 d4       	mov.aa %a4,%a13
8000de9e:	d9 55 08 00 	lea %a5,[%a5]8
8000dea2:	6d ff 5a f9 	call 8000d156 <_free_r>
8000dea6:	3c 0c       	j 8000debe <_realloc_r+0x3e4>
8000dea8:	8f 13 00 31 	and %d3,%d3,1
8000deac:	a6 83       	or %d3,%d8
8000deae:	59 e3 04 00 	st.w [%a14]4,%d3
8000deb2:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
8000deb6:	b7 10 21 20 	imask %e2,1,0,1
8000deba:	49 f2 44 08 	ldmst [%a15]4,%e2
8000debe:	40 d4       	mov.aa %a4,%a13
8000dec0:	6d ff bf e8 	call 8000b03e <__malloc_unlock>
8000dec4:	d9 e2 08 00 	lea %a2,[%a14]8
8000dec8:	00 90       	ret 

8000deca <_exit>:
8000deca:	76 43       	jz %d4,8000ded0 <_exit+0x6>
8000decc:	60 4e       	mov.a %a14,%d4
8000dece:	3c 04       	j 8000ded6 <_exit+0xc>
8000ded0:	bb d0 00 f9 	mov.u %d15,36877
8000ded4:	60 fe       	mov.a %a14,%d15
8000ded6:	00 a0       	debug 
8000ded8:	3c 00       	j 8000ded8 <_exit+0xe>

8000deda <sbrk>:
8000deda:	91 00 00 f7 	movh.a %a15,28672
8000dede:	19 ff 90 40 	ld.w %d15,[%a15]2320 <70000910 <heap_top.2289>>
8000dee2:	7b 00 00 27 	movh %d2,28672
8000dee6:	42 f4       	add %d4,%d15
8000dee8:	1b 82 c3 20 	addi %d2,%d2,3128
8000deec:	7f 42 09 80 	jge.u %d2,%d4,8000defe <sbrk+0x24>
8000def0:	6d 00 13 00 	call 8000df16 <__errno>
8000def4:	da 0c       	mov %d15,12
8000def6:	6c 20       	st.w [%a2]0,%d15
8000def8:	a0 02       	mov.a %a2,0
8000defa:	b0 f2       	add.a %a2,-1
8000defc:	00 90       	ret 
8000defe:	7b 00 00 27 	movh %d2,28672
8000df02:	1b 82 c3 20 	addi %d2,%d2,3128
8000df06:	7f 24 04 80 	jge.u %d4,%d2,8000df0e <sbrk+0x34>
8000df0a:	6d 00 0b 00 	call 8000df20 <abort>
8000df0e:	59 f4 90 40 	st.w [%a15]2320,%d4
8000df12:	60 f2       	mov.a %a2,%d15
8000df14:	00 90       	ret 

8000df16 <__errno>:
8000df16:	91 00 00 27 	movh.a %a2,28672
8000df1a:	d9 22 f0 00 	lea %a2,[%a2]3120 <70000c30 <_my_errno>>
8000df1e:	00 90       	ret 

8000df20 <abort>:
8000df20:	00 a0       	debug 
8000df22:	7b e0 ea fd 	movh %d15,57006
8000df26:	1b ff ee fb 	addi %d15,%d15,-16657
8000df2a:	60 fe       	mov.a %a14,%d15
8000df2c:	1d ff cf ff 	j 8000deca <_exit>
8000df30:	3c 00       	j 8000df30 <abort+0x10>

8000df32 <__eqdf2>:
8000df32:	20 38       	sub.a %sp,56
8000df34:	40 a4       	mov.aa %a4,%sp
8000df36:	d9 a5 10 00 	lea %a5,[%sp]16
8000df3a:	89 a4 40 09 	st.d [%sp],%e4
8000df3e:	89 a6 48 09 	st.d [%sp]8,%e6
8000df42:	6d ff 6a e5 	call 8000aa16 <__unpack_d>
8000df46:	d9 a4 08 00 	lea %a4,[%sp]8
8000df4a:	d9 a5 24 00 	lea %a5,[%sp]36
8000df4e:	6d ff 64 e5 	call 8000aa16 <__unpack_d>
8000df52:	39 af 10 00 	ld.bu %d15,[%sp]16
8000df56:	82 12       	mov %d2,1
8000df58:	bf 2f 0c 80 	jlt.u %d15,2,8000df70 <__eqdf2+0x3e>
8000df5c:	39 af 24 00 	ld.bu %d15,[%sp]36
8000df60:	bf 2f 08 80 	jlt.u %d15,2,8000df70 <__eqdf2+0x3e>
8000df64:	d9 a4 10 00 	lea %a4,[%sp]16
8000df68:	d9 a5 24 00 	lea %a5,[%sp]36
8000df6c:	6d 00 0d 01 	call 8000e186 <__fpcmp_parts_d>
8000df70:	00 90       	ret 

8000df72 <__nedf2>:
8000df72:	20 38       	sub.a %sp,56
8000df74:	40 a4       	mov.aa %a4,%sp
8000df76:	d9 a5 10 00 	lea %a5,[%sp]16
8000df7a:	89 a4 40 09 	st.d [%sp],%e4
8000df7e:	89 a6 48 09 	st.d [%sp]8,%e6
8000df82:	6d ff 4a e5 	call 8000aa16 <__unpack_d>
8000df86:	d9 a4 08 00 	lea %a4,[%sp]8
8000df8a:	d9 a5 24 00 	lea %a5,[%sp]36
8000df8e:	6d ff 44 e5 	call 8000aa16 <__unpack_d>
8000df92:	39 af 10 00 	ld.bu %d15,[%sp]16
8000df96:	82 12       	mov %d2,1
8000df98:	bf 2f 0c 80 	jlt.u %d15,2,8000dfb0 <__nedf2+0x3e>
8000df9c:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dfa0:	bf 2f 08 80 	jlt.u %d15,2,8000dfb0 <__nedf2+0x3e>
8000dfa4:	d9 a4 10 00 	lea %a4,[%sp]16
8000dfa8:	d9 a5 24 00 	lea %a5,[%sp]36
8000dfac:	6d 00 ed 00 	call 8000e186 <__fpcmp_parts_d>
8000dfb0:	00 90       	ret 

8000dfb2 <__gtdf2>:
8000dfb2:	20 38       	sub.a %sp,56
8000dfb4:	40 a4       	mov.aa %a4,%sp
8000dfb6:	d9 a5 10 00 	lea %a5,[%sp]16
8000dfba:	89 a4 40 09 	st.d [%sp],%e4
8000dfbe:	89 a6 48 09 	st.d [%sp]8,%e6
8000dfc2:	6d ff 2a e5 	call 8000aa16 <__unpack_d>
8000dfc6:	d9 a4 08 00 	lea %a4,[%sp]8
8000dfca:	d9 a5 24 00 	lea %a5,[%sp]36
8000dfce:	6d ff 24 e5 	call 8000aa16 <__unpack_d>
8000dfd2:	39 af 10 00 	ld.bu %d15,[%sp]16
8000dfd6:	82 f2       	mov %d2,-1
8000dfd8:	bf 2f 0c 80 	jlt.u %d15,2,8000dff0 <__gtdf2+0x3e>
8000dfdc:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dfe0:	bf 2f 08 80 	jlt.u %d15,2,8000dff0 <__gtdf2+0x3e>
8000dfe4:	d9 a4 10 00 	lea %a4,[%sp]16
8000dfe8:	d9 a5 24 00 	lea %a5,[%sp]36
8000dfec:	6d 00 cd 00 	call 8000e186 <__fpcmp_parts_d>
8000dff0:	00 90       	ret 

8000dff2 <__gedf2>:
8000dff2:	20 38       	sub.a %sp,56
8000dff4:	40 a4       	mov.aa %a4,%sp
8000dff6:	d9 a5 10 00 	lea %a5,[%sp]16
8000dffa:	89 a4 40 09 	st.d [%sp],%e4
8000dffe:	89 a6 48 09 	st.d [%sp]8,%e6
8000e002:	6d ff 0a e5 	call 8000aa16 <__unpack_d>
8000e006:	d9 a4 08 00 	lea %a4,[%sp]8
8000e00a:	d9 a5 24 00 	lea %a5,[%sp]36
8000e00e:	6d ff 04 e5 	call 8000aa16 <__unpack_d>
8000e012:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e016:	82 f2       	mov %d2,-1
8000e018:	bf 2f 0c 80 	jlt.u %d15,2,8000e030 <__gedf2+0x3e>
8000e01c:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e020:	bf 2f 08 80 	jlt.u %d15,2,8000e030 <__gedf2+0x3e>
8000e024:	d9 a4 10 00 	lea %a4,[%sp]16
8000e028:	d9 a5 24 00 	lea %a5,[%sp]36
8000e02c:	6d 00 ad 00 	call 8000e186 <__fpcmp_parts_d>
8000e030:	00 90       	ret 

8000e032 <__ltdf2>:
8000e032:	20 38       	sub.a %sp,56
8000e034:	40 a4       	mov.aa %a4,%sp
8000e036:	d9 a5 10 00 	lea %a5,[%sp]16
8000e03a:	89 a4 40 09 	st.d [%sp],%e4
8000e03e:	89 a6 48 09 	st.d [%sp]8,%e6
8000e042:	6d ff ea e4 	call 8000aa16 <__unpack_d>
8000e046:	d9 a4 08 00 	lea %a4,[%sp]8
8000e04a:	d9 a5 24 00 	lea %a5,[%sp]36
8000e04e:	6d ff e4 e4 	call 8000aa16 <__unpack_d>
8000e052:	39 af 10 00 	ld.bu %d15,[%sp]16
8000e056:	82 12       	mov %d2,1
8000e058:	bf 2f 0c 80 	jlt.u %d15,2,8000e070 <__ltdf2+0x3e>
8000e05c:	39 af 24 00 	ld.bu %d15,[%sp]36
8000e060:	bf 2f 08 80 	jlt.u %d15,2,8000e070 <__ltdf2+0x3e>
8000e064:	d9 a4 10 00 	lea %a4,[%sp]16
8000e068:	d9 a5 24 00 	lea %a5,[%sp]36
8000e06c:	6d 00 8d 00 	call 8000e186 <__fpcmp_parts_d>
8000e070:	00 90       	ret 

8000e072 <__fixdfsi>:
8000e072:	20 20       	sub.a %sp,32
8000e074:	d9 a4 20 00 	lea %a4,[%sp]32
8000e078:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000e07c:	d9 a5 0c 00 	lea %a5,[%sp]12
8000e080:	6d ff cb e4 	call 8000aa16 <__unpack_d>
8000e084:	0c ac       	ld.bu %d15,[%sp]12
8000e086:	82 02       	mov %d2,0
8000e088:	bf 3f 1b 80 	jlt.u %d15,3,8000e0be <__fixdfsi+0x4c>
8000e08c:	5e 48       	jne %d15,4,8000e09c <__fixdfsi+0x2a>
8000e08e:	7b 00 00 28 	movh %d2,32768
8000e092:	58 04       	ld.w %d15,[%sp]16
8000e094:	1b f2 ff 3f 	addi %d3,%d2,-1
8000e098:	6a 32       	cmovn %d2,%d15,%d3
8000e09a:	00 90       	ret 
8000e09c:	19 a6 14 00 	ld.w %d6,[%sp]20
8000e0a0:	82 02       	mov %d2,0
8000e0a2:	0e 6e       	jltz %d6,8000e0be <__fixdfsi+0x4c>
8000e0a4:	8b f6 81 f2 	ge %d15,%d6,31
8000e0a8:	ee f3       	jnz %d15,8000e08e <__fixdfsi+0x1c>
8000e0aa:	09 a4 58 09 	ld.d %e4,[%sp]24
8000e0ae:	8b c6 03 61 	rsub %d6,%d6,60
8000e0b2:	6d ff b0 e0 	call 8000a212 <__lshrdi3>
8000e0b6:	58 04       	ld.w %d15,[%sp]16
8000e0b8:	8b 02 00 41 	rsub %d4,%d2,0
8000e0bc:	2a 42       	cmov %d2,%d15,%d4
8000e0be:	00 90       	ret 

8000e0c0 <__udivdi3>:
8000e0c0:	0f 67 a0 20 	or %d2,%d7,%d6
8000e0c4:	0b 45 10 a8 	mov %e10,%d5,%d4
8000e0c8:	02 6f       	mov %d15,%d6
8000e0ca:	02 7c       	mov %d12,%d7
8000e0cc:	d2 f8       	mov %e8,-1
8000e0ce:	df 02 46 00 	jeq %d2,0,8000e15a <__udivdi3+0x9a>
8000e0d2:	8f 07 40 21 	or %d2,%d7,0
8000e0d6:	f6 2d       	jnz %d2,8000e0f0 <__udivdi3+0x30>
8000e0d8:	4b 6b 11 82 	div.u %e8,%d11,%d6
8000e0dc:	d2 04       	mov %e4,0
8000e0de:	02 a4       	mov %d4,%d10
8000e0e0:	42 95       	add %d5,%d9
8000e0e2:	6d 00 a5 00 	call 8000e22c <__udiv6432>
8000e0e6:	82 04       	mov %d4,0
8000e0e8:	02 85       	mov %d5,%d8
8000e0ea:	13 12 40 84 	madd.u %e8,%e4,%d2,1
8000e0ee:	3c 36       	j 8000e15a <__udivdi3+0x9a>
8000e0f0:	0b 7b 00 21 	eq %d2,%d11,%d7
8000e0f4:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
8000e0f8:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
8000e0fc:	d2 08       	mov %e8,0
8000e0fe:	df 02 2e 80 	jne %d2,0,8000e15a <__udivdi3+0x9a>
8000e102:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
8000e106:	0f 07 b0 d1 	clz %d13,%d7
8000e10a:	60 5f       	mov.a %a15,%d5
8000e10c:	0b 67 10 48 	mov %e4,%d7,%d6
8000e110:	02 d6       	mov %d6,%d13
8000e112:	6d ff a4 e3 	call 8000a85a <__ashldi3>
8000e116:	8f fb 1f e0 	sh %d14,%d11,-1
8000e11a:	80 f4       	mov.d %d4,%a15
8000e11c:	02 36       	mov %d6,%d3
8000e11e:	02 e5       	mov %d5,%d14
8000e120:	6d 00 86 00 	call 8000e22c <__udiv6432>
8000e124:	8b fd 01 d1 	rsub %d13,%d13,31
8000e128:	8b 0d 00 31 	rsub %d3,%d13,0
8000e12c:	0f 32 00 30 	sh %d3,%d2,%d3
8000e130:	02 32       	mov %d2,%d3
8000e132:	8b f2 9f 80 	addx %d8,%d2,-1
8000e136:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
8000e13a:	82 03       	mov %d3,0
8000e13c:	8b f3 bf 90 	addc %d9,%d3,-1
8000e140:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
8000e144:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
8000e148:	0b cb 00 41 	eq %d4,%d11,%d12
8000e14c:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
8000e150:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
8000e154:	f6 43       	jnz %d4,8000e15a <__udivdi3+0x9a>
8000e156:	0b 23 10 88 	mov %e8,%d3,%d2
8000e15a:	0b 89 10 28 	mov %e2,%d9,%d8
8000e15e:	00 90       	ret 

8000e160 <__umoddi3>:
8000e160:	0f 67 a0 90 	or %d9,%d7,%d6
8000e164:	02 6f       	mov %d15,%d6
8000e166:	d2 00       	mov %e0,0
8000e168:	76 9c       	jz %d9,8000e180 <__umoddi3+0x20>
8000e16a:	02 7a       	mov %d10,%d7
8000e16c:	0b 45 10 88 	mov %e8,%d5,%d4
8000e170:	6d ff a8 ff 	call 8000e0c0 <__udivdi3>
8000e174:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
8000e178:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
8000e17c:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
8000e180:	0b 01 10 28 	mov %e2,%d1,%d0
8000e184:	00 90       	ret 

8000e186 <__fpcmp_parts_d>:
8000e186:	14 43       	ld.bu %d3,[%a4]
8000e188:	82 12       	mov %d2,1
8000e18a:	bf 23 50 80 	jlt.u %d3,2,8000e22a <__fpcmp_parts_d+0xa4>
8000e18e:	0c 50       	ld.bu %d15,[%a5]0
8000e190:	bf 2f 4d 80 	jlt.u %d15,2,8000e22a <__fpcmp_parts_d+0xa4>
8000e194:	8b 43 00 42 	eq %d4,%d3,4
8000e198:	8b 4f 00 22 	eq %d2,%d15,4
8000e19c:	0f 24 80 50 	and %d5,%d4,%d2
8000e1a0:	76 56       	jz %d5,8000e1ac <__fpcmp_parts_d+0x26>
8000e1a2:	19 52 04 00 	ld.w %d2,[%a5]4
8000e1a6:	4c 41       	ld.w %d15,[%a4]4
8000e1a8:	a2 f2       	sub %d2,%d15
8000e1aa:	00 90       	ret 
8000e1ac:	76 47       	jz %d4,8000e1ba <__fpcmp_parts_d+0x34>
8000e1ae:	19 42 04 00 	ld.w %d2,[%a4]4
8000e1b2:	82 1f       	mov %d15,1
8000e1b4:	ab ff bf 22 	seln %d2,%d2,%d15,-1
8000e1b8:	00 90       	ret 
8000e1ba:	76 27       	jz %d2,8000e1c8 <__fpcmp_parts_d+0x42>
8000e1bc:	19 52 04 00 	ld.w %d2,[%a5]4
8000e1c0:	82 ff       	mov %d15,-1
8000e1c2:	ab 1f a0 22 	seln %d2,%d2,%d15,1
8000e1c6:	00 90       	ret 
8000e1c8:	df 23 06 80 	jne %d3,2,8000e1d4 <__fpcmp_parts_d+0x4e>
8000e1cc:	82 02       	mov %d2,0
8000e1ce:	df 2f f7 ff 	jne %d15,2,8000e1bc <__fpcmp_parts_d+0x36>
8000e1d2:	00 90       	ret 
8000e1d4:	df 2f ed 7f 	jeq %d15,2,8000e1ae <__fpcmp_parts_d+0x28>
8000e1d8:	19 45 04 00 	ld.w %d5,[%a4]4
8000e1dc:	4c 51       	ld.w %d15,[%a5]4
8000e1de:	5f f5 19 80 	jne %d5,%d15,8000e210 <__fpcmp_parts_d+0x8a>
8000e1e2:	19 42 08 00 	ld.w %d2,[%a4]8
8000e1e6:	4c 52       	ld.w %d15,[%a5]8
8000e1e8:	3f 2f 14 00 	jlt %d15,%d2,8000e210 <__fpcmp_parts_d+0x8a>
8000e1ec:	3f f2 1c 00 	jlt %d2,%d15,8000e224 <__fpcmp_parts_d+0x9e>
8000e1f0:	19 43 10 00 	ld.w %d3,[%a4]16
8000e1f4:	19 54 10 00 	ld.w %d4,[%a5]16
8000e1f8:	19 47 0c 00 	ld.w %d7,[%a4]12
8000e1fc:	19 56 0c 00 	ld.w %d6,[%a5]12
8000e200:	0b 43 00 21 	eq %d2,%d3,%d4
8000e204:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
8000e208:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
8000e20c:	3a 43       	eq %d15,%d3,%d4
8000e20e:	f6 25       	jnz %d2,8000e218 <__fpcmp_parts_d+0x92>
8000e210:	82 12       	mov %d2,1
8000e212:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
8000e216:	00 90       	ret 
8000e218:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
8000e21c:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
8000e220:	82 02       	mov %d2,0
8000e222:	ee 04       	jnz %d15,8000e22a <__fpcmp_parts_d+0xa4>
8000e224:	82 f2       	mov %d2,-1
8000e226:	ab 12 a0 25 	seln %d2,%d5,%d2,1
8000e22a:	00 90       	ret 

8000e22c <__udiv6432>:
8000e22c:	02 53       	mov %d3,%d5
8000e22e:	82 f2       	mov %d2,-1
8000e230:	7f 65 4b 80 	jge.u %d5,%d6,8000e2c6 <__udiv6432+0x9a>
8000e234:	0f 06 b0 21 	clz %d2,%d6
8000e238:	0f 26 00 60 	sh %d6,%d6,%d2
8000e23c:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
8000e240:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
8000e244:	8f 06 1f 70 	sh %d7,%d6,-16
8000e248:	4b 73 11 02 	div.u %e0,%d3,%d7
8000e24c:	b7 06 10 88 	insert %d8,%d6,0,16,16
8000e250:	0f 24 00 20 	sh %d2,%d4,%d2
8000e254:	02 05       	mov %d5,%d0
8000e256:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
8000e25a:	e2 80       	mul %d0,%d8
8000e25c:	8f 02 1f b0 	sh %d11,%d2,-16
8000e260:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000e264:	82 0c       	mov %d12,0
8000e266:	7b 10 00 90 	movh %d9,1
8000e26a:	7f 95 09 80 	jge.u %d5,%d9,8000e27c <__udiv6432+0x50>
8000e26e:	8f 01 01 f0 	sh %d15,%d1,16
8000e272:	0b 0c 00 a0 	add %d10,%d12,%d0
8000e276:	42 bf       	add %d15,%d11
8000e278:	7f af 07 80 	jge.u %d15,%d10,8000e286 <__udiv6432+0x5a>
8000e27c:	42 71       	add %d1,%d7
8000e27e:	c2 f5       	add %d5,-1
8000e280:	a2 8c       	sub %d12,%d8
8000e282:	3f 91 f4 ff 	jlt.u %d1,%d9,8000e26a <__udiv6432+0x3e>
8000e286:	8f 03 01 30 	sh %d3,%d3,16
8000e28a:	42 3b       	add %d11,%d3
8000e28c:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
8000e290:	82 0a       	mov %d10,0
8000e292:	4b 76 11 02 	div.u %e0,%d6,%d7
8000e296:	7b 10 00 10 	movh %d1,1
8000e29a:	02 03       	mov %d3,%d0
8000e29c:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
8000e2a0:	e2 80       	mul %d0,%d8
8000e2a2:	7f 13 09 80 	jge.u %d3,%d1,8000e2b4 <__udiv6432+0x88>
8000e2a6:	8f 06 01 f0 	sh %d15,%d6,16
8000e2aa:	0b 0a 00 90 	add %d9,%d10,%d0
8000e2ae:	42 2f       	add %d15,%d2
8000e2b0:	7f 9f 07 80 	jge.u %d15,%d9,8000e2be <__udiv6432+0x92>
8000e2b4:	42 76       	add %d6,%d7
8000e2b6:	c2 f3       	add %d3,-1
8000e2b8:	a2 8a       	sub %d10,%d8
8000e2ba:	3f 16 f4 ff 	jlt.u %d6,%d1,8000e2a2 <__udiv6432+0x76>
8000e2be:	8f 05 01 50 	sh %d5,%d5,16
8000e2c2:	0b 53 00 20 	add %d2,%d3,%d5
8000e2c6:	00 90       	ret 
